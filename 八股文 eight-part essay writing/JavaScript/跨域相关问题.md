---
title: 跨域相关问题
url: https://www.yuque.com/wcywxq/mxunh7/iqsxnp
---

<a name="BSrhW"></a>

## 同源策略

是一种安全策略。所谓的同源，指的是**协议**，**域名**，**端口**相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，**在没有明确授权**的情况下，不能读写对方的资源

<a name="wj9qu"></a>

## 跨域解决方案

<a name="YZ9Ls"></a>

### cors

跨域资源共享 CORS 是一种机制，它使用额外的 HTTP 头来告诉浏览器，让运行在一个 origin(domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器**「不同的域、协议或端口」**请求一个资源时，资源会发起一个 **「跨域 HTTP 请求」**

- 服务端 node.js 设置

```javascript
const Koa = require('koa')
const app = new Koa()

app.use(async (ctx, next) => {
	ctx.set('Access-Control-Allow-Origin', ctx.headers.origin)
  ctx.set('Access-Control-Allow-Credentials', true)
  ctx.set('Access-Control-Request-Method', 'PUT,POST,GET,DELETE,OPTIONS')
  ctx.set('Access-Control-Headers', 'Origin, X-Requested-With, Content-Type, Accept, cc')
  if (ctx.method === 'OPTIONS') {
  	ctx.status = 204
    return
  }
  await next()
})
```

<a name="OQ5Wh"></a>

### node 中间件代理

node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过启动一个代理服务器，从而实现数据的转发

- 前端代码

```html
<script>
  getlist.onClick = () => {
  	fetch('http://localhost:8080/api/corslist', { credentials: 'include' })
      .then(res => res.json())
      .then(data => console.log(data))
      .catch(err => console.log(err))
  }
  login.click = () => {
  	fetch('http://localhost:8080/api/login', { credentials: 'include' })
      .then(res => res.json())
      .then(data => console.log(data))
      .catch(err => console.log(err))
  }
</script>
```

- 中间件服务器

```javascript
const Koa = require('koa')
const proxy = require('http-proxy-middleware')
const app = new Koa()

app.use('/', (ctx, next) => {
	proxy({
  	// 代理跨域目标接口
    target: 'http://www.domain2.com:8080',
    changeOrigin: true,
    // 修改响应头信息，实现跨域并允许带 cookie
    onProxyRes() {
    	ctx.header('Access-Control-Allow-Origin', 'http://www.domain1.com')
      ctx.header('Access-Control-Allow-Credentials', true)
    },
    // 修改响应信息中的 cookie 域名
    cookieDomainRewrite: 'www.domain1.com' // 可以为 false，表示不修改
  })
})

app.listen(3000)
```

<a name="L6fcF"></a>

### nginx 反向代理

思路：通过 nginx 配置一个代理服务器做跳板机，反向代理访问目标域接口，实现跨域登陆

```nginx
server {
  listen 80;
  server_name 127.0.0.1;
  location /api {
    proxy_pass http://localhost:8080; # 反向代理
  }
}
```

- 前端代码

```html
<script>
	axios.defaults.withCredentials = true
  getList.onclick = () => {
  	axios.get('/api/corslist').then(res => {
    	console.log(res.data)
    })
  }
</script>
```

- 服务端 node.js 代码

```javascript
const Koa = require('koa')
const router = require('@koa/router')
const app = new Koa()

router.get('/api/corslist', async ctx => {
	ctx.body = {
  	data: [{ name: 'cors list' }]
  }
})

router.post('/api/login', async ctx => {
	ctx.cookies.set('token', token, {
  	expires: new Date(Date.now() + 1000 * 60 * 60 * 24 * 7)
  })
  ctx.body = {
    msg: 'success',
    code: 0
  }
})

app.use(router.routes())
app.use(router.allowMethods())

app.listen('http://localhost:8080')
```

<a name="sS5ZM"></a>

### jsonp

- 服务端 node.js 实现

```javascript
const Koa = require('koa')
const app = new Koa()

app.use(async (ctx, next) => {
	if (ctx.path === '/api/jsonp') {
    const { jsonpCallback: fn, ...params } = ctx.query
  	ctx.body = `${fn}(${JSON.stringify(params)})`
  }
})

app.listen(3000)
```

- 前端实现

```html
<script>
	var script = document.createElement('script')
  script.type = 'text/javascript'
  
  // 传递参数并指定回调执行函数 callback
  script.src = 'http://localhost:3000/api/jsonp?id=1&type=2&cb=jsonpCallback'
  // 回调执行函数
  function jsonpCallback(res) {
  	console.log(JSON.stringify(res))
  }
</script>
```

<a name="ASzaJ"></a>

### websocket

- 服务端实现

```javascript
const Koa = require('koa')
const ws = require('ws')

const server = new ws.Server({
    port: 3000
})

server.on('connection', socket => {
    socket.on('message', data => {
        socket.send(data)
    })
})
```

- 前端实现

```html
<script>
const socket = new WebSocket('ws://localhost:3000')
socket.onopen = () => {
	socket.send('信息')
}
socket.onmessage = event => {
	console.log(event.data)
}
</script>
```

<a name="ms2S2"></a>

### window.postMessage

postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决一下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的 iframe 消息传递
- 上面三个场景的跨域数据传递

用法：postMessage(data, origin) 方法接受两个参数

- a.html

```html
<iframe
  src="http://localhost:8080"
  frameborder="0"
  id="iframe"
  onload="load()"
></iframe>
<script>  
  function load() {    
    iframe.contentWindow.postMessage("秋风的笔记", "http://localhost:8080");    
    window.onmessage = e => {      
      console.log(e.data);    
    };  
  }
</script>
```

- b.html

```html
<div>hello</div>
<script>  
  window.onmessage = e => {    
    console.log(e.data); // 秋风的笔记    
    e.source.postMessage(e.data, e.origin); 
  };
</script>
```

<a name="Lab8V"></a>

### document.domain + iframe

实现原理：两个页面都通过 javaScript 强制设置 document.domain 为基础主域，这样就实现了同域
:::info
此方案仅限主域相同，子域不同的跨域应用场景
:::

- 主窗口

```html
<iframe id='iframe' src='http://child.domain.com/b.html'></iframe>
<script>
	document.domain = 'domain.com'
  var user = 'admin'
</script>
```

- 子窗口

```html
<script>
	document.domain = 'domain.com'
  // 获取父窗口中变量
  console.log(window.parent.user)
</script>
```

<a name="e9zoq"></a>

### window.location.hash + iframe

实现原理：通过 url 带 hash ，通过一个非跨域的中间页面来传递数据

- a,html

```html
<iframe src="http://localhost:8080/hash/c.html#name1"></iframe>
<script>
  console.log(location.hash);
  window.onhashchange = function() {
    console.log(location.hash);
  };
</script>
```

- b.html

```html
<script>
  window.parent.parent.location.hash = location.hash;
</script>
```

- c.html

```html
<script>
	console.log(location.hash);  
  const iframe = document.createElement("iframe");  
  iframe.src = "http://localhost:8000/hash/b.html#name2";  
  document.body.appendChild(iframe);
</script>
```

<a name="GRRUT"></a>

### window.name + iframe

window 对象的 name 属性是一个很特别的属性，当该 window 的 location 变化，然后重新加载，它的 name 属性可以依然保持不变

其中 a.html 和 b.html 是同域的，都是 http://localhost:8000，而 c.html 是 http://localhost:8080

- a.html

```html
<iframe
  src="http://localhost:8080/name/c.html"
  frameborder="0"
  onload="load()"
  id="iframe"
></iframe>
<script>
	let first = true
  // onload 事件会触发 2 次，第 1 次加载跨域页，并留存数据于 window.name
  function load() {
  	if (first) {
    	// 第 1 次 onload(跨域页)成功后，切换到同域代理页面
      iframe.src = 'http://localhost:8000/name/b.html'
    } else {
    	// 第 2 次 onload(同域 b.html 页)成功后，读取同域 window.name 中数据
      console.log(iframe.contentWindow.name)
    }
  }
</script>
```

- b.html 中间代理页，与 a.html 同域，内容为空

```html
<div></div>
```

- c.html

```html
<script>
	window.name = '发送内容'
</script>
```

:::info
通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作
::: <a name="LEr2B"></a>

### 借助 charles/fiddler 接口代理

<a name="B66rV"></a>

### 浏览器开启跨域

可以通过修改浏览器的配置来关闭默认的跨域方案
&#x20;	&#x9;
