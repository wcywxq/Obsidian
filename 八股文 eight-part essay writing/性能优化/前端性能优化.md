---
title: 前端性能优化
url: https://www.yuque.com/wcywxq/mxunh7/tcfotb
---

性能优化的目的：哪些指标影响了业务，则对应指标就是优化的关键点 <a name="SS7MK"></a>

## 常见的性能优化关键点

1. 首屏渲染时间
2. 首次可交互时间(例如：手机验证码的获取)
3. 首次有意义内容的渲染时间(例如：主要元素的渲染时间) <a name="EaHdU"></a>

## 性能优化-根据类型

<a name="gj5nn"></a>

### 只获取 所需资源

1. 异步加载路由
2. 图片的懒加载
3. babel 的 polyfill(低版本下对高版本语法的补充)
4. cdn 记载 polyfill 服务，可以实现对 polyfill 的按需加载 <a name="mWn1V"></a>

### 缩减资源体积

1. 打包压缩
2. gzip
3. 图片格式的优化、压缩(base64、svg、小图 png、照片 jpeg)；根据屏幕分辨率展示不同分辨率图片；webp 图片格式的使用；
4. 在请求头控制 cookie 大小 <a name="tn4pe"></a>

### 时序优化

1. 对于没有相互关联，没有依赖关系的请求，采用 Promise.all 并行请求
2. 服务端渲染 ssr(在服务端打包，同时可以做缓存)
3. 预解析 prefetch、预连接 preconnect、预加载 preload(利用 webpack 魔法注释：`/* webpackPrefetch: true */`)
   1. dns 预解析：`<link rel='dns-prefetch' href='xxx1.com' />`
   2. 预连接：`<link rel='preconnect' href='xxx1.com' />`
   3. 预加载 `<link rel='preload' as='image' href='https://xxx/a.png' />` <a name="VjDti"></a>

### 合理利用缓存

1. cdn(源站和 cdn 服务器域名一般都是不同的，其中一个目的是为了缩减不必要的 cookie 携带)
   1. cdn 预热：cdn 厂家不通过用户的访问提前把源站的内容分发到不同的 cdn 节点上(大流量场景都需要做)
   2. cdn 刷新：源站刷新了，将会让 cdn 节点强制拉取源站的 cdn 文件 <a name="ZRGfo"></a>

## 性能优化-根据优化方向

<a name="U4pU7"></a>

### 工程化方向

1. 客户端 gzip 离线包、服务器资源 gzip 压缩
2. es-module
3. 动态 Import
4. 动态 polyfill(利用 cdn)
5. 图片加载优化：webp、图片预加载、懒加载、客户端预渲染
6. 服务端渲染 ssr
7. cdn 静态资源加速
8. webpack 提供的优化：
   1. base64图片
   2. 使用 tree-shaking 去除未使用的代码
   3. 资源压缩
   4. 分包策略 chunk
   5. webpack dll、通用方法优先打包抽离
   6. 别名 alias 的使用
9. 浏览器缓存策略，service worker
10. 骨架图
11. 数据预存取：如接口缓存
12. 减少资源重定向
13. nginx 负载均衡(可以提高响应速度)
14. 使用 http/2。因为解析速度快，拥有 header 压缩、多路复用、服务器推送静态资源等功能
15. oss(对象存储。海量、安全、低成本、高可靠的云存储服务) + cdn(内容分发网络) <a name="NFPU2"></a>

### 开发细节方向

1. 图片：占位图、雪碧图(css 精灵)
2. prefetch/preload 预加载
3. defer/async：defer `=>` 所有资源加载完之后执行 js；async `=>` 加载完 js 立即执行
4. 减少 dom 操作，减少重排重绘
5. 在客户端层面，首屏减少和客户端交互，合并接口请求
6. 首页不加载不可视组件
7. 防止渲染抖动，控制加载时序
8. 减少组件层级
9. 优先使用弹性布局 <a name="EIl1N"></a>

## 解决卡顿问题

1. css 动画效率比 js 高，css 可以使用 gpu 加速，3d 加速。如果非要用 js 动画，可以使用 requestAnimationFrame
2. 批量进行 dom 操作，固定图片容器大小，避免屏幕抖动
3. 减少重排重绘
4. 防抖和节流
5. 减少临时大对象的产生，利用对象缓存，主要是减少垃圾回收时产生过多的内存碎片
6. 异步操作：IntersectionObserver、PostMessage、RequestIdleCallback <a name="KzSBK"></a>

## 性能优化 api

1. Performance。performance.now() 与 new Date() 是有区别的，它是高精度的，且是相对时间，相对于页面加载的那一刻。但是不一定适合单页面场景。
2. `window.addEventListener('load', '')`；`window.addEventListener('domContentLoaded', '')`
3. img 的 onload 事件，监听首屏内的图片是否加载完成，判断首屏事件
4. requestAnimationFrame 和 requestIdleCallback
5. IntersectionObserver、MutationObserver、PostMessage
6. web worker，耗时任务放在里面执行
