---
title: vue diff 算法
url: https://www.yuque.com/wcywxq/mxunh7/diavmt
---

<a name="4ec332ef"></a>

## diff 算法解决的问题

vnode 更新，diff 算法寻求最佳性能同步更新真实 dom。必须明确 old vnode 和 old 真实 dom 是过去时，new vnode 对应的 new 真实 dom 是我们最终想要的。基于 old，得到 new，如果让性能最好？最简单粗暴就是把 old 干掉，直接生成 new。但是性能消耗最大。最佳方法是，尽可能复用真实 dom。对真实 dom 的操作消耗关系：更新属性不移动 < 更新属性后移动到对应位置 < 创建新节点插入到对应位置。所以，diff 算法最终是要尽可能找到可被复用的真实 dom，如果不要移动最好，否则移动到对应位置，最后创建没有可复用的新节点，删除多余的未被复用的老真实 dom 节点。
vue3 的 diff 算法比 vue2 的快，主要原因是在于复用 dom 元素相同的情况，移动 dom 的次数减少，因为 vue3 用到了最长递增子序列方案。更细节的讨论放在后面分析。

所以算法目标是：

- 尽可能块的找到可复用真实 dom 节点
- 复用真实 dom 节点的时候，尽可能也复用其相对顺序，少做移动。

<a name="4ccd0554"></a>

## vue2 的 diff 算法

vue2 的 diff 算法采用了双端 diff 算法。

同时使用四个指针分别放到 old 子节点和 new 子节点的头和尾。
对比头头，尾尾，头尾，尾头，如果其一满足 sameVnode，则进行真实 dom 复用且不需要移动真实 dom，指针向内移动。否则，通过 keyToOldIdxMap 尝试快速找到 old 子节点中 key 相同 sameVnode，如果找到，则复用真实 dom，并移动到当前位置，然后将 old 子节点\[i]设置为 undefined，后续查找忽略此节点。如果没有找到则创建新的真实 dom 并插入。
最后满足 old 子节点的头尾交叉，或 new 子节点的头尾交叉。说明对比完了。此时如果 old 交叉，new 未交叉，说明 new 子节点剩下的都是要新创建并插入。反之，old 未交叉，new 交叉，说明 old 子节点剩下的是多余的，需要从 dom 中移除。

<a name="3815629f"></a>

### vue2 算法优劣分析

算法通过相互比较头尾，如果复用，不需要移动，直接复用。这个是优点也是缺点，缺点就在于只要复用的节点不在头尾，则一定得移动复用的真实 dom。并且受头尾影响，假如头尾是两个新节点，就一直不能头尾复用，剩下的所有节点复用，只可能走 keyToOldIdxMap 的方法，在头尾直接寻找复用元素，并移动它。试想一下，如果头尾直接的元素都是可被复用的，并且更新前后的相对顺序未发生变化，则所有的移动几乎都是额外的性能开销。是否可以有其他方案，尽可能在复用 old 子节点的同时，也复用其相对顺序，把移动真实 dom 的次数降到最低，较少性能消耗。后面 vue3 的 diff 算法提供了一个解决此问题的更好思路。

<a name="c449f9f6"></a>

## vue3 的 diff 算法

vue3 的 diff 算法借鉴了字符串 diff 的一些思路。

首先进行预处理，将前置和后置可复用的节点找出，且是不需要移动的。
判断是否存在剩余节点。如果 old 子节点存在剩余节点，new 子节点不存在，比对完成，移除多余的 old 子节点对应的真实 dom。如果 old 子节点不存在剩余节点，new 子节点存在，比对完成，新建多余的 new 子节点对应的真实 dom 并插入。如果 old 和 new 子节点都存在剩余子节点，则将剩余部分进行比对复用。
剩余部分比对非 vue2 的比对方式，用到了最长递增子序列，复用与最长递增子序列内的节点对应的 old 真实 dom 时，无需移动。进一步减少移动次数，提高了性能。

<a name="55c5b1df"></a>

### vue3 算法优劣分析

该算法引入最长递增子序列，尽可能复用了原来的顺序，减少移动次数，提升了性能。发散一下，该算法是移动次数最少的方法吗？还有没有其他更好的算法思路，有待进一步研究。
