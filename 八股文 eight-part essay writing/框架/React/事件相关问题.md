---
title: 事件相关问题
url: https://www.yuque.com/wcywxq/mxunh7/ed4qqb
---

<a name="kK7Bh"></a>

## 事件合成机制

react 根据 w3c 规范定义了每个事件处理函数的参数，即合成事件。react 在合成事件中做了两件事：**事件委派** 和 **自动绑定** <a name="TigwJ"></a>

### 事件委派

事件处理程序将会传递 SyntheticEvent(事件合成) 的实例。这是一个**跨浏览器原生事件包装器**，它**具有与浏览器原生事件相同的接口**，支持 stopProgation 和 preventDefault。可以通过使用 nativeEvent 属性来访问原生事件对象，同时在所有浏览器中，它们的工作方式都相同
react 合成的 SyntheticEvent 采用了 **事件池**，这样做可以大大节省内存，同时不会频繁的创建和销毁事件对象

- react 并不会把事件处理函数直接绑定到真实节点上，而是把所有事件放到统一的事件队列中，用监听器做监听。
- 通过监听器上的映射来保存所有组件内部的事件监听和处理函数。
- 在组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象。
- 事件触发时会先被监听器处理，然后通过映射调用真正的事件处理函数。
  :::success
  **这样做的优点：**
  解决了兼容性问题，并且简化了事件处理和回收机制(不需要手动解绑事件，react 已经在内部处理了)
  ::: <a name="k3bxz"></a>

### 自动绑定

1. 在 react 组件中，每个方法的上下文都会指向该组件的实例，即自动将上下文 this 指向当前组件
2. react 会对这种引用方式做缓存，从而优化 cpu 和 内存
3. 在使用 class 或 function 组件时，需要手动实现 this 绑定 <a name="sXERu"></a>

## react 事件与原生事件的区别

1. 事件传播与阻止事件传播：react 合成事件并没有实现事件捕获，只支持了事件冒泡。阻止事件传播 react 做了兼容性处理，只需要使用 e.preventDefault 即可，原生方法存在兼容性问题。
2. 事件类型：react 是原生事件类型的一个子集。阻止 react 事件冒泡的行为只能用于 react 事件合成系统，但是在原生事件中的阻止冒泡行为，却可以阻止 react 合成事件的传播
3. 事件的绑定方式：原生事件系统中支持多种不同的绑定事件的方式，react 只有一种
4. 事件对象：原生事件存在兼容性问题，react 做了兼容性处理 <a name="CjKqq"></a>

## react 事件和原生事件的执行顺序

1. 原生事件，依次冒泡执行
2. `react` 合成事件，依次冒泡执行
3. `document` 上挂载的事件执行

```shell
# 1. dom child
# 2. dom parent
# 3. react child
# 4. react parent
# 5. dom document
```

<a name="gAGP9"></a>

## react 事件与原生事件可以混用么

`react` 事件和原生事件最好不要混用。原生事件中如果执行了 `stopPropagation` 方法，则会导致其他 `react` 事件失效。因为所有元素的事件将无法冒泡到 `document` 上，导致所有的 `react` 事件都将无法被触发
