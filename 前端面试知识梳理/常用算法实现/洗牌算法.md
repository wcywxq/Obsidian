---
title: 洗牌算法
url: https://www.yuque.com/wcywxq/pgkpvh/tohw0k
---

<a name="wN5qR"></a>

## 代码模版

> 洗牌算法的正确性原则：产生的结果必须有 n! 种可能，否则就是错误的

```cpp
// 得到一个在闭区间 [min, max] 内的随机整数
int randInt(int min, int max);

// 第一种写法
void shuffle(int[] arr) {
    int n = arr.length();
    /******** 区别只有这两行 ********/
    for (int i = 0 ; i < n; i++) {
        // 从 i 到最后随机选一个元素
        int rand = randInt(i, n - 1);
        /*************************/
        swap(arr[i], arr[rand]);
    }
}

// 第二种写法
for (int i = 0 ; i < n - 1; i++)
    int rand = randInt(i, n - 1);

// 第三种写法
for (int i = n - 1 ; i >= 0; i--)
    int rand = randInt(0, i);

// 第四种写法
for (int i = n - 1 ; i > 0; i--)
    int rand = randInt(0, i);
```

***

<a name="Fisher-Yates"></a>

## Fisher-Yates

先看最经典的 [Fisher-Yates](http://en.wikipedia.org/wiki/Fisher-Yates_shuffle) 的洗牌算法
这里有一个该算法的[可视化实现](https://bost.ocks.org/mike/shuffle/)
其算法思想就是 **从原始数组中随机抽取一个新的元素到新数组中**

1. 从还没处理的数组（假如还剩 n 个）中，产生一个\[0, n]之间的随机数 random
2. 从剩下的 n 个元素中把第 random 个元素取出到新数组中
3. 删除原数组第 random 个元素
4. 重复第 2 3 步直到所有元素取完
5. 最终返回一个新的打乱的数组

按步骤一步一步来就很简单的实现


```javascript
function shuffle(arr) {
    var result = []
    while (arr.length > 0) {
        let index = Math.floor(Math.random() * arr.length)
        result.push(arr.splice(index, 1))
    }
    return result
}

function shuffle(arr) {
    for (let i = 0; i < arr.length; ++i) {
        const index = Math.floor(Math.random() * (arr.length - i)) + i
        ;[arr[i], arr[index]] = [arr[index], arr[i]]
    }
    return this.nums
}
```

这种算法要去除原数组 arr 中的元素，所以时间复杂度为 O(n2))

<a name="ab672078"></a>

## Knuth-Durstenfeld Shuffle

Fisher-Yates 洗牌算法的一个变种是 Knuth Shuffle
**每次从未处理的数组中随机取一个元素，然后把该元素放到数组的尾部，即数组的尾部放的就是已经处理过的元素**，这是一种原地打乱的算法，每个元素随机概率也相等，时间复杂度从 Fisher 算法的 O(n2)提升到了 O(n)

1. 选取数组(长度 n)中最后一个元素(arr\[length-1])，将其与 n 个元素中的任意一个交换，此时最后一个元素已经确定
2. 选取倒数第二个元素(arr\[length-2])，将其与 n-1 个元素中的任意一个交换
3. 重复第 1 2 步，直到剩下 1 个元素为止

```javascript
function shuffle(arr) {
    var length = arr.length,
        temp,
        random
    while (0 != length) {
        random = Math.floor(Math.random() * length)
        length--
        // swap
        temp = arr[length]
        arr[length] = arr[random]
        arr[random] = temp
    }
    return arr
}
```

Durstenfeld Shuffle 的算法是从数组第一个开始，和 Knuth 的区别是遍历的方向不同

<a name="Other"></a>

## Other

<a name="4f0db99a"></a>

### Array.sort()

利用 Array 的 sort 方法可以更简洁的实现打乱，对于数量小的数组来说足够。因为随着数组元素增加，随机性会变差。

```javascript
;[1, 2, 3, 4, 5, 6].sort(function () {
    return 0.5 - Math.random()
})
```
