{
  "id": 69585869,
  "slug": "cwwn2a",
  "title": "常用排序算法",
  "book_id": 25332296,
  "book": {
    "id": 25332296,
    "type": "Book",
    "slug": "xxble8",
    "name": "前端技术文章",
    "user_id": 732231,
    "description": "记录前端相关的技术性文章",
    "creator_id": 732231,
    "public": 0,
    "items_count": 23,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2022-06-15T01:16:19.043Z",
    "updated_at": "2023-11-11T18:11:38.000Z",
    "created_at": "2022-03-13T09:55:39.000Z",
    "namespace": "wcywxq/xxble8",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"RY5r7\"></a>\n## 插入排序\n<a name=\"BU6C3\"></a>\n### 原理\n第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第 3 个元素开始，向前对比，重复之前的操作。\n<a name=\"xDMWu\"></a>\n### 实现\n```javascript\nfunction insertSort(arr) {\n  // 外层控制循环次数\n  for (let i = 1; i < arr.length; i++) {\n    for (let j = i - 1; i >= 0 && arr[j] > arr[j + 1]; j--) {\n      [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n    }\n  }\n  return arr;\n}\n```\n<a name=\"Ga4Mk\"></a>\n### 时间复杂度\n时间复杂度: O(n2)\n\n---\n\n<a name=\"AuEPb\"></a>\n## 堆排序\n<a name=\"fMMHl\"></a>\n### 原理\n堆排序利用了二叉堆的特性来做，二叉堆通常用数组来表示，并且二叉堆是一颗完全二叉树(除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列)。二叉堆分为大根堆和小根堆。\n\n- 大根堆是某个节点的所有子节点的值都比它小\n- 小根堆是某个节点的所有子节点的值都比它大\n\n堆排序的原理就是组成一个大根堆或小根堆。以小跟堆为例，某个节点的左边子节点的索引是 i ✖️ 2 + 1，右边是 i ✖️ 2 + 2，父节点是 (i - 1) / 2 => i >> 1\n\n1. 首先遍历数组，判断该节点的父节点是否比它小，如果小就交换位置并继续判断，直到它的父节点比它大\n2. 重复以上操作 1，直到数组首位是最大值\n3. 然后将首位和末尾交换位置并将数组长度减 1，表示数组末尾已经是最大值，不需要再比较大小\n4. 对比左右节点哪个大，然后记住大的节点的索引的值并和父节点对比大小，如果子节点大就交换位置\n5. 重复 3 - 4 直到整个数组都是大根堆\n<a name=\"vyyO9\"></a>\n### 实现\n```javascript\nfunction heap(arr) {\n    // 将最大值放到首位\n    for (let i = 0; i < arr.length; i++) {\n        heapInsert(arr, i);\n    }\n    // 交换队首和队尾\n    [arr[0], arr[arr.length - 1]] = [arr[arr.length - 1], arr[0]];\n    while (arr.length > 0) {\n        heapify(arr, 0, arr.length - 1);\n        [arr[0], [arr[arr.length - 1]]] = [arr[arr.length - 1], arr[0]];\n    }\n    return arr;\n}\nfunction heapInsert(arr, index) {\n    // 如果当前节点比父节点大，就交换\n    while(arr[index] > arr[index >> 1]) {\n        // 交换\n        [arr[index], arr[index >> 1]] = [arr[index >> 1], arr[index]];\n        // 将索引变为父节点\n        index = index >> 1;\n    }\n}\nfunction heapify(arr, index, size) {\n    let left = index << 1 + 1;\n    while (left < size) {\n        // 判断左右节点大小\n        let largest = left + 1 < size && arr[left] < arr[left + 1] ? left + 1 : left;\n        // 判断子节点和父节点大小\n        largest = arr[index] < arr[largest] ? largest : index;\n        if (largest === index) break;\n        [arr[index], arr[largest]] = [arr[lagest], arr[index]];\n        index = largest;\n        left = index << 1 + 1;\n    }\n}\n```\n<a name=\"Qn227\"></a>\n### 时间复杂度\n最佳: O(nlogn) 最差: O(nlogn) 平均: O(nlogn)\n\n---\n\n<a name=\"Fgk8d\"></a>\n## 归并排序\n<a name=\"oC8Lf\"></a>\n### 原理\n递归的将数组两两分开直到包含两个元素，然后将数组排序合并。最终合并为排序好的数组。\n\n分冶思想，即将大问题拆成小问题，小问题解决后大问题自然就解决了。\n<a name=\"bNZcJ\"></a>\n### 例子\n[3, 1, 2, 8, 9, 7, 6] 中间数索引为 3, 先排序数组 [3, 1, 2, 8], 继续拆分直到变为数组包含两个元素, 如果数组长度为奇数, 有一个拆分到只剩下 1 个元素。然后排序数组 [3, 1] [2, 8], 再排序 [1, 2, 3, 8], 这样左边数组就排序完毕，同理排序右边数组，最后排序左右数组合并后的结果\n<a name=\"TzrjJ\"></a>\n### 实现\n```javascript\n// 拆分\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  let middle =  arr.length >> 1; // arr.length >> 1 等价于 Math.floot(arr.length / 2)\n  let left = arr.slice(0, middle);\n  let right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n// 合并\nfunction merge(left, right) {\n  const result = [];\n  while (left.length > 0 && right.length > 0) {\n    if (left[0] <= right[0]) {\n      result.push(left.shift());\n    } else {\n      result.push(right.shift());\n    }\n  }\n  return result.concat(left, right);\n}\n```\n<a name=\"LG3Fg\"></a>\n### 时间复杂度\n拆分数组需要 logn 步, 合并需要 n 步, 因此 O(nlogn)\n\n---\n\n<a name=\"be91b57e\"></a>\n## 基数排序\n<a name=\"mPf0U\"></a>\n### 原理\n基数排序是一种非比较型整数排序算法，也是桶排序的一种特殊情况。其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较\n\n简单来说就是分成 10 个桶，按照每个数字的最后一位数字进行分桶，然后按顺序放入桶中，之后按照桶大小从桶底部按顺序放入数列中。第一轮完毕后将按照每个数字的倒数第二位数字进行分桶，原理同上，当没有位数时，将按 0 处理。\n<a name=\"oR6aZ\"></a>\n### 实现\n```javascript\n/**\n *\n * @param arr 待排序数组\n * @param max 最大位数\n */\nfunction radixSort(arr, max) {\n  const buckets = [];\n  let unit = 10,\n    base = 1;\n  for (let i = 0; i < max; i++, base *= 10, unit *= 10) {\n    for (let j = 0; j < array.length; j++) {\n      let index = ~~((array[j] % unit) / base); //依次过滤出个位，十位等等数字\n      if (buckets[index] == null) {\n        buckets[index] = []; //初始化桶\n      }\n      buckets[index].push(array[j]); //往不同桶里添加数据\n    }\n    let pos = 0,\n      value;\n    for (let j = 0, length = buckets.length; j < length; j++) {\n      if (buckets[j] != null) {\n        while ((value = buckets[j].shift()) != null) {\n          array[pos++] = value; //将不同桶里数据挨个捞出来，为下一轮高位排序做准备，由于靠近桶底的元素排名靠前，因此从桶底先捞\n        }\n      }\n    }\n  }\n  return arr;\n}\n```\n\n---\n\n<a name=\"uOcpR\"></a>\n## 计数排序\n<a name=\"uzVZx\"></a>\n### 原理\n对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。\n<a name=\"i1t42\"></a>\n### 实现\n```javascript\nfunction countionSort(arr) {\n  let obj = {};\n  // 遍历原数组，给对象新增键值对，如果已经存在就对应的属性值++，如果不存在则新增键值对\n  for (let i = 0; i < arr.length; i++) {\n    if (!obj[arr[i]]) {\n      obj[arr[i]] = 1;\n    } else {\n      obj[arr[i]]++;\n    }\n  }\n  let index = 0;\n  // 遍历对象属性名，按顺序放回覆盖原数组\n  for (let key in obj) {\n    while (obj[key] > 0) {\n      arr[index] = Number(key);\n      obj[key]--;\n      index++;\n    }\n  }\n  return arr;\n}\n```\n\n---\n\n<a name=\"ydBb0\"></a>\n## 快速排序\n<a name=\"P9ohy\"></a>\n### 特点\n快速排序的特点就是快，而且效率高。它是处理大数据最快的排序算法之一\n<a name=\"W5oA8\"></a>\n### 原理\n随机选取一个数组中的值作为基准值，从左至右取值与基准值比较大小。比基准值小的放到数组左边，比基准值大的放到数组右边，对比完成后将基准值和第一个比基准值大的值交换位置，然后将数组以基准值的位置分为两个部分，继续递归以上操作。\n```javascript\nfunction quickSort(arr) {\n    if (arr.length <= 1) return arr;\n    // 取基准点\n    const middleIndex = arr.length >> 1;\n    // 取基准点的值\n    const middle = arr.splice(middleIndex, 1)[0];\n    const left = [];\n    const right = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] < middle) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat(middle, quickSort(right))\n}\n```\n<a name=\"kazHZ\"></a>\n### 时间复杂度\n最佳: O(nlogn) 最差: O(n2) 平均: O(nlogn)\n\n---\n\n<a name=\"UblUz\"></a>\n## 冒泡排序\n<a name=\"Kncte\"></a>\n### 原理\n从第一个元素开始，把当前元素和下一个索引元素进行比较，如果当前元素大，就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 2 的位置即可\n<a name=\"dkeBR\"></a>\n### 实现\n```javascript\nfunction bubbleSort(arr) {\n  for (let i = arr.length - 1; i > 0; i--) {\n    for (let j = 0; j < i; j++) {\n      // 索引大的数组值大于索引小的数组值，交换\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n  return arr;\n}\n```\n<a name=\"WrrPF\"></a>\n### 时间复杂度\n时间复杂度: O(n2)\n\n---\n\n<a name=\"396d121b\"></a>\n## 桶排序\n<a name=\"Hle0W\"></a>\n### 原理\n桶排序是计数排序的升级版，也采用了分冶思想\n\n1. 将要排序的数据分到有限数量的几个有序桶里\n2. 每个桶里的数据再单独进行排序(一般用插入排序或者快速排序)\n3. 桶内排完序后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了\n<a name=\"dlvUu\"></a>\n### 实现\n```javascript\nfunction bucketSort(arr, bucketSize) {\n  if (arr.length === 0) return arr;\n  let i = 0;\n  let min = arr[0];\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    } else if (arr[i] > max) {\n      max = arr[i];\n    }\n  }\n\n  // 初始化桶\n  const DEFAULT_BUCKET_SIZE = 5; // 桶的数量\n  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\n  const bucketCount = Math.floor((max - min) / bucketSize) + 1;\n  const buckets = new Array(bucketCount);\n  for (let i = 0; i < buckets.length; i++) {\n    buckets[i] = [];\n  }\n\n  // 利用映射函数将数据分配到各个桶中\n  for (let i = 0; i < arr.length; i++) {\n    buckets[Math.floor((arr[i] - min) / bucketSize)].push(arr[i]);\n  }\n\n  arr.length = 0;\n  for (let i = 0; i < buckets.length; i++) {\n    quickSort(bucket[i]);\n    for (let j = 0; j < buckets[i].length; j++) {\n      arr.push(buckets[i][j]);\n    }\n  }\n\n  return arr;\n}\n\nfunction quickSort(arr) {\n  if (arr.length <= 1) return arr;\n  const middleIndex = arr.length >> 1;\n  const middle = arr.splice(middleIndex, 1)[0];\n  const left = [];\n  const right = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < middle) {\n      left.push(arr[i]);\n    } else {\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat(middle, quickSort(right));\n}\n```\n\n---\n\n<a name=\"6f523ee9\"></a>\n## 希尔排序\n<a name=\"Fu3mP\"></a>\n### 原理\n\n1. 先将整个待排序的记录序列分割为若干子序列\n2. 分别进行直接插入排序\n3. 待整个序列中的记录基本有序时，再对全体记录进行直接插入排序\n<a name=\"FQ3De\"></a>\n### 例子\n\n1. [35, 33, 42, 10, 14, 19, 27, 44] 采用间隔为 4, 创建一个位于 4 个位置间隔的所有值的虚拟子列表 [35, 14] [33, 19] [42, 27] [10, 44]\n2. 比较每个子列表的值，并在原始数组中交换它们。完成此步骤后，新数组应改为 [14, 19, 27, 10, 35, 33, 42, 44]\n3. 然后采用 2 间隔，产生两个虚拟子列表 [14, 27, 35, 42] [19, 10, 33, 44]\n4. 比较并交换原始数组中的值。新数组变为 [14, 10, 27, 19, 35, 33, 42, 44]\n5. 最后，使用间隔为 1 对数组其余部分进行排序，使用插入排序对数组进行排序\n<a name=\"Sh8KJ\"></a>\n### 实现\n```javascript\nfunction shellSort(arr) {\n  let gap = 1; // 间隔\n  let temp;\n  while (gap < arr.length / 3) {\n    // 动态定义间隔序列\n    gap = gap * 3 + 1;\n  }\n  for (gap; gap > 0; gap = Math.floot(gap / 3)) {\n    for (let i = gap; i < arr.length; i++) {\n      for (j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {\n        [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]];\n      }\n    }\n  }\n  return arr;\n}\n```\n<a name=\"AKYow\"></a>\n### 时间复杂度\n最佳: O(nlogn) 最差: O(nlog2n) 平均: O(nlog2n)\n\n---\n\n<a name=\"7da8b8bc\"></a>\n## 选择排序\n<a name=\"KKCy6\"></a>\n### 思想\n在冒泡排序上做了优化，减少了交换次数，首轮最大数放在第一项，一轮之后第一项就是有序的，第二轮开始选最大值放第二项，重复此操作。\n<a name=\"DsZ5Z\"></a>\n### 原理\n遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值。下次遍历就可以从索引 1 开始重复上述操作。\n<a name=\"PUphp\"></a>\n### 实现\n```javascript\nfunction selectionSort(arr) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    let minIndex = i;\n    for (let j = i + 1; j < arr.length; j++) {\n      minIndex = arr[j] < arr[minIndex] ? j : minIndex;\n    }\n    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n  }\n  return arr;\n}\n```\n<a name=\"hnNa8\"></a>\n### 时间复杂度\n时间复杂度: O(n2)\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"RY5r7\"><span class=\"ne-text\">插入排序</span></h2><h3 id=\"BU6C3\"><span class=\"ne-text\">原理</span></h3><p id=\"ue7e27734\" class=\"ne-p\"><span class=\"ne-text\">第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第 3 个元素开始，向前对比，重复之前的操作。</span></p><h3 id=\"xDMWu\"><span class=\"ne-text\">实现</span></h3><pre data-language=\"javascript\" id=\"61a4caa6\" class=\"ne-codeblock language-javascript\">function insertSort(arr) {\n  // 外层控制循环次数\n  for (let i = 1; i &lt; arr.length; i++) {\n    for (let j = i - 1; i &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {\n      [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n    }\n  }\n  return arr;\n}</pre><h3 id=\"Ga4Mk\"><span class=\"ne-text\">时间复杂度</span></h3><p id=\"u3960bcc3\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度: O(n</span><span class=\"ne-text\">2</span><span class=\"ne-text\">)</span></p><hr id=\"aDl0x\" class=\"ne-hr\"><h2 id=\"AuEPb\"><span class=\"ne-text\">堆排序</span></h2><h3 id=\"fMMHl\"><span class=\"ne-text\">原理</span></h3><p id=\"ufc55efba\" class=\"ne-p\"><span class=\"ne-text\">堆排序利用了二叉堆的特性来做，二叉堆通常用数组来表示，并且二叉堆是一颗完全二叉树(除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列)。二叉堆分为大根堆和小根堆。</span></p><ul class=\"ne-ul\"><li id=\"ub736057d\"><span class=\"ne-text\">大根堆是某个节点的所有子节点的值都比它小</span></li><li id=\"u73bd046b\"><span class=\"ne-text\">小根堆是某个节点的所有子节点的值都比它大</span></li></ul><p id=\"u5ac3a3ca\" class=\"ne-p\"><br></p><p id=\"ue38122ea\" class=\"ne-p\"><span class=\"ne-text\">堆排序的原理就是组成一个大根堆或小根堆。以小跟堆为例，某个节点的左边子节点的索引是 i ✖️ 2 + 1，右边是 i ✖️ 2 + 2，父节点是 (i - 1) / 2 =&gt; i &gt;&gt; 1</span></p><ol class=\"ne-ol\"><li id=\"u989f778a\"><span class=\"ne-text\">首先遍历数组，判断该节点的父节点是否比它小，如果小就交换位置并继续判断，直到它的父节点比它大</span></li><li id=\"u62bb7f47\"><span class=\"ne-text\">重复以上操作 1，直到数组首位是最大值</span></li></ol><ol start=\"3\" class=\"ne-ol\"><li id=\"u6cc08546\"><span class=\"ne-text\">然后将首位和末尾交换位置并将数组长度减 1，表示数组末尾已经是最大值，不需要再比较大小</span></li><li id=\"u885bdc13\"><span class=\"ne-text\">对比左右节点哪个大，然后记住大的节点的索引的值并和父节点对比大小，如果子节点大就交换位置</span></li></ol><ol start=\"5\" class=\"ne-ol\"><li id=\"uc64c88ee\"><span class=\"ne-text\">重复 3 - 4 直到整个数组都是大根堆</span></li></ol><h3 id=\"vyyO9\"><span class=\"ne-text\">实现</span></h3><pre data-language=\"javascript\" id=\"22311562\" class=\"ne-codeblock language-javascript\">function heap(arr) {\n    // 将最大值放到首位\n    for (let i = 0; i &lt; arr.length; i++) {\n        heapInsert(arr, i);\n    }\n    // 交换队首和队尾\n    [arr[0], arr[arr.length - 1]] = [arr[arr.length - 1], arr[0]];\n    while (arr.length &gt; 0) {\n        heapify(arr, 0, arr.length - 1);\n        [arr[0], [arr[arr.length - 1]]] = [arr[arr.length - 1], arr[0]];\n    }\n    return arr;\n}\nfunction heapInsert(arr, index) {\n    // 如果当前节点比父节点大，就交换\n    while(arr[index] &gt; arr[index &gt;&gt; 1]) {\n        // 交换\n        [arr[index], arr[index &gt;&gt; 1]] = [arr[index &gt;&gt; 1], arr[index]];\n        // 将索引变为父节点\n        index = index &gt;&gt; 1;\n    }\n}\nfunction heapify(arr, index, size) {\n    let left = index &lt;&lt; 1 + 1;\n    while (left &lt; size) {\n        // 判断左右节点大小\n        let largest = left + 1 &lt; size &amp;&amp; arr[left] &lt; arr[left + 1] ? left + 1 : left;\n        // 判断子节点和父节点大小\n        largest = arr[index] &lt; arr[largest] ? largest : index;\n        if (largest === index) break;\n        [arr[index], arr[largest]] = [arr[lagest], arr[index]];\n        index = largest;\n        left = index &lt;&lt; 1 + 1;\n    }\n}</pre><h3 id=\"Qn227\"><span class=\"ne-text\">时间复杂度</span></h3><p id=\"uc0f85f49\" class=\"ne-p\"><span class=\"ne-text\">最佳: O(nlogn) 最差: O(nlogn) 平均: O(nlogn)</span></p><hr id=\"cKK7A\" class=\"ne-hr\"><h2 id=\"Fgk8d\"><span class=\"ne-text\">归并排序</span></h2><h3 id=\"oC8Lf\"><span class=\"ne-text\">原理</span></h3><p id=\"ueb9b9a48\" class=\"ne-p\"><span class=\"ne-text\">递归的将数组两两分开直到包含两个元素，然后将数组排序合并。最终合并为排序好的数组。</span></p><p id=\"ue0542626\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u0436f05d\" class=\"ne-p\"><span class=\"ne-text\">分冶思想，即将大问题拆成小问题，小问题解决后大问题自然就解决了。</span></p><h3 id=\"bNZcJ\"><span class=\"ne-text\">例子</span></h3><p id=\"u11b277c4\" class=\"ne-p\"><span class=\"ne-text\">[3, 1, 2, 8, 9, 7, 6] 中间数索引为 3, 先排序数组 [3, 1, 2, 8], 继续拆分直到变为数组包含两个元素, 如果数组长度为奇数, 有一个拆分到只剩下 1 个元素。然后排序数组 [3, 1] [2, 8], 再排序 [1, 2, 3, 8], 这样左边数组就排序完毕，同理排序右边数组，最后排序左右数组合并后的结果</span></p><h3 id=\"TzrjJ\"><span class=\"ne-text\">实现</span></h3><pre data-language=\"javascript\" id=\"b5b328ec\" class=\"ne-codeblock language-javascript\">// 拆分\nfunction mergeSort(arr) {\n  if (arr.length &lt;= 1) return arr;\n  let middle =  arr.length &gt;&gt; 1; // arr.length &gt;&gt; 1 等价于 Math.floot(arr.length / 2)\n  let left = arr.slice(0, middle);\n  let right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n// 合并\nfunction merge(left, right) {\n  const result = [];\n  while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {\n    if (left[0] &lt;= right[0]) {\n      result.push(left.shift());\n    } else {\n      result.push(right.shift());\n    }\n  }\n  return result.concat(left, right);\n}</pre><h3 id=\"LG3Fg\"><span class=\"ne-text\">时间复杂度</span></h3><p id=\"ua5a24e82\" class=\"ne-p\"><span class=\"ne-text\">拆分数组需要 logn 步, 合并需要 n 步, 因此 O(nlogn)</span></p><hr id=\"pNGxb\" class=\"ne-hr\"><h2 id=\"be91b57e\"><span class=\"ne-text\">基数排序</span></h2><h3 id=\"mPf0U\"><span class=\"ne-text\">原理</span></h3><p id=\"uf1fb8e16\" class=\"ne-p\"><span class=\"ne-text\">基数排序是一种非比较型整数排序算法，也是桶排序的一种特殊情况。其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较</span></p><p id=\"u57f4e0bb\" class=\"ne-p\"><br></p><p id=\"uf1a65188\" class=\"ne-p\"><span class=\"ne-text\">简单来说就是分成 10 个桶，按照每个数字的最后一位数字进行分桶，然后按顺序放入桶中，之后按照桶大小从桶底部按顺序放入数列中。第一轮完毕后将按照每个数字的倒数第二位数字进行分桶，原理同上，当没有位数时，将按 0 处理。</span></p><h3 id=\"oR6aZ\"><span class=\"ne-text\">实现</span></h3><pre data-language=\"javascript\" id=\"e455bd36\" class=\"ne-codeblock language-javascript\">/**\n *\n * @param arr 待排序数组\n * @param max 最大位数\n */\nfunction radixSort(arr, max) {\n  const buckets = [];\n  let unit = 10,\n    base = 1;\n  for (let i = 0; i &lt; max; i++, base *= 10, unit *= 10) {\n    for (let j = 0; j &lt; array.length; j++) {\n      let index = ~~((array[j] % unit) / base); //依次过滤出个位，十位等等数字\n      if (buckets[index] == null) {\n        buckets[index] = []; //初始化桶\n      }\n      buckets[index].push(array[j]); //往不同桶里添加数据\n    }\n    let pos = 0,\n      value;\n    for (let j = 0, length = buckets.length; j &lt; length; j++) {\n      if (buckets[j] != null) {\n        while ((value = buckets[j].shift()) != null) {\n          array[pos++] = value; //将不同桶里数据挨个捞出来，为下一轮高位排序做准备，由于靠近桶底的元素排名靠前，因此从桶底先捞\n        }\n      }\n    }\n  }\n  return arr;\n}</pre><hr id=\"ft0pp\" class=\"ne-hr\"><h2 id=\"uOcpR\"><span class=\"ne-text\">计数排序</span></h2><h3 id=\"uzVZx\"><span class=\"ne-text\">原理</span></h3><p id=\"u0375819d\" class=\"ne-p\"><span class=\"ne-text\">对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。</span></p><h3 id=\"i1t42\"><span class=\"ne-text\">实现</span></h3><pre data-language=\"javascript\" id=\"a4076647\" class=\"ne-codeblock language-javascript\">function countionSort(arr) {\n  let obj = {};\n  // 遍历原数组，给对象新增键值对，如果已经存在就对应的属性值++，如果不存在则新增键值对\n  for (let i = 0; i &lt; arr.length; i++) {\n    if (!obj[arr[i]]) {\n      obj[arr[i]] = 1;\n    } else {\n      obj[arr[i]]++;\n    }\n  }\n  let index = 0;\n  // 遍历对象属性名，按顺序放回覆盖原数组\n  for (let key in obj) {\n    while (obj[key] &gt; 0) {\n      arr[index] = Number(key);\n      obj[key]--;\n      index++;\n    }\n  }\n  return arr;\n}</pre><hr id=\"JNcIh\" class=\"ne-hr\"><h2 id=\"ydBb0\"><span class=\"ne-text\">快速排序</span></h2><h3 id=\"P9ohy\"><span class=\"ne-text\">特点</span></h3><p id=\"u7ecca22c\" class=\"ne-p\"><span class=\"ne-text\">快速排序的特点就是快，而且效率高。它是处理大数据最快的排序算法之一</span></p><h3 id=\"W5oA8\"><span class=\"ne-text\">原理</span></h3><p id=\"u619bf2cb\" class=\"ne-p\"><span class=\"ne-text\">随机选取一个数组中的值作为基准值，从左至右取值与基准值比较大小。比基准值小的放到数组左边，比基准值大的放到数组右边，对比完成后将基准值和第一个比基准值大的值交换位置，然后将数组以基准值的位置分为两个部分，继续递归以上操作。</span></p><pre data-language=\"javascript\" id=\"d9136be3\" class=\"ne-codeblock language-javascript\">function quickSort(arr) {\n    if (arr.length &lt;= 1) return arr;\n    // 取基准点\n    const middleIndex = arr.length &gt;&gt; 1;\n    // 取基准点的值\n    const middle = arr.splice(middleIndex, 1)[0];\n    const left = [];\n    const right = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n        if (arr[i] &lt; middle) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat(middle, quickSort(right))\n}</pre><h3 id=\"kazHZ\"><span class=\"ne-text\">时间复杂度</span></h3><p id=\"u6a3ecdac\" class=\"ne-p\"><span class=\"ne-text\">最佳: O(nlogn) 最差: O(n</span><span class=\"ne-text\">2</span><span class=\"ne-text\">) 平均: O(nlogn)</span></p><hr id=\"zSSZk\" class=\"ne-hr\"><h2 id=\"UblUz\"><span class=\"ne-text\">冒泡排序</span></h2><h3 id=\"Kncte\"><span class=\"ne-text\">原理</span></h3><p id=\"u7644f19d\" class=\"ne-p\"><span class=\"ne-text\">从第一个元素开始，把当前元素和下一个索引元素进行比较，如果当前元素大，就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 2 的位置即可</span></p><h3 id=\"dkeBR\"><span class=\"ne-text\">实现</span></h3><pre data-language=\"javascript\" id=\"e504345b\" class=\"ne-codeblock language-javascript\">function bubbleSort(arr) {\n  for (let i = arr.length - 1; i &gt; 0; i--) {\n    for (let j = 0; j &lt; i; j++) {\n      // 索引大的数组值大于索引小的数组值，交换\n      if (arr[j] &gt; arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n  return arr;\n}</pre><h3 id=\"WrrPF\"><span class=\"ne-text\">时间复杂度</span></h3><p id=\"u2099b77c\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度: O(n</span><span class=\"ne-text\">2</span><span class=\"ne-text\">)</span></p><hr id=\"TKxIO\" class=\"ne-hr\"><h2 id=\"396d121b\"><span class=\"ne-text\">桶排序</span></h2><h3 id=\"Hle0W\"><span class=\"ne-text\">原理</span></h3><p id=\"u89ccf869\" class=\"ne-p\"><span class=\"ne-text\">桶排序是计数排序的升级版，也采用了分冶思想</span></p><ol class=\"ne-ol\"><li id=\"u06e23347\"><span class=\"ne-text\">将要排序的数据分到有限数量的几个有序桶里</span></li><li id=\"uc519f97c\"><span class=\"ne-text\">每个桶里的数据再单独进行排序(一般用插入排序或者快速排序)</span></li></ol><ol start=\"3\" class=\"ne-ol\"><li id=\"u7107acca\"><span class=\"ne-text\">桶内排完序后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</span></li></ol><h3 id=\"dlvUu\"><span class=\"ne-text\">实现</span></h3><pre data-language=\"javascript\" id=\"d31b0703\" class=\"ne-codeblock language-javascript\">function bucketSort(arr, bucketSize) {\n  if (arr.length === 0) return arr;\n  let i = 0;\n  let min = arr[0];\n  let max = arr[0];\n  for (let i = 1; i &lt; arr.length; i++) {\n    if (arr[i] &lt; min) {\n      min = arr[i];\n    } else if (arr[i] &gt; max) {\n      max = arr[i];\n    }\n  }\n\n  // 初始化桶\n  const DEFAULT_BUCKET_SIZE = 5; // 桶的数量\n  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\n  const bucketCount = Math.floor((max - min) / bucketSize) + 1;\n  const buckets = new Array(bucketCount);\n  for (let i = 0; i &lt; buckets.length; i++) {\n    buckets[i] = [];\n  }\n\n  // 利用映射函数将数据分配到各个桶中\n  for (let i = 0; i &lt; arr.length; i++) {\n    buckets[Math.floor((arr[i] - min) / bucketSize)].push(arr[i]);\n  }\n\n  arr.length = 0;\n  for (let i = 0; i &lt; buckets.length; i++) {\n    quickSort(bucket[i]);\n    for (let j = 0; j &lt; buckets[i].length; j++) {\n      arr.push(buckets[i][j]);\n    }\n  }\n\n  return arr;\n}\n\nfunction quickSort(arr) {\n  if (arr.length &lt;= 1) return arr;\n  const middleIndex = arr.length &gt;&gt; 1;\n  const middle = arr.splice(middleIndex, 1)[0];\n  const left = [];\n  const right = [];\n  for (let i = 0; i &lt; arr.length; i++) {\n    if (arr[i] &lt; middle) {\n      left.push(arr[i]);\n    } else {\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat(middle, quickSort(right));\n}</pre><hr id=\"XSP1l\" class=\"ne-hr\"><h2 id=\"6f523ee9\"><span class=\"ne-text\">希尔排序</span></h2><h3 id=\"Fu3mP\"><span class=\"ne-text\">原理</span></h3><ol class=\"ne-ol\"><li id=\"udb3b87e2\"><span class=\"ne-text\">先将整个待排序的记录序列分割为若干子序列</span></li><li id=\"u367c4ced\"><span class=\"ne-text\">分别进行直接插入排序</span></li></ol><ol start=\"3\" class=\"ne-ol\"><li id=\"ub8c8c682\"><span class=\"ne-text\">待整个序列中的记录基本有序时，再对全体记录进行直接插入排序</span></li></ol><h3 id=\"FQ3De\"><span class=\"ne-text\">例子</span></h3><ol class=\"ne-ol\"><li id=\"u0aa141b9\"><span class=\"ne-text\">[35, 33, 42, 10, 14, 19, 27, 44] 采用间隔为 4, 创建一个位于 4 个位置间隔的所有值的虚拟子列表 [35, 14] [33, 19] [42, 27] [10, 44]</span></li><li id=\"uf27a3ee2\"><span class=\"ne-text\">比较每个子列表的值，并在原始数组中交换它们。完成此步骤后，新数组应改为 [14, 19, 27, 10, 35, 33, 42, 44]</span></li></ol><ol start=\"3\" class=\"ne-ol\"><li id=\"uea7d772b\"><span class=\"ne-text\">然后采用 2 间隔，产生两个虚拟子列表 [14, 27, 35, 42] [19, 10, 33, 44]</span></li><li id=\"u58fda10f\"><span class=\"ne-text\">比较并交换原始数组中的值。新数组变为 [14, 10, 27, 19, 35, 33, 42, 44]</span></li></ol><ol start=\"5\" class=\"ne-ol\"><li id=\"uc2b9d28e\"><span class=\"ne-text\">最后，使用间隔为 1 对数组其余部分进行排序，使用插入排序对数组进行排序</span></li></ol><h3 id=\"Sh8KJ\"><span class=\"ne-text\">实现</span></h3><pre data-language=\"javascript\" id=\"d12c4af5\" class=\"ne-codeblock language-javascript\">function shellSort(arr) {\n  let gap = 1; // 间隔\n  let temp;\n  while (gap &lt; arr.length / 3) {\n    // 动态定义间隔序列\n    gap = gap * 3 + 1;\n  }\n  for (gap; gap &gt; 0; gap = Math.floot(gap / 3)) {\n    for (let i = gap; i &lt; arr.length; i++) {\n      for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) {\n        [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]];\n      }\n    }\n  }\n  return arr;\n}</pre><h3 id=\"AKYow\"><span class=\"ne-text\">时间复杂度</span></h3><p id=\"u7879b156\" class=\"ne-p\"><span class=\"ne-text\">最佳: O(nlogn) 最差: O(nlog2n) 平均: O(nlog2n)</span></p><hr id=\"dvPxh\" class=\"ne-hr\"><h2 id=\"7da8b8bc\"><span class=\"ne-text\">选择排序</span></h2><h3 id=\"KKCy6\"><span class=\"ne-text\">思想</span></h3><p id=\"uddbc3211\" class=\"ne-p\"><span class=\"ne-text\">在冒泡排序上做了优化，减少了交换次数，首轮最大数放在第一项，一轮之后第一项就是有序的，第二轮开始选最大值放第二项，重复此操作。</span></p><h3 id=\"DsZ5Z\"><span class=\"ne-text\">原理</span></h3><p id=\"u957a3c1a\" class=\"ne-p\"><span class=\"ne-text\">遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值。下次遍历就可以从索引 1 开始重复上述操作。</span></p><h3 id=\"PUphp\"><span class=\"ne-text\">实现</span></h3><pre data-language=\"javascript\" id=\"0a4a067b\" class=\"ne-codeblock language-javascript\">function selectionSort(arr) {\n  for (let i = 0; i &lt; arr.length - 1; i++) {\n    let minIndex = i;\n    for (let j = i + 1; j &lt; arr.length; j++) {\n      minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;\n    }\n    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n  }\n  return arr;\n}</pre><h3 id=\"hnNa8\"><span class=\"ne-text\">时间复杂度</span></h3><p id=\"u09dff031\" class=\"ne-p\"><span class=\"ne-text\">时间复杂度: O(n2)</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"RY5r7\" id=\"RY5r7\"><span data-lake-id=\"u9c45b385\" id=\"u9c45b385\">插入排序</span></h2><h3 data-lake-id=\"BU6C3\" id=\"BU6C3\"><span data-lake-id=\"u003be884\" id=\"u003be884\">原理</span></h3><p data-lake-id=\"ue7e27734\" id=\"ue7e27734\"><span data-lake-id=\"u65dc1f84\" id=\"u65dc1f84\">第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第 3 个元素开始，向前对比，重复之前的操作。</span></p><h3 data-lake-id=\"xDMWu\" id=\"xDMWu\"><span data-lake-id=\"u04fcf363\" id=\"u04fcf363\">实现</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20insertSort(arr)%20%7B%5Cn%20%20%2F%2F%20%E5%A4%96%E5%B1%82%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0%5Cn%20%20for%20(let%20i%20%3D%201%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20for%20(let%20j%20%3D%20i%20-%201%3B%20i%20%3E%3D%200%20%26%26%20arr%5Bj%5D%20%3E%20arr%5Bj%20%2B%201%5D%3B%20j--)%20%7B%5Cn%20%20%20%20%20%20%5Barr%5Bj%5D%2C%20arr%5Bj%20%2B%201%5D%5D%20%3D%20%5Barr%5Bj%20%2B%201%5D%2C%20arr%5Bj%5D%5D%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20return%20arr%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2261a4caa6%22%7D\"></card><h3 data-lake-id=\"Ga4Mk\" id=\"Ga4Mk\"><span data-lake-id=\"ua3072de6\" id=\"ua3072de6\">时间复杂度</span></h3><p data-lake-id=\"u3960bcc3\" id=\"u3960bcc3\"><span data-lake-id=\"u3640c781\" id=\"u3640c781\">时间复杂度: O(n</span><span data-lake-id=\"u3ff5838c\" id=\"u3ff5838c\">2</span><span data-lake-id=\"u56f45199\" id=\"u56f45199\">)</span></p><card type=\"block\" name=\"hr\"></card><h2 data-lake-id=\"AuEPb\" id=\"AuEPb\"><span data-lake-id=\"u7a970326\" id=\"u7a970326\">堆排序</span></h2><h3 data-lake-id=\"fMMHl\" id=\"fMMHl\"><span data-lake-id=\"ua5da59c2\" id=\"ua5da59c2\">原理</span></h3><p data-lake-id=\"ufc55efba\" id=\"ufc55efba\"><span data-lake-id=\"ud8facaa9\" id=\"ud8facaa9\">堆排序利用了二叉堆的特性来做，二叉堆通常用数组来表示，并且二叉堆是一颗完全二叉树(除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列)。二叉堆分为大根堆和小根堆。</span></p><ul list=\"u56b14d9e\"><li fid=\"uea9fd965\" data-lake-id=\"ub736057d\" id=\"ub736057d\"><span data-lake-id=\"u49ecb07a\" id=\"u49ecb07a\">大根堆是某个节点的所有子节点的值都比它小</span></li><li fid=\"uea9fd965\" data-lake-id=\"u73bd046b\" id=\"u73bd046b\"><span data-lake-id=\"ue5cfdb6d\" id=\"ue5cfdb6d\">小根堆是某个节点的所有子节点的值都比它大</span></li></ul><p data-lake-id=\"u5ac3a3ca\" id=\"u5ac3a3ca\"><br></p><p data-lake-id=\"ue38122ea\" id=\"ue38122ea\"><span data-lake-id=\"u9398e406\" id=\"u9398e406\">堆排序的原理就是组成一个大根堆或小根堆。以小跟堆为例，某个节点的左边子节点的索引是 i ✖️ 2 + 1，右边是 i ✖️ 2 + 2，父节点是 (i - 1) / 2 =&gt; i &gt;&gt; 1</span></p><ol list=\"u62ea4b02\"><li fid=\"u9d9b53dd\" data-lake-id=\"u989f778a\" id=\"u989f778a\"><span data-lake-id=\"u284ca8b0\" id=\"u284ca8b0\">首先遍历数组，判断该节点的父节点是否比它小，如果小就交换位置并继续判断，直到它的父节点比它大</span></li><li fid=\"u9d9b53dd\" data-lake-id=\"u62bb7f47\" id=\"u62bb7f47\"><span data-lake-id=\"u42f122ce\" id=\"u42f122ce\">重复以上操作 1，直到数组首位是最大值</span></li><li fid=\"u9d9b53dd\" data-lake-id=\"u6cc08546\" id=\"u6cc08546\"><span data-lake-id=\"ua6349643\" id=\"ua6349643\">然后将首位和末尾交换位置并将数组长度减 1，表示数组末尾已经是最大值，不需要再比较大小</span></li><li fid=\"u9d9b53dd\" data-lake-id=\"u885bdc13\" id=\"u885bdc13\"><span data-lake-id=\"u7beef0a9\" id=\"u7beef0a9\">对比左右节点哪个大，然后记住大的节点的索引的值并和父节点对比大小，如果子节点大就交换位置</span></li><li fid=\"u9d9b53dd\" data-lake-id=\"uc64c88ee\" id=\"uc64c88ee\"><span data-lake-id=\"u9abc49a6\" id=\"u9abc49a6\">重复 3 - 4 直到整个数组都是大根堆</span></li></ol><h3 data-lake-id=\"vyyO9\" id=\"vyyO9\"><span data-lake-id=\"ufa540b43\" id=\"ufa540b43\">实现</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20heap(arr)%20%7B%5Cn%20%20%20%20%2F%2F%20%E5%B0%86%E6%9C%80%E5%A4%A7%E5%80%BC%E6%94%BE%E5%88%B0%E9%A6%96%E4%BD%8D%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20heapInsert(arr%2C%20i)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F%2F%20%E4%BA%A4%E6%8D%A2%E9%98%9F%E9%A6%96%E5%92%8C%E9%98%9F%E5%B0%BE%5Cn%20%20%20%20%5Barr%5B0%5D%2C%20arr%5Barr.length%20-%201%5D%5D%20%3D%20%5Barr%5Barr.length%20-%201%5D%2C%20arr%5B0%5D%5D%3B%5Cn%20%20%20%20while%20(arr.length%20%3E%200)%20%7B%5Cn%20%20%20%20%20%20%20%20heapify(arr%2C%200%2C%20arr.length%20-%201)%3B%5Cn%20%20%20%20%20%20%20%20%5Barr%5B0%5D%2C%20%5Barr%5Barr.length%20-%201%5D%5D%5D%20%3D%20%5Barr%5Barr.length%20-%201%5D%2C%20arr%5B0%5D%5D%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20arr%3B%5Cn%7D%5Cnfunction%20heapInsert(arr%2C%20index)%20%7B%5Cn%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%AF%94%E7%88%B6%E8%8A%82%E7%82%B9%E5%A4%A7%EF%BC%8C%E5%B0%B1%E4%BA%A4%E6%8D%A2%5Cn%20%20%20%20while(arr%5Bindex%5D%20%3E%20arr%5Bindex%20%3E%3E%201%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E4%BA%A4%E6%8D%A2%5Cn%20%20%20%20%20%20%20%20%5Barr%5Bindex%5D%2C%20arr%5Bindex%20%3E%3E%201%5D%5D%20%3D%20%5Barr%5Bindex%20%3E%3E%201%5D%2C%20arr%5Bindex%5D%5D%3B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%B0%86%E7%B4%A2%E5%BC%95%E5%8F%98%E4%B8%BA%E7%88%B6%E8%8A%82%E7%82%B9%5Cn%20%20%20%20%20%20%20%20index%20%3D%20index%20%3E%3E%201%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cnfunction%20heapify(arr%2C%20index%2C%20size)%20%7B%5Cn%20%20%20%20let%20left%20%3D%20index%20%3C%3C%201%20%2B%201%3B%5Cn%20%20%20%20while%20(left%20%3C%20size)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%88%A4%E6%96%AD%E5%B7%A6%E5%8F%B3%E8%8A%82%E7%82%B9%E5%A4%A7%E5%B0%8F%5Cn%20%20%20%20%20%20%20%20let%20largest%20%3D%20left%20%2B%201%20%3C%20size%20%26%26%20arr%5Bleft%5D%20%3C%20arr%5Bleft%20%2B%201%5D%20%3F%20left%20%2B%201%20%3A%20left%3B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%88%A4%E6%96%AD%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E7%88%B6%E8%8A%82%E7%82%B9%E5%A4%A7%E5%B0%8F%5Cn%20%20%20%20%20%20%20%20largest%20%3D%20arr%5Bindex%5D%20%3C%20arr%5Blargest%5D%20%3F%20largest%20%3A%20index%3B%5Cn%20%20%20%20%20%20%20%20if%20(largest%20%3D%3D%3D%20index)%20break%3B%5Cn%20%20%20%20%20%20%20%20%5Barr%5Bindex%5D%2C%20arr%5Blargest%5D%5D%20%3D%20%5Barr%5Blagest%5D%2C%20arr%5Bindex%5D%5D%3B%5Cn%20%20%20%20%20%20%20%20index%20%3D%20largest%3B%5Cn%20%20%20%20%20%20%20%20left%20%3D%20index%20%3C%3C%201%20%2B%201%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2222311562%22%7D\"></card><h3 data-lake-id=\"Qn227\" id=\"Qn227\"><span data-lake-id=\"uf0ea5024\" id=\"uf0ea5024\">时间复杂度</span></h3><p data-lake-id=\"uc0f85f49\" id=\"uc0f85f49\"><span data-lake-id=\"ue82bf593\" id=\"ue82bf593\">最佳: O(nlogn) 最差: O(nlogn) 平均: O(nlogn)</span></p><card type=\"block\" name=\"hr\"></card><h2 data-lake-id=\"Fgk8d\" id=\"Fgk8d\"><span data-lake-id=\"u3284951b\" id=\"u3284951b\">归并排序</span></h2><h3 data-lake-id=\"oC8Lf\" id=\"oC8Lf\"><span data-lake-id=\"ue6e3a07c\" id=\"ue6e3a07c\">原理</span></h3><p data-lake-id=\"ueb9b9a48\" id=\"ueb9b9a48\"><span data-lake-id=\"u28d03d64\" id=\"u28d03d64\">递归的将数组两两分开直到包含两个元素，然后将数组排序合并。最终合并为排序好的数组。</span></p><p data-lake-id=\"ue0542626\" id=\"ue0542626\"><span data-lake-id=\"u1347549c\" id=\"u1347549c\">​</span><br></p><p data-lake-id=\"u0436f05d\" id=\"u0436f05d\"><span data-lake-id=\"ucd15c8d0\" id=\"ucd15c8d0\">分冶思想，即将大问题拆成小问题，小问题解决后大问题自然就解决了。</span></p><h3 data-lake-id=\"bNZcJ\" id=\"bNZcJ\"><span data-lake-id=\"u23318c4a\" id=\"u23318c4a\">例子</span></h3><p data-lake-id=\"u11b277c4\" id=\"u11b277c4\"><span data-lake-id=\"u99842db5\" id=\"u99842db5\">[3, 1, 2, 8, 9, 7, 6] 中间数索引为 3, 先排序数组 [3, 1, 2, 8], 继续拆分直到变为数组包含两个元素, 如果数组长度为奇数, 有一个拆分到只剩下 1 个元素。然后排序数组 [3, 1] [2, 8], 再排序 [1, 2, 3, 8], 这样左边数组就排序完毕，同理排序右边数组，最后排序左右数组合并后的结果</span></p><h3 data-lake-id=\"TzrjJ\" id=\"TzrjJ\"><span data-lake-id=\"u55dcb659\" id=\"u55dcb659\">实现</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E6%8B%86%E5%88%86%5Cnfunction%20mergeSort(arr)%20%7B%5Cn%20%20if%20(arr.length%20%3C%3D%201)%20return%20arr%3B%5Cn%20%20let%20middle%20%3D%20%20arr.length%20%3E%3E%201%3B%20%2F%2F%20arr.length%20%3E%3E%201%20%E7%AD%89%E4%BB%B7%E4%BA%8E%20Math.floot(arr.length%20%2F%202)%5Cn%20%20let%20left%20%3D%20arr.slice(0%2C%20middle)%3B%5Cn%20%20let%20right%20%3D%20arr.slice(middle)%3B%5Cn%20%20return%20merge(mergeSort(left)%2C%20mergeSort(right))%3B%5Cn%7D%5Cn%2F%2F%20%E5%90%88%E5%B9%B6%5Cnfunction%20merge(left%2C%20right)%20%7B%5Cn%20%20const%20result%20%3D%20%5B%5D%3B%5Cn%20%20while%20(left.length%20%3E%200%20%26%26%20right.length%20%3E%200)%20%7B%5Cn%20%20%20%20if%20(left%5B0%5D%20%3C%3D%20right%5B0%5D)%20%7B%5Cn%20%20%20%20%20%20result.push(left.shift())%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20result.push(right.shift())%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20return%20result.concat(left%2C%20right)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22b5b328ec%22%7D\"></card><h3 data-lake-id=\"LG3Fg\" id=\"LG3Fg\"><span data-lake-id=\"u7b0696da\" id=\"u7b0696da\">时间复杂度</span></h3><p data-lake-id=\"ua5a24e82\" id=\"ua5a24e82\"><span data-lake-id=\"u30f59293\" id=\"u30f59293\">拆分数组需要 logn 步, 合并需要 n 步, 因此 O(nlogn)</span></p><card type=\"block\" name=\"hr\"></card><h2 data-lake-id=\"be91b57e\" id=\"be91b57e\"><span data-lake-id=\"uaed42a6a\" id=\"uaed42a6a\">基数排序</span></h2><h3 data-lake-id=\"mPf0U\" id=\"mPf0U\"><span data-lake-id=\"u4dce0c76\" id=\"u4dce0c76\">原理</span></h3><p data-lake-id=\"uf1fb8e16\" id=\"uf1fb8e16\"><span data-lake-id=\"u12f77bfa\" id=\"u12f77bfa\">基数排序是一种非比较型整数排序算法，也是桶排序的一种特殊情况。其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较</span></p><p data-lake-id=\"u57f4e0bb\" id=\"u57f4e0bb\"><br></p><p data-lake-id=\"uf1a65188\" id=\"uf1a65188\"><span data-lake-id=\"u6bf5e036\" id=\"u6bf5e036\">简单来说就是分成 10 个桶，按照每个数字的最后一位数字进行分桶，然后按顺序放入桶中，之后按照桶大小从桶底部按顺序放入数列中。第一轮完毕后将按照每个数字的倒数第二位数字进行分桶，原理同上，当没有位数时，将按 0 处理。</span></p><h3 data-lake-id=\"oR6aZ\" id=\"oR6aZ\"><span data-lake-id=\"ubfb449e3\" id=\"ubfb449e3\">实现</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F**%5Cn%20*%5Cn%20*%20%40param%20arr%20%E5%BE%85%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%5Cn%20*%20%40param%20max%20%E6%9C%80%E5%A4%A7%E4%BD%8D%E6%95%B0%5Cn%20*%2F%5Cnfunction%20radixSort(arr%2C%20max)%20%7B%5Cn%20%20const%20buckets%20%3D%20%5B%5D%3B%5Cn%20%20let%20unit%20%3D%2010%2C%5Cn%20%20%20%20base%20%3D%201%3B%5Cn%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20max%3B%20i%2B%2B%2C%20base%20*%3D%2010%2C%20unit%20*%3D%2010)%20%7B%5Cn%20%20%20%20for%20(let%20j%20%3D%200%3B%20j%20%3C%20array.length%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20let%20index%20%3D%20~~((array%5Bj%5D%20%25%20unit)%20%2F%20base)%3B%20%2F%2F%E4%BE%9D%E6%AC%A1%E8%BF%87%E6%BB%A4%E5%87%BA%E4%B8%AA%E4%BD%8D%EF%BC%8C%E5%8D%81%E4%BD%8D%E7%AD%89%E7%AD%89%E6%95%B0%E5%AD%97%5Cn%20%20%20%20%20%20if%20(buckets%5Bindex%5D%20%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20buckets%5Bindex%5D%20%3D%20%5B%5D%3B%20%2F%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%B6%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20buckets%5Bindex%5D.push(array%5Bj%5D)%3B%20%2F%2F%E5%BE%80%E4%B8%8D%E5%90%8C%E6%A1%B6%E9%87%8C%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%5Cn%20%20%20%20%7D%5Cn%20%20%20%20let%20pos%20%3D%200%2C%5Cn%20%20%20%20%20%20value%3B%5Cn%20%20%20%20for%20(let%20j%20%3D%200%2C%20length%20%3D%20buckets.length%3B%20j%20%3C%20length%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20if%20(buckets%5Bj%5D%20!%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20while%20((value%20%3D%20buckets%5Bj%5D.shift())%20!%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20array%5Bpos%2B%2B%5D%20%3D%20value%3B%20%2F%2F%E5%B0%86%E4%B8%8D%E5%90%8C%E6%A1%B6%E9%87%8C%E6%95%B0%E6%8D%AE%E6%8C%A8%E4%B8%AA%E6%8D%9E%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%B8%BA%E4%B8%8B%E4%B8%80%E8%BD%AE%E9%AB%98%E4%BD%8D%E6%8E%92%E5%BA%8F%E5%81%9A%E5%87%86%E5%A4%87%EF%BC%8C%E7%94%B1%E4%BA%8E%E9%9D%A0%E8%BF%91%E6%A1%B6%E5%BA%95%E7%9A%84%E5%85%83%E7%B4%A0%E6%8E%92%E5%90%8D%E9%9D%A0%E5%89%8D%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%BB%8E%E6%A1%B6%E5%BA%95%E5%85%88%E6%8D%9E%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20return%20arr%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22e455bd36%22%7D\"></card><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22ft0pp%22%7D\"></card><h2 data-lake-id=\"uOcpR\" id=\"uOcpR\"><span data-lake-id=\"u4aba535d\" id=\"u4aba535d\">计数排序</span></h2><h3 data-lake-id=\"uzVZx\" id=\"uzVZx\"><span data-lake-id=\"u9f96e7ff\" id=\"u9f96e7ff\">原理</span></h3><p data-lake-id=\"u0375819d\" id=\"u0375819d\"><span data-lake-id=\"u81757088\" id=\"u81757088\">对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。</span></p><h3 data-lake-id=\"i1t42\" id=\"i1t42\"><span data-lake-id=\"u25d9cdf4\" id=\"u25d9cdf4\">实现</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20countionSort(arr)%20%7B%5Cn%20%20let%20obj%20%3D%20%7B%7D%3B%5Cn%20%20%2F%2F%20%E9%81%8D%E5%8E%86%E5%8E%9F%E6%95%B0%E7%BB%84%EF%BC%8C%E7%BB%99%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E5%B0%B1%E5%AF%B9%E5%BA%94%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%2B%2B%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%88%99%E6%96%B0%E5%A2%9E%E9%94%AE%E5%80%BC%E5%AF%B9%5Cn%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20if%20(!obj%5Barr%5Bi%5D%5D)%20%7B%5Cn%20%20%20%20%20%20obj%5Barr%5Bi%5D%5D%20%3D%201%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20obj%5Barr%5Bi%5D%5D%2B%2B%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20let%20index%20%3D%200%3B%5Cn%20%20%2F%2F%20%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%90%8D%EF%BC%8C%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%94%BE%E5%9B%9E%E8%A6%86%E7%9B%96%E5%8E%9F%E6%95%B0%E7%BB%84%5Cn%20%20for%20(let%20key%20in%20obj)%20%7B%5Cn%20%20%20%20while%20(obj%5Bkey%5D%20%3E%200)%20%7B%5Cn%20%20%20%20%20%20arr%5Bindex%5D%20%3D%20Number(key)%3B%5Cn%20%20%20%20%20%20obj%5Bkey%5D--%3B%5Cn%20%20%20%20%20%20index%2B%2B%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20return%20arr%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22a4076647%22%7D\"></card><card type=\"block\" name=\"hr\"></card><h2 data-lake-id=\"ydBb0\" id=\"ydBb0\"><span data-lake-id=\"u98594787\" id=\"u98594787\">快速排序</span></h2><h3 data-lake-id=\"P9ohy\" id=\"P9ohy\"><span data-lake-id=\"u7c27d911\" id=\"u7c27d911\">特点</span></h3><p data-lake-id=\"u7ecca22c\" id=\"u7ecca22c\"><span data-lake-id=\"u5e825370\" id=\"u5e825370\">快速排序的特点就是快，而且效率高。它是处理大数据最快的排序算法之一</span></p><h3 data-lake-id=\"W5oA8\" id=\"W5oA8\"><span data-lake-id=\"uf99d679d\" id=\"uf99d679d\">原理</span></h3><p data-lake-id=\"u619bf2cb\" id=\"u619bf2cb\"><span data-lake-id=\"u5a03319c\" id=\"u5a03319c\">随机选取一个数组中的值作为基准值，从左至右取值与基准值比较大小。比基准值小的放到数组左边，比基准值大的放到数组右边，对比完成后将基准值和第一个比基准值大的值交换位置，然后将数组以基准值的位置分为两个部分，继续递归以上操作。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20quickSort(arr)%20%7B%5Cn%20%20%20%20if%20(arr.length%20%3C%3D%201)%20return%20arr%3B%5Cn%20%20%20%20%2F%2F%20%E5%8F%96%E5%9F%BA%E5%87%86%E7%82%B9%5Cn%20%20%20%20const%20middleIndex%20%3D%20arr.length%20%3E%3E%201%3B%5Cn%20%20%20%20%2F%2F%20%E5%8F%96%E5%9F%BA%E5%87%86%E7%82%B9%E7%9A%84%E5%80%BC%5Cn%20%20%20%20const%20middle%20%3D%20arr.splice(middleIndex%2C%201)%5B0%5D%3B%5Cn%20%20%20%20const%20left%20%3D%20%5B%5D%3B%5Cn%20%20%20%20const%20right%20%3D%20%5B%5D%3B%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(arr%5Bi%5D%20%3C%20middle)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20left.push(arr%5Bi%5D)%3B%5Cn%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20right.push(arr%5Bi%5D)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20quickSort(left).concat(middle%2C%20quickSort(right))%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22d9136be3%22%7D\"></card><h3 data-lake-id=\"kazHZ\" id=\"kazHZ\"><span data-lake-id=\"u11e8696b\" id=\"u11e8696b\">时间复杂度</span></h3><p data-lake-id=\"u6a3ecdac\" id=\"u6a3ecdac\"><span data-lake-id=\"u8637a1b5\" id=\"u8637a1b5\">最佳: O(nlogn) 最差: O(n</span><span data-lake-id=\"uc376422f\" id=\"uc376422f\">2</span><span data-lake-id=\"u948b010b\" id=\"u948b010b\">) 平均: O(nlogn)</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22zSSZk%22%7D\"></card><h2 data-lake-id=\"UblUz\" id=\"UblUz\"><span data-lake-id=\"ucb19c0ec\" id=\"ucb19c0ec\">冒泡排序</span></h2><h3 data-lake-id=\"Kncte\" id=\"Kncte\"><span data-lake-id=\"u53fce29f\" id=\"u53fce29f\">原理</span></h3><p data-lake-id=\"u7644f19d\" id=\"u7644f19d\"><span data-lake-id=\"uc09d9b93\" id=\"uc09d9b93\">从第一个元素开始，把当前元素和下一个索引元素进行比较，如果当前元素大，就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 2 的位置即可</span></p><h3 data-lake-id=\"dkeBR\" id=\"dkeBR\"><span data-lake-id=\"u87322553\" id=\"u87322553\">实现</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20bubbleSort(arr)%20%7B%5Cn%20%20for%20(let%20i%20%3D%20arr.length%20-%201%3B%20i%20%3E%200%3B%20i--)%20%7B%5Cn%20%20%20%20for%20(let%20j%20%3D%200%3B%20j%20%3C%20i%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%2F%2F%20%E7%B4%A2%E5%BC%95%E5%A4%A7%E7%9A%84%E6%95%B0%E7%BB%84%E5%80%BC%E5%A4%A7%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84%E5%80%BC%EF%BC%8C%E4%BA%A4%E6%8D%A2%5Cn%20%20%20%20%20%20if%20(arr%5Bj%5D%20%3E%20arr%5Bj%20%2B%201%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20%5Barr%5Bj%5D%2C%20arr%5Bj%20%2B%201%5D%5D%20%3D%20%5Barr%5Bj%20%2B%201%5D%2C%20arr%5Bj%5D%5D%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20return%20arr%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22e504345b%22%7D\"></card><h3 data-lake-id=\"WrrPF\" id=\"WrrPF\"><span data-lake-id=\"udcbab841\" id=\"udcbab841\">时间复杂度</span></h3><p data-lake-id=\"u2099b77c\" id=\"u2099b77c\"><span data-lake-id=\"u3cbb0bcc\" id=\"u3cbb0bcc\">时间复杂度: O(n</span><span data-lake-id=\"ud684e884\" id=\"ud684e884\">2</span><span data-lake-id=\"ue07cee11\" id=\"ue07cee11\">)</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22TKxIO%22%7D\"></card><h2 data-lake-id=\"396d121b\" id=\"396d121b\"><span data-lake-id=\"u666912f8\" id=\"u666912f8\">桶排序</span></h2><h3 data-lake-id=\"Hle0W\" id=\"Hle0W\"><span data-lake-id=\"u28927785\" id=\"u28927785\">原理</span></h3><p data-lake-id=\"u89ccf869\" id=\"u89ccf869\"><span data-lake-id=\"uca8563f3\" id=\"uca8563f3\">桶排序是计数排序的升级版，也采用了分冶思想</span></p><ol list=\"u120c1eac\"><li fid=\"uaeb64ae5\" data-lake-id=\"u06e23347\" id=\"u06e23347\"><span data-lake-id=\"u23e112d4\" id=\"u23e112d4\">将要排序的数据分到有限数量的几个有序桶里</span></li><li fid=\"uaeb64ae5\" data-lake-id=\"uc519f97c\" id=\"uc519f97c\"><span data-lake-id=\"ubced399e\" id=\"ubced399e\">每个桶里的数据再单独进行排序(一般用插入排序或者快速排序)</span></li><li fid=\"uaeb64ae5\" data-lake-id=\"u7107acca\" id=\"u7107acca\"><span data-lake-id=\"ud0ee0775\" id=\"ud0ee0775\">桶内排完序后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</span></li></ol><h3 data-lake-id=\"dlvUu\" id=\"dlvUu\"><span data-lake-id=\"ub53a9e4f\" id=\"ub53a9e4f\">实现</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20bucketSort(arr%2C%20bucketSize)%20%7B%5Cn%20%20if%20(arr.length%20%3D%3D%3D%200)%20return%20arr%3B%5Cn%20%20let%20i%20%3D%200%3B%5Cn%20%20let%20min%20%3D%20arr%5B0%5D%3B%5Cn%20%20let%20max%20%3D%20arr%5B0%5D%3B%5Cn%20%20for%20(let%20i%20%3D%201%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20if%20(arr%5Bi%5D%20%3C%20min)%20%7B%5Cn%20%20%20%20%20%20min%20%3D%20arr%5Bi%5D%3B%5Cn%20%20%20%20%7D%20else%20if%20(arr%5Bi%5D%20%3E%20max)%20%7B%5Cn%20%20%20%20%20%20max%20%3D%20arr%5Bi%5D%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%5Cn%20%20%2F%2F%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%B6%5Cn%20%20const%20DEFAULT_BUCKET_SIZE%20%3D%205%3B%20%2F%2F%20%E6%A1%B6%E7%9A%84%E6%95%B0%E9%87%8F%5Cn%20%20bucketSize%20%3D%20bucketSize%20%7C%7C%20DEFAULT_BUCKET_SIZE%3B%5Cn%20%20const%20bucketCount%20%3D%20Math.floor((max%20-%20min)%20%2F%20bucketSize)%20%2B%201%3B%5Cn%20%20const%20buckets%20%3D%20new%20Array(bucketCount)%3B%5Cn%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20buckets.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20buckets%5Bi%5D%20%3D%20%5B%5D%3B%5Cn%20%20%7D%5Cn%5Cn%20%20%2F%2F%20%E5%88%A9%E7%94%A8%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0%E5%B0%86%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%88%B0%E5%90%84%E4%B8%AA%E6%A1%B6%E4%B8%AD%5Cn%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20buckets%5BMath.floor((arr%5Bi%5D%20-%20min)%20%2F%20bucketSize)%5D.push(arr%5Bi%5D)%3B%5Cn%20%20%7D%5Cn%5Cn%20%20arr.length%20%3D%200%3B%5Cn%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20buckets.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20quickSort(bucket%5Bi%5D)%3B%5Cn%20%20%20%20for%20(let%20j%20%3D%200%3B%20j%20%3C%20buckets%5Bi%5D.length%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20arr.push(buckets%5Bi%5D%5Bj%5D)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%5Cn%20%20return%20arr%3B%5Cn%7D%5Cn%5Cnfunction%20quickSort(arr)%20%7B%5Cn%20%20if%20(arr.length%20%3C%3D%201)%20return%20arr%3B%5Cn%20%20const%20middleIndex%20%3D%20arr.length%20%3E%3E%201%3B%5Cn%20%20const%20middle%20%3D%20arr.splice(middleIndex%2C%201)%5B0%5D%3B%5Cn%20%20const%20left%20%3D%20%5B%5D%3B%5Cn%20%20const%20right%20%3D%20%5B%5D%3B%5Cn%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20if%20(arr%5Bi%5D%20%3C%20middle)%20%7B%5Cn%20%20%20%20%20%20left.push(arr%5Bi%5D)%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20right.push(arr%5Bi%5D)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20return%20quickSort(left).concat(middle%2C%20quickSort(right))%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22d31b0703%22%7D\"></card><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22XSP1l%22%7D\"></card><h2 data-lake-id=\"6f523ee9\" id=\"6f523ee9\"><span data-lake-id=\"ub5839776\" id=\"ub5839776\">希尔排序</span></h2><h3 data-lake-id=\"Fu3mP\" id=\"Fu3mP\"><span data-lake-id=\"u53ccb651\" id=\"u53ccb651\">原理</span></h3><ol list=\"uf7ede7e7\"><li fid=\"u08679a33\" data-lake-id=\"udb3b87e2\" id=\"udb3b87e2\"><span data-lake-id=\"ub31cdd87\" id=\"ub31cdd87\">先将整个待排序的记录序列分割为若干子序列</span></li><li fid=\"u08679a33\" data-lake-id=\"u367c4ced\" id=\"u367c4ced\"><span data-lake-id=\"u2de636da\" id=\"u2de636da\">分别进行直接插入排序</span></li><li fid=\"u08679a33\" data-lake-id=\"ub8c8c682\" id=\"ub8c8c682\"><span data-lake-id=\"u06223470\" id=\"u06223470\">待整个序列中的记录基本有序时，再对全体记录进行直接插入排序</span></li></ol><h3 data-lake-id=\"FQ3De\" id=\"FQ3De\"><span data-lake-id=\"u4e6afaf7\" id=\"u4e6afaf7\">例子</span></h3><ol list=\"u91870b29\"><li fid=\"u9eed96e1\" data-lake-id=\"u0aa141b9\" id=\"u0aa141b9\"><span data-lake-id=\"uba010046\" id=\"uba010046\">[35, 33, 42, 10, 14, 19, 27, 44] 采用间隔为 4, 创建一个位于 4 个位置间隔的所有值的虚拟子列表 [35, 14] [33, 19] [42, 27] [10, 44]</span></li><li fid=\"u9eed96e1\" data-lake-id=\"uf27a3ee2\" id=\"uf27a3ee2\"><span data-lake-id=\"u58a28eb5\" id=\"u58a28eb5\">比较每个子列表的值，并在原始数组中交换它们。完成此步骤后，新数组应改为 [14, 19, 27, 10, 35, 33, 42, 44]</span></li><li fid=\"u9eed96e1\" data-lake-id=\"uea7d772b\" id=\"uea7d772b\"><span data-lake-id=\"u1964177b\" id=\"u1964177b\">然后采用 2 间隔，产生两个虚拟子列表 [14, 27, 35, 42] [19, 10, 33, 44]</span></li><li fid=\"u9eed96e1\" data-lake-id=\"u58fda10f\" id=\"u58fda10f\"><span data-lake-id=\"u7fde54eb\" id=\"u7fde54eb\">比较并交换原始数组中的值。新数组变为 [14, 10, 27, 19, 35, 33, 42, 44]</span></li><li fid=\"u9eed96e1\" data-lake-id=\"uc2b9d28e\" id=\"uc2b9d28e\"><span data-lake-id=\"u8e90658a\" id=\"u8e90658a\">最后，使用间隔为 1 对数组其余部分进行排序，使用插入排序对数组进行排序</span></li></ol><h3 data-lake-id=\"Sh8KJ\" id=\"Sh8KJ\"><span data-lake-id=\"u2b450759\" id=\"u2b450759\">实现</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20shellSort(arr)%20%7B%5Cn%20%20let%20gap%20%3D%201%3B%20%2F%2F%20%E9%97%B4%E9%9A%94%5Cn%20%20let%20temp%3B%5Cn%20%20while%20(gap%20%3C%20arr.length%20%2F%203)%20%7B%5Cn%20%20%20%20%2F%2F%20%E5%8A%A8%E6%80%81%E5%AE%9A%E4%B9%89%E9%97%B4%E9%9A%94%E5%BA%8F%E5%88%97%5Cn%20%20%20%20gap%20%3D%20gap%20*%203%20%2B%201%3B%5Cn%20%20%7D%5Cn%20%20for%20(gap%3B%20gap%20%3E%200%3B%20gap%20%3D%20Math.floot(gap%20%2F%203))%20%7B%5Cn%20%20%20%20for%20(let%20i%20%3D%20gap%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20for%20(j%20%3D%20i%20-%20gap%3B%20j%20%3E%3D%200%20%26%26%20arr%5Bj%5D%20%3E%20temp%3B%20j%20-%3D%20gap)%20%7B%5Cn%20%20%20%20%20%20%20%20%5Barr%5Bj%5D%2C%20arr%5Bj%20%2B%20gap%5D%5D%20%3D%20%5Barr%5Bj%20%2B%20gap%5D%2C%20arr%5Bj%5D%5D%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20return%20arr%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22d12c4af5%22%7D\"></card><h3 data-lake-id=\"AKYow\" id=\"AKYow\"><span data-lake-id=\"ud97d01af\" id=\"ud97d01af\">时间复杂度</span></h3><p data-lake-id=\"u7879b156\" id=\"u7879b156\"><span data-lake-id=\"u5ced13d1\" id=\"u5ced13d1\">最佳: O(nlogn) 最差: O(nlog2n) 平均: O(nlog2n)</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22dvPxh%22%7D\"></card><h2 data-lake-id=\"7da8b8bc\" id=\"7da8b8bc\"><span data-lake-id=\"ue12d8c4b\" id=\"ue12d8c4b\">选择排序</span></h2><h3 data-lake-id=\"KKCy6\" id=\"KKCy6\"><span data-lake-id=\"u383e76fa\" id=\"u383e76fa\">思想</span></h3><p data-lake-id=\"uddbc3211\" id=\"uddbc3211\"><span data-lake-id=\"u1b693768\" id=\"u1b693768\">在冒泡排序上做了优化，减少了交换次数，首轮最大数放在第一项，一轮之后第一项就是有序的，第二轮开始选最大值放第二项，重复此操作。</span></p><h3 data-lake-id=\"DsZ5Z\" id=\"DsZ5Z\"><span data-lake-id=\"u55f117e1\" id=\"u55f117e1\">原理</span></h3><p data-lake-id=\"u957a3c1a\" id=\"u957a3c1a\"><span data-lake-id=\"u69faf3fe\" id=\"u69faf3fe\">遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值。下次遍历就可以从索引 1 开始重复上述操作。</span></p><h3 data-lake-id=\"PUphp\" id=\"PUphp\"><span data-lake-id=\"u9737ff1a\" id=\"u9737ff1a\">实现</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20selectionSort(arr)%20%7B%5Cn%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20arr.length%20-%201%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20let%20minIndex%20%3D%20i%3B%5Cn%20%20%20%20for%20(let%20j%20%3D%20i%20%2B%201%3B%20j%20%3C%20arr.length%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20minIndex%20%3D%20arr%5Bj%5D%20%3C%20arr%5BminIndex%5D%20%3F%20j%20%3A%20minIndex%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%5Barr%5Bi%5D%2C%20arr%5BminIndex%5D%5D%20%3D%20%5Barr%5BminIndex%5D%2C%20arr%5Bi%5D%5D%3B%5Cn%20%20%7D%5Cn%20%20return%20arr%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%220a4a067b%22%7D\"></card><h3 data-lake-id=\"hnNa8\" id=\"hnNa8\"><span data-lake-id=\"u3eb470a7\" id=\"u3eb470a7\">时间复杂度</span></h3><p data-lake-id=\"u09dff031\" id=\"u09dff031\"><span data-lake-id=\"u2d7db4fa\" id=\"u2d7db4fa\">时间复杂度: O(n2)</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-03-15T16:17:05.000Z",
  "deleted_at": null,
  "created_at": "2022-03-15T16:07:17.000Z",
  "updated_at": "2022-03-15T16:17:05.000Z",
  "published_at": "2022-03-15T16:17:05.000Z",
  "first_published_at": "2022-03-15T16:08:16.000Z",
  "word_count": 3082,
  "cover": null,
  "description": "插入排序原理第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第 3 个元素开始，向前对比，重复之前的操作。实现function insertSort(arr) {   // 外层控制循环次数   for ...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}