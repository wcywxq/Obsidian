{
  "id": 32985721,
  "slug": "lscqxu",
  "title": "编写 React 组件时常见的 5 个错误",
  "book_id": 25332296,
  "book": {
    "id": 25332296,
    "type": "Book",
    "slug": "xxble8",
    "name": "前端技术文章",
    "user_id": 732231,
    "description": "记录前端相关的技术性文章",
    "creator_id": 732231,
    "public": 0,
    "items_count": 23,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2022-06-15T01:16:19.043Z",
    "updated_at": "2023-11-11T18:11:38.000Z",
    "created_at": "2022-03-13T09:55:39.000Z",
    "namespace": "wcywxq/xxble8",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"b343d5c4\"></a>\n# 编写 React 组件时常见的 5 个错误\n\n<a name=\"afd85692\"></a>\n## 1. 在不需要重渲染时使用 useState\n\nReact 的一个核心概念是处理状态。你可以通过状态控制整个数据流和渲染过程。每次树被重新渲染时，很可能是因为状态的变化。\n\n使用 useState hook，你现在还可以在函数组件中定义状态，这种方法可以真正简洁地在 React 中处理状态。但正如以下示例所示，它也可能被滥用。\n\n关于下面这个示例我们需要说明一下。假设我们有两个按钮，一个按钮是计数器，另一个按钮使用当前计数发送请求或触发动作。但是，当前编号永远不会显示在组件内。当你单击第二个按钮时才需要这个请求。\n\n这很危险❌\n\n```jsx\nfunction ClickButton(props) {\n  const [count, setCount] = useState(0);\n  const onClickCount = () => {\n    setCount((c) => c + 1);\n  };\n  const onClickRequest = () => {\n    apiCall(count);\n  };\n  return (\n    <div>\n      <button onClick={onClickCount}>Counter</button>\n      <button onClick={onClickRequest}>Submit</button>\n    </div>\n  );\n}\n```\n\n<a name=\"2bed77ed\"></a>\n### 问题⚡\n\n乍一看，你可能会问这到底有什么问题？状态不就是这样用的吗？你当然没错，它运行很正常，并且可能永远不会出问题，但是在 React 中，每个状态更改都将强制对该组件，很有可能还有其子级进行重渲染，但在上面的示例中，因为我们从未在渲染部分中使用这个状态，结果每次设置计数器时都会有不必要的重渲染，这可能会影响性能或产生意外的副作用。\n\n<a name=\"6d6afad5\"></a>\n### 解决方案✅\n\n如果要在组件内部使用一个变量，希望该变量在渲染之间保持其值，但又不强制重新渲染，则可以使用 useRef hook。它将保留值，但不强制重新渲染组件。\n\n```jsx\nfunction ClickButton(props) {\n  const count = useRef(0);\n  const onClickCount = () => {\n    count.current++;\n  };\n  const onClickRequest = () => {\n    apiCall(count.current);\n  };\n  return (\n    <div>\n      <button onClick={onClickCount}>Counter</button>\n      <button onClick={onClickRequest}>Submit</button>\n    </div>\n  );\n}\n```\n\n<a name=\"c3296fec\"></a>\n## 2. 使用 router.push 代替链接\n\n这可能是一个显而易见的错误，其实和 React 本身没什么关系，但是当人们编写 React 组件时经常会犯这种错误。\n\n假设你要编写一个按钮，单击该按钮应将用户重定向到另一个页面。由于它是一个 SPA，因此这个动作是客户端路由机制。于是你需要某种库来执行此动作。在 React 中最流行的是 react-router，下面的示例就会使用它。\n\n所以，添加一个点击侦听器会将用户重定向到所需的页面，对吗？\n\n<a name=\"0682bbd6\"></a>\n### 这很危险❌\n\n```jsx\nfunction ClickButton(props) {\n  const history = useHistory();\n  const onClick = () => {\n    history.push('/next-page');\n  };\n  return <button onClick={onClick}>Go to next page</button>;\n}\n```\n\n<a name=\"2bed77ed-1\"></a>\n### 问题⚡\n\n就算这段代码对于大多数用户来说都可以正常工作，但这里也有严重的可访问性问题。这个按钮根本不会被标记为链接到另一个页面，于是屏幕阅读器几乎无法识别它。而且你能在新标签页或窗口中打开它吗？很可能做不到。\n\n<a name=\"6d6afad5-1\"></a>\n### 解决方案✅\n\n只要指向其他页面的链接带有某种用户交互，就要尽量用 < Link> 组件或常规的 < a> 标签处理。\n\n```jsx\nfunction ClickButton(props) {\n  return (\n    <Link to=\"/next-page\">\n      <span>Go to next page</span>\n    </Link>\n  );\n}\n```\n\n优点：这也使代码更易读，更短！\n\n<a name=\"1a8f40e8\"></a>\n## 3. 通过 useEffect 处理动作\n\nReact 引入的最好用，最贴心的一个 hook 是 useEffect。它可以处理与 prop 或 state 更改相关的动作。可就算它很好用，人们也不该到处滥用它。\n\n想象一下有一个组件，其获取一个项目列表并将其渲染给 dom。另外，如果请求成功，我们将调用“onSuccess”函数，该函数作为一个 prop 传递给这个组件。\n\n<a name=\"0682bbd6-1\"></a>\n### 这很危险❌\n\n```jsx\nfunction DataList({ onSuccess }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const fetchData = useCallback(() => {\n    setLoading(true);\n    callApi()\n      .then((res) => setData(res))\n      .catch((err) => setError(err))\n      .finally(() => setLoading(false));\n  }, []);\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  useEffect(() => {\n    if (!loading && !error && data) {\n      onSuccess();\n    }\n  }, [loading, error, data, onSuccess]);\n  return <div>Data: {data}</div>;\n}\n```\n\n<a name=\"2bed77ed-2\"></a>\n### 问题⚡\n\n一共有两个 useEffect hooks，第一个在初始渲染时处理 api 调用，第二个会调用 onSuccess 函数，假设当状态没有加载、没有错误但有数据时调用肯定成功。这很有道理是吧？\n\n对第一个调用来说这肯定是正确的，并且可能永远不会失败。但你也失去了动作和需要调用的函数之间的直接联系。同样也没有 100％的保证可以说这种情况仅在 fetch 动作成功后才会发生，而这正是我们开发人员不想看到的。\n\n<a name=\"6d6afad5-2\"></a>\n### 解决方案✅\n\n一个简单明了的解决方案是将“onSuccess”函数设置为调用成功的实际位置：\n\n```jsx\nfunction DataList({ onSuccess }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const fetchData = useCallback(() => {\n    setLoading(true);\n    callApi()\n      .then((fetchedData) => {\n        setData(fetchedData);\n        onSuccess();\n      })\n      .catch((err) => setError(err))\n      .finally(() => setLoading(false));\n  }, [onSuccess]);\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  return <div>{data}</div>;\n}\n```\n\n现在一目了然了，在 api 调用成功的情况下才调用 onSuccess。\n\n<a name=\"088924da\"></a>\n## 4. 单一责任组件\n\n组合组件可能不是什么轻松的事情。什么时候将一个组件拆分为几个较小的组件？如何构造组件树？使用基于组件的框架时，每天都会遇到这些问题。设计组件时常见的一个错误是将两个用例合并到一个组件中。以一个 header 为例，其在移动设备上显示一个汉堡按钮，或在桌面屏幕上显示标签。（这里的条件通过神奇的 isMobile 函数处理，这里就不深入讲解了。）\n\n<a name=\"0682bbd6-2\"></a>\n### 这很危险❌\n\n```jsx\nfunction Header(props) {\n  return (\n    <header>\n      <HeaderInner menuItems={menuItems} />\n    </header>\n  );\n}\nfunction HeaderInner({ menuItems }) {\n  return isMobile() ? \n        <BurgerButton menuItems={menuItems} /> : \n        <Tabs tabData={menuItems} />;\n}\n```\n\n<a name=\"2bed77ed-3\"></a>\n### 问题⚡\n\n使用这种方法时，HeaderInner 组件试图同时兼顾两件事情，而我们都知道一心最好不要二用。而且，这种组件很难在其他地方测试或重用。\n\n<a name=\"6d6afad5-3\"></a>\n### 解决方案✅\n\n将条件提高一级，这样就能更容易看清组件的本来用途，搞明白它们只应该负责一个任务，不管是 Header、Tab 或 BurgerButton 也好，总之不要一心多用。\n\n```jsx\nfunction Header(props) {\n  return (\n    <header>\n        {\n            isMobile() ? \n                <BurgerButton menuItems={menuItems} /> : \n                <Tabs tabData={menuItems} />\n        }\n        </header>\n  );\n}\n```\n\n<a name=\"3691cbd4\"></a>\n## 5. 单一责任的 useEffects\n\n还记得以前，我们只能用 componentWillReceiveProps 或 componentDidUpdate 方法挂接到 React 组件的渲染过程吗？那是一段黑暗的回忆，也让我们意识到了 useEffect hook 的美妙之处，尤其是你可以随意使用这些 hooks。\n\n但是有时因为粗心而让“useEffect”身兼数职，就会带回那些黑暗的回忆。例如，假设你有一个组件以某种方式从后端获取一些数据，并且还会根据当前位置显示面包屑。（再次使用 react-router 获取当前位置。）\n\n<a name=\"0682bbd6-3\"></a>\n### 这很危险❌\n\n```jsx\nfunction Example(props) {\n  const location = useLocation();\n  const fetchData = useCallback(() => {\n    /*  Calling the api */\n  }, []);\n  const updateBreadcrumbs = useCallback(() => {\n    /* Updating the breadcrumbs*/\n  }, []);\n  useEffect(() => {\n    fetchData();\n    updateBreadcrumbs();\n  }, [location.pathname, fetchData, updateBreadcrumbs]);\n  return (\n    <div>\n      <BreadCrumbs />\n    </div>\n  );\n}\n```\n\n<a name=\"2bed77ed-4\"></a>\n### 问题⚡\n\n这里有两个用例，即“数据获取”和“显示面包屑”。两者都通过 useEffect hook 更新。当 fetchData 和 updateBreadcrumbs 函数或 location 更改时，都会运行这个 useEffect hook。现在的主要问题是，当位置更改时，我们还调用了 fetchData 函数。这可能是我们没有想到的副作用。\n\n<a name=\"6d6afad5-4\"></a>\n### 解决方案✅\n\n把效果拆分开来，确保它们只用于一种效果，意外的副作用也就消失了。\n\n```jsx\nfunction Example(props) {\n  const location = useLocation();\n  const updateBreadcrumbs = useCallback(() => {\n    /* Updating the breadcrumbs*/\n  }, []);\n  useEffect(() => {\n    updateBreadcrumbs();\n  }, [location.pathname, updateBreadcrumbs]);\n  const fetchData = useCallback(() => {\n    /*  Calling the api */\n  }, []);\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  return (\n    <div>\n      <BreadCrumbs />\n    </div>\n  );\n}\n```\n\n**额外的收获是**，这些用例现在也在组件内按顺序排好了。\n",
  "body_draft": "",
  "body_html": "<!doctype html><a name=\"编写-React-组件时常见的-5-个错误\"></a><h1 id=\"b343d5c4\">编写 React 组件时常见的 5 个错误</h1><p><br /></p><a name=\"1.-在不需要重渲染时使用-useState\"></a><h2 id=\"afd85692\">1. 在不需要重渲染时使用 useState</h2><p><br /></p><p>React 的一个核心概念是处理状态。你可以通过状态控制整个数据流和渲染过程。每次树被重新渲染时，很可能是因为状态的变化。</p><p><br /></p><p>使用 useState hook，你现在还可以在函数组件中定义状态，这种方法可以真正简洁地在 React 中处理状态。但正如以下示例所示，它也可能被滥用。</p><p><br /></p><p>关于下面这个示例我们需要说明一下。假设我们有两个按钮，一个按钮是计数器，另一个按钮使用当前计数发送请求或触发动作。但是，当前编号永远不会显示在组件内。当你单击第二个按钮时才需要这个请求。</p><p><br /></p><p>这很危险❌</p><p><br /></p><pre data-lang=\"jsx\"><code>function ClickButton(props) {\n  const [count, setCount] = useState(0);\n  const onClickCount = () =&gt; {\n    setCount((c) =&gt; c + 1);\n  };\n  const onClickRequest = () =&gt; {\n    apiCall(count);\n  };\n  return (\n    &lt;div&gt;\n      &lt;button onClick={onClickCount}&gt;Counter&lt;/button&gt;\n      &lt;button onClick={onClickRequest}&gt;Submit&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed\">问题⚡</h3><p><br /></p><p>乍一看，你可能会问这到底有什么问题？状态不就是这样用的吗？你当然没错，它运行很正常，并且可能永远不会出问题，但是在 React 中，每个状态更改都将强制对该组件，很有可能还有其子级进行重渲染，但在上面的示例中，因为我们从未在渲染部分中使用这个状态，结果每次设置计数器时都会有不必要的重渲染，这可能会影响性能或产生意外的副作用。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5\">解决方案✅</h3><p><br /></p><p>如果要在组件内部使用一个变量，希望该变量在渲染之间保持其值，但又不强制重新渲染，则可以使用 useRef hook。它将保留值，但不强制重新渲染组件。</p><p><br /></p><pre data-lang=\"jsx\"><code>function ClickButton(props) {\n  const count = useRef(0);\n  const onClickCount = () =&gt; {\n    count.current++;\n  };\n  const onClickRequest = () =&gt; {\n    apiCall(count.current);\n  };\n  return (\n    &lt;div&gt;\n      &lt;button onClick={onClickCount}&gt;Counter&lt;/button&gt;\n      &lt;button onClick={onClickRequest}&gt;Submit&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p><br /></p><a name=\"2.-使用-router.push-代替链接\"></a><h2 id=\"c3296fec\">2. 使用 router.push 代替链接</h2><p><br /></p><p>这可能是一个显而易见的错误，其实和 React 本身没什么关系，但是当人们编写 React 组件时经常会犯这种错误。</p><p><br /></p><p>假设你要编写一个按钮，单击该按钮应将用户重定向到另一个页面。由于它是一个 SPA，因此这个动作是客户端路由机制。于是你需要某种库来执行此动作。在 React 中最流行的是 react-router，下面的示例就会使用它。</p><p><br /></p><p>所以，添加一个点击侦听器会将用户重定向到所需的页面，对吗？</p><p><br /></p><a name=\"这很危险❌\"></a><h3 id=\"0682bbd6\">这很危险❌</h3><p><br /></p><pre data-lang=\"jsx\"><code>function ClickButton(props) {\n  const history = useHistory();\n  const onClick = () =&gt; {\n    history.push('/next-page');\n  };\n  return &lt;button onClick={onClick}&gt;Go to next page&lt;/button&gt;;\n}</code></pre><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed-1\">问题⚡</h3><p><br /></p><p>就算这段代码对于大多数用户来说都可以正常工作，但这里也有严重的可访问性问题。这个按钮根本不会被标记为链接到另一个页面，于是屏幕阅读器几乎无法识别它。而且你能在新标签页或窗口中打开它吗？很可能做不到。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5-1\">解决方案✅</h3><p><br /></p><p>只要指向其他页面的链接带有某种用户交互，就要尽量用 &lt; Link&gt; 组件或常规的 &lt; a&gt; 标签处理。</p><p><br /></p><pre data-lang=\"jsx\"><code>function ClickButton(props) {\n  return (\n    &lt;Link to=&quot;/next-page&quot;&gt;\n      &lt;span&gt;Go to next page&lt;/span&gt;\n    &lt;/Link&gt;\n  );\n}</code></pre><p><br /></p><p>优点：这也使代码更易读，更短！</p><p><br /></p><a name=\"3.-通过-useEffect-处理动作\"></a><h2 id=\"1a8f40e8\">3. 通过 useEffect 处理动作</h2><p><br /></p><p>React 引入的最好用，最贴心的一个 hook 是 useEffect。它可以处理与 prop 或 state 更改相关的动作。可就算它很好用，人们也不该到处滥用它。</p><p><br /></p><p>想象一下有一个组件，其获取一个项目列表并将其渲染给 dom。另外，如果请求成功，我们将调用“onSuccess”函数，该函数作为一个 prop 传递给这个组件。</p><p><br /></p><a name=\"这很危险❌\"></a><h3 id=\"0682bbd6-1\">这很危险❌</h3><p><br /></p><pre data-lang=\"jsx\"><code>function DataList({ onSuccess }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const fetchData = useCallback(() =&gt; {\n    setLoading(true);\n    callApi()\n      .then((res) =&gt; setData(res))\n      .catch((err) =&gt; setError(err))\n      .finally(() =&gt; setLoading(false));\n  }, []);\n  useEffect(() =&gt; {\n    fetchData();\n  }, [fetchData]);\n  useEffect(() =&gt; {\n    if (!loading &amp;&amp; !error &amp;&amp; data) {\n      onSuccess();\n    }\n  }, [loading, error, data, onSuccess]);\n  return &lt;div&gt;Data: {data}&lt;/div&gt;;\n}</code></pre><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed-2\">问题⚡</h3><p><br /></p><p>一共有两个 useEffect hooks，第一个在初始渲染时处理 api 调用，第二个会调用 onSuccess 函数，假设当状态没有加载、没有错误但有数据时调用肯定成功。这很有道理是吧？</p><p><br /></p><p>对第一个调用来说这肯定是正确的，并且可能永远不会失败。但你也失去了动作和需要调用的函数之间的直接联系。同样也没有 100％的保证可以说这种情况仅在 fetch 动作成功后才会发生，而这正是我们开发人员不想看到的。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5-2\">解决方案✅</h3><p><br /></p><p>一个简单明了的解决方案是将“onSuccess”函数设置为调用成功的实际位置：</p><p><br /></p><pre data-lang=\"jsx\"><code>function DataList({ onSuccess }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const fetchData = useCallback(() =&gt; {\n    setLoading(true);\n    callApi()\n      .then((fetchedData) =&gt; {\n        setData(fetchedData);\n        onSuccess();\n      })\n      .catch((err) =&gt; setError(err))\n      .finally(() =&gt; setLoading(false));\n  }, [onSuccess]);\n  useEffect(() =&gt; {\n    fetchData();\n  }, [fetchData]);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n}</code></pre><p><br /></p><p>现在一目了然了，在 api 调用成功的情况下才调用 onSuccess。</p><p><br /></p><a name=\"4.-单一责任组件\"></a><h2 id=\"088924da\">4. 单一责任组件</h2><p><br /></p><p>组合组件可能不是什么轻松的事情。什么时候将一个组件拆分为几个较小的组件？如何构造组件树？使用基于组件的框架时，每天都会遇到这些问题。设计组件时常见的一个错误是将两个用例合并到一个组件中。以一个 header 为例，其在移动设备上显示一个汉堡按钮，或在桌面屏幕上显示标签。（这里的条件通过神奇的 isMobile 函数处理，这里就不深入讲解了。）</p><p><br /></p><a name=\"这很危险❌\"></a><h3 id=\"0682bbd6-2\">这很危险❌</h3><p><br /></p><pre data-lang=\"jsx\"><code>function Header(props) {\n  return (\n    &lt;header&gt;\n      &lt;HeaderInner menuItems={menuItems} /&gt;\n    &lt;/header&gt;\n  );\n}\nfunction HeaderInner({ menuItems }) {\n  return isMobile() ? \n        &lt;BurgerButton menuItems={menuItems} /&gt; : \n        &lt;Tabs tabData={menuItems} /&gt;;\n}</code></pre><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed-3\">问题⚡</h3><p><br /></p><p>使用这种方法时，HeaderInner 组件试图同时兼顾两件事情，而我们都知道一心最好不要二用。而且，这种组件很难在其他地方测试或重用。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5-3\">解决方案✅</h3><p><br /></p><p>将条件提高一级，这样就能更容易看清组件的本来用途，搞明白它们只应该负责一个任务，不管是 Header、Tab 或 BurgerButton 也好，总之不要一心多用。</p><p><br /></p><pre data-lang=\"jsx\"><code>function Header(props) {\n  return (\n    &lt;header&gt;\n        {\n            isMobile() ? \n                &lt;BurgerButton menuItems={menuItems} /&gt; : \n                &lt;Tabs tabData={menuItems} /&gt;\n        }\n        &lt;/header&gt;\n  );\n}</code></pre><p><br /></p><a name=\"5.-单一责任的-useEffects\"></a><h2 id=\"3691cbd4\">5. 单一责任的 useEffects</h2><p><br /></p><p>还记得以前，我们只能用 componentWillReceiveProps 或 componentDidUpdate 方法挂接到 React 组件的渲染过程吗？那是一段黑暗的回忆，也让我们意识到了 useEffect hook 的美妙之处，尤其是你可以随意使用这些 hooks。</p><p><br /></p><p>但是有时因为粗心而让“useEffect”身兼数职，就会带回那些黑暗的回忆。例如，假设你有一个组件以某种方式从后端获取一些数据，并且还会根据当前位置显示面包屑。（再次使用 react-router 获取当前位置。）</p><p><br /></p><a name=\"这很危险❌\"></a><h3 id=\"0682bbd6-3\">这很危险❌</h3><p><br /></p><pre data-lang=\"jsx\"><code>function Example(props) {\n  const location = useLocation();\n  const fetchData = useCallback(() =&gt; {\n    /*  Calling the api */\n  }, []);\n  const updateBreadcrumbs = useCallback(() =&gt; {\n    /* Updating the breadcrumbs*/\n  }, []);\n  useEffect(() =&gt; {\n    fetchData();\n    updateBreadcrumbs();\n  }, [location.pathname, fetchData, updateBreadcrumbs]);\n  return (\n    &lt;div&gt;\n      &lt;BreadCrumbs /&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed-4\">问题⚡</h3><p><br /></p><p>这里有两个用例，即“数据获取”和“显示面包屑”。两者都通过 useEffect hook 更新。当 fetchData 和 updateBreadcrumbs 函数或 location 更改时，都会运行这个 useEffect hook。现在的主要问题是，当位置更改时，我们还调用了 fetchData 函数。这可能是我们没有想到的副作用。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5-4\">解决方案✅</h3><p><br /></p><p>把效果拆分开来，确保它们只用于一种效果，意外的副作用也就消失了。</p><p><br /></p><pre data-lang=\"jsx\"><code>function Example(props) {\n  const location = useLocation();\n  const updateBreadcrumbs = useCallback(() =&gt; {\n    /* Updating the breadcrumbs*/\n  }, []);\n  useEffect(() =&gt; {\n    updateBreadcrumbs();\n  }, [location.pathname, updateBreadcrumbs]);\n  const fetchData = useCallback(() =&gt; {\n    /*  Calling the api */\n  }, []);\n  useEffect(() =&gt; {\n    fetchData();\n  }, [fetchData]);\n  return (\n    &lt;div&gt;\n      &lt;BreadCrumbs /&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p><br /></p><p><strong>额外的收获是</strong>，这些用例现在也在组件内按顺序排好了。</p>",
  "body_lake": "<!doctype lake><a name=\"编写-React-组件时常见的-5-个错误\"></a><h1 id=\"b343d5c4\">编写 React 组件时常见的 5 个错误</h1><p><br /></p><a name=\"1.-在不需要重渲染时使用-useState\"></a><h2 id=\"afd85692\">1. 在不需要重渲染时使用 useState</h2><p><br /></p><p>React 的一个核心概念是处理状态。你可以通过状态控制整个数据流和渲染过程。每次树被重新渲染时，很可能是因为状态的变化。</p><p><br /></p><p>使用 useState hook，你现在还可以在函数组件中定义状态，这种方法可以真正简洁地在 React 中处理状态。但正如以下示例所示，它也可能被滥用。</p><p><br /></p><p>关于下面这个示例我们需要说明一下。假设我们有两个按钮，一个按钮是计数器，另一个按钮使用当前计数发送请求或触发动作。但是，当前编号永远不会显示在组件内。当你单击第二个按钮时才需要这个请求。</p><p><br /></p><p>这很危险❌</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22e4a331b7%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20ClickButton(props)%20%7B%5Cn%20%20const%20%5Bcount%2C%20setCount%5D%20%3D%20useState(0)%3B%5Cn%20%20const%20onClickCount%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20%20%20setCount((c)%20%3D%3E%20c%20%2B%201)%3B%5Cn%20%20%7D%3B%5Cn%20%20const%20onClickRequest%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20%20%20apiCall(count)%3B%5Cn%20%20%7D%3B%5Cn%20%20return%20(%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%3Cbutton%20onClick%3D%7BonClickCount%7D%3ECounter%3C%2Fbutton%3E%5Cn%20%20%20%20%20%20%3Cbutton%20onClick%3D%7BonClickRequest%7D%3ESubmit%3C%2Fbutton%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20)%3B%5Cn%7D%22%7D\"></card><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed\">问题⚡</h3><p><br /></p><p>乍一看，你可能会问这到底有什么问题？状态不就是这样用的吗？你当然没错，它运行很正常，并且可能永远不会出问题，但是在 React 中，每个状态更改都将强制对该组件，很有可能还有其子级进行重渲染，但在上面的示例中，因为我们从未在渲染部分中使用这个状态，结果每次设置计数器时都会有不必要的重渲染，这可能会影响性能或产生意外的副作用。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5\">解决方案✅</h3><p><br /></p><p>如果要在组件内部使用一个变量，希望该变量在渲染之间保持其值，但又不强制重新渲染，则可以使用 useRef hook。它将保留值，但不强制重新渲染组件。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22654906f1%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20ClickButton(props)%20%7B%5Cn%20%20const%20count%20%3D%20useRef(0)%3B%5Cn%20%20const%20onClickCount%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20%20%20count.current%2B%2B%3B%5Cn%20%20%7D%3B%5Cn%20%20const%20onClickRequest%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20%20%20apiCall(count.current)%3B%5Cn%20%20%7D%3B%5Cn%20%20return%20(%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%3Cbutton%20onClick%3D%7BonClickCount%7D%3ECounter%3C%2Fbutton%3E%5Cn%20%20%20%20%20%20%3Cbutton%20onClick%3D%7BonClickRequest%7D%3ESubmit%3C%2Fbutton%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20)%3B%5Cn%7D%22%7D\"></card><p><br /></p><a name=\"2.-使用-router.push-代替链接\"></a><h2 id=\"c3296fec\">2. 使用 router.push 代替链接</h2><p><br /></p><p>这可能是一个显而易见的错误，其实和 React 本身没什么关系，但是当人们编写 React 组件时经常会犯这种错误。</p><p><br /></p><p>假设你要编写一个按钮，单击该按钮应将用户重定向到另一个页面。由于它是一个 SPA，因此这个动作是客户端路由机制。于是你需要某种库来执行此动作。在 React 中最流行的是 react-router，下面的示例就会使用它。</p><p><br /></p><p>所以，添加一个点击侦听器会将用户重定向到所需的页面，对吗？</p><p><br /></p><a name=\"这很危险❌\"></a><h3 id=\"0682bbd6\">这很危险❌</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b2a571a8%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20ClickButton(props)%20%7B%5Cn%20%20const%20history%20%3D%20useHistory()%3B%5Cn%20%20const%20onClick%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20%20%20history.push('%2Fnext-page')%3B%5Cn%20%20%7D%3B%5Cn%20%20return%20%3Cbutton%20onClick%3D%7BonClick%7D%3EGo%20to%20next%20page%3C%2Fbutton%3E%3B%5Cn%7D%22%7D\"></card><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed-1\">问题⚡</h3><p><br /></p><p>就算这段代码对于大多数用户来说都可以正常工作，但这里也有严重的可访问性问题。这个按钮根本不会被标记为链接到另一个页面，于是屏幕阅读器几乎无法识别它。而且你能在新标签页或窗口中打开它吗？很可能做不到。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5-1\">解决方案✅</h3><p><br /></p><p>只要指向其他页面的链接带有某种用户交互，就要尽量用 &lt; Link&gt; 组件或常规的 &lt; a&gt; 标签处理。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22636713a1%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20ClickButton(props)%20%7B%5Cn%20%20return%20(%5Cn%20%20%20%20%3CLink%20to%3D%5C%22%2Fnext-page%5C%22%3E%5Cn%20%20%20%20%20%20%3Cspan%3EGo%20to%20next%20page%3C%2Fspan%3E%5Cn%20%20%20%20%3C%2FLink%3E%5Cn%20%20)%3B%5Cn%7D%22%7D\"></card><p><br /></p><p>优点：这也使代码更易读，更短！</p><p><br /></p><a name=\"3.-通过-useEffect-处理动作\"></a><h2 id=\"1a8f40e8\">3. 通过 useEffect 处理动作</h2><p><br /></p><p>React 引入的最好用，最贴心的一个 hook 是 useEffect。它可以处理与 prop 或 state 更改相关的动作。可就算它很好用，人们也不该到处滥用它。</p><p><br /></p><p>想象一下有一个组件，其获取一个项目列表并将其渲染给 dom。另外，如果请求成功，我们将调用“onSuccess”函数，该函数作为一个 prop 传递给这个组件。</p><p><br /></p><a name=\"这很危险❌\"></a><h3 id=\"0682bbd6-1\">这很危险❌</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2233c6b55f%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20DataList(%7B%20onSuccess%20%7D)%20%7B%5Cn%20%20const%20%5Bloading%2C%20setLoading%5D%20%3D%20useState(false)%3B%5Cn%20%20const%20%5Berror%2C%20setError%5D%20%3D%20useState(null)%3B%5Cn%20%20const%20%5Bdata%2C%20setData%5D%20%3D%20useState(null)%3B%5Cn%20%20const%20fetchData%20%3D%20useCallback(()%20%3D%3E%20%7B%5Cn%20%20%20%20setLoading(true)%3B%5Cn%20%20%20%20callApi()%5Cn%20%20%20%20%20%20.then((res)%20%3D%3E%20setData(res))%5Cn%20%20%20%20%20%20.catch((err)%20%3D%3E%20setError(err))%5Cn%20%20%20%20%20%20.finally(()%20%3D%3E%20setLoading(false))%3B%5Cn%20%20%7D%2C%20%5B%5D)%3B%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20fetchData()%3B%5Cn%20%20%7D%2C%20%5BfetchData%5D)%3B%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20if%20(!loading%20%26%26%20!error%20%26%26%20data)%20%7B%5Cn%20%20%20%20%20%20onSuccess()%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%2C%20%5Bloading%2C%20error%2C%20data%2C%20onSuccess%5D)%3B%5Cn%20%20return%20%3Cdiv%3EData%3A%20%7Bdata%7D%3C%2Fdiv%3E%3B%5Cn%7D%22%7D\"></card><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed-2\">问题⚡</h3><p><br /></p><p>一共有两个 useEffect hooks，第一个在初始渲染时处理 api 调用，第二个会调用 onSuccess 函数，假设当状态没有加载、没有错误但有数据时调用肯定成功。这很有道理是吧？</p><p><br /></p><p>对第一个调用来说这肯定是正确的，并且可能永远不会失败。但你也失去了动作和需要调用的函数之间的直接联系。同样也没有 100％的保证可以说这种情况仅在 fetch 动作成功后才会发生，而这正是我们开发人员不想看到的。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5-2\">解决方案✅</h3><p><br /></p><p>一个简单明了的解决方案是将“onSuccess”函数设置为调用成功的实际位置：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%220de0828a%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20DataList(%7B%20onSuccess%20%7D)%20%7B%5Cn%20%20const%20%5Bloading%2C%20setLoading%5D%20%3D%20useState(false)%3B%5Cn%20%20const%20%5Berror%2C%20setError%5D%20%3D%20useState(null)%3B%5Cn%20%20const%20%5Bdata%2C%20setData%5D%20%3D%20useState(null)%3B%5Cn%20%20const%20fetchData%20%3D%20useCallback(()%20%3D%3E%20%7B%5Cn%20%20%20%20setLoading(true)%3B%5Cn%20%20%20%20callApi()%5Cn%20%20%20%20%20%20.then((fetchedData)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20setData(fetchedData)%3B%5Cn%20%20%20%20%20%20%20%20onSuccess()%3B%5Cn%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20.catch((err)%20%3D%3E%20setError(err))%5Cn%20%20%20%20%20%20.finally(()%20%3D%3E%20setLoading(false))%3B%5Cn%20%20%7D%2C%20%5BonSuccess%5D)%3B%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20fetchData()%3B%5Cn%20%20%7D%2C%20%5BfetchData%5D)%3B%5Cn%20%20return%20%3Cdiv%3E%7Bdata%7D%3C%2Fdiv%3E%3B%5Cn%7D%22%7D\"></card><p><br /></p><p>现在一目了然了，在 api 调用成功的情况下才调用 onSuccess。</p><p><br /></p><a name=\"4.-单一责任组件\"></a><h2 id=\"088924da\">4. 单一责任组件</h2><p><br /></p><p>组合组件可能不是什么轻松的事情。什么时候将一个组件拆分为几个较小的组件？如何构造组件树？使用基于组件的框架时，每天都会遇到这些问题。设计组件时常见的一个错误是将两个用例合并到一个组件中。以一个 header 为例，其在移动设备上显示一个汉堡按钮，或在桌面屏幕上显示标签。（这里的条件通过神奇的 isMobile 函数处理，这里就不深入讲解了。）</p><p><br /></p><a name=\"这很危险❌\"></a><h3 id=\"0682bbd6-2\">这很危险❌</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2216abfad6%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20Header(props)%20%7B%5Cn%20%20return%20(%5Cn%20%20%20%20%3Cheader%3E%5Cn%20%20%20%20%20%20%3CHeaderInner%20menuItems%3D%7BmenuItems%7D%20%2F%3E%5Cn%20%20%20%20%3C%2Fheader%3E%5Cn%20%20)%3B%5Cn%7D%5Cnfunction%20HeaderInner(%7B%20menuItems%20%7D)%20%7B%5Cn%20%20return%20isMobile()%20%3F%20%5Cn%20%20%20%20%20%20%20%20%3CBurgerButton%20menuItems%3D%7BmenuItems%7D%20%2F%3E%20%3A%20%5Cn%20%20%20%20%20%20%20%20%3CTabs%20tabData%3D%7BmenuItems%7D%20%2F%3E%3B%5Cn%7D%22%7D\"></card><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed-3\">问题⚡</h3><p><br /></p><p>使用这种方法时，HeaderInner 组件试图同时兼顾两件事情，而我们都知道一心最好不要二用。而且，这种组件很难在其他地方测试或重用。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5-3\">解决方案✅</h3><p><br /></p><p>将条件提高一级，这样就能更容易看清组件的本来用途，搞明白它们只应该负责一个任务，不管是 Header、Tab 或 BurgerButton 也好，总之不要一心多用。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%227263cdbd%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20Header(props)%20%7B%5Cn%20%20return%20(%5Cn%20%20%20%20%3Cheader%3E%5Cn%20%20%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20isMobile()%20%3F%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CBurgerButton%20menuItems%3D%7BmenuItems%7D%20%2F%3E%20%3A%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CTabs%20tabData%3D%7BmenuItems%7D%20%2F%3E%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%3C%2Fheader%3E%5Cn%20%20)%3B%5Cn%7D%22%7D\"></card><p><br /></p><a name=\"5.-单一责任的-useEffects\"></a><h2 id=\"3691cbd4\">5. 单一责任的 useEffects</h2><p><br /></p><p>还记得以前，我们只能用 componentWillReceiveProps 或 componentDidUpdate 方法挂接到 React 组件的渲染过程吗？那是一段黑暗的回忆，也让我们意识到了 useEffect hook 的美妙之处，尤其是你可以随意使用这些 hooks。</p><p><br /></p><p>但是有时因为粗心而让“useEffect”身兼数职，就会带回那些黑暗的回忆。例如，假设你有一个组件以某种方式从后端获取一些数据，并且还会根据当前位置显示面包屑。（再次使用 react-router 获取当前位置。）</p><p><br /></p><a name=\"这很危险❌\"></a><h3 id=\"0682bbd6-3\">这很危险❌</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22c8d8200c%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20Example(props)%20%7B%5Cn%20%20const%20location%20%3D%20useLocation()%3B%5Cn%20%20const%20fetchData%20%3D%20useCallback(()%20%3D%3E%20%7B%5Cn%20%20%20%20%2F*%20%20Calling%20the%20api%20*%2F%5Cn%20%20%7D%2C%20%5B%5D)%3B%5Cn%20%20const%20updateBreadcrumbs%20%3D%20useCallback(()%20%3D%3E%20%7B%5Cn%20%20%20%20%2F*%20Updating%20the%20breadcrumbs*%2F%5Cn%20%20%7D%2C%20%5B%5D)%3B%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20fetchData()%3B%5Cn%20%20%20%20updateBreadcrumbs()%3B%5Cn%20%20%7D%2C%20%5Blocation.pathname%2C%20fetchData%2C%20updateBreadcrumbs%5D)%3B%5Cn%20%20return%20(%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%3CBreadCrumbs%20%2F%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20)%3B%5Cn%7D%22%7D\"></card><p><br /></p><a name=\"问题⚡\"></a><h3 id=\"2bed77ed-4\">问题⚡</h3><p><br /></p><p>这里有两个用例，即“数据获取”和“显示面包屑”。两者都通过 useEffect hook 更新。当 fetchData 和 updateBreadcrumbs 函数或 location 更改时，都会运行这个 useEffect hook。现在的主要问题是，当位置更改时，我们还调用了 fetchData 函数。这可能是我们没有想到的副作用。</p><p><br /></p><a name=\"解决方案✅\"></a><h3 id=\"6d6afad5-4\">解决方案✅</h3><p><br /></p><p>把效果拆分开来，确保它们只用于一种效果，意外的副作用也就消失了。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22f742dc1e%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20Example(props)%20%7B%5Cn%20%20const%20location%20%3D%20useLocation()%3B%5Cn%20%20const%20updateBreadcrumbs%20%3D%20useCallback(()%20%3D%3E%20%7B%5Cn%20%20%20%20%2F*%20Updating%20the%20breadcrumbs*%2F%5Cn%20%20%7D%2C%20%5B%5D)%3B%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20updateBreadcrumbs()%3B%5Cn%20%20%7D%2C%20%5Blocation.pathname%2C%20updateBreadcrumbs%5D)%3B%5Cn%20%20const%20fetchData%20%3D%20useCallback(()%20%3D%3E%20%7B%5Cn%20%20%20%20%2F*%20%20Calling%20the%20api%20*%2F%5Cn%20%20%7D%2C%20%5B%5D)%3B%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20fetchData()%3B%5Cn%20%20%7D%2C%20%5BfetchData%5D)%3B%5Cn%20%20return%20(%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%3CBreadCrumbs%20%2F%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20)%3B%5Cn%7D%22%7D\"></card><p><br /></p><p><strong>额外的收获是</strong>，这些用例现在也在组件内按顺序排好了。</p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2021-03-16T06:05:16.000Z",
  "deleted_at": null,
  "created_at": "2021-03-16T06:05:16.000Z",
  "updated_at": "2023-11-12T12:52:53.000Z",
  "published_at": "2021-03-16T06:05:16.000Z",
  "first_published_at": "2021-03-16T06:05:16.000Z",
  "word_count": 2159,
  "cover": null,
  "description": null,
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}