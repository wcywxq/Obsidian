{
  "id": 72212076,
  "slug": "irz8zx",
  "title": "ajax、jsonp、fetch",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"qogHC\"></a>\n## ajax\n<a name=\"VOyeY\"></a>\n### 实现 ajax 请求的五个步骤\n\n1. 创建 `XMLHttpRequest` 对象\n2. 使用 open 方法创建 http 请求，并设置请求地址和请求方式\n3. 设置发送的数据，用 send 发送请求\n4. 注册事件\n5. 获取响应并更新页面\n```javascript\nfunction request() {\n\t// 1 创建 XMLHttpRequest 对象\n  var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP')\n  // 2 发送请求\n  xhr.open('get', 'http://localhost:3000') // 第三个参数表示是否异步\n  // 3 发送数据\n  xhr.send('id=1')\n  // 4 服务端响应\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var obj = JSON.parse(xhr.responseText)\n      console.log(obj)\n    }\n  }\n}\n```\n<a name=\"dq8az\"></a>\n## jsonp\njsonp 实际上是一种跨域解决方案。\n:::info\n由于 javaScript 跨域请求数据是不可以的，但是 javaScript 跨域请求 javaScript 脚本是被允许的，因此可以把要请求的数据封装成一个 javaScript 语句，做一个方法的调用。另外，在得到脚本后会立即执行，同时会把数据作为参数传递到方法中，从而解决跨域问题。\n:::\n<a name=\"CrBPb\"></a>\n### 实现原理\n浏览器在 javaScript 请求中，是允许通过 script 标签的 src 跨域请求，可以在请求的结果中添加回调方法名，在请求页面中定义方法，就可获取到跨域请求的数据\n```javascript\nconst generateUrl = (obj, cb) => {\n\tlet dataSrc = ''\n  for (let key in obj) {\n  \tif (obj.hasOwnProperty(key)) {\n    \tdataSrc += `${key}=${obj[key]}&`\n    }\n  }\n  dataSrc += `callback=${cb}`\n  return `${url}?${dataSrc}`\n}\n\nconst jsonp = ({ url, params, callback }) => {\n  return new Promise((resolve, reject) => {\n  \tconst createScript = document.createElement('script')\n    createScript.src = generateUrl(params, callback)\n    document.body.appendChild(createScript)\n    window.callback = data => {\n    \tresolve(data)\n      document.removeChild(createScript)\n    }\n  })\n}\n```\n:::warning\n**jsonp 缺点：**只能实现 get 一种请求\n:::\n<a name=\"EO66e\"></a>\n## fetch\nfetch 是 web api 中新增的 api，是基于 promise 实现的。用来取代 XMLHttpRequest 的网络请求，其提供了更优雅的接口，更灵活强大的功能。\n```javascript\nfetch('http://localhost:3000')\n  \t.then(res => res.json())\n\t\t.then(data => console.log(data))\n\t\t.catch(err => console.log(err))\n```\n \t\t\t<br /> \t\t<br /> \t \n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"qogHC\"><span>ajax</span></h2><h3 id=\"VOyeY\"><span>实现 ajax 请求的五个步骤</span></h3><ol><li><span>创建 </span><code><span>XMLHttpRequest</span></code><span> 对象</span></li><li><span>使用 open 方法创建 http 请求，并设置请求地址和请求方式</span></li><li><span>设置发送的数据，用 send 发送请求</span></li><li><span>注册事件</span></li><li><span>获取响应并更新页面</span></li></ol><pre data-lang=\"javascript\"><code>function request() {\n\t// 1 创建 XMLHttpRequest 对象\n  var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP')\n  // 2 发送请求\n  xhr.open('get', 'http://localhost:3000') // 第三个参数表示是否异步\n  // 3 发送数据\n  xhr.send('id=1')\n  // 4 服务端响应\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {\n      var obj = JSON.parse(xhr.responseText)\n      console.log(obj)\n    }\n  }\n}</code></pre><h2 id=\"dq8az\"><span>jsonp</span></h2><p data-lake-id=\"u444810c1\"><span>jsonp 实际上是一种跨域解决方案。</span></p><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u731a138f\"><span>由于 javaScript 跨域请求数据是不可以的，但是 javaScript 跨域请求 javaScript 脚本是被允许的，因此可以把要请求的数据封装成一个 javaScript 语句，做一个方法的调用。另外，在得到脚本后会立即执行，同时会把数据作为参数传递到方法中，从而解决跨域问题。</span></p></blockquote><h3 id=\"CrBPb\"><span>实现原理</span></h3><p data-lake-id=\"u9ff11777\"><span>浏览器在 javaScript 请求中，是允许通过 script 标签的 src 跨域请求，可以在请求的结果中添加回调方法名，在请求页面中定义方法，就可获取到跨域请求的数据</span></p><pre data-lang=\"javascript\"><code>const generateUrl = (obj, cb) =&gt; {\n\tlet dataSrc = ''\n  for (let key in obj) {\n  \tif (obj.hasOwnProperty(key)) {\n    \tdataSrc += `${key}=${obj[key]}&amp;`\n    }\n  }\n  dataSrc += `callback=${cb}`\n  return `${url}?${dataSrc}`\n}\n\nconst jsonp = ({ url, params, callback }) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n  \tconst createScript = document.createElement('script')\n    createScript.src = generateUrl(params, callback)\n    document.body.appendChild(createScript)\n    window.callback = data =&gt; {\n    \tresolve(data)\n      document.removeChild(createScript)\n    }\n  })\n}</code></pre><blockquote class=\"lake-alert lake-alert-warning\"><p data-lake-id=\"u43f4b643\"><strong><span>jsonp 缺点：</span></strong><span>只能实现 get 一种请求</span></p></blockquote><h2 id=\"EO66e\"><span>fetch</span></h2><p data-lake-id=\"u444f53b9\"><span>fetch 是 web api 中新增的 api，是基于 promise 实现的。用来取代 XMLHttpRequest 的网络请求，</span><span class=\"lake-fontsize-12\" style=\"color: #404040;\">其提供了更优雅的接口，更灵活强大的功能。</span></p><pre data-lang=\"javascript\"><code>fetch('http://localhost:3000')\n  \t.then(res =&gt; res.json())\n\t\t.then(data =&gt; console.log(data))\n\t\t.catch(err =&gt; console.log(err))</code></pre><p data-lake-id=\"u260efc9d\"><span> \t\t\t</span></p><p data-lake-id=\"u1451a7a5\"><span> \t\t</span></p><p data-lake-id=\"ucfee5351\"><span> \t </span></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"qogHC\" id=\"qogHC\"><span data-lake-id=\"uedbece3a\" id=\"uedbece3a\">ajax</span></h2><h3 data-lake-id=\"VOyeY\" id=\"VOyeY\"><span data-lake-id=\"uc0b75e99\" id=\"uc0b75e99\">实现 ajax 请求的五个步骤</span></h3><ol list=\"ud08dddf9\"><li fid=\"uc2a57ae9\" data-lake-id=\"u31b99872\" id=\"u31b99872\"><span data-lake-id=\"u55b44039\" id=\"u55b44039\">创建 </span><code data-lake-id=\"u2cf62ac5\" id=\"u2cf62ac5\"><span data-lake-id=\"u71fad1d2\" id=\"u71fad1d2\">XMLHttpRequest</span></code><span data-lake-id=\"u91a8a1ae\" id=\"u91a8a1ae\"> 对象</span></li><li fid=\"uc2a57ae9\" data-lake-id=\"ue1e3b24a\" id=\"ue1e3b24a\"><span data-lake-id=\"u5996f581\" id=\"u5996f581\">使用 open 方法创建 http 请求，并设置请求地址和请求方式</span></li><li fid=\"uc2a57ae9\" data-lake-id=\"u98de3627\" id=\"u98de3627\"><span data-lake-id=\"ud508e2a1\" id=\"ud508e2a1\">设置发送的数据，用 send 发送请求</span></li><li fid=\"uc2a57ae9\" data-lake-id=\"ub780caa5\" id=\"ub780caa5\"><span data-lake-id=\"ub0f21b0c\" id=\"ub0f21b0c\">注册事件</span></li><li fid=\"uc2a57ae9\" data-lake-id=\"u045fdfca\" id=\"u045fdfca\"><span data-lake-id=\"u415f9075\" id=\"u415f9075\">获取响应并更新页面</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20request()%20%7B%5Cn%5Ct%2F%2F%201%20%E5%88%9B%E5%BB%BA%20XMLHttpRequest%20%E5%AF%B9%E8%B1%A1%5Cn%20%20var%20xhr%20%3D%20window.XMLHttpRequest%20%3F%20new%20XMLHttpRequest()%20%3A%20new%20ActiveXObject('Microsoft.XMLHTTP')%5Cn%20%20%2F%2F%202%20%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%5Cn%20%20xhr.open('get'%2C%20'http%3A%2F%2Flocalhost%3A3000')%20%2F%2F%20%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%98%AF%E5%90%A6%E5%BC%82%E6%AD%A5%5Cn%20%20%2F%2F%203%20%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%5Cn%20%20xhr.send('id%3D1')%5Cn%20%20%2F%2F%204%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%93%8D%E5%BA%94%5Cn%20%20xhr.onreadystatechange%20%3D%20function()%20%7B%5Cn%20%20%20%20if%20(xhr.readyState%20%3D%3D%3D%204%20%26%26%20xhr.status%20%3D%3D%3D%20200)%20%7B%5Cn%20%20%20%20%20%20var%20obj%20%3D%20JSON.parse(xhr.responseText)%5Cn%20%20%20%20%20%20console.log(obj)%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22EGAMT%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"dq8az\" id=\"dq8az\"><span data-lake-id=\"uac743109\" id=\"uac743109\">jsonp</span></h2><p data-lake-id=\"u444810c1\" id=\"u444810c1\"><span data-lake-id=\"u98dcf506\" id=\"u98dcf506\">jsonp 实际上是一种跨域解决方案。</span></p><blockquote data-lake-id=\"u719d8827\" id=\"u719d8827\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u731a138f\" id=\"u731a138f\"><span data-lake-id=\"ucea1c38d\" id=\"ucea1c38d\">由于 javaScript 跨域请求数据是不可以的，但是 javaScript 跨域请求 javaScript 脚本是被允许的，因此可以把要请求的数据封装成一个 javaScript 语句，做一个方法的调用。另外，在得到脚本后会立即执行，同时会把数据作为参数传递到方法中，从而解决跨域问题。</span></p></blockquote><h3 data-lake-id=\"CrBPb\" id=\"CrBPb\"><span data-lake-id=\"u11e8cd52\" id=\"u11e8cd52\">实现原理</span></h3><p data-lake-id=\"u9ff11777\" id=\"u9ff11777\"><span data-lake-id=\"ud60cd4a6\" id=\"ud60cd4a6\">浏览器在 javaScript 请求中，是允许通过 script 标签的 src 跨域请求，可以在请求的结果中添加回调方法名，在请求页面中定义方法，就可获取到跨域请求的数据</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20generateUrl%20%3D%20(obj%2C%20cb)%20%3D%3E%20%7B%5Cn%5Ctlet%20dataSrc%20%3D%20''%5Cn%20%20for%20(let%20key%20in%20obj)%20%7B%5Cn%20%20%5Ctif%20(obj.hasOwnProperty(key))%20%7B%5Cn%20%20%20%20%5CtdataSrc%20%2B%3D%20%60%24%7Bkey%7D%3D%24%7Bobj%5Bkey%5D%7D%26%60%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20dataSrc%20%2B%3D%20%60callback%3D%24%7Bcb%7D%60%5Cn%20%20return%20%60%24%7Burl%7D%3F%24%7BdataSrc%7D%60%5Cn%7D%5Cn%5Cnconst%20jsonp%20%3D%20(%7B%20url%2C%20params%2C%20callback%20%7D)%20%3D%3E%20%7B%5Cn%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%5Cn%20%20%5Ctconst%20createScript%20%3D%20document.createElement('script')%5Cn%20%20%20%20createScript.src%20%3D%20generateUrl(params%2C%20callback)%5Cn%20%20%20%20document.body.appendChild(createScript)%5Cn%20%20%20%20window.callback%20%3D%20data%20%3D%3E%20%7B%5Cn%20%20%20%20%5Ctresolve(data)%5Cn%20%20%20%20%20%20document.removeChild(createScript)%5Cn%20%20%20%20%7D%5Cn%20%20%7D)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22YngpO%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><blockquote data-lake-id=\"u584eda4e\" id=\"u584eda4e\" class=\"lake-alert lake-alert-warning\"><p data-lake-id=\"u43f4b643\" id=\"u43f4b643\"><strong><span data-lake-id=\"u0792e8b7\" id=\"u0792e8b7\">jsonp 缺点：</span></strong><span data-lake-id=\"u4b151d4e\" id=\"u4b151d4e\">只能实现 get 一种请求</span></p></blockquote><h2 data-lake-id=\"EO66e\" id=\"EO66e\"><span data-lake-id=\"u81773b4e\" id=\"u81773b4e\">fetch</span></h2><p data-lake-id=\"u444f53b9\" id=\"u444f53b9\"><span data-lake-id=\"u04bfc6f4\" id=\"u04bfc6f4\">fetch 是 web api 中新增的 api，是基于 promise 实现的。用来取代 XMLHttpRequest 的网络请求，</span><span data-lake-id=\"u7ee0f098\" id=\"u7ee0f098\" class=\"lake-fontsize-12\" style=\"color: rgb(64, 64, 64)\">其提供了更优雅的接口，更灵活强大的功能。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22fetch('http%3A%2F%2Flocalhost%3A3000')%5Cn%20%20%5Ct.then(res%20%3D%3E%20res.json())%5Cn%5Ct%5Ct.then(data%20%3D%3E%20console.log(data))%5Cn%5Ct%5Ct.catch(err%20%3D%3E%20console.log(err))%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22S63zO%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u260efc9d\" id=\"u260efc9d\"><span data-lake-id=\"u31325a7b\" id=\"u31325a7b\"> \t\t\t</span></p><p data-lake-id=\"u1451a7a5\" id=\"u1451a7a5\"><span data-lake-id=\"u9da4e78c\" id=\"u9da4e78c\"> \t\t</span></p><p data-lake-id=\"ucfee5351\" id=\"ucfee5351\"><span data-lake-id=\"udcece1ab\" id=\"udcece1ab\"> \t </span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:32:53.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:53.000Z",
  "updated_at": "2022-05-10T15:12:41.000Z",
  "published_at": "2022-04-04T11:32:53.000Z",
  "first_published_at": "2022-04-04T11:32:52.668Z",
  "word_count": 464,
  "cover": null,
  "description": "ajax实现 ajax 请求的五个步骤创建 XMLHttpRequest 对象使用 open 方法创建 http 请求，并设置请求地址和请求方式设置发送的数据，用 send 发送请求注册事件获取响应并更新页面function request() { \t// 1 创建 XMLHttpReques...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}