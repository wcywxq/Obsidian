{
  "id": 72212124,
  "slug": "lv63wa",
  "title": "redux",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"Ym5u3\"></a>\n## ![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647690613642-27b36729-1d2c-49db-82ea-fa36534369cf.png#clientId=u9d71fc54-22fb-4&from=paste&height=669&id=u2fcb785b&originHeight=669&originWidth=669&originalType=binary&ratio=1&size=242613&status=done&style=none&taskId=uddd292e8-e04d-46ab-a235-6068af21f6c&width=669)\n<a name=\"X8NnL\"></a>\n## redux 原理\n:::info\n**通俗解释:**\n\n1. 首先，用户通过 View 发出 Action，发出方式用到了 Dispatch 方法\n2. Store 调用 Reducer，传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 State\n3. State 一旦有变化，Store 就会调用监听函数，来更新 View\n\n以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由 Reducers 来担任，store 只做存储，中间人，当Reducers 的更新完成以后会通过 store 的订阅来通知 react component，组件把新的状态重新获取渲染，组件中也能主动发送 action，创建 action 后这个动作是不会执行的，所以要 dispatch 这个 action，让 store 通过 reducers 去做更新React Component 就是 react 的每个组件。\n:::\n<a name=\"flaEE\"></a>\n### 概念介绍\n\n- Store\n\n保存数据的地方，你可以把它看作一个容器，整个应用只能有一个 Store\n\n- State\n\nStore 对象包含所有数据，如果想得到某个时点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫 State\n\n- Action\n\nState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了\n\n- Action Creator\n\nView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦，所以我们定义一个函数来生成 Action，这个函数就叫 Action Creator\n\n- Reducer\n\nStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State\n\n- Dispatch\n\n是 View 发出 Action 的唯一方法\n<a name=\"hy08o\"></a>\n### 三个原则\n\n- 单个事件来源\n\n整个应用程序状态存储在单个存储的对象中\n\n- 状态只读\n\n更改状态的唯一方法就是触发一个动作\n\n- 中间件\n\naction -> reducer -> action -> middlewares -> reducer\n<a name=\"W6OEV\"></a>\n## redux 中的异步处理方式\n<a name=\"qj6IR\"></a>\n#### redux-thunk\n:::success\n优点：\n\n1. 体积小：redux-thunk 的实现方式很简单，只有不到 20 行代码\n2. 使用简单：redux-thunk 没有引入像 redux-saga 或者 redux-observable :额外的范式，上手简单\n:::\n:::danger\n缺点：\n\n1. 样板代码过多：与 redux 本身一样，通常一个请求需要大量的代码，而且很多都是重复性质的\n2. 耦合严重：异步操作与 redux 的 action 耦合在一起，不方便管理\n3. 功能孱弱：有一些实际开发中常用的功能需要自行封装\n:::\n<a name=\"gQjXq\"></a>\n#### redux-saga\n:::success\n优点：\n\n1. 异步解耦：异步操作被转移到单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中\n2. action 摆脱 thunk function：dispatch 的参数依然是一个纯粹的 action(FSA)，而不是充满\"黑魔法\"的 thunk function\n3. 异常处理：受益于 generator function 的 saga 实现，代码异常/请求失败，都可以直接通过 try/catch 语法直接捕获处理\n4. 功能请打：redux-saga 提供了大量的 saga 辅助函数和 effect 创建器供开发者使用，开发者无须封装或者简单封装即可使用\n5. 灵活：redux-saga 可以将多个 saga 串行/并行组合起来，形成一个非常实用的异步 flow\n6. 易测试，提供了各种 case 的测试方案，包括 mock task，分之覆盖等等\n:::\n:::danger\n缺点：\n\n1. 额外的学习成本：redux-saga 不仅在使用难以理解的 generator function，而且有数十个 API，学习成本远超 redux-thunk，最重要的是额外的学习只服务于这个库，与 redux-observable 不同，redux-observable 的背后是基于 rxjs 的一整套思想\n2. 体积庞大：代码略大，接近 2000 行，min 版 25kb 左右\n3. 功能过剩：实际上并发控制等功能很难用到，但是我们依然需要引入这些代码\n4. ts 支持不友好：yield 无法返回 TS 类型\n:::\n<a name=\"XE4t0\"></a>\n### redux 属性传递\nreact-redux 数据传输∶ view-->action-->reducer-->store-->view。看下点击事件的数据是如何通过 redux 传到 view 上：\n\n- view 上的 AddClick 事件通过mapDispatchToProps 把数据传到 action ---> click:()=>dispatch(ADD)\n- action 的 ADD 传到 reducer 上\n- reducer 传到 store 上 const store = createStore(reducer);\n- store 再通过 mapStateToProps 映射穿到 view 上 text:State.text\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"Ym5u3\"><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647690613642-27b36729-1d2c-49db-82ea-fa36534369cf.png#clientId=u9d71fc54-22fb-4&amp;from=paste&amp;height=669&amp;id=u2fcb785b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=669&amp;originWidth=669&amp;originalType=binary&amp;ratio=1&amp;size=242613&amp;status=done&amp;style=none&amp;taskId=uddd292e8-e04d-46ab-a235-6068af21f6c&amp;width=669\" style=\"max-width: 600px; width: 669px;\" /></h2><h2 id=\"X8NnL\"><span>redux 原理</span></h2><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u23fc4ea9\"><strong><span>通俗解释:</span></strong></p><ol><li><span>首先，用户通过 View 发出 Action，发出方式用到了 Dispatch 方法</span></li><li><span>Store 调用 Reducer，传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 State</span></li><li><span>State 一旦有变化，Store 就会调用监听函数，来更新 View</span></li></ol><p data-lake-id=\"u6d003389\" style=\"text-indent: 2em;\"><span>以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由 Reducers 来担任，store 只做存储，中间人，当Reducers 的更新完成以后会通过 store 的订阅来通知 react component，组件把新的状态重新获取渲染，组件中也能主动发送 action，创建 action 后这个动作是不会执行的，所以要 dispatch 这个 action，让 store 通过 reducers 去做更新React Component 就是 react 的每个组件。</span></p></blockquote><h3 id=\"flaEE\"><span>概念介绍</span></h3><ul><li><span>Store</span></li></ul><p data-lake-id=\"u7108927a\"><span>保存数据的地方，你可以把它看作一个容器，整个应用只能有一个 Store</span></p><ul><li><span>State</span></li></ul><p data-lake-id=\"u29f30469\"><span>Store 对象包含所有数据，如果想得到某个时点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫 State</span></p><ul><li><span>Action</span></li></ul><p data-lake-id=\"u634af813\"><span>State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了</span></p><ul><li><span>Action Creator</span></li></ul><p data-lake-id=\"ud93a9b6b\"><span>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦，所以我们定义一个函数来生成 Action，这个函数就叫 Action Creator</span></p><ul><li><span>Reducer</span></li></ul><p data-lake-id=\"u55db1318\"><span>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State</span></p><ul><li><span>Dispatch</span></li></ul><p data-lake-id=\"u073ed732\"><span>是 View 发出 Action 的唯一方法</span></p><h3 id=\"hy08o\"><span>三个原则</span></h3><ul><li><span>单个事件来源</span></li></ul><p data-lake-id=\"u5530c115\"><span>整个应用程序状态存储在单个存储的对象中</span></p><ul><li><span>状态只读</span></li></ul><p data-lake-id=\"u8d8f105b\"><span>更改状态的唯一方法就是触发一个动作</span></p><ul><li><span>中间件</span></li></ul><p data-lake-id=\"ub7a4c700\"><span>action -&gt; reducer -&gt; action -&gt; middlewares -&gt; reducer</span></p><h2 id=\"W6OEV\"><span>redux 中的异步处理方式</span></h2><h4 id=\"qj6IR\"><span>redux-thunk</span></h4><blockquote class=\"lake-alert lake-alert-success\"><p data-lake-id=\"u85448025\"><span>优点：</span></p><ol><li><span>体积小：redux-thunk 的实现方式很简单，只有不到 20 行代码</span></li><li><span>使用简单：redux-thunk 没有引入像 redux-saga 或者 redux-observable :额外的范式，上手简单</span></li></ol></blockquote><blockquote class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"u0a97d21e\"><span>缺点：</span></p><ol><li><span>样板代码过多：与 redux 本身一样，通常一个请求需要大量的代码，而且很多都是重复性质的</span></li><li><span>耦合严重：异步操作与 redux 的 action 耦合在一起，不方便管理</span></li><li><span>功能</span><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">孱</span><span>弱：有一些实际开发中常用的功能需要自行封装</span></li></ol></blockquote><h4 id=\"gQjXq\"><span>redux-saga</span></h4><blockquote class=\"lake-alert lake-alert-success\"><p data-lake-id=\"uda548b54\"><span>优点：</span></p><ol><li><span>异步解耦：异步操作被转移到单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中</span></li><li><span>action 摆脱 thunk function：dispatch 的参数依然是一个纯粹的 action(FSA)，而不是充满&quot;黑魔法&quot;的 thunk function</span></li><li><span>异常处理：受益于 generator function 的 saga 实现，代码异常/请求失败，都可以直接通过 try/catch 语法直接捕获处理</span></li><li><span>功能请打：redux-saga 提供了大量的 saga 辅助函数和 effect 创建器供开发者使用，开发者无须封装或者简单封装即可使用</span></li><li><span>灵活：redux-saga 可以将多个 saga 串行/并行组合起来，形成一个非常实用的异步 flow</span></li><li><span>易测试，提供了各种 case 的测试方案，包括 mock task，分之覆盖等等</span></li></ol></blockquote><blockquote class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"ud712044d\"><span>缺点：</span></p><ol><li><span>额外的学习成本：redux-saga 不仅在使用难以理解的 generator function，而且有数十个 API，学习成本远超 redux-thunk，最重要的是额外的学习只服务于这个库，与 redux-observable 不同，redux-observable 的背后是基于 rxjs 的一整套思想</span></li><li><span>体积庞大：代码略大，接近 2000 行，min 版 25kb 左右</span></li><li><span>功能过剩：实际上并发控制等功能很难用到，但是我们依然需要引入这些代码</span></li><li><span>ts 支持不友好：yield 无法返回 TS 类型</span></li></ol></blockquote><h3 id=\"XE4t0\"><span>redux 属性传递</span></h3><p data-lake-id=\"u6c939f29\"><span>react-redux 数据传输∶ view--&gt;action--&gt;reducer--&gt;store--&gt;view。看下点击事件的数据是如何通过 redux 传到 view 上：</span></p><ul><li><span>view 上的 AddClick 事件通过mapDispatchToProps 把数据传到 action ---&gt; click:()=&gt;dispatch(ADD)</span></li><li><span>action 的 ADD 传到 reducer 上</span></li><li><span>reducer 传到 store 上 const store = createStore(reducer);</span></li><li><span>store 再通过 mapStateToProps 映射穿到 view 上 text:State.text</span></li></ul>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"Ym5u3\" id=\"Ym5u3\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647690613642-27b36729-1d2c-49db-82ea-fa36534369cf.png%22%2C%22taskId%22%3A%22uddd292e8-e04d-46ab-a235-6068af21f6c%22%2C%22clientId%22%3A%22u9d71fc54-22fb-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A669%2C%22height%22%3A669%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A242613%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A669%2C%22originHeight%22%3A669%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22STORE%203%20%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81%20%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE(CONNECT)%20REDUX%20CONTAINER%20REDUCERS%20COMPONENT%20COMBINEREDUCERS%20%E5%8F%91%E8%B5%B7%E6%9B%B4%E6%96%B0%E5%8A%A8%E4%BD%9C(DISPATCHACTION)%20%E8%B4%9F%E8%B4%A3VIEW%E7%8A%B6%E6%80%81%20%E5%8F%91%E8%B5%B7%E6%9B%B4%E6%96%B0%E5%8A%A8%E4%BD%9C%20%E4%BC%A0%E9%80%92STATE%20PRESENTATIONAL%20COMPONENT%20%E8%B4%9F%E8%B4%A3VIEW%E6%B8%B2%E6%9F%93%20%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A306.11423%2C%22y%22%3A65.65802%2C%22width%22%3A62.11086999999998%2C%22height%22%3A20.39974000000001%2C%22text%22%3A%22STORE%22%7D%2C%7B%22x%22%3A560.4891%2C%22y%22%3A87.841805%2C%22width%22%3A15.595500000000015%2C%22height%22%3A23.343715000000003%2C%22text%22%3A%223%22%7D%2C%7B%22x%22%3A495.18494%2C%22y%22%3A97.302284%2C%22width%22%3A73.01225999999997%2C%22height%22%3A78.14017600000001%2C%22text%22%3A%22%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81%22%7D%2C%7B%22x%22%3A73.41559%2C%22y%22%3A59.31183%2C%22width%22%3A152.66638%2C%22height%22%3A144.64096999999998%2C%22text%22%3A%22%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE(CONNECT)%22%7D%2C%7B%22x%22%3A309.6185%2C%22y%22%3A277.5911%2C%22width%22%3A54.84097000000003%2C%22height%22%3A15.949950000000001%2C%22text%22%3A%22REDUX%22%7D%2C%7B%22x%22%3A38.423122%2C%22y%22%3A300.1762%2C%22width%22%3A76.45508799999999%2C%22height%22%3A15.85790000000003%2C%22text%22%3A%22CONTAINER%22%7D%2C%7B%22x%22%3A538.44714%2C%22y%22%3A310.69254%2C%22width%22%3A109.51020000000005%2C%22height%22%3A21.1336%2C%22text%22%3A%22REDUCERS%22%7D%2C%7B%22x%22%3A31.557726%2C%22y%22%3A321.8784%2C%22width%22%3A90.371684%2C%22height%22%3A17.151599999999974%2C%22text%22%3A%22COMPONENT%22%7D%2C%7B%22x%22%3A523.1507%2C%22y%22%3A348.53043%2C%22width%22%3A138.81309999999996%2C%22height%22%3A13.580069999999978%2C%22text%22%3A%22COMBINEREDUCERS%22%7D%2C%7B%22x%22%3A193.74324%2C%22y%22%3A352.6611%2C%22width%22%3A280.56789000000003%2C%22height%22%3A23.37808000000001%2C%22text%22%3A%22%E5%8F%91%E8%B5%B7%E6%9B%B4%E6%96%B0%E5%8A%A8%E4%BD%9C(DISPATCHACTION)%22%7D%2C%7B%22x%22%3A20.625769%2C%22y%22%3A352.8066%2C%22width%22%3A112.657691%2C%22height%22%3A18.068429999999978%2C%22text%22%3A%22%E8%B4%9F%E8%B4%A3VIEW%E7%8A%B6%E6%80%81%22%7D%2C%7B%22x%22%3A151.20503%2C%22y%22%3A425.62527%2C%22width%22%3A94.33081000000001%2C%22height%22%3A106.61433%2C%22text%22%3A%22%E5%8F%91%E8%B5%B7%E6%9B%B4%E6%96%B0%E5%8A%A8%E4%BD%9C%22%7D%2C%7B%22x%22%3A89.365456%2C%22y%22%3A488.44553%2C%22width%22%3A77.639914%2C%22height%22%3A81.30916999999994%2C%22text%22%3A%22%E4%BC%A0%E9%80%92STATE%22%7D%2C%7B%22x%22%3A278.65707%2C%22y%22%3A558.64514%2C%22width%22%3A109.6037%2C%22height%22%3A16.530360000000087%2C%22text%22%3A%22PRESENTATIONAL%22%7D%2C%7B%22x%22%3A288.61304%2C%22y%22%3A582.9327%2C%22width%22%3A92.03255999999999%2C%22height%22%3A14.383500000000026%2C%22text%22%3A%22COMPONENT%22%7D%2C%7B%22x%22%3A278.9503%2C%22y%22%3A609.3907%2C%22width%22%3A111.67479999999995%2C%22height%22%3A15.770739999999932%2C%22text%22%3A%22%E8%B4%9F%E8%B4%A3VIEW%E6%B8%B2%E6%9F%93%22%7D%2C%7B%22x%22%3A507.43845%2C%22y%22%3A630.6986%2C%22width%22%3A142.95905000000005%2C%22height%22%3A18.480199999999968%2C%22text%22%3A%22%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%7D%5D%2C%22id%22%3A%22u2fcb785b%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></h2><h2 data-lake-id=\"X8NnL\" id=\"X8NnL\"><span data-lake-id=\"ubda01f73\" id=\"ubda01f73\">redux 原理</span></h2><blockquote data-lake-id=\"u7fa10774\" id=\"u7fa10774\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u23fc4ea9\" id=\"u23fc4ea9\"><strong><span data-lake-id=\"ue92e2b97\" id=\"ue92e2b97\">通俗解释:</span></strong></p><ol list=\"uc61147d4\"><li fid=\"u9da2f9a1\" data-lake-id=\"uae7520e2\" id=\"uae7520e2\"><span data-lake-id=\"u4436aa85\" id=\"u4436aa85\">首先，用户通过 View 发出 Action，发出方式用到了 Dispatch 方法</span></li><li fid=\"u9da2f9a1\" data-lake-id=\"ub44326a3\" id=\"ub44326a3\"><span data-lake-id=\"u31ad28d9\" id=\"u31ad28d9\">Store 调用 Reducer，传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 State</span></li><li fid=\"u9da2f9a1\" data-lake-id=\"uaa8ba2b6\" id=\"uaa8ba2b6\"><span data-lake-id=\"ucddc9496\" id=\"ucddc9496\">State 一旦有变化，Store 就会调用监听函数，来更新 View</span></li></ol><p data-lake-id=\"u6d003389\" id=\"u6d003389\" style=\"text-indent: 2em\"><span data-lake-id=\"u6cf79e06\" id=\"u6cf79e06\">以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由 Reducers 来担任，store 只做存储，中间人，当Reducers 的更新完成以后会通过 store 的订阅来通知 react component，组件把新的状态重新获取渲染，组件中也能主动发送 action，创建 action 后这个动作是不会执行的，所以要 dispatch 这个 action，让 store 通过 reducers 去做更新React Component 就是 react 的每个组件。</span></p></blockquote><h3 data-lake-id=\"flaEE\" id=\"flaEE\"><span data-lake-id=\"u8972389e\" id=\"u8972389e\">概念介绍</span></h3><ul list=\"u60fa398d\"><li fid=\"u71cfa01d\" data-lake-id=\"u496b3da5\" id=\"u496b3da5\"><span data-lake-id=\"ud7ae0275\" id=\"ud7ae0275\">Store</span></li></ul><p data-lake-id=\"u7108927a\" id=\"u7108927a\"><span data-lake-id=\"u270a8697\" id=\"u270a8697\">保存数据的地方，你可以把它看作一个容器，整个应用只能有一个 Store</span></p><ul list=\"u60fa398d\" start=\"2\"><li fid=\"u71cfa01d\" data-lake-id=\"ua96a93a6\" id=\"ua96a93a6\"><span data-lake-id=\"u78f1f615\" id=\"u78f1f615\">State</span></li></ul><p data-lake-id=\"u29f30469\" id=\"u29f30469\"><span data-lake-id=\"uae2eaf81\" id=\"uae2eaf81\">Store 对象包含所有数据，如果想得到某个时点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫 State</span></p><ul list=\"u60fa398d\" start=\"3\"><li fid=\"u71cfa01d\" data-lake-id=\"u29ed7c39\" id=\"u29ed7c39\"><span data-lake-id=\"u9e58e3b8\" id=\"u9e58e3b8\">Action</span></li></ul><p data-lake-id=\"u634af813\" id=\"u634af813\"><span data-lake-id=\"u696f7bea\" id=\"u696f7bea\">State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了</span></p><ul list=\"u60fa398d\" start=\"4\"><li fid=\"u71cfa01d\" data-lake-id=\"ub38e10f5\" id=\"ub38e10f5\"><span data-lake-id=\"u8f98e912\" id=\"u8f98e912\">Action Creator</span></li></ul><p data-lake-id=\"ud93a9b6b\" id=\"ud93a9b6b\"><span data-lake-id=\"ud0ce84e5\" id=\"ud0ce84e5\">View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦，所以我们定义一个函数来生成 Action，这个函数就叫 Action Creator</span></p><ul list=\"u60fa398d\" start=\"5\"><li fid=\"u71cfa01d\" data-lake-id=\"u3f4cf6fc\" id=\"u3f4cf6fc\"><span data-lake-id=\"u53e4c433\" id=\"u53e4c433\">Reducer</span></li></ul><p data-lake-id=\"u55db1318\" id=\"u55db1318\"><span data-lake-id=\"uc67e26c4\" id=\"uc67e26c4\">Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State</span></p><ul list=\"u60fa398d\" start=\"6\"><li fid=\"u71cfa01d\" data-lake-id=\"u4f088c85\" id=\"u4f088c85\"><span data-lake-id=\"u8242091f\" id=\"u8242091f\">Dispatch</span></li></ul><p data-lake-id=\"u073ed732\" id=\"u073ed732\"><span data-lake-id=\"u546010c4\" id=\"u546010c4\">是 View 发出 Action 的唯一方法</span></p><h3 data-lake-id=\"hy08o\" id=\"hy08o\"><span data-lake-id=\"u14d9527f\" id=\"u14d9527f\">三个原则</span></h3><ul list=\"u94479067\"><li fid=\"u5a6cfa50\" data-lake-id=\"u6f4345c6\" id=\"u6f4345c6\"><span data-lake-id=\"uf989162d\" id=\"uf989162d\">单个事件来源</span></li></ul><p data-lake-id=\"u5530c115\" id=\"u5530c115\"><span data-lake-id=\"u750253e4\" id=\"u750253e4\">整个应用程序状态存储在单个存储的对象中</span></p><ul list=\"u94479067\" start=\"2\"><li fid=\"u5a6cfa50\" data-lake-id=\"ue993bb85\" id=\"ue993bb85\"><span data-lake-id=\"uca9ddae1\" id=\"uca9ddae1\">状态只读</span></li></ul><p data-lake-id=\"u8d8f105b\" id=\"u8d8f105b\"><span data-lake-id=\"u822e0dfa\" id=\"u822e0dfa\">更改状态的唯一方法就是触发一个动作</span></p><ul list=\"u94479067\" start=\"3\"><li fid=\"u5a6cfa50\" data-lake-id=\"u12804b68\" id=\"u12804b68\"><span data-lake-id=\"u3b8cf367\" id=\"u3b8cf367\">中间件</span></li></ul><p data-lake-id=\"ub7a4c700\" id=\"ub7a4c700\"><span data-lake-id=\"uabad1bfa\" id=\"uabad1bfa\">action -&gt; reducer -&gt; action -&gt; middlewares -&gt; reducer</span></p><h2 data-lake-id=\"W6OEV\" id=\"W6OEV\"><span data-lake-id=\"u0a9023b6\" id=\"u0a9023b6\">redux 中的异步处理方式</span></h2><h4 data-lake-id=\"qj6IR\" id=\"qj6IR\"><span data-lake-id=\"u2d2a73da\" id=\"u2d2a73da\">redux-thunk</span></h4><blockquote data-lake-id=\"u22223e80\" id=\"u22223e80\" class=\"lake-alert lake-alert-success\"><p data-lake-id=\"u85448025\" id=\"u85448025\"><span data-lake-id=\"ud8444c15\" id=\"ud8444c15\">优点：</span></p><ol list=\"u51da9b51\"><li fid=\"u221fb61e\" data-lake-id=\"u10a96639\" id=\"u10a96639\"><span data-lake-id=\"u5df750dd\" id=\"u5df750dd\">体积小：redux-thunk 的实现方式很简单，只有不到 20 行代码</span></li><li fid=\"u221fb61e\" data-lake-id=\"u3f48a14f\" id=\"u3f48a14f\"><span data-lake-id=\"u0c7ac3c4\" id=\"u0c7ac3c4\">使用简单：redux-thunk 没有引入像 redux-saga 或者 redux-observable :额外的范式，上手简单</span></li></ol></blockquote><blockquote data-lake-id=\"udc9a7269\" id=\"udc9a7269\" class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"u0a97d21e\" id=\"u0a97d21e\"><span data-lake-id=\"u4e046892\" id=\"u4e046892\">缺点：</span></p><ol list=\"uc68c9b86\"><li fid=\"uc50358f9\" data-lake-id=\"u22fce84d\" id=\"u22fce84d\"><span data-lake-id=\"u3e25e854\" id=\"u3e25e854\">样板代码过多：与 redux 本身一样，通常一个请求需要大量的代码，而且很多都是重复性质的</span></li><li fid=\"uc50358f9\" data-lake-id=\"u825e3f17\" id=\"u825e3f17\"><span data-lake-id=\"u71eb3cd6\" id=\"u71eb3cd6\">耦合严重：异步操作与 redux 的 action 耦合在一起，不方便管理</span></li><li fid=\"uc50358f9\" data-lake-id=\"u7eb6cce8\" id=\"u7eb6cce8\"><span data-lake-id=\"u807dc82b\" id=\"u807dc82b\">功能</span><span data-lake-id=\"u3c5d3a28\" id=\"u3c5d3a28\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">孱</span><span data-lake-id=\"u597221bc\" id=\"u597221bc\">弱：有一些实际开发中常用的功能需要自行封装</span></li></ol></blockquote><h4 data-lake-id=\"gQjXq\" id=\"gQjXq\"><span data-lake-id=\"u138fa833\" id=\"u138fa833\">redux-saga</span></h4><blockquote data-lake-id=\"u2cfd31c6\" id=\"u2cfd31c6\" class=\"lake-alert lake-alert-success\"><p data-lake-id=\"uda548b54\" id=\"uda548b54\"><span data-lake-id=\"u0589f5d8\" id=\"u0589f5d8\">优点：</span></p><ol list=\"u74f4ed55\"><li fid=\"u8778ac71\" data-lake-id=\"u1bbac800\" id=\"u1bbac800\"><span data-lake-id=\"ua73adebb\" id=\"ua73adebb\">异步解耦：异步操作被转移到单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中</span></li><li fid=\"u8778ac71\" data-lake-id=\"ufd853d8c\" id=\"ufd853d8c\"><span data-lake-id=\"u174b1f58\" id=\"u174b1f58\">action 摆脱 thunk function：dispatch 的参数依然是一个纯粹的 action(FSA)，而不是充满&quot;黑魔法&quot;的 thunk function</span></li><li fid=\"u8778ac71\" data-lake-id=\"u65743f9e\" id=\"u65743f9e\"><span data-lake-id=\"u76b6fd05\" id=\"u76b6fd05\">异常处理：受益于 generator function 的 saga 实现，代码异常/请求失败，都可以直接通过 try/catch 语法直接捕获处理</span></li><li fid=\"u8778ac71\" data-lake-id=\"u75764661\" id=\"u75764661\"><span data-lake-id=\"u49ce8d22\" id=\"u49ce8d22\">功能请打：redux-saga 提供了大量的 saga 辅助函数和 effect 创建器供开发者使用，开发者无须封装或者简单封装即可使用</span></li><li fid=\"u8778ac71\" data-lake-id=\"u49c06cd9\" id=\"u49c06cd9\"><span data-lake-id=\"uc8195ac0\" id=\"uc8195ac0\">灵活：redux-saga 可以将多个 saga 串行/并行组合起来，形成一个非常实用的异步 flow</span></li><li fid=\"u8778ac71\" data-lake-id=\"u91ff2f11\" id=\"u91ff2f11\"><span data-lake-id=\"uf2ea497f\" id=\"uf2ea497f\">易测试，提供了各种 case 的测试方案，包括 mock task，分之覆盖等等</span></li></ol></blockquote><blockquote data-lake-id=\"u18093034\" id=\"u18093034\" class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"ud712044d\" id=\"ud712044d\"><span data-lake-id=\"uc8276e45\" id=\"uc8276e45\">缺点：</span></p><ol list=\"u31b3e21a\"><li fid=\"u11582ff3\" data-lake-id=\"ue4083463\" id=\"ue4083463\"><span data-lake-id=\"ubb243450\" id=\"ubb243450\">额外的学习成本：redux-saga 不仅在使用难以理解的 generator function，而且有数十个 API，学习成本远超 redux-thunk，最重要的是额外的学习只服务于这个库，与 redux-observable 不同，redux-observable 的背后是基于 rxjs 的一整套思想</span></li><li fid=\"u11582ff3\" data-lake-id=\"ud5f0a9c2\" id=\"ud5f0a9c2\"><span data-lake-id=\"u329fa2d4\" id=\"u329fa2d4\">体积庞大：代码略大，接近 2000 行，min 版 25kb 左右</span></li><li fid=\"u11582ff3\" data-lake-id=\"u1ffeff40\" id=\"u1ffeff40\"><span data-lake-id=\"ub2e25811\" id=\"ub2e25811\">功能过剩：实际上并发控制等功能很难用到，但是我们依然需要引入这些代码</span></li><li fid=\"u11582ff3\" data-lake-id=\"u4289e5cf\" id=\"u4289e5cf\"><span data-lake-id=\"u7b449f16\" id=\"u7b449f16\">ts 支持不友好：yield 无法返回 TS 类型</span></li></ol></blockquote><h3 data-lake-id=\"XE4t0\" id=\"XE4t0\"><span data-lake-id=\"u1848be63\" id=\"u1848be63\">redux 属性传递</span></h3><p data-lake-id=\"u6c939f29\" id=\"u6c939f29\"><span data-lake-id=\"u75118572\" id=\"u75118572\">react-redux 数据传输∶ view--&gt;action--&gt;reducer--&gt;store--&gt;view。看下点击事件的数据是如何通过 redux 传到 view 上：</span></p><ul list=\"u7c17de99\"><li fid=\"u0e4df1d7\" data-lake-id=\"uc5303f27\" id=\"uc5303f27\"><span data-lake-id=\"u16309bd8\" id=\"u16309bd8\">view 上的 AddClick 事件通过mapDispatchToProps 把数据传到 action ---&gt; click:()=&gt;dispatch(ADD)</span></li><li fid=\"u0e4df1d7\" data-lake-id=\"ub65778da\" id=\"ub65778da\"><span data-lake-id=\"u3665ce80\" id=\"u3665ce80\">action 的 ADD 传到 reducer 上</span></li><li fid=\"u0e4df1d7\" data-lake-id=\"u97d08751\" id=\"u97d08751\"><span data-lake-id=\"uac6a84d7\" id=\"uac6a84d7\">reducer 传到 store 上 const store = createStore(reducer);</span></li><li fid=\"u0e4df1d7\" data-lake-id=\"ub10e6647\" id=\"ub10e6647\"><span data-lake-id=\"u48e48df2\" id=\"u48e48df2\">store 再通过 mapStateToProps 映射穿到 view 上 text:State.text</span></li></ul>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:09.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:09.000Z",
  "updated_at": "2022-05-10T15:12:39.000Z",
  "published_at": "2022-04-04T11:33:09.000Z",
  "first_published_at": "2022-04-04T11:33:08.837Z",
  "word_count": 1168,
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1647690613642-27b36729-1d2c-49db-82ea-fa36534369cf.png",
  "description": "redux 原理通俗解释:首先，用户通过 View 发出 Action，发出方式用到了 Dispatch 方法Store 调用 Reducer，传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 StateState 一旦有变化，Store 就会调用监听函数，来...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}