{
  "id": 72212208,
  "slug": "bgt6ta",
  "title": "受控组件和非受控组件",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": ":::success\n页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。\n:::\n<a name=\"boLYp\"></a>\n## 受控组件 \n在使用表单来收集用户输入时，例如<input><select><textearea>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。\n\n受控组件更新state的流程：\n\n- 可以通过初始state中设置表单的默认值\n- 每当表单的值发生变化时，调用onChange事件处理器\n- 事件处理器通过事件对象e拿到改变后的状态，并更新组件的state\n- 一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新\n\n<br />\n:::danger\n**受控组件缺陷：** <br />表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。\n:::\n<br />\n<a name=\"DpYBm\"></a>\n## 非受控组件\n如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。\n:::info\n**React官方的解释：**<br />要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。 因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。\n:::\n例如，下面的代码在非受控组件中接收单个属性：\n```jsx\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.input.value);\n    event.preventDefault();\n  }\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" ref={(input) => this.input = input} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><blockquote class=\"lake-alert lake-alert-success\"><p data-lake-id=\"ud084a40a\" style=\"text-indent: 2em;\"><span>页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。</span></p></blockquote><h2 id=\"boLYp\"><span>受控组件 </span></h2><p data-lake-id=\"uf7d10ec4\" style=\"text-indent: 2em;\"><span>在使用表单来收集用户输入时，例如&lt;input&gt;&lt;select&gt;&lt;textearea&gt;等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。</span></p><p data-lake-id=\"uca019dcf\"><span>​</span><br /></p><p data-lake-id=\"ubed3bd41\"><span>受控组件更新state的流程：</span></p><ul><li><span>可以通过初始state中设置表单的默认值</span></li><li><span>每当表单的值发生变化时，调用onChange事件处理器</span></li><li><span>事件处理器通过事件对象e拿到改变后的状态，并更新组件的state</span></li><li><span>一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新</span></li></ul><p data-lake-id=\"u51521ac7\"><strong><span>​</span></strong><br /></p><blockquote class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"u2ec99ec2\"><strong><span>受控组件缺陷：</span></strong><span> </span></p><p data-lake-id=\"ue6f5fb9c\" style=\"text-indent: 2em;\"><span>表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。</span></p></blockquote><p data-lake-id=\"u9b39610b\"><strong><span>​</span></strong><br /></p><h2 id=\"DpYBm\"><span>非受控组件</span></h2><p data-lake-id=\"ubb0cf517\" style=\"text-indent: 2em;\"><span>如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。</span></p><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"ucbe9e57f\"><strong><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">React官方的解释：</span></strong></p><p data-lake-id=\"u3228fc57\" style=\"text-indent: 2em;\"><span>要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。 因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</span></p></blockquote><p data-lake-id=\"u35cd021c\"><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">例如，下面的代码在非受控组件中接收单个属性：</span></p><pre data-lang=\"jsx\"><code>class NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.input.value);\n    event.preventDefault();\n  }\n  render() {\n    return (\n      &lt;form onSubmit={this.handleSubmit}&gt;\n        &lt;label&gt;\n          Name:\n          &lt;input type=&quot;text&quot; ref={(input) =&gt; this.input = input} /&gt;\n        &lt;/label&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</code></pre><p data-lake-id=\"uc80e887c\"><br /></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><blockquote data-lake-id=\"ud496ab92\" id=\"ud496ab92\" class=\"lake-alert lake-alert-success\"><p data-lake-id=\"ud084a40a\" id=\"ud084a40a\" style=\"text-indent: 2em\"><span data-lake-id=\"udccd8b29\" id=\"udccd8b29\">页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。</span></p></blockquote><h2 data-lake-id=\"boLYp\" id=\"boLYp\"><span data-lake-id=\"u0043f272\" id=\"u0043f272\">受控组件 </span></h2><p data-lake-id=\"uf7d10ec4\" id=\"uf7d10ec4\" style=\"text-indent: 2em\"><span data-lake-id=\"uc1cb72e5\" id=\"uc1cb72e5\">在使用表单来收集用户输入时，例如&lt;input&gt;&lt;select&gt;&lt;textearea&gt;等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。</span></p><p data-lake-id=\"uca019dcf\" id=\"uca019dcf\"><span data-lake-id=\"ucaffe584\" id=\"ucaffe584\">​</span><br></p><p data-lake-id=\"ubed3bd41\" id=\"ubed3bd41\"><span data-lake-id=\"u9affff52\" id=\"u9affff52\">受控组件更新state的流程：</span></p><ul list=\"ucc3fdb38\"><li fid=\"u48e43156\" data-lake-id=\"u2038fad3\" id=\"u2038fad3\"><span data-lake-id=\"u2987bd03\" id=\"u2987bd03\">可以通过初始state中设置表单的默认值</span></li><li fid=\"u48e43156\" data-lake-id=\"uc688d1a0\" id=\"uc688d1a0\"><span data-lake-id=\"u94ab3a11\" id=\"u94ab3a11\">每当表单的值发生变化时，调用onChange事件处理器</span></li><li fid=\"u48e43156\" data-lake-id=\"uba3b8c80\" id=\"uba3b8c80\"><span data-lake-id=\"u7e5b8a1e\" id=\"u7e5b8a1e\">事件处理器通过事件对象e拿到改变后的状态，并更新组件的state</span></li><li fid=\"u48e43156\" data-lake-id=\"u52f80ba2\" id=\"u52f80ba2\"><span data-lake-id=\"u9e9cd0f9\" id=\"u9e9cd0f9\">一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新</span></li></ul><p data-lake-id=\"u51521ac7\" id=\"u51521ac7\"><strong><span data-lake-id=\"u7383f1f8\" id=\"u7383f1f8\">​</span></strong><br></p><blockquote data-lake-id=\"u4b2c35df\" id=\"u4b2c35df\" class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"u2ec99ec2\" id=\"u2ec99ec2\"><strong><span data-lake-id=\"uf2b83948\" id=\"uf2b83948\">受控组件缺陷：</span></strong><span data-lake-id=\"u866d4bac\" id=\"u866d4bac\"> </span></p><p data-lake-id=\"ue6f5fb9c\" id=\"ue6f5fb9c\" style=\"text-indent: 2em\"><span data-lake-id=\"u3cff4c7b\" id=\"u3cff4c7b\">表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。</span></p></blockquote><p data-lake-id=\"u9b39610b\" id=\"u9b39610b\"><strong><span data-lake-id=\"u4a2c362d\" id=\"u4a2c362d\">​</span></strong><br></p><h2 data-lake-id=\"DpYBm\" id=\"DpYBm\"><span data-lake-id=\"ub6675b24\" id=\"ub6675b24\">非受控组件</span></h2><p data-lake-id=\"ubb0cf517\" id=\"ubb0cf517\" style=\"text-indent: 2em\"><span data-lake-id=\"u1716eb0b\" id=\"u1716eb0b\">如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。</span></p><blockquote data-lake-id=\"ue6cf7087\" id=\"ue6cf7087\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"ucbe9e57f\" id=\"ucbe9e57f\"><strong><span data-lake-id=\"uab838d22\" id=\"uab838d22\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">React官方的解释：</span></strong></p><p data-lake-id=\"u3228fc57\" id=\"u3228fc57\" style=\"text-indent: 2em\"><span data-lake-id=\"u1aa9588a\" id=\"u1aa9588a\">要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。 因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</span></p></blockquote><p data-lake-id=\"u35cd021c\" id=\"u35cd021c\"><span data-lake-id=\"u46541fbc\" id=\"u46541fbc\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">例如，下面的代码在非受控组件中接收单个属性：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22class%20NameForm%20extends%20React.Component%20%7B%5Cn%20%20constructor(props)%20%7B%5Cn%20%20%20%20super(props)%3B%5Cn%20%20%20%20this.handleSubmit%20%3D%20this.handleSubmit.bind(this)%3B%5Cn%20%20%7D%5Cn%20%20handleSubmit(event)%20%7B%5Cn%20%20%20%20alert('A%20name%20was%20submitted%3A%20'%20%2B%20this.input.value)%3B%5Cn%20%20%20%20event.preventDefault()%3B%5Cn%20%20%7D%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cform%20onSubmit%3D%7Bthis.handleSubmit%7D%3E%5Cn%20%20%20%20%20%20%20%20%3Clabel%3E%5Cn%20%20%20%20%20%20%20%20%20%20Name%3A%5Cn%20%20%20%20%20%20%20%20%20%20%3Cinput%20type%3D%5C%22text%5C%22%20ref%3D%7B(input)%20%3D%3E%20this.input%20%3D%20input%7D%20%2F%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Flabel%3E%5Cn%20%20%20%20%20%20%20%20%3Cinput%20type%3D%5C%22submit%5C%22%20value%3D%5C%22Submit%5C%22%20%2F%3E%5Cn%20%20%20%20%20%20%3C%2Fform%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22DVOcd%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"uc80e887c\" id=\"uc80e887c\"><br></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:38.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:38.000Z",
  "updated_at": "2022-05-10T15:12:35.000Z",
  "published_at": "2022-04-04T11:33:38.000Z",
  "first_published_at": "2022-04-04T11:33:37.610Z",
  "word_count": 746,
  "cover": null,
  "description": "页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。受控组件 在使用表单来收集用户输入时，例如<input><select><textearea>等元素都要绑...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}