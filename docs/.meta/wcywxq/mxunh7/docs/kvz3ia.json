{
  "id": 72212317,
  "slug": "kvz3ia",
  "title": "NodeJS",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"14640111\"></a>\n# 一、Node 基础概念\n\n<a name=\"885b7fb2\"></a>\n## 1.1 Node 是什么\n\nNode.js 是一个开源与跨平台的 JavaScript 运行时环境。在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能。我们可以理解为：Node.js 就是一个服务器端的、非阻塞式 I/O 的、事件驱动的 JavaScript 运行环境。<br />理解 Node，有几个基础的概念：非阻塞异步和事件驱动。\n\n- **非阻塞异步：** Nodejs 采用了非阻塞型 I/O 机制，在做 I/O 操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作。例如，在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。\n- **事件驱动：** 事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。比如，读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理。\n\n![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776298-7e87f64c-6d5e-4d9c-8342-b987468c6aae.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufb8791da&margin=%5Bobject%20Object%5D&originHeight=423&originWidth=734&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u266205b6-6e9a-4e90-a495-40e5ee1d71b&title=#averageHue=%23fbfbfb&id=Zt6RL&originHeight=423&originWidth=734&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n<a name=\"532bae4f\"></a>\n## 1.2 Node 的应用场景及存在的缺点\n\n<a name=\"52c34190\"></a>\n### 1.2.1 优缺点\n\nNode.js 适合用于 I/O 密集型应用，值的是应用在运行极限时，CPU 占用率仍然比较低，大部分时间是在做 I/O 硬盘内存读写操作。缺点如下：\n\n- 不适合 CPU 密集型应用\n- 只支持单核 CPU，不能充分利用 CPU\n- 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃\n\n对于第三点，常用的解决方案是，使用 Nnigx 反向代理，开多个进程绑定多个端口，或者开多个进程监听同一个端口。\n\n<a name=\"6c69ebca\"></a>\n### 1.2.1 应用场景\n\n在熟悉了 Nodejs 的优点和弊端后，我们可以看到它适合以下的应用场景：\n\n- 善于 I/O，不善于计算。因为 Nodejs 是一个单线程，如果计算（同步）太多，则会阻塞这个线程。\n- 大量并发的 I/O，应用程序内部并不需要进行非常复杂的处理。\n- 与 WeSocket 配合，开发长连接的实时交互应用程序。\n\n具体的使用场景如下：\n\n1. 用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的 web 应用程序。\n2. 基于 web、canvas 等多人联网游戏。\n3. 基于 web 的多人实时聊天客户端、聊天室、图文直播。\n4. 单页面浏览器应用程序。\n5. 操作数据库、为前端和移动端提供基于 json 的 API。\n\n<a name=\"706d7949\"></a>\n# 二、Node 全部对象\n\n在浏览器 JavaScript 中，window 是全局对象， 而 Nodejs 中的全局对象则是 **global**。<br />在 NodeJS 里，是不可能在最外层定义一个变量，因为所有的用户代码都是当前模块的，只在当前模块里可用，但可以通过 exports 对象的使用将其传递给模块外部。所以，在 NodeJS 中，用 var 声明的变量并不属于全局的变量，只在当前模块生效。像上述的 global 全局对象则在全局作用域中，任何全局变量、函数、对象都是该对象的一个属性值。\n\n<a name=\"a6c8674d\"></a>\n## 2.1 常见全局对象\n\nNode 常见的全局对象有如下一些：\n\n- Class:Buffer\n- process\n- console\n- clearInterval、setInterval\n- clearTimeout、setTimeout\n- global\n\n`Class:Buffer` 可以用来处理二进制以及非 `Unicode` 编码的数据，在 `Buffer` 类实例化中存储了原始数据。`Buffer` 类似于一个整数数组，在 `V8` 堆原始存储空间给它分配了内存，一旦创建了 `Buffer` 实例，则无法改变大小。\n\n`process` 表示进程对象，提供有关当前过程的信息和控制。包括在执行 `node` 程序的过程中，如果需要传递参数，我们想要获取这个参数需要在 `process` 内置对象中。比如，我们有如下一个文件：\n\n```javascript\nprocess.argv.forEach((val, index) => {\n    console.log(`${index}: ${val}`)\n})\n```\n\n当我们需要启动一个进程时，可以使用下面的命令：\n\n```shell\nnode index.js\n```\n\n`console` 主要用来打印 `stdout` 和 `stderr`，最常用的比如日志输出：`console.log`。清空控制台的命令为：`console.clear`。如果需要打印函数的调用栈，可以使用命令 `console.trace`。\n\n`setInterval` 用于设置定时器，语法格式如下：\n\n```javascript\nsetInterval(callback, delay[, ...args])\n```\n\n`clearInterval` 则用于清除定时器，`callback` 每 `delay` 毫秒重复执行一次。\n\n和 `setInterval` 一样，`setTimeout` 主要用于设置延时器，而 `clearTimeout` 则用于清除设置的延时器。\n\n`global` 是一个全局命名空间对象，前面讲到的 `process`、`console`、`setTimeout` 等可以放到 `global` 中，例如：\n\n```javascript\nconsole.log(process === global.process) //输出 true\n```\n\n<a name=\"a987960b\"></a>\n## 2.2 模块中的全局对象\n\n除了系统提供的全局对象外，还有一些只是在模块中出现，看起来像全局变量，如下所示：\n\n- `__dirname`\n- `__filename`\n- `exports`\n- `module`\n- `require`\n\n`__dirname` 主要用于获取当前文件所在的路径，不包括后面的文件名。比如，在 `/Users/mjr` 中运行 `node example.js`，打印结果如下：\n\n```javascript\nconsole.log(__dirname) // 打印: /Users/mjr\n```\n\n`__filename` 用于获取当前文件所在的路径和文件名称，包括后面的文件名称。比如，在 `/Users/mjr` 中运行 `node example.js`，打印的结果如下：\n\n```javascript\nconsole.log(__filename) // 打印: /Users/mjr/example.js\n```\n\n`module.exports` 用于导出一个指定模块所的内容，然后也可以使用 `require()` 访问里面的内容。\n\n```javascript\nexports.name = name\nexports.age = age\nexports.sayHello = sayHello\n```\n\n`require` 主要用于引入模块、`JSON`、或本地文件， 可以从 `node_modules` 引入模块。可以使用相对路径引入本地模块或 `JSON` 文件，路径会根据 `__dirname` 定义的目录名或当前工作目录进行处理。\n\n<a name=\"7a19c723\"></a>\n# 三、谈谈对 process 的理解\n\n<a name=\"fcea9dd2\"></a>\n## 3.1 基本概念\n\n我们知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器。当我们启动一个 js 文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享。<br />process 对象是 Node 的一个全局变量，提供了有关当前 Node.js 进程的信息并对其进行控制。 由于 JavaScript 是一个单线程语言，所以通过 node xxx 启动一个文件后，只有一条主线程。\n\n<a name=\"46d5f104\"></a>\n## 3.2 常用属性和方法\n\nprocess 的常见属性如下：\n\n- process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息\n- process.nextTick：这个在谈及 EventLoop 时经常为会提到\n- process.pid：获取当前进程 id\n- process.ppid：当前进程对应的父进程\n- process.cwd()：获取当前进程工作目录\n- process.platform：获取当前进程运行的操作系统平台\n- process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值\n\n进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听\n\n- 三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出\n- process.title：用于指定进程名称，有的时候需要给进程指定一个名称\n\n<a name=\"d381b7d6\"></a>\n# 四、谈谈你对 fs 模块的理解\n\n<a name=\"9ea26fe6\"></a>\n## 4.1 fs 是什么\n\nfs（filesystem）是文件系统模块，该模块提供本地文件的读写能力，基本上是 POSIX 文件操作命令的简单包装。可以说，所有与文件的操作都是通过 fs 核心模块来实现的。<br />使用之前，需要先导入 fs 模块，如下：\n\n```javascript\nconst fs = require(\"fs\")\n```\n\n<a name=\"83aa8750\"></a>\n## 4.2 文件基础知识\n\n在计算机中，有关于文件的基础知识有如下一些：\n\n- 权限位 mode\n- 标识位 flag\n- 文件描述为 fd\n\n<a name=\"8b15b7d7\"></a>\n### 4.2.1 权限位 mode\n\n![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776369-f24a77ac-46e8-4d3b-8060-cb87862d35d5.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9d544723&margin=%5Bobject%20Object%5D&originHeight=208&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u466a6cd9-2a76-4ae7-864f-0863d99a4a6&title=#averageHue=%23f3f3f3&id=cioq6&originHeight=208&originWidth=935&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位 4、2、1，不具备权限为 0。如在 linux 查看文件权限位的命令如下：\n\n```markdown\ndrwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core -rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md\n```\n\n在开头前十位中，d 为文件夹，-为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限。\n\n<a name=\"d1a14988\"></a>\n### 4.2.2 标识位\n\n标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示： ![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776337-d3459565-762c-4ad9-893d-a8182c7fad6b.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua982a818&margin=%5Bobject%20Object%5D&originHeight=846&originWidth=982&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8906bb54-c483-46c9-9748-373ba87bc40&title=#id=xiyc9&originHeight=846&originWidth=982&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n<a name=\"c39a80ba\"></a>\n### 4.2.3 文件描述 fd\n\n操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件。\n\nWindow 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。\n\n在 NodeJS 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2 三个比较特殊的描述符，分别代表 process.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出）。\n\n<a name=\"dea7c041\"></a>\n## 4.3 常用方法\n\n由于 fs 模块主要是操作文件的，所以常见的文件操作方法有如下一些：\n\n- 文件读取\n- 文件写入\n- 文件追加写入\n- 文件拷贝\n- 创建目录\n\n<a name=\"f0ae08e8\"></a>\n### 4.3.1 文件读取\n\n常用的文件读取有 readFileSync 和 readFile 两个方法。其中，readFileSync 表示同步读取，如下：\n\n```javascript\nconst fs = require(\"fs\")\nlet buf = fs.readFileSync(\"1.txt\")\nlet data = fs.readFileSync(\"1.txt\", \"utf8\")\nconsole.log(buf) // <Buffer 48 65 6c 6c 6f>\nconsole.log(data) // Hello\n```\n\n- 第一个参数为读取文件的路径或文件描述符。\n- 第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding。\n\nreadFile 为异步读取方法， readFile 与 readFileSync 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 err（错误）和 data（数据），该方法没有返回值，回调函数在读取文件成功后执行。\n\n```javascript\nconst fs = require(\"fs\")\nfs.readFile(\"1.txt\", \"utf8\", (err, data) => {\n    if (!err) {\n        console.log(data)\n        // Hello\n    }\n})\n```\n\n<a name=\"78888f32\"></a>\n### 4.3.2 文件写入\n\n文件写入需要用到 writeFileSync 和 writeFile 两个方法。writeFileSync 表示同步写入，如下所示。\n\n```javascript\nconst fs = require(\"fs\")\nfs.writeFileSync(\"2.txt\", \"Hello world\")\nlet data = fs.readFileSync(\"2.txt\", \"utf8\")\nconsole.log(data) // Hello world\n```\n\n- 第一个参数为写入文件的路径或文件描述符。\n- 第二个参数为写入的数据，类型为 String 或 Buffer。\n- 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding。\n\nwriteFile 表示异步写入，writeFile 与 writeFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件写入数据成功后执行。\n\n```javascript\nconst fs = require(\"fs\")\nfs.writeFile(\"2.txt\", \"Hello world\", err => {\n    if (!err) {\n        fs.readFile(\"2.txt\", \"utf8\", (err, data) => {\n            console.log(data) // Hello world\n        })\n    }\n})\n```\n\n<a name=\"5b6754f5\"></a>\n### 4.3.3 文件追加写入\n\n文件追加写入需要用到 appendFileSync 和 appendFile 两个方法。appendFileSync 表示同步写入，如下。\n\n```javascript\nconst fs = require(\"fs\")\nfs.appendFileSync(\"3.txt\", \" world\")\nlet data = fs.readFileSync(\"3.txt\", \"utf8\")\n```\n\n- 第一个参数为写入文件的路径或文件描述符。\n- 第二个参数为写入的数据，类型为 String 或 Buffer。\n- 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding。\n\nappendFile 表示异步追加写入，方法 appendFile 与 appendFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件追加写入数据成功后执行，如下所示。\n\n```javascript\nconst fs = require(\"fs\")\nfs.appendFile(\"3.txt\", \" world\", err => {\n    if (!err) {\n        fs.readFile(\"3.txt\", \"utf8\", (err, data) => {\n            console.log(data) // Hello world\n        })\n    }\n})\n```\n\n<a name=\"b936db03\"></a>\n### 4.3.4 创建目录\n\n创建目录主要有 mkdirSync 和 mkdir 两个方法。其中，mkdirSync 为同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常。\n\n```javascript\n// 假设已经有了 a 文件夹和 a 下的 b 文件夹\nfs.mkdirSync(\"a/b/c\")\n```\n\nmkdir 为异步创建，第二个参数为回调函数，如下所示。\n\n```javascript\nfs.mkdir(\"a/b/c\", err => {\n    if (!err) console.log(\"创建成功\")\n})\n```\n\n<a name=\"3d21eed3\"></a>\n# 五、谈谈你对 Stream 的理解\n\n<a name=\"d4b7a6c3\"></a>\n## 5.1 基本概念\n\n流（Stream）是一种数据传输的手段，是一种端到端信息交换的方式，而且是有顺序的，是逐块读取数据、处理内容，用于顺序读取输入或写入输出。在 Node 中，Stream 分成三部分：source、dest、pipe。\n\n其中，在 source 和 dest 之间有一个连接的管道 pipe，它的基本语法是 source.pipe(dest)，source 和 dest 就是通过 pipe 连接，让数据从 source 流向 dest，如下图所示：<br /> ![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776316-ec2753d3-05e5-475e-987b-b79ac8d11923.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0f84404c&margin=%5Bobject%20Object%5D&originHeight=311&originWidth=352&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1b177b68-1c96-4214-87fa-097ee0ec21f&title=#id=e7iAA&originHeight=311&originWidth=352&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n<a name=\"d52b149f\"></a>\n## 5.2 流的分类\n\n在 Node，流可以分成四个种类：\n\n- **可写流**：可写入数据的流，例如 fs.createWriteStream() 可以使用流将数据写入文件。\n- **可读流**： 可读取数据的流，例如 fs.createReadStream() 可以从文件读取内容。\n- **双工流**： 既可读又可写的流，例如 net.Socket。\n- **转换流**： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据。\n\n在 Node 的 HTTP 服务器模块中，request 是可读流，response 是可写流。对于 fs 模块来说，能同时处理可读和可写文件流可读流和可写流都是单向的，比较容易理解。而 Socket 是双向的，可读可写。\n\n<a name=\"9c010904\"></a>\n### 5.2.1 双工流\n\n在 Node 中，比较的常见的全双工通信就是 websocket，因为发送方和接受方都是各自独立的方法，发送和接收都没有任何关系。 ![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776316-96152afb-5799-49e4-ac4a-c792f1da517c.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf71601d0&margin=%5Bobject%20Object%5D&originHeight=191&originWidth=500&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc8cbaf81-b3a4-4be0-9bb8-87d66a6e85c&title=#id=DyHvq&originHeight=191&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 基本的使用方法如下：\n\n```javascript\nconst { Duplex } = require(\"stream\")\n\nconst myDuplex = new Duplex({\n    read(size) {\n        // ...\n    },\n    write(chunk, encoding, callback) {\n        // ...\n    }\n})\n```\n\n<a name=\"513831a5\"></a>\n## 5.3 使用场景\n\n流的常见使用场景有：\n\n- get 请求返回文件给客户端\n- 文件操作\n- 一些打包工具的底层操作\n\n<a name=\"fe9be06e\"></a>\n### 5.3.1 网络请求\n\n流一个常见的使用场景就是网络请求，比如使用 stream 流返回文件，res 也是一个 stream 对象，通过 pipe 管道将文件数据返回。\n\n```javascript\nconst server = http.createServer(function (req, res) {\n    const method = req.method\n    // get 请求\n    if (method === \"GET\") {\n        const fileName = path.resolve(__dirname, \"data.txt\")\n        let stream = fs.createReadStream(fileName)\n        stream.pipe(res)\n    }\n})\nserver.listen(8080)\n```\n\n<a name=\"e4795cb4\"></a>\n### 5.3.2 文件操作\n\n文件的读取也是流操作，创建一个可读数据流 readStream，一个可写数据流 writeStream，通过 pipe 管道把数据流转过去。\n\n```javascript\nconst fs = require(\"fs\")\nconst path = require(\"path\")\n\n// 两个文件名\nconst fileName1 = path.resolve(__dirname, \"data.txt\")\nconst fileName2 = path.resolve(__dirname, \"data-bak.txt\")\n// 读取文件的 stream 对象\nconst readStream = fs.createReadStream(fileName1)\n// 写入文件的 stream 对象\nconst writeStream = fs.createWriteStream(fileName2)\n// 通过 pipe执行拷贝，数据流转\nreadStream.pipe(writeStream)\n// 数据读取完成监听，即拷贝完成\nreadStream.on(\"end\", function () {\n    console.log(\"拷贝完成\")\n})\n```\n\n另外，一些打包工具，Webpack 和 Vite 等都涉及很多流的操作。\n\n<a name=\"7dea4013\"></a>\n# 六、事件循环机制\n\n<a name=\"31308610\"></a>\n## 6.1 什么是浏览器事件循环\n\nNode.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。\n\n当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)，其运行原理如下图所示。<br />![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776762-39a74481-73e0-45f4-b0a7-c509ef0b3358.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0c77ed56&margin=%5Bobject%20Object%5D&originHeight=316&originWidth=800&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucae1209f-930b-4741-820d-2ffe75c4935&title=#id=cKJ7V&originHeight=316&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 从左到右，从上到下，Node.js 被分为了四层，分别是 应用层、V8 引擎层、Node API 层 和 LIBUV 层。\n\n- **应用层**： 即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 http，fs\n- **V8 引擎层**： 即利用 V8 引擎来解析 JavaScript 语法，进而和下层 API 交互\n- **Node API 层**： 为上层模块提供系统调用，一般是由 C 语言来实现，和操作系统进行交互 。\n- **LIBUV 层**： 是跨平台的底层封装，实现了 事件循环、文件操作等，是 Node.js 实现异步的核心 。\n\n在 Node 中，我们所说的事件循环是基于 libuv 实现的，libuv 是一个多平台的专注于异步 IO 的库。上图的 EVENT_QUEUE 给人看起来只有一个队列，但事实上 EventLoop 存在 6 个阶段，每个阶段都有对应的一个先进先出的回调队列。\n\n<a name=\"fd2efd28\"></a>\n## 6.2 事件循环的六个阶段\n\n事件循环一共可以分成了六个阶段，如下图所示。 ![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776842-ddc16b06-3ced-4c9d-af77-41a1bef3eed7.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc1b560a1&margin=%5Bobject%20Object%5D&originHeight=414&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0abf45b3-21f7-4925-9910-0ccee24f01f&title=#id=k48OI&originHeight=414&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n- timers 阶段：此阶段主要执行 timer（setTimeout、setInterval）的回调。\n- I/O 事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些 I/O 回调。\n- 闲置阶段(idle、prepare)：仅系统内部使用。\n- 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。\n- 检查阶段(check)：setImmediate() 回调函数在这里执行\n- 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)\n\n每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段，如下图所示。 ![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776814-ea6ed8b4-5eb8-44f7-ba02-ffc37686b00f.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub6591ff1&margin=%5Bobject%20Object%5D&originHeight=613&originWidth=703&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5750c350-d871-4e63-861a-a422c186d3a&title=#id=gmy0w&originHeight=613&originWidth=703&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n<a name=\"50dfc512\"></a>\n# 七、EventEmitter\n\n<a name=\"9729e412\"></a>\n## 7.1 基本概念\n\n前文说过，Node 采用了事件驱动机制，而 EventEmitter 就是 Node 实现事件驱动的基础。在 EventEmitter 的基础上，Node 几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定、触发监听器，实现了异步操作。\n\nNode.js 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件，这些产生事件的对象都是 events.EventEmitter 的实例，用于将一个或多个函数绑定到命名事件上。\n\n<a name=\"80390061\"></a>\n## 7.2 基本使用\n\nNode 的 events 模块只提供了一个 EventEmitter 类，这个类实现了 Node 异步事件驱动架构的基本模式：观察者模式。\n\n在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新会依次通知观察者，使用方式如下。\n\n```javascript\nconst EventEmitter = require(\"events\")\n\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter()\n\nfunction callback() {\n    console.log(\"触发了event事件！\")\n}\nmyEmitter.on(\"event\", callback)\nmyEmitter.emit(\"event\")\nmyEmitter.removeListener(\"event\", callback)\n```\n\n在上面的代码中，我们通过实例对象的 on 方法注册一个名为 event 的事件，通过 emit 方法触发该事件，而 removeListener 用于取消事件的监听。<br />除了上面介绍的一些方法外，其他常用的方法还有如下一些：\n\n- emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部。\n- emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部。\n- emitter.emit(eventName[, ...args])：触发类型为 eventName 的监听事件。\n- emitter.removeListener/off(eventName, listener)：移除类型为 eventName 的监听事件。\n- emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除。\n- emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件。\n\n<a name=\"a25f2215\"></a>\n## 7.3 实现原理\n\nEventEmitter 其实是一个构造函数，内部存在一个包含所有事件的对象。\n\n```javascript\nclass EventEmitter {\n    constructor() {\n        this.events = {}\n    }\n}\n```\n\n其中，events 存放的监听事件的函数的结构如下：\n\n```javascript\n{\n  \"event1\": [f1,f2,f3]，\n  \"event2\": [f4,f5]，\n  ...\n}\n```\n\n然后，开始一步步实现实例方法，首先是 emit，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：\n\n```javascript\nemit(type, ...args) {\n    this.events[type].forEach((item) => {\n        Reflect.apply(item, this, args);\n    });\n}\n```\n\n实现了 emit 方法之后，然后依次实现 on、addListener、prependListener 这三个实例方法，它们都是添加事件监听触发函数的。\n\n```javascript\non(type, handler) {\n    if (!this.events[type]) {\n        this.events[type] = []\n    }\n    this.events[type].push(handler);\n}\n\naddListener(type,handler){\n    this.on(type,handler)\n}\n\nprependListener(type, handler) {\n    if (!this.events[type]) {\n        this.events[type] = []\n    }\n    this.events[type].unshift(handler)\n}\n```\n\n实现 once 方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过 fired 属性值判断事件函数是否执行过。\n\n```javascript\nremoveListener(type, handler) {\n    if (!this.events[type]) {\n        return\n    }\n    this.events[type] = this.events[type].filter(item => item !== handler)\n}\n\noff(type,handler){\n    this.removeListener(type,handler)\n}\n```\n\n下面是完成的测试代码：\n\n```javascript\nclass EventEmitter {\n    constructor() {\n        this.events = {}\n    }\n\n    on(type, handler) {\n        if (!this.events[type]) {\n            this.events[type] = []\n        }\n        this.events[type].push(handler)\n    }\n\n    addListener(type, handler) {\n        this.on(type, handler)\n    }\n\n    prependListener(type, handler) {\n        if (!this.events[type]) {\n            this.events[type] = []\n        }\n        this.events[type].unshift(handler)\n    }\n\n    removeListener(type, handler) {\n        if (!this.events[type]) {\n            return\n        }\n        this.events[type] = this.events[type].filter(item => item !== handler)\n    }\n\n    off(type, handler) {\n        this.removeListener(type, handler)\n    }\n\n    emit(type, ...args) {\n        this.events[type].forEach(item => {\n            Reflect.apply(item, this, args)\n        })\n    }\n\n    once(type, handler) {\n        this.on(type, this._onceWrap(type, handler, this))\n    }\n\n    _onceWrap(type, handler, target) {\n        const state = { fired: false, handler, type, target }\n        const wrapFn = this._onceWrapper.bind(state)\n        state.wrapFn = wrapFn\n        return wrapFn\n    }\n\n    _onceWrapper(...args) {\n        if (!this.fired) {\n            this.fired = true\n            Reflect.apply(this.handler, this.target, args)\n            this.target.off(this.type, this.wrapFn)\n        }\n    }\n}\n```\n\n<a name=\"097f5f61\"></a>\n# 八、中间件\n\n<a name=\"54ec71ce\"></a>\n## 8.1 基本概念\n\n中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。 在 Node 中，中间件主要是指封装 http 请求细节处理的方法。例如，在 express、koa 等 web 框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数，架构示意图如下。<br />![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776860-f2586f50-2de4-4f9b-b56e-7082c70b5070.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4c39c39c&margin=%5Bobject%20Object%5D&originHeight=412&originWidth=913&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u724dc371-8c3c-4fa1-83fe-2736bef4a90&title=#id=N5GxZ&originHeight=412&originWidth=913&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />通常，在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作。\n\n<a name=\"7c87a55a\"></a>\n## 8.2 koa\n\nKoa 是基于 Node 当前比较流行的 web 框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助开发者快速而愉快地编写服务端应用程序。 ![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776892-bff5e920-ac91-481f-9f57-4acf8664a57a.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc6948f4d&margin=%5Bobject%20Object%5D&originHeight=620&originWidth=699&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u20597ab3-78c2-4ca2-b232-c8b5c3caba6&title=#id=AZXtr&originHeight=620&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />Koa 中间件采用的是洋葱圈模型，每次执行下一个中间件都传入两个参数：\n\n- ctx ：封装了 request 和 response 的变量\n- next ：进入下一个要执行的中间件的函数\n\n通过前面的介绍，我们知道了 Koa 中间件本质上就是一个函数，可以是 async 函数，也可以是普通函数。下面就针对 koa 进行中间件的封装：\n\n```javascript\n// async 函数\napp.use(async (ctx, next) => {\n    const start = Date.now()\n    await next()\n    const ms = Date.now() - start\n    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`)\n})\n\n// 普通函数\napp.use((ctx, next) => {\n    const start = Date.now()\n    return next().then(() => {\n        const ms = Date.now() - start\n        console.log(`${ctx.method} ${ctx.url} - ${ms}ms`)\n    })\n})\n```\n\n当然，我们还可以通过中间件封装 http 请求过程中几个常用的功能：\n\n**token 校验**\n\n```javascript\nmodule.exports = (options) => async (ctx, next) {\n  try {\n    // 获取 token\n    const token = ctx.header.authorization\n    if (token) {\n      try {\n          // verify 函数验证 token，并获取用户相关信息\n          await verify(token)\n      } catch (err) {\n        console.log(err)\n      }\n    }\n    // 进入下一个中间件\n    await next()\n  } catch (err) {\n    console.log(err)\n  }\n}\n```\n\n**日志模块**\n\n```javascript\nconst fs = require(\"fs\")\nmodule.exports = options => async (ctx, next) => {\n    const startTime = Date.now()\n    const requestTime = new Date()\n    await next()\n    const ms = Date.now() - startTime\n    let logout = `${ctx.request.ip} -- ${requestTime} -- ${ctx.method} -- ${ctx.url} -- ${ms}ms`\n    // 输出日志文件\n    fs.appendFileSync(\"./log.txt\", logout + \"\\n\")\n}\n```\n\nKoa 存在很多第三方的中间件，如 koa-bodyparser、koa-static 等。\n\n<a name=\"9edbeff9\"></a>\n## 8.3 Koa 中间件\n\n**koa-bodyparser** koa-bodyparser 中间件是将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body 上，方便我们在其他中间件或接口处取值。\n\n```javascript\n// 文件：my-koa-bodyparser.js\nconst querystring = require(\"querystring\")\n\nmodule.exports = function bodyParser() {\n    return async (ctx, next) => {\n        await new Promise((resolve, reject) => {\n            // 存储数据的数组\n            let dataArr = []\n\n            // 接收数据\n            ctx.req.on(\"data\", data => dataArr.push(data))\n\n            // 整合数据并使用 Promise 成功\n            ctx.req.on(\"end\", () => {\n                // 获取请求数据的类型 json 或表单\n                let contentType = ctx.get(\"Content-Type\")\n\n                // 获取数据 Buffer 格式\n                let data = Buffer.concat(dataArr).toString()\n\n                if (contentType === \"application/x-www-form-urlencoded\") {\n                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body\n                    ctx.request.body = querystring.parse(data)\n                } else if (contentType === \"applaction/json\") {\n                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body\n                    ctx.request.body = JSON.parse(data)\n                }\n\n                // 执行成功的回调\n                resolve()\n            })\n        })\n\n        // 继续向下执行\n        await next()\n    }\n}\n```\n\n**koa-static** koa-static 中间件的作用是在服务器接到请求时，帮我们处理静态文件，比如。\n\n```javascript\nconst fs = require(\"fs\")\nconst path = require(\"path\")\nconst mime = require(\"mime\")\nconst { promisify } = require(\"util\")\n\n// 将 stat 和 access 转换成 Promise\nconst stat = promisify(fs.stat)\nconst access = promisify(fs.access)\n\nmodule.exports = function (dir) {\n    return async (ctx, next) => {\n        // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /\n        let realPath = path.join(dir, ctx.path)\n\n        try {\n            // 获取 stat 对象\n            let statObj = await stat(realPath)\n\n            // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html\n            if (statObj.isFile()) {\n                ctx.set(\"Content-Type\", `${mime.getType()};charset=utf8`)\n                ctx.body = fs.createReadStream(realPath)\n            } else {\n                let filename = path.join(realPath, \"index.html\")\n\n                // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理\n                await access(filename)\n\n                // 存在设置文件类型并响应内容\n                ctx.set(\"Content-Type\", \"text/html;charset=utf8\")\n                ctx.body = fs.createReadStream(filename)\n            }\n        } catch (e) {\n            await next()\n        }\n    }\n}\n```\n\n总的来说，在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据。\n\n<a name=\"480ee596\"></a>\n# 九、如何设计并实现 JWT 鉴权\n\n<a name=\"7d9bbac5\"></a>\n## 9.1 JWT 是什么\n\nJWT（JSON Web Token），本质就是一个字符串书写规范，作用是用来在用户和服务器之间传递安全可靠的，如下图。\n\n ![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828777364-f26cadff-b496-4390-888c-f915db496f3b.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udcd225de&margin=%5Bobject%20Object%5D&originHeight=166&originWidth=695&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u838a29dd-cbf2-4cbd-937d-afffc146266&title=#id=GT4zu&originHeight=166&originWidth=695&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) \n\n在目前前后端分离的开发过程中，使用 token 鉴权机制用于身份验证是最常见的方案，流程如下：\n\n- 服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证。\n- 后续访问会根据这个令牌判断用户时候有权限进行访问。\n\nToken，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以.进行拼接。其中头部和载荷都是以 JSON 格式存放数据，只是进行了编码，示意图如下。 ![](https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828777403-f4df86c4-d16b-4f91-bae8-e6e5b727bb53.webp#clientId=uc25a66e0-829f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9f25c564&margin=%5Bobject%20Object%5D&originHeight=637&originWidth=574&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua6a8a38c-f0bb-4346-aee1-9cbde264cb8&title=#id=AHjxY&originHeight=637&originWidth=574&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n<a name=\"bf7e3d7b\"></a>\n### 9.1.1 header\n\n每个 JWT 都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为 alg，同时还有一个 typ 的字段，默认 JWT 即可。以下示例中算法为 HS256：\n\n```json\n{ \"alg\": \"HS256\", \"typ\": \"JWT\" }\n```\n\n因为 JWT 是字符串，所以我们还需要对以上内容进行 Base64 编码，编码后字符串如下：\n\n```json\n{ \"alg\": \"HS256\", \"typ\": \"JWT\" }\n```\n\n<a name=\"74a378af\"></a>\n### 9.1.2 payload\n\n载荷即消息体，这里会存放实际的内容，也就是 Token 的数据声明，例如用户的 id 和 name，默认情况下也会携带令牌的签发时间 iat，通过还可以设置过期时间，如下：\n\n```json\n{\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"iat\": 1516239022\n}\n```\n\n同样进行 Base64 编码后，字符串如下：\n\n```javascript\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ\n```\n\n<a name=\"7c0a4684\"></a>\n### 9.1.3 Signature\n\n签名是对头部和载荷内容进行签名，一般情况，设置一个 secretKey，对前两个的结果进行 HMACSHA25 算法，公式如下：\n\n```javascript\nSignature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)\n```\n\n因此，就算前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名也是不一致的。\n\n<a name=\"fc688326\"></a>\n## 9.2 设计实现\n\n通常，Token 的使用分成了两部分：生成 token 和校验 token。\n\n- **生成 token**：登录成功的时候，颁发 token。\n- **验证 token**：访问某些资源或者接口时，验证 token。\n\n<a name=\"b311b79d\"></a>\n### 9.2.1 生成 token\n\n借助第三方库 jsonwebtoken，通过 jsonwebtoken 的 sign 方法生成一个 token。sign 有三个参数：\n\n- 第一个参数指的是 Payload。\n- 第二个是秘钥，服务端特有。\n- 第三个参数是 option，可以定义 token 过期时间。\n\n下面是一个前端生成 token 的例子：\n\n```javascript\nconst crypto = require(\"crypto\"),\n    jwt = require(\"jsonwebtoken\")\n// TODO:使用数据库\n// 这里应该是用数据库存储，这里只是演示用\nlet userList = []\n\nclass UserController {\n    // 用户登录\n    static async login(ctx) {\n        const data = ctx.request.body\n        if (!data.name || !data.password) {\n            return (ctx.body = {\n                code: \"000002\",\n                message: \"参数不合法\"\n            })\n        }\n        const result = userList.find(\n            item => item.name === data.name && item.password === crypto.createHash(\"md5\").update(data.password).digest(\"hex\")\n        )\n        if (result) {\n            // 生成token\n            const token = jwt.sign(\n                {\n                    name: result.name\n                },\n                \"test_token\", // secret\n                { expiresIn: 60 * 60 } // 过期时间：60 * 60 s\n            )\n            return (ctx.body = {\n                code: \"0\",\n                message: \"登录成功\",\n                data: {\n                    token\n                }\n            })\n        } else {\n            return (ctx.body = {\n                code: \"000002\",\n                message: \"用户名或密码错误\"\n            })\n        }\n    }\n}\n\nmodule.exports = UserController\n```\n\n<a name=\"6bcae3ff\"></a>\n### 9.2.2 校验 token\n\n首先，我们需要使用 koa-jwt 中间件进行验证，方式比较简单，在路由跳转前校验即可，如下。\n\n```javascript\napp.use(\n    koajwt({\n        secret: \"test_token\"\n    }).unless({\n        // 配置白名单\n        path: [/\\/api\\/register/, /\\/api\\/login/]\n    })\n)\n```\n\n使用 koa-jwt 中间件进行校验时，需要注意以下几点：\n\n- secret 必须和 sign 时候保持一致。\n- 可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆/注册都可以不用校验。\n- 校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验。\n\n获取用户 token 信息的方法如下：\n\n```javascript\nrouter.get('/api/userInfo',async (ctx,next) => {\n const authorization =  ctx.header.authorization // 获取jwt\n const token = authorization.replace('Beraer ','')\n const result = jwt.verify(token,'test_token')\n ctx.body = result\n}\n```\n\n**注意**：上述的 HMA256 加密算法为单秘钥的形式，一旦泄露后果非常的危险。\n\n在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌。这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择 RS256 等非对称算法。<br />Ï<br />除此之外，JWT 鉴权还需要注意以下几点：\n\n- payload 部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息。\n- 需要保护好加密密钥，一旦泄露后果不堪设想。\n- 为避免 token 被劫持，最好使用 https 协议。\n\n<a name=\"15496b07\"></a>\n# 十、Node 性能监控与优化\n\n<a name=\"d54e2d41\"></a>\n## 10.1 Node 优化点\n\nNode 作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下几点：\n\n- CPU\n- 内存\n- I/O\n- 网络\n\n<a name=\"20eb2623\"></a>\n### 10.1.1 CPU\n\n对于 CPU 的指标，主要关注如下两点：\n\n- **CPU 负载**：在某个时间段内，占用以及等待 CPU 的进程总数。\n- **CPU 使用率**：CPU 时间占用状况，等于 1 - 空闲 CPU 时间(idle time) / CPU 总时间。\n\n这两个指标都是用来评估系统当前 CPU 的繁忙程度的量化指标。Node 应用一般不会消耗很多的 CPU，如果 CPU 占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞。\n\n<a name=\"f7c41a62\"></a>\n### 10.1.2 内存指标\n\n内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于 Node 来说，内部内存堆栈的使用状态也是一个可以量化的指标，可以使用下面的代码来获取内存的相关数据：\n\n```javascript\n// /app/lib/memory.js\nconst os = require(\"os\")\n// 获取当前Node内存堆栈情况\nconst { rss, heapUsed, heapTotal } = process.memoryUsage()\n// 获取系统空闲内存\nconst sysFree = os.freemem()\n// 获取系统总内存\nconst sysTotal = os.totalmem()\n\nmodule.exports = {\n    memory: () => {\n        return {\n            sys: 1 - sysFree / sysTotal, // 系统内存占用率\n            heap: heapUsed / headTotal, // Node堆内存占用率\n            node: rss / sysTotal // Node占用系统内存的比例\n        }\n    }\n}\n```\n\n- rss：表示 node 进程占用的内存总量。\n- heapTotal：表示堆内存的总量。\n- heapUsed：实际堆内存的使用量。\n- external ：外部程序的内存使用量，包含 Node 核心的 C++程序的内存使用量。\n\n在 Node 中，一个进程的最大内存容量为 1.5GB，因此在实际使用时请合理控制内存的使用。\n\n<a name=\"ab218129\"></a>\n### 10.13 磁盘 I/O\n\n硬盘的 IO 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍。内存 IO 比磁盘 IO 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 redis、memcached 等。\n\n并且，并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决。\n\n<a name=\"11a4576d\"></a>\n## 10.2 如何监控\n\n关于性能方面的监控，一般情况都需要借助工具来实现，比如 Easy-Monitor、阿里 Node 性能平台等。<br />这里采用 Easy-Monitor 2.0，其是轻量级的 Node.js 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 require 一次，无需改动任何业务代码即可开启内核级别的性能监控分析。\n\n```javascript\nconst easyMonitor = require(\"easy-monitor\")\neasyMonitor(\"项目名称\")\n```\n\n打开你的浏览器，访问 [http://localhost:12333](https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A12333) ，即可看到进程界面，更详细的内容请参考[官网](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feasy-monitor)\n\n<a name=\"959cf5c2\"></a>\n## 10.3 Node 性能优化\n\n关于 Node 的性能优化的方式有如下几个：\n\n- 使用最新版本 Node.js\n- 正确使用流 Stream\n- 代码层面优化\n- 内存管理优化\n\n<a name=\"04ddb6f6\"></a>\n### 10.3.1 使用最新版本 Node.js\n\n每个版本的性能提升主要来自于两个方面：\n\n- V8 的版本更新\n- Node.js 内部代码的更新优化\n\n<a name=\"8888e1ce\"></a>\n### 10.3.2 正确使用流\n\n在 Node 中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存。\n\n```javascript\nconst http = require(\"http\")\nconst fs = require(\"fs\")\n\n// 错误方式\nhttp.createServer(function (req, res) {\n    fs.readFile(__dirname + \"/data.txt\", function (err, data) {\n        res.end(data)\n    })\n})\n\n// 正确方式\nhttp.createServer(function (req, res) {\n    const stream = fs.createReadStream(__dirname + \"/data.txt\")\n    stream.pipe(res)\n})\n```\n\n<a name=\"7d90ae5d\"></a>\n### 10.3.3 代码层面优化\n\n合并查询，将多次查询合并一次，减少数据库的查询次数。\n\n```javascript\n// 错误方式\nfor user_id in userIds\n     let account = user_account.findOne(user_id)\n\n// 正确方式\nconst user_account_map = {}\n // 注意这个对象将会消耗大量内存。\nuser_account.find(user_id in user_ids).forEach(account){\n    user_account_map[account.user_id] =  account\n}\nfor user_id in userIds\n    var account = user_account_map[user_id]\n```\n\n<a name=\"b7d743b1\"></a>\n### 10.3.4 内存管理优化\n\n在 V8 中，主要将内存分为新生代和老生代两代：\n\n- **新生代**：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。\n- **老生代**：对象存活时间较长。经历过一次或多次垃圾回收的对象。\n\n若新生代内存空间不够，直接分配到老生代。通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低，比如下面的例子。\n\n```javascript\nconst buffer = fs.readFileSync(__dirname + \"/source/index.htm\")\n\napp.use(\n    mount(\"/\", async ctx => {\n        ctx.status = 200\n        ctx.type = \"html\"\n        ctx.body = buffer\n        leak.push(fs.readFileSync(__dirname + \"/source/index.htm\"))\n    })\n)\n\nconst leak = []\n```\n\n当 leak 的内存非常大的时候，就有可能造成内存泄露，应当避免这样的操作。\n\n减少内存使用，可以明显的提高服务性能。而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作。例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新 new 这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动。而使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中，从而避免重读的初始化操作，从而提高框架的性能。\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h1 id=\"14640111\"><span class=\"ne-text\">一、Node 基础概念</span></h1><p id=\"u9d3241dd\" class=\"ne-p\"><br></p><h2 id=\"885b7fb2\"><span class=\"ne-text\">1.1 Node 是什么</span></h2><p id=\"uf174728d\" class=\"ne-p\"><br></p><p id=\"u7ad0a454\" class=\"ne-p\"><span class=\"ne-text\">Node.js 是一个开源与跨平台的 JavaScript 运行时环境。在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能。我们可以理解为：Node.js 就是一个服务器端的、非阻塞式 I/O 的、事件驱动的 JavaScript 运行环境。<br /></span><span class=\"ne-text\">理解 Node，有几个基础的概念：非阻塞异步和事件驱动。</span></p><p id=\"ub2aca590\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u9d0ea74f\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">非阻塞异步：</span></strong><span class=\"ne-text\"> Nodejs 采用了非阻塞型 I/O 机制，在做 I/O 操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作。例如，在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。</span></li><li id=\"u6900b00d\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">事件驱动：</span></strong><span class=\"ne-text\"> 事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。比如，读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理。</span></li></ul><p id=\"udd7ce47d\" class=\"ne-p\"><br></p><p id=\"ue6560a94\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776298-7e87f64c-6d5e-4d9c-8342-b987468c6aae.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ufb8791da&amp;margin=%5Bobject%20Object%5D&amp;originHeight=423&amp;originWidth=734&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u266205b6-6e9a-4e90-a495-40e5ee1d71b&amp;title=\" width=\"734\" id=\"Zt6RL\" class=\"ne-image\"></p><p id=\"u29eef851\" class=\"ne-p\"><br></p><h2 id=\"532bae4f\"><span class=\"ne-text\">1.2 Node 的应用场景及存在的缺点</span></h2><p id=\"u18d74480\" class=\"ne-p\"><br></p><h3 id=\"52c34190\"><span class=\"ne-text\">1.2.1 优缺点</span></h3><p id=\"uc6e6450c\" class=\"ne-p\"><br></p><p id=\"ud793e40f\" class=\"ne-p\"><span class=\"ne-text\">Node.js 适合用于 I/O 密集型应用，值的是应用在运行极限时，CPU 占用率仍然比较低，大部分时间是在做 I/O 硬盘内存读写操作。缺点如下：</span></p><p id=\"u33bb219a\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u3ede0a72\" data-lake-index-type=\"0\"><span class=\"ne-text\">不适合 CPU 密集型应用</span></li><li id=\"u63ae9428\" data-lake-index-type=\"0\"><span class=\"ne-text\">只支持单核 CPU，不能充分利用 CPU</span></li><li id=\"ucafc9e34\" data-lake-index-type=\"0\"><span class=\"ne-text\">可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</span></li></ul><p id=\"ua3bcb5ca\" class=\"ne-p\"><br></p><p id=\"ued22667b\" class=\"ne-p\"><span class=\"ne-text\">对于第三点，常用的解决方案是，使用 Nnigx 反向代理，开多个进程绑定多个端口，或者开多个进程监听同一个端口。</span></p><p id=\"u0e00edef\" class=\"ne-p\"><br></p><h3 id=\"6c69ebca\"><span class=\"ne-text\">1.2.1 应用场景</span></h3><p id=\"u57c5aeff\" class=\"ne-p\"><br></p><p id=\"ue33680f4\" class=\"ne-p\"><span class=\"ne-text\">在熟悉了 Nodejs 的优点和弊端后，我们可以看到它适合以下的应用场景：</span></p><p id=\"u41a84452\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"uc80d0644\" data-lake-index-type=\"0\"><span class=\"ne-text\">善于 I/O，不善于计算。因为 Nodejs 是一个单线程，如果计算（同步）太多，则会阻塞这个线程。</span></li><li id=\"u263b2f01\" data-lake-index-type=\"0\"><span class=\"ne-text\">大量并发的 I/O，应用程序内部并不需要进行非常复杂的处理。</span></li><li id=\"u3b6d91a2\" data-lake-index-type=\"0\"><span class=\"ne-text\">与 WeSocket 配合，开发长连接的实时交互应用程序。</span></li></ul><p id=\"u365d8cdd\" class=\"ne-p\"><br></p><p id=\"u979124e4\" class=\"ne-p\"><span class=\"ne-text\">具体的使用场景如下：</span></p><p id=\"ucf1a2c9b\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u8a90dba1\" data-lake-index-type=\"0\"><span class=\"ne-text\">用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的 web 应用程序。</span></li><li id=\"ub09ed20b\" data-lake-index-type=\"0\"><span class=\"ne-text\">基于 web、canvas 等多人联网游戏。</span></li><li id=\"ua18c7755\" data-lake-index-type=\"0\"><span class=\"ne-text\">基于 web 的多人实时聊天客户端、聊天室、图文直播。</span></li><li id=\"u8cd5bae1\" data-lake-index-type=\"0\"><span class=\"ne-text\">单页面浏览器应用程序。</span></li><li id=\"u3230b4e9\" data-lake-index-type=\"0\"><span class=\"ne-text\">操作数据库、为前端和移动端提供基于 json 的 API。</span></li></ol><p id=\"ub4e8b090\" class=\"ne-p\"><br></p><h1 id=\"706d7949\"><span class=\"ne-text\">二、Node 全部对象</span></h1><p id=\"ud2aa87fa\" class=\"ne-p\"><br></p><p id=\"u60859149\" class=\"ne-p\"><span class=\"ne-text\">在浏览器 JavaScript 中，window 是全局对象， 而 Nodejs 中的全局对象则是 </span><strong><span class=\"ne-text\">global</span></strong><span class=\"ne-text\">。<br /></span><span class=\"ne-text\">在 NodeJS 里，是不可能在最外层定义一个变量，因为所有的用户代码都是当前模块的，只在当前模块里可用，但可以通过 exports 对象的使用将其传递给模块外部。所以，在 NodeJS 中，用 var 声明的变量并不属于全局的变量，只在当前模块生效。像上述的 global 全局对象则在全局作用域中，任何全局变量、函数、对象都是该对象的一个属性值。</span></p><p id=\"ue31af441\" class=\"ne-p\"><br></p><h2 id=\"a6c8674d\"><span class=\"ne-text\">2.1 常见全局对象</span></h2><p id=\"u4e978d2f\" class=\"ne-p\"><br></p><p id=\"u55932616\" class=\"ne-p\"><span class=\"ne-text\">Node 常见的全局对象有如下一些：</span></p><p id=\"uda861901\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u112f1fa7\" data-lake-index-type=\"0\"><span class=\"ne-text\">Class:Buffer</span></li><li id=\"u5b9fb36e\" data-lake-index-type=\"0\"><span class=\"ne-text\">process</span></li><li id=\"u252ff90a\" data-lake-index-type=\"0\"><span class=\"ne-text\">console</span></li><li id=\"u76ed4277\" data-lake-index-type=\"0\"><span class=\"ne-text\">clearInterval、setInterval</span></li><li id=\"u60dacb54\" data-lake-index-type=\"0\"><span class=\"ne-text\">clearTimeout、setTimeout</span></li><li id=\"udbf2db48\" data-lake-index-type=\"0\"><span class=\"ne-text\">global</span></li></ul><p id=\"ua5f5d6fd\" class=\"ne-p\"><br></p><p id=\"u8aac44c6\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">Class:Buffer</span></code><span class=\"ne-text\"> 可以用来处理二进制以及非 </span><code class=\"ne-code\"><span class=\"ne-text\">Unicode</span></code><span class=\"ne-text\"> 编码的数据，在 </span><code class=\"ne-code\"><span class=\"ne-text\">Buffer</span></code><span class=\"ne-text\"> 类实例化中存储了原始数据。</span><code class=\"ne-code\"><span class=\"ne-text\">Buffer</span></code><span class=\"ne-text\"> 类似于一个整数数组，在 </span><code class=\"ne-code\"><span class=\"ne-text\">V8</span></code><span class=\"ne-text\"> 堆原始存储空间给它分配了内存，一旦创建了 </span><code class=\"ne-code\"><span class=\"ne-text\">Buffer</span></code><span class=\"ne-text\"> 实例，则无法改变大小。</span></p><p id=\"u4bde522d\" class=\"ne-p\"><br></p><p id=\"ua72a02de\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">process</span></code><span class=\"ne-text\"> 表示进程对象，提供有关当前过程的信息和控制。包括在执行 </span><code class=\"ne-code\"><span class=\"ne-text\">node</span></code><span class=\"ne-text\"> 程序的过程中，如果需要传递参数，我们想要获取这个参数需要在 </span><code class=\"ne-code\"><span class=\"ne-text\">process</span></code><span class=\"ne-text\"> 内置对象中。比如，我们有如下一个文件：</span></p><p id=\"u5505d1d0\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"fce1321b\" class=\"ne-codeblock language-javascript\"><code>process.argv.forEach((val, index) =&gt; {\n    console.log(`${index}: ${val}`)\n})</code></pre><p id=\"uaeb1cf8c\" class=\"ne-p\"><br></p><p id=\"u2a95db76\" class=\"ne-p\"><span class=\"ne-text\">当我们需要启动一个进程时，可以使用下面的命令：</span></p><p id=\"u637163cd\" class=\"ne-p\"><br></p><pre data-language=\"shell\" id=\"f1f483f1\" class=\"ne-codeblock language-shell\"><code>node index.js</code></pre><p id=\"u576c6d3b\" class=\"ne-p\"><br></p><p id=\"u328e70e1\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">console</span></code><span class=\"ne-text\"> 主要用来打印 </span><code class=\"ne-code\"><span class=\"ne-text\">stdout</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">stderr</span></code><span class=\"ne-text\">，最常用的比如日志输出：</span><code class=\"ne-code\"><span class=\"ne-text\">console.log</span></code><span class=\"ne-text\">。清空控制台的命令为：</span><code class=\"ne-code\"><span class=\"ne-text\">console.clear</span></code><span class=\"ne-text\">。如果需要打印函数的调用栈，可以使用命令 </span><code class=\"ne-code\"><span class=\"ne-text\">console.trace</span></code><span class=\"ne-text\">。</span></p><p id=\"ub6676466\" class=\"ne-p\"><br></p><p id=\"ua35af201\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">setInterval</span></code><span class=\"ne-text\"> 用于设置定时器，语法格式如下：</span></p><p id=\"u197c15cd\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"29f31e79\" class=\"ne-codeblock language-javascript\"><code>setInterval(callback, delay[, ...args])</code></pre><p id=\"u4f364e59\" class=\"ne-p\"><br></p><p id=\"udba108a3\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">clearInterval</span></code><span class=\"ne-text\"> 则用于清除定时器，</span><code class=\"ne-code\"><span class=\"ne-text\">callback</span></code><span class=\"ne-text\"> 每 </span><code class=\"ne-code\"><span class=\"ne-text\">delay</span></code><span class=\"ne-text\"> 毫秒重复执行一次。</span></p><p id=\"u8d6746d9\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">和 </span><code class=\"ne-code\"><span class=\"ne-text\">setInterval</span></code><span class=\"ne-text\"> 一样，</span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\"> 主要用于设置延时器，而 </span><code class=\"ne-code\"><span class=\"ne-text\">clearTimeout</span></code><span class=\"ne-text\"> 则用于清除设置的延时器。</span></p><p id=\"u7c86fe6f\" class=\"ne-p\"><br></p><p id=\"u214b9ce1\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">global</span></code><span class=\"ne-text\"> 是一个全局命名空间对象，前面讲到的 </span><code class=\"ne-code\"><span class=\"ne-text\">process</span></code><span class=\"ne-text\">、</span><code class=\"ne-code\"><span class=\"ne-text\">console</span></code><span class=\"ne-text\">、</span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\"> 等可以放到 </span><code class=\"ne-code\"><span class=\"ne-text\">global</span></code><span class=\"ne-text\"> 中，例如：</span></p><p id=\"u5850fc65\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"8ecc2035\" class=\"ne-codeblock language-javascript\"><code>console.log(process === global.process) //输出 true</code></pre><p id=\"ub9a8f12e\" class=\"ne-p\"><br></p><h2 id=\"a987960b\"><span class=\"ne-text\">2.2 模块中的全局对象</span></h2><p id=\"u0b8a164b\" class=\"ne-p\"><br></p><p id=\"u99f5b4bd\" class=\"ne-p\"><span class=\"ne-text\">除了系统提供的全局对象外，还有一些只是在模块中出现，看起来像全局变量，如下所示：</span></p><p id=\"ud0a327d2\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u02e037f7\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">__dirname</span></code></li><li id=\"ua7542ff8\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">__filename</span></code></li><li id=\"ufa497932\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">exports</span></code></li><li id=\"uc3e46d56\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">module</span></code></li><li id=\"u311778ca\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">require</span></code></li></ul><p id=\"u4bdab3ce\" class=\"ne-p\"><br></p><p id=\"ued8eada2\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">__dirname</span></code><span class=\"ne-text\"> 主要用于获取当前文件所在的路径，不包括后面的文件名。比如，在 </span><code class=\"ne-code\"><span class=\"ne-text\">/Users/mjr</span></code><span class=\"ne-text\"> 中运行 </span><code class=\"ne-code\"><span class=\"ne-text\">node example.js</span></code><span class=\"ne-text\">，打印结果如下：</span></p><p id=\"u734f6d4b\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"38091a85\" class=\"ne-codeblock language-javascript\"><code>console.log(__dirname) // 打印: /Users/mjr</code></pre><p id=\"u8d81068b\" class=\"ne-p\"><br></p><p id=\"u33751a80\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">__filename</span></code><span class=\"ne-text\"> 用于获取当前文件所在的路径和文件名称，包括后面的文件名称。比如，在 </span><code class=\"ne-code\"><span class=\"ne-text\">/Users/mjr</span></code><span class=\"ne-text\"> 中运行 </span><code class=\"ne-code\"><span class=\"ne-text\">node example.js</span></code><span class=\"ne-text\">，打印的结果如下：</span></p><p id=\"ub01a60a3\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"1dcd1f92\" class=\"ne-codeblock language-javascript\"><code>console.log(__filename) // 打印: /Users/mjr/example.js</code></pre><p id=\"u4247212f\" class=\"ne-p\"><br></p><p id=\"u182a1c2f\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">module.exports</span></code><span class=\"ne-text\"> 用于导出一个指定模块所的内容，然后也可以使用 </span><code class=\"ne-code\"><span class=\"ne-text\">require()</span></code><span class=\"ne-text\"> 访问里面的内容。</span></p><p id=\"uf13d112d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3163e268\" class=\"ne-codeblock language-javascript\"><code>exports.name = name\nexports.age = age\nexports.sayHello = sayHello</code></pre><p id=\"u10aff8f2\" class=\"ne-p\"><br></p><p id=\"u35c9f072\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">require</span></code><span class=\"ne-text\"> 主要用于引入模块、</span><code class=\"ne-code\"><span class=\"ne-text\">JSON</span></code><span class=\"ne-text\">、或本地文件， 可以从 </span><code class=\"ne-code\"><span class=\"ne-text\">node_modules</span></code><span class=\"ne-text\"> 引入模块。可以使用相对路径引入本地模块或 </span><code class=\"ne-code\"><span class=\"ne-text\">JSON</span></code><span class=\"ne-text\"> 文件，路径会根据 </span><code class=\"ne-code\"><span class=\"ne-text\">__dirname</span></code><span class=\"ne-text\"> 定义的目录名或当前工作目录进行处理。</span></p><p id=\"u351a5a0b\" class=\"ne-p\"><br></p><h1 id=\"7a19c723\"><span class=\"ne-text\">三、谈谈对 process 的理解</span></h1><p id=\"u4d84c3b0\" class=\"ne-p\"><br></p><h2 id=\"fcea9dd2\"><span class=\"ne-text\">3.1 基本概念</span></h2><p id=\"u9ab3c044\" class=\"ne-p\"><br></p><p id=\"u68e8b091\" class=\"ne-p\"><span class=\"ne-text\">我们知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器。当我们启动一个 js 文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享。<br /></span><span class=\"ne-text\">process 对象是 Node 的一个全局变量，提供了有关当前 Node.js 进程的信息并对其进行控制。 由于 JavaScript 是一个单线程语言，所以通过 node xxx 启动一个文件后，只有一条主线程。</span></p><p id=\"ub9823731\" class=\"ne-p\"><br></p><h2 id=\"46d5f104\"><span class=\"ne-text\">3.2 常用属性和方法</span></h2><p id=\"u05039696\" class=\"ne-p\"><br></p><p id=\"u38bf5062\" class=\"ne-p\"><span class=\"ne-text\">process 的常见属性如下：</span></p><p id=\"u45864067\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u4f7bd424\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息</span></li><li id=\"uf17edf82\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.nextTick：这个在谈及 EventLoop 时经常为会提到</span></li><li id=\"ud57b18a7\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.pid：获取当前进程 id</span></li><li id=\"udf33339a\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.ppid：当前进程对应的父进程</span></li><li id=\"ue4593f7e\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.cwd()：获取当前进程工作目录</span></li><li id=\"u5dbade7a\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.platform：获取当前进程运行的操作系统平台</span></li><li id=\"u071cc581\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</span></li></ul><p id=\"u9d5c57f0\" class=\"ne-p\"><br></p><p id=\"u022d8288\" class=\"ne-p\"><span class=\"ne-text\">进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</span></p><p id=\"u05921653\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u25e9c331\" data-lake-index-type=\"0\"><span class=\"ne-text\">三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</span></li><li id=\"u0a26c586\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.title：用于指定进程名称，有的时候需要给进程指定一个名称</span></li></ul><p id=\"u35d98953\" class=\"ne-p\"><br></p><h1 id=\"d381b7d6\"><span class=\"ne-text\">四、谈谈你对 fs 模块的理解</span></h1><p id=\"u5f7dee6c\" class=\"ne-p\"><br></p><h2 id=\"9ea26fe6\"><span class=\"ne-text\">4.1 fs 是什么</span></h2><p id=\"ue92d397a\" class=\"ne-p\"><br></p><p id=\"u28210b1d\" class=\"ne-p\"><span class=\"ne-text\">fs（filesystem）是文件系统模块，该模块提供本地文件的读写能力，基本上是 POSIX 文件操作命令的简单包装。可以说，所有与文件的操作都是通过 fs 核心模块来实现的。<br /></span><span class=\"ne-text\">使用之前，需要先导入 fs 模块，如下：</span></p><p id=\"ud77b833d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"fc960e73\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)</code></pre><p id=\"ua1ca2482\" class=\"ne-p\"><br></p><h2 id=\"83aa8750\"><span class=\"ne-text\">4.2 文件基础知识</span></h2><p id=\"u93144b7f\" class=\"ne-p\"><br></p><p id=\"u9179c1d2\" class=\"ne-p\"><span class=\"ne-text\">在计算机中，有关于文件的基础知识有如下一些：</span></p><p id=\"uc641b6fd\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u14c6cbfb\" data-lake-index-type=\"0\"><span class=\"ne-text\">权限位 mode</span></li><li id=\"ud47d7640\" data-lake-index-type=\"0\"><span class=\"ne-text\">标识位 flag</span></li><li id=\"uf5ed3c2d\" data-lake-index-type=\"0\"><span class=\"ne-text\">文件描述为 fd</span></li></ul><p id=\"uc3ef17aa\" class=\"ne-p\"><br></p><h3 id=\"8b15b7d7\"><span class=\"ne-text\">4.2.1 权限位 mode</span></h3><p id=\"u84abc37a\" class=\"ne-p\"><br></p><p id=\"u5e54ecd8\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776369-f24a77ac-46e8-4d3b-8060-cb87862d35d5.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9d544723&amp;margin=%5Bobject%20Object%5D&amp;originHeight=208&amp;originWidth=935&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u466a6cd9-2a76-4ae7-864f-0863d99a4a6&amp;title=\" width=\"935\" id=\"cioq6\" class=\"ne-image\"><span class=\"ne-text\"> 针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位 4、2、1，不具备权限为 0。如在 linux 查看文件权限位的命令如下：</span></p><p id=\"ufa720d03\" class=\"ne-p\"><br></p><pre data-language=\"markdown\" id=\"f25f6fb4\" class=\"ne-codeblock language-markdown\"><code>drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core -rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md</code></pre><p id=\"u9ace4341\" class=\"ne-p\"><br></p><p id=\"u7e11099d\" class=\"ne-p\"><span class=\"ne-text\">在开头前十位中，d 为文件夹，-为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限。</span></p><p id=\"u257c9d83\" class=\"ne-p\"><br></p><h3 id=\"d1a14988\"><span class=\"ne-text\">4.2.2 标识位</span></h3><p id=\"uce21a724\" class=\"ne-p\"><br></p><p id=\"uc2fe8d33\" class=\"ne-p\"><span class=\"ne-text\">标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示： </span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776337-d3459565-762c-4ad9-893d-a8182c7fad6b.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua982a818&amp;margin=%5Bobject%20Object%5D&amp;originHeight=846&amp;originWidth=982&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8906bb54-c483-46c9-9748-373ba87bc40&amp;title=\" width=\"982\" id=\"xiyc9\" class=\"ne-image\"></p><p id=\"u72c4d4b6\" class=\"ne-p\"><br></p><h3 id=\"c39a80ba\"><span class=\"ne-text\">4.2.3 文件描述 fd</span></h3><p id=\"ud7d03fe6\" class=\"ne-p\"><br></p><p id=\"u2744058b\" class=\"ne-p\"><span class=\"ne-text\">操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件。</span></p><p id=\"u6fbabc16\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">Window 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。</span></p><p id=\"ue921f6ea\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在 NodeJS 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2 三个比较特殊的描述符，分别代表 process.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出）。</span></p><p id=\"uac3bf9ef\" class=\"ne-p\"><br></p><h2 id=\"dea7c041\"><span class=\"ne-text\">4.3 常用方法</span></h2><p id=\"ud31947db\" class=\"ne-p\"><br></p><p id=\"u3fb437ac\" class=\"ne-p\"><span class=\"ne-text\">由于 fs 模块主要是操作文件的，所以常见的文件操作方法有如下一些：</span></p><p id=\"u2d06bcf1\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u71f623cd\" data-lake-index-type=\"0\"><span class=\"ne-text\">文件读取</span></li><li id=\"u0f2a0e87\" data-lake-index-type=\"0\"><span class=\"ne-text\">文件写入</span></li><li id=\"u86306ae3\" data-lake-index-type=\"0\"><span class=\"ne-text\">文件追加写入</span></li><li id=\"ua56d60da\" data-lake-index-type=\"0\"><span class=\"ne-text\">文件拷贝</span></li><li id=\"u7294f407\" data-lake-index-type=\"0\"><span class=\"ne-text\">创建目录</span></li></ul><p id=\"uf2fd284a\" class=\"ne-p\"><br></p><h3 id=\"f0ae08e8\"><span class=\"ne-text\">4.3.1 文件读取</span></h3><p id=\"uc182b34f\" class=\"ne-p\"><br></p><p id=\"u02fa3fca\" class=\"ne-p\"><span class=\"ne-text\">常用的文件读取有 readFileSync 和 readFile 两个方法。其中，readFileSync 表示同步读取，如下：</span></p><p id=\"ucc4c3fad\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"b56d8f1c\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)\nlet buf = fs.readFileSync(&quot;1.txt&quot;)\nlet data = fs.readFileSync(&quot;1.txt&quot;, &quot;utf8&quot;)\nconsole.log(buf) // &lt;Buffer 48 65 6c 6c 6f&gt;\nconsole.log(data) // Hello</code></pre><p id=\"ue8976a18\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u08a2deb0\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个参数为读取文件的路径或文件描述符。</span></li><li id=\"u7db3db71\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding。</span></li></ul><p id=\"u0785fc77\" class=\"ne-p\"><br></p><p id=\"u8ede1d05\" class=\"ne-p\"><span class=\"ne-text\">readFile 为异步读取方法， readFile 与 readFileSync 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 err（错误）和 data（数据），该方法没有返回值，回调函数在读取文件成功后执行。</span></p><p id=\"u4f936a2e\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"e0379f45\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)\nfs.readFile(&quot;1.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; {\n    if (!err) {\n        console.log(data)\n        // Hello\n    }\n})</code></pre><p id=\"u8ecc006a\" class=\"ne-p\"><br></p><h3 id=\"78888f32\"><span class=\"ne-text\">4.3.2 文件写入</span></h3><p id=\"u2b9b128d\" class=\"ne-p\"><br></p><p id=\"ue404e8bb\" class=\"ne-p\"><span class=\"ne-text\">文件写入需要用到 writeFileSync 和 writeFile 两个方法。writeFileSync 表示同步写入，如下所示。</span></p><p id=\"ue67094e8\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"389de4e2\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)\nfs.writeFileSync(&quot;2.txt&quot;, &quot;Hello world&quot;)\nlet data = fs.readFileSync(&quot;2.txt&quot;, &quot;utf8&quot;)\nconsole.log(data) // Hello world</code></pre><p id=\"uc62ec377\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u5e8dcee9\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个参数为写入文件的路径或文件描述符。</span></li><li id=\"u2a8f6fbb\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个参数为写入的数据，类型为 String 或 Buffer。</span></li><li id=\"u946e8eff\" data-lake-index-type=\"0\"><span class=\"ne-text\">第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding。</span></li></ul><p id=\"uc7da433d\" class=\"ne-p\"><br></p><p id=\"u0dfac5fd\" class=\"ne-p\"><span class=\"ne-text\">writeFile 表示异步写入，writeFile 与 writeFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件写入数据成功后执行。</span></p><p id=\"u7df698e1\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"fa2ec1ae\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)\nfs.writeFile(&quot;2.txt&quot;, &quot;Hello world&quot;, err =&gt; {\n    if (!err) {\n        fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; {\n            console.log(data) // Hello world\n        })\n    }\n})</code></pre><p id=\"u17ebc7d3\" class=\"ne-p\"><br></p><h3 id=\"5b6754f5\"><span class=\"ne-text\">4.3.3 文件追加写入</span></h3><p id=\"u50fe4bfe\" class=\"ne-p\"><br></p><p id=\"ue8900591\" class=\"ne-p\"><span class=\"ne-text\">文件追加写入需要用到 appendFileSync 和 appendFile 两个方法。appendFileSync 表示同步写入，如下。</span></p><p id=\"ub8188dd7\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"b539a81c\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)\nfs.appendFileSync(&quot;3.txt&quot;, &quot; world&quot;)\nlet data = fs.readFileSync(&quot;3.txt&quot;, &quot;utf8&quot;)</code></pre><p id=\"u9f61f95c\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u1613e319\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个参数为写入文件的路径或文件描述符。</span></li><li id=\"u47e32315\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个参数为写入的数据，类型为 String 或 Buffer。</span></li><li id=\"uc77d87e5\" data-lake-index-type=\"0\"><span class=\"ne-text\">第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding。</span></li></ul><p id=\"u88e776c2\" class=\"ne-p\"><br></p><p id=\"uc3c60ba0\" class=\"ne-p\"><span class=\"ne-text\">appendFile 表示异步追加写入，方法 appendFile 与 appendFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件追加写入数据成功后执行，如下所示。</span></p><p id=\"u5daf20d0\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"dd90beea\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)\nfs.appendFile(&quot;3.txt&quot;, &quot; world&quot;, err =&gt; {\n    if (!err) {\n        fs.readFile(&quot;3.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; {\n            console.log(data) // Hello world\n        })\n    }\n})</code></pre><p id=\"ua904b351\" class=\"ne-p\"><br></p><h3 id=\"b936db03\"><span class=\"ne-text\">4.3.4 创建目录</span></h3><p id=\"uae5e94e3\" class=\"ne-p\"><br></p><p id=\"u05efe491\" class=\"ne-p\"><span class=\"ne-text\">创建目录主要有 mkdirSync 和 mkdir 两个方法。其中，mkdirSync 为同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常。</span></p><p id=\"uba872c08\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"39b76651\" class=\"ne-codeblock language-javascript\"><code>// 假设已经有了 a 文件夹和 a 下的 b 文件夹\nfs.mkdirSync(&quot;a/b/c&quot;)</code></pre><p id=\"u9f17a9e0\" class=\"ne-p\"><br></p><p id=\"u8caed4fd\" class=\"ne-p\"><span class=\"ne-text\">mkdir 为异步创建，第二个参数为回调函数，如下所示。</span></p><p id=\"u2ab7556f\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"dc45f69e\" class=\"ne-codeblock language-javascript\"><code>fs.mkdir(&quot;a/b/c&quot;, err =&gt; {\n    if (!err) console.log(&quot;创建成功&quot;)\n})</code></pre><p id=\"u056123dc\" class=\"ne-p\"><br></p><h1 id=\"3d21eed3\"><span class=\"ne-text\">五、谈谈你对 Stream 的理解</span></h1><p id=\"ub85b833b\" class=\"ne-p\"><br></p><h2 id=\"d4b7a6c3\"><span class=\"ne-text\">5.1 基本概念</span></h2><p id=\"u0c7baaaa\" class=\"ne-p\"><br></p><p id=\"u8f9fb53c\" class=\"ne-p\"><span class=\"ne-text\">流（Stream）是一种数据传输的手段，是一种端到端信息交换的方式，而且是有顺序的，是逐块读取数据、处理内容，用于顺序读取输入或写入输出。在 Node 中，Stream 分成三部分：source、dest、pipe。</span></p><p id=\"u86a8f7a8\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">其中，在 source 和 dest 之间有一个连接的管道 pipe，它的基本语法是 source.pipe(dest)，source 和 dest 就是通过 pipe 连接，让数据从 source 流向 dest，如下图所示：</span></p><p id=\"u49eefe9e\" class=\"ne-p\"><span class=\"ne-text\"> </span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776316-ec2753d3-05e5-475e-987b-b79ac8d11923.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0f84404c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=311&amp;originWidth=352&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1b177b68-1c96-4214-87fa-097ee0ec21f&amp;title=\" width=\"352\" id=\"e7iAA\" class=\"ne-image\"></p><p id=\"u78a6d595\" class=\"ne-p\"><br></p><h2 id=\"d52b149f\"><span class=\"ne-text\">5.2 流的分类</span></h2><p id=\"uecd686f8\" class=\"ne-p\"><br></p><p id=\"uaa3b2116\" class=\"ne-p\"><span class=\"ne-text\">在 Node，流可以分成四个种类：</span></p><p id=\"u4d292dc7\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ud98cea51\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">可写流</span></strong><span class=\"ne-text\">：可写入数据的流，例如 fs.createWriteStream() 可以使用流将数据写入文件。</span></li><li id=\"u878829c1\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">可读流</span></strong><span class=\"ne-text\">： 可读取数据的流，例如 fs.createReadStream() 可以从文件读取内容。</span></li><li id=\"ua660b003\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">双工流</span></strong><span class=\"ne-text\">： 既可读又可写的流，例如 net.Socket。</span></li><li id=\"u95aa2584\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">转换流</span></strong><span class=\"ne-text\">： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据。</span></li></ul><p id=\"u01862e3e\" class=\"ne-p\"><br></p><p id=\"u720d84d2\" class=\"ne-p\"><span class=\"ne-text\">在 Node 的 HTTP 服务器模块中，request 是可读流，response 是可写流。对于 fs 模块来说，能同时处理可读和可写文件流可读流和可写流都是单向的，比较容易理解。而 Socket 是双向的，可读可写。</span></p><p id=\"u83469b7a\" class=\"ne-p\"><br></p><h3 id=\"9c010904\"><span class=\"ne-text\">5.2.1 双工流</span></h3><p id=\"u12b4624b\" class=\"ne-p\"><br></p><p id=\"ua8e6477e\" class=\"ne-p\"><span class=\"ne-text\">在 Node 中，比较的常见的全双工通信就是 websocket，因为发送方和接受方都是各自独立的方法，发送和接收都没有任何关系。 </span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776316-96152afb-5799-49e4-ac4a-c792f1da517c.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uf71601d0&amp;margin=%5Bobject%20Object%5D&amp;originHeight=191&amp;originWidth=500&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc8cbaf81-b3a4-4be0-9bb8-87d66a6e85c&amp;title=\" width=\"500\" id=\"DyHvq\" class=\"ne-image\"><span class=\"ne-text\"> 基本的使用方法如下：</span></p><p id=\"uefafeb9d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"16e17564\" class=\"ne-codeblock language-javascript\"><code>const { Duplex } = require(&quot;stream&quot;)\n\nconst myDuplex = new Duplex({\n    read(size) {\n        // ...\n    },\n    write(chunk, encoding, callback) {\n        // ...\n    }\n})</code></pre><p id=\"ua61c7713\" class=\"ne-p\"><br></p><h2 id=\"513831a5\"><span class=\"ne-text\">5.3 使用场景</span></h2><p id=\"u272088f8\" class=\"ne-p\"><br></p><p id=\"u3e074365\" class=\"ne-p\"><span class=\"ne-text\">流的常见使用场景有：</span></p><p id=\"u765e2372\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u80a304e6\" data-lake-index-type=\"0\"><span class=\"ne-text\">get 请求返回文件给客户端</span></li><li id=\"u85075518\" data-lake-index-type=\"0\"><span class=\"ne-text\">文件操作</span></li><li id=\"u5c1247e8\" data-lake-index-type=\"0\"><span class=\"ne-text\">一些打包工具的底层操作</span></li></ul><p id=\"u430e2555\" class=\"ne-p\"><br></p><h3 id=\"fe9be06e\"><span class=\"ne-text\">5.3.1 网络请求</span></h3><p id=\"u23ef2900\" class=\"ne-p\"><br></p><p id=\"ud3a89473\" class=\"ne-p\"><span class=\"ne-text\">流一个常见的使用场景就是网络请求，比如使用 stream 流返回文件，res 也是一个 stream 对象，通过 pipe 管道将文件数据返回。</span></p><p id=\"ud1588f48\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"5365cf98\" class=\"ne-codeblock language-javascript\"><code>const server = http.createServer(function (req, res) {\n    const method = req.method\n    // get 请求\n    if (method === &quot;GET&quot;) {\n        const fileName = path.resolve(__dirname, &quot;data.txt&quot;)\n        let stream = fs.createReadStream(fileName)\n        stream.pipe(res)\n    }\n})\nserver.listen(8080)</code></pre><p id=\"u0a8afbfa\" class=\"ne-p\"><br></p><h3 id=\"e4795cb4\"><span class=\"ne-text\">5.3.2 文件操作</span></h3><p id=\"u76d86c2e\" class=\"ne-p\"><br></p><p id=\"ub3f45a95\" class=\"ne-p\"><span class=\"ne-text\">文件的读取也是流操作，创建一个可读数据流 readStream，一个可写数据流 writeStream，通过 pipe 管道把数据流转过去。</span></p><p id=\"u9ac859ba\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3c9cc257\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)\nconst path = require(&quot;path&quot;)\n\n// 两个文件名\nconst fileName1 = path.resolve(__dirname, &quot;data.txt&quot;)\nconst fileName2 = path.resolve(__dirname, &quot;data-bak.txt&quot;)\n// 读取文件的 stream 对象\nconst readStream = fs.createReadStream(fileName1)\n// 写入文件的 stream 对象\nconst writeStream = fs.createWriteStream(fileName2)\n// 通过 pipe执行拷贝，数据流转\nreadStream.pipe(writeStream)\n// 数据读取完成监听，即拷贝完成\nreadStream.on(&quot;end&quot;, function () {\n    console.log(&quot;拷贝完成&quot;)\n})</code></pre><p id=\"u510a54ba\" class=\"ne-p\"><br></p><p id=\"u05457edf\" class=\"ne-p\"><span class=\"ne-text\">另外，一些打包工具，Webpack 和 Vite 等都涉及很多流的操作。</span></p><p id=\"udd643c2c\" class=\"ne-p\"><br></p><h1 id=\"7dea4013\"><span class=\"ne-text\">六、事件循环机制</span></h1><p id=\"u4a8e6a08\" class=\"ne-p\"><br></p><h2 id=\"31308610\"><span class=\"ne-text\">6.1 什么是浏览器事件循环</span></h2><p id=\"uf702f07f\" class=\"ne-p\"><br></p><p id=\"u941a8dec\" class=\"ne-p\"><span class=\"ne-text\">Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</span></p><p id=\"ub9e94e4c\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)，其运行原理如下图所示。<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776762-39a74481-73e0-45f4-b0a7-c509ef0b3358.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u0c77ed56&amp;margin=%5Bobject%20Object%5D&amp;originHeight=316&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucae1209f-930b-4741-820d-2ffe75c4935&amp;title=\" width=\"800\" id=\"cKJ7V\" class=\"ne-image\"><span class=\"ne-text\"> 从左到右，从上到下，Node.js 被分为了四层，分别是 应用层、V8 引擎层、Node API 层 和 LIBUV 层。</span></p><p id=\"u14c998eb\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u67b2837a\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">应用层</span></strong><span class=\"ne-text\">： 即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 http，fs</span></li><li id=\"u644f869e\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">V8 引擎层</span></strong><span class=\"ne-text\">： 即利用 V8 引擎来解析 JavaScript 语法，进而和下层 API 交互</span></li><li id=\"u2a9031ed\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">Node API 层</span></strong><span class=\"ne-text\">： 为上层模块提供系统调用，一般是由 C 语言来实现，和操作系统进行交互 。</span></li><li id=\"u3997af0d\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">LIBUV 层</span></strong><span class=\"ne-text\">： 是跨平台的底层封装，实现了 事件循环、文件操作等，是 Node.js 实现异步的核心 。</span></li></ul><p id=\"uf39bf341\" class=\"ne-p\"><br></p><p id=\"ucba1aa91\" class=\"ne-p\"><span class=\"ne-text\">在 Node 中，我们所说的事件循环是基于 libuv 实现的，libuv 是一个多平台的专注于异步 IO 的库。上图的 EVENT_QUEUE 给人看起来只有一个队列，但事实上 EventLoop 存在 6 个阶段，每个阶段都有对应的一个先进先出的回调队列。</span></p><p id=\"u76812caa\" class=\"ne-p\"><br></p><h2 id=\"fd2efd28\"><span class=\"ne-text\">6.2 事件循环的六个阶段</span></h2><p id=\"uf5590380\" class=\"ne-p\"><br></p><p id=\"u4a58bc3f\" class=\"ne-p\"><span class=\"ne-text\">事件循环一共可以分成了六个阶段，如下图所示。 </span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776842-ddc16b06-3ced-4c9d-af77-41a1bef3eed7.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc1b560a1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=414&amp;originWidth=670&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0abf45b3-21f7-4925-9910-0ccee24f01f&amp;title=\" width=\"670\" id=\"k48OI\" class=\"ne-image\"></p><p id=\"ubf13a481\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"uaa144ec1\" data-lake-index-type=\"0\"><span class=\"ne-text\">timers 阶段：此阶段主要执行 timer（setTimeout、setInterval）的回调。</span></li><li id=\"u2fd2a3cd\" data-lake-index-type=\"0\"><span class=\"ne-text\">I/O 事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些 I/O 回调。</span></li><li id=\"u8714a9f7\" data-lake-index-type=\"0\"><span class=\"ne-text\">闲置阶段(idle、prepare)：仅系统内部使用。</span></li><li id=\"ube39f2fb\" data-lake-index-type=\"0\"><span class=\"ne-text\">轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</span></li><li id=\"u70b4d556\" data-lake-index-type=\"0\"><span class=\"ne-text\">检查阶段(check)：setImmediate() 回调函数在这里执行</span></li><li id=\"u80854589\" data-lake-index-type=\"0\"><span class=\"ne-text\">关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)</span></li></ul><p id=\"u6c219dd5\" class=\"ne-p\"><br></p><p id=\"u9f4eb7bd\" class=\"ne-p\"><span class=\"ne-text\">每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段，如下图所示。 </span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776814-ea6ed8b4-5eb8-44f7-ba02-ffc37686b00f.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ub6591ff1&amp;margin=%5Bobject%20Object%5D&amp;originHeight=613&amp;originWidth=703&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5750c350-d871-4e63-861a-a422c186d3a&amp;title=\" width=\"703\" id=\"gmy0w\" class=\"ne-image\"></p><p id=\"uee1d5529\" class=\"ne-p\"><br></p><h1 id=\"50dfc512\"><span class=\"ne-text\">七、EventEmitter</span></h1><p id=\"udd35618f\" class=\"ne-p\"><br></p><h2 id=\"9729e412\"><span class=\"ne-text\">7.1 基本概念</span></h2><p id=\"u7f67d359\" class=\"ne-p\"><br></p><p id=\"uaa19f13a\" class=\"ne-p\"><span class=\"ne-text\">前文说过，Node 采用了事件驱动机制，而 EventEmitter 就是 Node 实现事件驱动的基础。在 EventEmitter 的基础上，Node 几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定、触发监听器，实现了异步操作。</span></p><p id=\"ucf208608\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">Node.js 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件，这些产生事件的对象都是 events.EventEmitter 的实例，用于将一个或多个函数绑定到命名事件上。</span></p><p id=\"ua8250389\" class=\"ne-p\"><br></p><h2 id=\"80390061\"><span class=\"ne-text\">7.2 基本使用</span></h2><p id=\"u869dc699\" class=\"ne-p\"><br></p><p id=\"u4163e078\" class=\"ne-p\"><span class=\"ne-text\">Node 的 events 模块只提供了一个 EventEmitter 类，这个类实现了 Node 异步事件驱动架构的基本模式：观察者模式。</span></p><p id=\"u429935dc\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新会依次通知观察者，使用方式如下。</span></p><p id=\"uc0a3dfc3\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"fdbfe087\" class=\"ne-codeblock language-javascript\"><code>const EventEmitter = require(&quot;events&quot;)\n\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter()\n\nfunction callback() {\n    console.log(&quot;触发了event事件！&quot;)\n}\nmyEmitter.on(&quot;event&quot;, callback)\nmyEmitter.emit(&quot;event&quot;)\nmyEmitter.removeListener(&quot;event&quot;, callback)</code></pre><p id=\"u4cdafbc6\" class=\"ne-p\"><br></p><p id=\"u26d7727c\" class=\"ne-p\"><span class=\"ne-text\">在上面的代码中，我们通过实例对象的 on 方法注册一个名为 event 的事件，通过 emit 方法触发该事件，而 removeListener 用于取消事件的监听。<br /></span><span class=\"ne-text\">除了上面介绍的一些方法外，其他常用的方法还有如下一些：</span></p><p id=\"u06b2e808\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ubd6135e7\" data-lake-index-type=\"0\"><span class=\"ne-text\">emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部。</span></li><li id=\"uc889b39d\" data-lake-index-type=\"0\"><span class=\"ne-text\">emitter.prependListener(eventName, listener)</span><span class=\"ne-text\">：添加类型为 eventName 的监听事件到事件数组头部。</span></li><li id=\"ud938db95\" data-lake-index-type=\"0\"><span class=\"ne-text\">emitter.emit(eventName[, ...args])</span><span class=\"ne-text\">：触发类型为 eventName 的监听事件。</span></li><li id=\"u56f407e9\" data-lake-index-type=\"0\"><span class=\"ne-text\">emitter.removeListener/off(eventName, listener)</span><span class=\"ne-text\">：移除类型为 eventName 的监听事件。</span></li><li id=\"u9fa75ca3\" data-lake-index-type=\"0\"><span class=\"ne-text\">emitter.once(eventName, listener)</span><span class=\"ne-text\">：添加类型为 eventName 的监听事件，以后只能执行一次并删除。</span></li><li id=\"u6e047d53\" data-lake-index-type=\"0\"><span class=\"ne-text\">emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件。</span></li></ul><p id=\"u8af3d3cc\" class=\"ne-p\"><br></p><h2 id=\"a25f2215\"><span class=\"ne-text\">7.3 实现原理</span></h2><p id=\"u7893785f\" class=\"ne-p\"><br></p><p id=\"ub03d1e66\" class=\"ne-p\"><span class=\"ne-text\">EventEmitter 其实是一个构造函数，内部存在一个包含所有事件的对象。</span></p><p id=\"u12dac5cf\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"5b5ba724\" class=\"ne-codeblock language-javascript\"><code>class EventEmitter {\n    constructor() {\n        this.events = {}\n    }\n}</code></pre><p id=\"uc992c1a9\" class=\"ne-p\"><br></p><p id=\"u207f2713\" class=\"ne-p\"><span class=\"ne-text\">其中，events 存放的监听事件的函数的结构如下：</span></p><p id=\"ucba412f5\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"984aa5f0\" class=\"ne-codeblock language-javascript\"><code>{\n  &quot;event1&quot;: [f1,f2,f3]，\n  &quot;event2&quot;: [f4,f5]，\n  ...\n}</code></pre><p id=\"u9b59b320\" class=\"ne-p\"><br></p><p id=\"u4401338c\" class=\"ne-p\"><span class=\"ne-text\">然后，开始一步步实现实例方法，首先是 emit，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</span></p><p id=\"ue535ee73\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"34d6f80c\" class=\"ne-codeblock language-javascript\"><code>emit(type, ...args) {\n    this.events[type].forEach((item) =&gt; {\n        Reflect.apply(item, this, args);\n    });\n}</code></pre><p id=\"u740ef1a5\" class=\"ne-p\"><br></p><p id=\"u70e45741\" class=\"ne-p\"><span class=\"ne-text\">实现了 emit 方法之后，然后依次实现 on、addListener、prependListener 这三个实例方法，它们都是添加事件监听触发函数的。</span></p><p id=\"u1ca01caa\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0a88d6df\" class=\"ne-codeblock language-javascript\"><code>on(type, handler) {\n    if (!this.events[type]) {\n        this.events[type] = []\n    }\n    this.events[type].push(handler);\n}\n\naddListener(type,handler){\n    this.on(type,handler)\n}\n\nprependListener(type, handler) {\n    if (!this.events[type]) {\n        this.events[type] = []\n    }\n    this.events[type].unshift(handler)\n}</code></pre><p id=\"u067e6b17\" class=\"ne-p\"><br></p><p id=\"ueb653963\" class=\"ne-p\"><span class=\"ne-text\">实现 once 方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过 fired 属性值判断事件函数是否执行过。</span></p><p id=\"uecd9a49e\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3be3c752\" class=\"ne-codeblock language-javascript\"><code>removeListener(type, handler) {\n    if (!this.events[type]) {\n        return\n    }\n    this.events[type] = this.events[type].filter(item =&gt; item !== handler)\n}\n\noff(type,handler){\n    this.removeListener(type,handler)\n}</code></pre><p id=\"u6a848d68\" class=\"ne-p\"><br></p><p id=\"u2b361610\" class=\"ne-p\"><span class=\"ne-text\">下面是完成的测试代码：</span></p><p id=\"ubefe39ae\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"68459fc6\" class=\"ne-codeblock language-javascript\"><code>class EventEmitter {\n    constructor() {\n        this.events = {}\n    }\n\n    on(type, handler) {\n        if (!this.events[type]) {\n            this.events[type] = []\n        }\n        this.events[type].push(handler)\n    }\n\n    addListener(type, handler) {\n        this.on(type, handler)\n    }\n\n    prependListener(type, handler) {\n        if (!this.events[type]) {\n            this.events[type] = []\n        }\n        this.events[type].unshift(handler)\n    }\n\n    removeListener(type, handler) {\n        if (!this.events[type]) {\n            return\n        }\n        this.events[type] = this.events[type].filter(item =&gt; item !== handler)\n    }\n\n    off(type, handler) {\n        this.removeListener(type, handler)\n    }\n\n    emit(type, ...args) {\n        this.events[type].forEach(item =&gt; {\n            Reflect.apply(item, this, args)\n        })\n    }\n\n    once(type, handler) {\n        this.on(type, this._onceWrap(type, handler, this))\n    }\n\n    _onceWrap(type, handler, target) {\n        const state = { fired: false, handler, type, target }\n        const wrapFn = this._onceWrapper.bind(state)\n        state.wrapFn = wrapFn\n        return wrapFn\n    }\n\n    _onceWrapper(...args) {\n        if (!this.fired) {\n            this.fired = true\n            Reflect.apply(this.handler, this.target, args)\n            this.target.off(this.type, this.wrapFn)\n        }\n    }\n}</code></pre><p id=\"u37b279ae\" class=\"ne-p\"><br></p><h1 id=\"097f5f61\"><span class=\"ne-text\">八、中间件</span></h1><p id=\"u9c1b83b6\" class=\"ne-p\"><br></p><h2 id=\"54ec71ce\"><span class=\"ne-text\">8.1 基本概念</span></h2><p id=\"u0c7c8630\" class=\"ne-p\"><br></p><p id=\"u45a79b57\" class=\"ne-p\"><span class=\"ne-text\">中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。 在 Node 中，中间件主要是指封装 http 请求细节处理的方法。例如，在 express、koa 等 web 框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数，架构示意图如下。<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776860-f2586f50-2de4-4f9b-b56e-7082c70b5070.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u4c39c39c&amp;margin=%5Bobject%20Object%5D&amp;originHeight=412&amp;originWidth=913&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u724dc371-8c3c-4fa1-83fe-2736bef4a90&amp;title=\" width=\"913\" id=\"N5GxZ\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">通常，在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作。</span></p><p id=\"u5cb74889\" class=\"ne-p\"><br></p><h2 id=\"7c87a55a\"><span class=\"ne-text\">8.2 koa</span></h2><p id=\"ufe2f3ef5\" class=\"ne-p\"><br></p><p id=\"u2158aa2f\" class=\"ne-p\"><span class=\"ne-text\">Koa 是基于 Node 当前比较流行的 web 框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助开发者快速而愉快地编写服务端应用程序。 </span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828776892-bff5e920-ac91-481f-9f57-4acf8664a57a.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc6948f4d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=620&amp;originWidth=699&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u20597ab3-78c2-4ca2-b232-c8b5c3caba6&amp;title=\" width=\"699\" id=\"AZXtr\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">Koa 中间件采用的是洋葱圈模型，每次执行下一个中间件都传入两个参数：</span></p><p id=\"ud8762759\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u747c5e45\" data-lake-index-type=\"0\"><span class=\"ne-text\">ctx ：封装了 request 和 response 的变量</span></li><li id=\"u25f71760\" data-lake-index-type=\"0\"><span class=\"ne-text\">next ：进入下一个要执行的中间件的函数</span></li></ul><p id=\"ub3e1b64e\" class=\"ne-p\"><br></p><p id=\"u77318e3f\" class=\"ne-p\"><span class=\"ne-text\">通过前面的介绍，我们知道了 Koa 中间件本质上就是一个函数，可以是 async 函数，也可以是普通函数。下面就针对 koa 进行中间件的封装：</span></p><p id=\"u65d13cf4\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"08f263d6\" class=\"ne-codeblock language-javascript\"><code>// async 函数\napp.use(async (ctx, next) =&gt; {\n    const start = Date.now()\n    await next()\n    const ms = Date.now() - start\n    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`)\n})\n\n// 普通函数\napp.use((ctx, next) =&gt; {\n    const start = Date.now()\n    return next().then(() =&gt; {\n        const ms = Date.now() - start\n        console.log(`${ctx.method} ${ctx.url} - ${ms}ms`)\n    })\n})</code></pre><p id=\"u6322cd89\" class=\"ne-p\"><br></p><p id=\"u6d14e79e\" class=\"ne-p\"><span class=\"ne-text\">当然，我们还可以通过中间件封装 http 请求过程中几个常用的功能：</span></p><p id=\"u0d9293cf\" class=\"ne-p\"><br></p><p id=\"ud27106d0\" class=\"ne-p\"><strong><span class=\"ne-text\">token 校验</span></strong></p><p id=\"u489c14a6\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"543e5fd3\" class=\"ne-codeblock language-javascript\"><code>module.exports = (options) =&gt; async (ctx, next) {\n  try {\n    // 获取 token\n    const token = ctx.header.authorization\n    if (token) {\n      try {\n          // verify 函数验证 token，并获取用户相关信息\n          await verify(token)\n      } catch (err) {\n        console.log(err)\n      }\n    }\n    // 进入下一个中间件\n    await next()\n  } catch (err) {\n    console.log(err)\n  }\n}</code></pre><p id=\"uf03be165\" class=\"ne-p\"><br></p><p id=\"ub677f475\" class=\"ne-p\"><strong><span class=\"ne-text\">日志模块</span></strong></p><p id=\"u0904a739\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ec4d92c5\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)\nmodule.exports = options =&gt; async (ctx, next) =&gt; {\n    const startTime = Date.now()\n    const requestTime = new Date()\n    await next()\n    const ms = Date.now() - startTime\n    let logout = `${ctx.request.ip} -- ${requestTime} -- ${ctx.method} -- ${ctx.url} -- ${ms}ms`\n    // 输出日志文件\n    fs.appendFileSync(&quot;./log.txt&quot;, logout + &quot;\\n&quot;)\n}</code></pre><p id=\"ud7262d99\" class=\"ne-p\"><br></p><p id=\"u41e8e461\" class=\"ne-p\"><span class=\"ne-text\">Koa 存在很多第三方的中间件，如 koa-bodyparser、koa-static 等。</span></p><p id=\"u5a8e13a7\" class=\"ne-p\"><br></p><h2 id=\"9edbeff9\"><span class=\"ne-text\">8.3 Koa 中间件</span></h2><p id=\"u4653f80e\" class=\"ne-p\"><br></p><p id=\"ua725a010\" class=\"ne-p\"><strong><span class=\"ne-text\">koa-bodyparser</span></strong><span class=\"ne-text\"> koa-bodyparser 中间件是将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body 上，方便我们在其他中间件或接口处取值。</span></p><p id=\"u17d7e680\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"481698ce\" class=\"ne-codeblock language-javascript\"><code>// 文件：my-koa-bodyparser.js\nconst querystring = require(&quot;querystring&quot;)\n\nmodule.exports = function bodyParser() {\n    return async (ctx, next) =&gt; {\n        await new Promise((resolve, reject) =&gt; {\n            // 存储数据的数组\n            let dataArr = []\n\n            // 接收数据\n            ctx.req.on(&quot;data&quot;, data =&gt; dataArr.push(data))\n\n            // 整合数据并使用 Promise 成功\n            ctx.req.on(&quot;end&quot;, () =&gt; {\n                // 获取请求数据的类型 json 或表单\n                let contentType = ctx.get(&quot;Content-Type&quot;)\n\n                // 获取数据 Buffer 格式\n                let data = Buffer.concat(dataArr).toString()\n\n                if (contentType === &quot;application/x-www-form-urlencoded&quot;) {\n                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body\n                    ctx.request.body = querystring.parse(data)\n                } else if (contentType === &quot;applaction/json&quot;) {\n                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body\n                    ctx.request.body = JSON.parse(data)\n                }\n\n                // 执行成功的回调\n                resolve()\n            })\n        })\n\n        // 继续向下执行\n        await next()\n    }\n}</code></pre><p id=\"u45be4a62\" class=\"ne-p\"><br></p><p id=\"u723a589a\" class=\"ne-p\"><strong><span class=\"ne-text\">koa-static</span></strong><span class=\"ne-text\"> koa-static 中间件的作用是在服务器接到请求时，帮我们处理静态文件，比如。</span></p><p id=\"u440305fc\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"bdf862b0\" class=\"ne-codeblock language-javascript\"><code>const fs = require(&quot;fs&quot;)\nconst path = require(&quot;path&quot;)\nconst mime = require(&quot;mime&quot;)\nconst { promisify } = require(&quot;util&quot;)\n\n// 将 stat 和 access 转换成 Promise\nconst stat = promisify(fs.stat)\nconst access = promisify(fs.access)\n\nmodule.exports = function (dir) {\n    return async (ctx, next) =&gt; {\n        // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /\n        let realPath = path.join(dir, ctx.path)\n\n        try {\n            // 获取 stat 对象\n            let statObj = await stat(realPath)\n\n            // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html\n            if (statObj.isFile()) {\n                ctx.set(&quot;Content-Type&quot;, `${mime.getType()};charset=utf8`)\n                ctx.body = fs.createReadStream(realPath)\n            } else {\n                let filename = path.join(realPath, &quot;index.html&quot;)\n\n                // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理\n                await access(filename)\n\n                // 存在设置文件类型并响应内容\n                ctx.set(&quot;Content-Type&quot;, &quot;text/html;charset=utf8&quot;)\n                ctx.body = fs.createReadStream(filename)\n            }\n        } catch (e) {\n            await next()\n        }\n    }\n}</code></pre><p id=\"uda667179\" class=\"ne-p\"><br></p><p id=\"u4b6b0d79\" class=\"ne-p\"><span class=\"ne-text\">总的来说，在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据。</span></p><p id=\"u39754fce\" class=\"ne-p\"><br></p><h1 id=\"480ee596\"><span class=\"ne-text\">九、如何设计并实现 JWT 鉴权</span></h1><p id=\"ube8d085c\" class=\"ne-p\"><br></p><h2 id=\"7d9bbac5\"><span class=\"ne-text\">9.1 JWT 是什么</span></h2><p id=\"u672962b6\" class=\"ne-p\"><br></p><p id=\"u2c40d786\" class=\"ne-p\"><span class=\"ne-text\">JWT（JSON Web Token），本质就是一个字符串书写规范，作用是用来在用户和服务器之间传递安全可靠的，如下图。</span></p><p id=\"ud33500c2\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u9bdc02a4\" class=\"ne-p\"><span class=\"ne-text\"> </span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828777364-f26cadff-b496-4390-888c-f915db496f3b.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=udcd225de&amp;margin=%5Bobject%20Object%5D&amp;originHeight=166&amp;originWidth=695&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u838a29dd-cbf2-4cbd-937d-afffc146266&amp;title=\" width=\"695\" id=\"GT4zu\" class=\"ne-image\"><span class=\"ne-text\"> </span></p><p id=\"u7330e614\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"udecbbfea\" class=\"ne-p\"><span class=\"ne-text\">在目前前后端分离的开发过程中，使用 token 鉴权机制用于身份验证是最常见的方案，流程如下：</span></p><p id=\"u1be76739\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"uf662ebc3\" data-lake-index-type=\"0\"><span class=\"ne-text\">服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证。</span></li><li id=\"uba743b35\" data-lake-index-type=\"0\"><span class=\"ne-text\">后续访问会根据这个令牌判断用户时候有权限进行访问。</span></li></ul><p id=\"u453322da\" class=\"ne-p\"><br></p><p id=\"u619a497c\" class=\"ne-p\"><span class=\"ne-text\">Token，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以.进行拼接。其中头部和载荷都是以 JSON 格式存放数据，只是进行了编码，示意图如下。 </span><img src=\"https://cdn.nlark.com/yuque/0/2022/webp/732231/1648828777403-f4df86c4-d16b-4f91-bae8-e6e5b727bb53.webp#clientId=uc25a66e0-829f-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9f25c564&amp;margin=%5Bobject%20Object%5D&amp;originHeight=637&amp;originWidth=574&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua6a8a38c-f0bb-4346-aee1-9cbde264cb8&amp;title=\" width=\"574\" id=\"AHjxY\" class=\"ne-image\"></p><p id=\"ube789f93\" class=\"ne-p\"><br></p><h3 id=\"bf7e3d7b\"><span class=\"ne-text\">9.1.1 header</span></h3><p id=\"u90935813\" class=\"ne-p\"><br></p><p id=\"ud2f45240\" class=\"ne-p\"><span class=\"ne-text\">每个 JWT 都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为 alg，同时还有一个 typ 的字段，默认 JWT 即可。以下示例中算法为 HS256：</span></p><p id=\"ufbdf210d\" class=\"ne-p\"><br></p><pre data-language=\"json\" id=\"7d32605f\" class=\"ne-codeblock language-json\"><code>{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; }</code></pre><p id=\"u52d5b94e\" class=\"ne-p\"><br></p><p id=\"ufba4ffb8\" class=\"ne-p\"><span class=\"ne-text\">因为 JWT 是字符串，所以我们还需要对以上内容进行 Base64 编码，编码后字符串如下：</span></p><p id=\"udb039908\" class=\"ne-p\"><br></p><pre data-language=\"json\" id=\"7d32605f-1\" class=\"ne-codeblock language-json\"><code>{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; }</code></pre><p id=\"ua3697713\" class=\"ne-p\"><br></p><h3 id=\"74a378af\"><span class=\"ne-text\">9.1.2 payload</span></h3><p id=\"u7e5a0e28\" class=\"ne-p\"><br></p><p id=\"u8619b589\" class=\"ne-p\"><span class=\"ne-text\">载荷即消息体，这里会存放实际的内容，也就是 Token 的数据声明，例如用户的 id 和 name，默认情况下也会携带令牌的签发时间 iat，通过还可以设置过期时间，如下：</span></p><p id=\"u0a273a1c\" class=\"ne-p\"><br></p><pre data-language=\"json\" id=\"3045a387\" class=\"ne-codeblock language-json\"><code>{\n    &quot;sub&quot;: &quot;1234567890&quot;,\n    &quot;name&quot;: &quot;John Doe&quot;,\n    &quot;iat&quot;: 1516239022\n}</code></pre><p id=\"u18125f8c\" class=\"ne-p\"><br></p><p id=\"u5d6798d4\" class=\"ne-p\"><span class=\"ne-text\">同样进行 Base64 编码后，字符串如下：</span></p><p id=\"uf4819c81\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"e70d9f83\" class=\"ne-codeblock language-javascript\"><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</code></pre><p id=\"uc0961802\" class=\"ne-p\"><br></p><h3 id=\"7c0a4684\"><span class=\"ne-text\">9.1.3 Signature</span></h3><p id=\"udf686bd6\" class=\"ne-p\"><br></p><p id=\"u08c0071b\" class=\"ne-p\"><span class=\"ne-text\">签名是对头部和载荷内容进行签名，一般情况，设置一个 secretKey，对前两个的结果进行 HMACSHA25 算法，公式如下：</span></p><p id=\"ubb4cbe5c\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"573cf1a4\" class=\"ne-codeblock language-javascript\"><code>Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)</code></pre><p id=\"ue4b99c8b\" class=\"ne-p\"><br></p><p id=\"u32f0faab\" class=\"ne-p\"><span class=\"ne-text\">因此，就算前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名也是不一致的。</span></p><p id=\"ub95754c3\" class=\"ne-p\"><br></p><h2 id=\"fc688326\"><span class=\"ne-text\">9.2 设计实现</span></h2><p id=\"u9e2ac86d\" class=\"ne-p\"><br></p><p id=\"u3feb99c6\" class=\"ne-p\"><span class=\"ne-text\">通常，Token 的使用分成了两部分：生成 token 和校验 token。</span></p><p id=\"u4f260c7c\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ubbfe75bf\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">生成 token</span></strong><span class=\"ne-text\">：登录成功的时候，颁发 token。</span></li><li id=\"uf51afa03\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">验证 token</span></strong><span class=\"ne-text\">：访问某些资源或者接口时，验证 token。</span></li></ul><p id=\"u703be6e0\" class=\"ne-p\"><br></p><h3 id=\"b311b79d\"><span class=\"ne-text\">9.2.1 生成 token</span></h3><p id=\"u7535a6a5\" class=\"ne-p\"><br></p><p id=\"u884ddcf3\" class=\"ne-p\"><span class=\"ne-text\">借助第三方库 jsonwebtoken，通过 jsonwebtoken 的 sign 方法生成一个 token。sign 有三个参数：</span></p><p id=\"u8a266f5d\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ub02a9506\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个参数指的是 Payload。</span></li><li id=\"uc9f66bdc\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个是秘钥，服务端特有。</span></li><li id=\"uf5a900b4\" data-lake-index-type=\"0\"><span class=\"ne-text\">第三个参数是 option，可以定义 token 过期时间。</span></li></ul><p id=\"uea43f2cb\" class=\"ne-p\"><br></p><p id=\"uda25de59\" class=\"ne-p\"><span class=\"ne-text\">下面是一个前端生成 token 的例子：</span></p><p id=\"ub0212067\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"b252c82b\" class=\"ne-codeblock language-javascript\"><code>const crypto = require(&quot;crypto&quot;),\n    jwt = require(&quot;jsonwebtoken&quot;)\n// TODO:使用数据库\n// 这里应该是用数据库存储，这里只是演示用\nlet userList = []\n\nclass UserController {\n    // 用户登录\n    static async login(ctx) {\n        const data = ctx.request.body\n        if (!data.name || !data.password) {\n            return (ctx.body = {\n                code: &quot;000002&quot;,\n                message: &quot;参数不合法&quot;\n            })\n        }\n        const result = userList.find(\n            item =&gt; item.name === data.name &amp;&amp; item.password === crypto.createHash(&quot;md5&quot;).update(data.password).digest(&quot;hex&quot;)\n        )\n        if (result) {\n            // 生成token\n            const token = jwt.sign(\n                {\n                    name: result.name\n                },\n                &quot;test_token&quot;, // secret\n                { expiresIn: 60 * 60 } // 过期时间：60 * 60 s\n            )\n            return (ctx.body = {\n                code: &quot;0&quot;,\n                message: &quot;登录成功&quot;,\n                data: {\n                    token\n                }\n            })\n        } else {\n            return (ctx.body = {\n                code: &quot;000002&quot;,\n                message: &quot;用户名或密码错误&quot;\n            })\n        }\n    }\n}\n\nmodule.exports = UserController</code></pre><p id=\"ud3bd8f98\" class=\"ne-p\"><br></p><h3 id=\"6bcae3ff\"><span class=\"ne-text\">9.2.2 校验 token</span></h3><p id=\"u9edcea43\" class=\"ne-p\"><br></p><p id=\"ucd7721fb\" class=\"ne-p\"><span class=\"ne-text\">首先，我们需要使用 koa-jwt 中间件进行验证，方式比较简单，在路由跳转前校验即可，如下。</span></p><p id=\"u5b53d61a\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0029f779\" class=\"ne-codeblock language-javascript\"><code>app.use(\n    koajwt({\n        secret: &quot;test_token&quot;\n    }).unless({\n        // 配置白名单\n        path: [/\\/api\\/register/, /\\/api\\/login/]\n    })\n)</code></pre><p id=\"ud6ff238a\" class=\"ne-p\"><br></p><p id=\"ub3dca904\" class=\"ne-p\"><span class=\"ne-text\">使用 koa-jwt 中间件进行校验时，需要注意以下几点：</span></p><p id=\"u4ecd6d3d\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u56e219fe\" data-lake-index-type=\"0\"><span class=\"ne-text\">secret 必须和 sign 时候保持一致。</span></li><li id=\"u47ad6b0c\" data-lake-index-type=\"0\"><span class=\"ne-text\">可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆/注册都可以不用校验。</span></li><li id=\"u24b76e0e\" data-lake-index-type=\"0\"><span class=\"ne-text\">校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验。</span></li></ul><p id=\"ub4fb2d29\" class=\"ne-p\"><br></p><p id=\"u34d0b6a9\" class=\"ne-p\"><span class=\"ne-text\">获取用户 token 信息的方法如下：</span></p><p id=\"uc9ea7eb6\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ef9091ac\" class=\"ne-codeblock language-javascript\"><code>router.get('/api/userInfo',async (ctx,next) =&gt; {\n const authorization =  ctx.header.authorization // 获取jwt\n const token = authorization.replace('Beraer ','')\n const result = jwt.verify(token,'test_token')\n ctx.body = result\n}</code></pre><p id=\"ua6a02d13\" class=\"ne-p\"><br></p><p id=\"u389b0595\" class=\"ne-p\"><strong><span class=\"ne-text\">注意</span></strong><span class=\"ne-text\">：上述的 HMA256 加密算法为单秘钥的形式，一旦泄露后果非常的危险。</span></p><p id=\"ub616d4b3\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌。这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择 RS256 等非对称算法。</span></p><p id=\"ufa374397\" class=\"ne-p\"><span class=\"ne-text\">Ï<br /></span><span class=\"ne-text\">除此之外，JWT 鉴权还需要注意以下几点：</span></p><p id=\"u3f608e92\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ufbda8ac8\" data-lake-index-type=\"0\"><span class=\"ne-text\">payload 部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息。</span></li><li id=\"u0c5bec28\" data-lake-index-type=\"0\"><span class=\"ne-text\">需要保护好加密密钥，一旦泄露后果不堪设想。</span></li><li id=\"ucbb2b1ee\" data-lake-index-type=\"0\"><span class=\"ne-text\">为避免 token 被劫持，最好使用 https 协议。</span></li></ul><p id=\"u9ffc68e2\" class=\"ne-p\"><br></p><h1 id=\"15496b07\"><span class=\"ne-text\">十、Node 性能监控与优化</span></h1><p id=\"u91356be8\" class=\"ne-p\"><br></p><h2 id=\"d54e2d41\"><span class=\"ne-text\">10.1 Node 优化点</span></h2><p id=\"u7608e4bc\" class=\"ne-p\"><br></p><p id=\"u46b20a0e\" class=\"ne-p\"><span class=\"ne-text\">Node 作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下几点：</span></p><p id=\"ufb157cd3\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ub9e132f0\" data-lake-index-type=\"0\"><span class=\"ne-text\">CPU</span></li><li id=\"u671759d1\" data-lake-index-type=\"0\"><span class=\"ne-text\">内存</span></li><li id=\"u6b88f444\" data-lake-index-type=\"0\"><span class=\"ne-text\">I/O</span></li><li id=\"u5fb5a7ca\" data-lake-index-type=\"0\"><span class=\"ne-text\">网络</span></li></ul><p id=\"u2804f05a\" class=\"ne-p\"><br></p><h3 id=\"20eb2623\"><span class=\"ne-text\">10.1.1 CPU</span></h3><p id=\"u8d0ed5da\" class=\"ne-p\"><br></p><p id=\"u9e8f5532\" class=\"ne-p\"><span class=\"ne-text\">对于 CPU 的指标，主要关注如下两点：</span></p><p id=\"u02e35ea2\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u509939db\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">CPU 负载</span></strong><span class=\"ne-text\">：在某个时间段内，占用以及等待 CPU 的进程总数。</span></li><li id=\"u6817b691\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">CPU 使用率</span></strong><span class=\"ne-text\">：CPU 时间占用状况，等于 1 - 空闲 CPU 时间(idle time) / CPU 总时间。</span></li></ul><p id=\"u8675e87d\" class=\"ne-p\"><br></p><p id=\"uc7be4886\" class=\"ne-p\"><span class=\"ne-text\">这两个指标都是用来评估系统当前 CPU 的繁忙程度的量化指标。Node 应用一般不会消耗很多的 CPU，如果 CPU 占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞。</span></p><p id=\"u00e85346\" class=\"ne-p\"><br></p><h3 id=\"f7c41a62\"><span class=\"ne-text\">10.1.2 内存指标</span></h3><p id=\"u4e3f1d05\" class=\"ne-p\"><br></p><p id=\"u4f7a9679\" class=\"ne-p\"><span class=\"ne-text\">内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于 Node 来说，内部内存堆栈的使用状态也是一个可以量化的指标，可以使用下面的代码来获取内存的相关数据：</span></p><p id=\"u23c29eda\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"9d2c014d\" class=\"ne-codeblock language-javascript\"><code>// /app/lib/memory.js\nconst os = require(&quot;os&quot;)\n// 获取当前Node内存堆栈情况\nconst { rss, heapUsed, heapTotal } = process.memoryUsage()\n// 获取系统空闲内存\nconst sysFree = os.freemem()\n// 获取系统总内存\nconst sysTotal = os.totalmem()\n\nmodule.exports = {\n    memory: () =&gt; {\n        return {\n            sys: 1 - sysFree / sysTotal, // 系统内存占用率\n            heap: heapUsed / headTotal, // Node堆内存占用率\n            node: rss / sysTotal // Node占用系统内存的比例\n        }\n    }\n}</code></pre><p id=\"u0a9be450\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u0dab4a20\" data-lake-index-type=\"0\"><span class=\"ne-text\">rss：表示 node 进程占用的内存总量。</span></li><li id=\"ufba67b5b\" data-lake-index-type=\"0\"><span class=\"ne-text\">heapTotal：表示堆内存的总量。</span></li><li id=\"ua63e4e48\" data-lake-index-type=\"0\"><span class=\"ne-text\">heapUsed：实际堆内存的使用量。</span></li><li id=\"u1b7a74cd\" data-lake-index-type=\"0\"><span class=\"ne-text\">external ：外部程序的内存使用量，包含 Node 核心的 C++程序的内存使用量。</span></li></ul><p id=\"uf5e5a8e1\" class=\"ne-p\"><br></p><p id=\"ubd14796b\" class=\"ne-p\"><span class=\"ne-text\">在 Node 中，一个进程的最大内存容量为 1.5GB，因此在实际使用时请合理控制内存的使用。</span></p><p id=\"ucd289114\" class=\"ne-p\"><br></p><h3 id=\"ab218129\"><span class=\"ne-text\">10.13 磁盘 I/O</span></h3><p id=\"uf3489877\" class=\"ne-p\"><br></p><p id=\"ued811ac2\" class=\"ne-p\"><span class=\"ne-text\">硬盘的 IO 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍。内存 IO 比磁盘 IO 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 redis、memcached 等。</span></p><p id=\"ub96a039e\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">并且，并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决。</span></p><p id=\"u784e48f9\" class=\"ne-p\"><br></p><h2 id=\"11a4576d\"><span class=\"ne-text\">10.2 如何监控</span></h2><p id=\"uddd37c84\" class=\"ne-p\"><br></p><p id=\"ud92bbe02\" class=\"ne-p\"><span class=\"ne-text\">关于性能方面的监控，一般情况都需要借助工具来实现，比如 Easy-Monitor、阿里 Node 性能平台等。<br /></span><span class=\"ne-text\">这里采用 Easy-Monitor 2.0，其是轻量级的 Node.js 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 require 一次，无需改动任何业务代码即可开启内核级别的性能监控分析。</span></p><p id=\"u32ec0599\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d15ec2d6\" class=\"ne-codeblock language-javascript\"><code>const easyMonitor = require(&quot;easy-monitor&quot;)\neasyMonitor(&quot;项目名称&quot;)</code></pre><p id=\"u501904b1\" class=\"ne-p\"><br></p><p id=\"u30901bad\" class=\"ne-p\"><span class=\"ne-text\">打开你的浏览器，访问 </span><a href=\"https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A12333\" data-href=\"https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A12333\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">http://localhost:12333</span></a><span class=\"ne-text\"> ，即可看到进程界面，更详细的内容请参考</span><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feasy-monitor\" data-href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feasy-monitor\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">官网</span></a></p><p id=\"u79397f1d\" class=\"ne-p\"><br></p><h2 id=\"959cf5c2\"><span class=\"ne-text\">10.3 Node 性能优化</span></h2><p id=\"ue6a9ad18\" class=\"ne-p\"><br></p><p id=\"u52a64bef\" class=\"ne-p\"><span class=\"ne-text\">关于 Node 的性能优化的方式有如下几个：</span></p><p id=\"u7d906e77\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"uc899c481\" data-lake-index-type=\"0\"><span class=\"ne-text\">使用最新版本 Node.js</span></li><li id=\"ud1aeac8a\" data-lake-index-type=\"0\"><span class=\"ne-text\">正确使用流 Stream</span></li><li id=\"u3f92ee64\" data-lake-index-type=\"0\"><span class=\"ne-text\">代码层面优化</span></li><li id=\"u87ace8e0\" data-lake-index-type=\"0\"><span class=\"ne-text\">内存管理优化</span></li></ul><p id=\"u05403980\" class=\"ne-p\"><br></p><h3 id=\"04ddb6f6\"><span class=\"ne-text\">10.3.1 使用最新版本 Node.js</span></h3><p id=\"u8a89061e\" class=\"ne-p\"><br></p><p id=\"u91cde639\" class=\"ne-p\"><span class=\"ne-text\">每个版本的性能提升主要来自于两个方面：</span></p><p id=\"uf41c8172\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"uec3a6434\" data-lake-index-type=\"0\"><span class=\"ne-text\">V8 的版本更新</span></li><li id=\"uf7b273df\" data-lake-index-type=\"0\"><span class=\"ne-text\">Node.js 内部代码的更新优化</span></li></ul><p id=\"ud0e88893\" class=\"ne-p\"><br></p><h3 id=\"8888e1ce\"><span class=\"ne-text\">10.3.2 正确使用流</span></h3><p id=\"ube1db77f\" class=\"ne-p\"><br></p><p id=\"u3e5d51de\" class=\"ne-p\"><span class=\"ne-text\">在 Node 中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存。</span></p><p id=\"u2d28352b\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"fe2e83be\" class=\"ne-codeblock language-javascript\"><code>const http = require(&quot;http&quot;)\nconst fs = require(&quot;fs&quot;)\n\n// 错误方式\nhttp.createServer(function (req, res) {\n    fs.readFile(__dirname + &quot;/data.txt&quot;, function (err, data) {\n        res.end(data)\n    })\n})\n\n// 正确方式\nhttp.createServer(function (req, res) {\n    const stream = fs.createReadStream(__dirname + &quot;/data.txt&quot;)\n    stream.pipe(res)\n})</code></pre><p id=\"u92286467\" class=\"ne-p\"><br></p><h3 id=\"7d90ae5d\"><span class=\"ne-text\">10.3.3 代码层面优化</span></h3><p id=\"ud027b63c\" class=\"ne-p\"><br></p><p id=\"ue063a655\" class=\"ne-p\"><span class=\"ne-text\">合并查询，将多次查询合并一次，减少数据库的查询次数。</span></p><p id=\"u27c03f42\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0cf13494\" class=\"ne-codeblock language-javascript\"><code>// 错误方式\nfor user_id in userIds\n     let account = user_account.findOne(user_id)\n\n// 正确方式\nconst user_account_map = {}\n // 注意这个对象将会消耗大量内存。\nuser_account.find(user_id in user_ids).forEach(account){\n    user_account_map[account.user_id] =  account\n}\nfor user_id in userIds\n    var account = user_account_map[user_id]</code></pre><p id=\"u3aba27a1\" class=\"ne-p\"><br></p><h3 id=\"b7d743b1\"><span class=\"ne-text\">10.3.4 内存管理优化</span></h3><p id=\"uc975815b\" class=\"ne-p\"><br></p><p id=\"u5bd7ad55\" class=\"ne-p\"><span class=\"ne-text\">在 V8 中，主要将内存分为新生代和老生代两代：</span></p><p id=\"u9706ae7e\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u3039acfb\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">新生代</span></strong><span class=\"ne-text\">：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。</span></li><li id=\"ue2297c0d\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">老生代</span></strong><span class=\"ne-text\">：对象存活时间较长。经历过一次或多次垃圾回收的对象。</span></li></ul><p id=\"u2e8f46f5\" class=\"ne-p\"><br></p><p id=\"uababed11\" class=\"ne-p\"><span class=\"ne-text\">若新生代内存空间不够，直接分配到老生代。通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低，比如下面的例子。</span></p><p id=\"u11b08290\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"327efb1f\" class=\"ne-codeblock language-javascript\"><code>const buffer = fs.readFileSync(__dirname + &quot;/source/index.htm&quot;)\n\napp.use(\n    mount(&quot;/&quot;, async ctx =&gt; {\n        ctx.status = 200\n        ctx.type = &quot;html&quot;\n        ctx.body = buffer\n        leak.push(fs.readFileSync(__dirname + &quot;/source/index.htm&quot;))\n    })\n)\n\nconst leak = []</code></pre><p id=\"uda449fd5\" class=\"ne-p\"><br></p><p id=\"udb6bb60e\" class=\"ne-p\"><span class=\"ne-text\">当 leak 的内存非常大的时候，就有可能造成内存泄露，应当避免这样的操作。</span></p><p id=\"u3fa9f528\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">减少内存使用，可以明显的提高服务性能。而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作。例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新 new 这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动。而使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中，从而避免重读的初始化操作，从而提高框架的性能。</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"viewport\" content=\"adapt\" /><meta name=\"typography\" content=\"classic\" /><h1 data-lake-id=\"14640111\" id=\"14640111\"><span data-lake-id=\"u34662b13\" id=\"u34662b13\">一、Node 基础概念</span></h1><p data-lake-id=\"u9d3241dd\" id=\"u9d3241dd\"><br></p><h2 data-lake-id=\"885b7fb2\" id=\"885b7fb2\"><span data-lake-id=\"u5c6e038e\" id=\"u5c6e038e\">1.1 Node 是什么</span></h2><p data-lake-id=\"uf174728d\" id=\"uf174728d\"><br></p><p data-lake-id=\"u7ad0a454\" id=\"u7ad0a454\"><span data-lake-id=\"ufe3dc26f\" id=\"ufe3dc26f\">Node.js 是一个开源与跨平台的 JavaScript 运行时环境。在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能。我们可以理解为：Node.js 就是一个服务器端的、非阻塞式 I/O 的、事件驱动的 JavaScript 运行环境。<br /></span><span data-lake-id=\"uad2c5c20\" id=\"uad2c5c20\">理解 Node，有几个基础的概念：非阻塞异步和事件驱动。</span></p><p data-lake-id=\"ub2aca590\" id=\"ub2aca590\"><br></p><ul list=\"uea526884\"><li fid=\"uf00d173c\" data-lake-id=\"u9d0ea74f\" id=\"u9d0ea74f\"><strong><span data-lake-id=\"uf3bb2d77\" id=\"uf3bb2d77\">非阻塞异步：</span></strong><span data-lake-id=\"ueb8734b4\" id=\"ueb8734b4\"> Nodejs 采用了非阻塞型 I/O 机制，在做 I/O 操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作。例如，在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。</span></li><li fid=\"uf00d173c\" data-lake-id=\"u6900b00d\" id=\"u6900b00d\"><strong><span data-lake-id=\"ue47d0055\" id=\"ue47d0055\">事件驱动：</span></strong><span data-lake-id=\"ube276085\" id=\"ube276085\"> 事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。比如，读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理。</span></li></ul><p data-lake-id=\"udd7ce47d\" id=\"udd7ce47d\"><br></p><p data-lake-id=\"ue6560a94\" id=\"ue6560a94\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776298-7e87f64c-6d5e-4d9c-8342-b987468c6aae.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Dufb8791da%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D423%26originWidth%3D734%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Du266205b6-6e9a-4e90-a495-40e5ee1d71b%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A734%2C%22originHeight%22%3A423%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23fbfbfb%22%2C%22id%22%3A%22Zt6RL%22%7D\"></card></p><p data-lake-id=\"u29eef851\" id=\"u29eef851\"><br></p><h2 data-lake-id=\"532bae4f\" id=\"532bae4f\"><span data-lake-id=\"ua1415844\" id=\"ua1415844\">1.2 Node 的应用场景及存在的缺点</span></h2><p data-lake-id=\"u18d74480\" id=\"u18d74480\"><br></p><h3 data-lake-id=\"52c34190\" id=\"52c34190\"><span data-lake-id=\"ufd237fd8\" id=\"ufd237fd8\">1.2.1 优缺点</span></h3><p data-lake-id=\"uc6e6450c\" id=\"uc6e6450c\"><br></p><p data-lake-id=\"ud793e40f\" id=\"ud793e40f\"><span data-lake-id=\"u4550f38c\" id=\"u4550f38c\">Node.js 适合用于 I/O 密集型应用，值的是应用在运行极限时，CPU 占用率仍然比较低，大部分时间是在做 I/O 硬盘内存读写操作。缺点如下：</span></p><p data-lake-id=\"u33bb219a\" id=\"u33bb219a\"><br></p><ul list=\"u3e4603dc\"><li fid=\"u0ac1b1e1\" data-lake-id=\"u3ede0a72\" id=\"u3ede0a72\"><span data-lake-id=\"u828a15b5\" id=\"u828a15b5\">不适合 CPU 密集型应用</span></li><li fid=\"u0ac1b1e1\" data-lake-id=\"u63ae9428\" id=\"u63ae9428\"><span data-lake-id=\"u05538d0c\" id=\"u05538d0c\">只支持单核 CPU，不能充分利用 CPU</span></li><li fid=\"u0ac1b1e1\" data-lake-id=\"ucafc9e34\" id=\"ucafc9e34\"><span data-lake-id=\"u1377a0d0\" id=\"u1377a0d0\">可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</span></li></ul><p data-lake-id=\"ua3bcb5ca\" id=\"ua3bcb5ca\"><br></p><p data-lake-id=\"ued22667b\" id=\"ued22667b\"><span data-lake-id=\"u46348904\" id=\"u46348904\">对于第三点，常用的解决方案是，使用 Nnigx 反向代理，开多个进程绑定多个端口，或者开多个进程监听同一个端口。</span></p><p data-lake-id=\"u0e00edef\" id=\"u0e00edef\"><br></p><h3 data-lake-id=\"6c69ebca\" id=\"6c69ebca\"><span data-lake-id=\"uf7ef5f65\" id=\"uf7ef5f65\">1.2.1 应用场景</span></h3><p data-lake-id=\"u57c5aeff\" id=\"u57c5aeff\"><br></p><p data-lake-id=\"ue33680f4\" id=\"ue33680f4\"><span data-lake-id=\"uf9b10d13\" id=\"uf9b10d13\">在熟悉了 Nodejs 的优点和弊端后，我们可以看到它适合以下的应用场景：</span></p><p data-lake-id=\"u41a84452\" id=\"u41a84452\"><br></p><ul list=\"u8abf8cc5\"><li fid=\"ubdeab944\" data-lake-id=\"uc80d0644\" id=\"uc80d0644\"><span data-lake-id=\"u5e3a605e\" id=\"u5e3a605e\">善于 I/O，不善于计算。因为 Nodejs 是一个单线程，如果计算（同步）太多，则会阻塞这个线程。</span></li><li fid=\"ubdeab944\" data-lake-id=\"u263b2f01\" id=\"u263b2f01\"><span data-lake-id=\"u2ffb343c\" id=\"u2ffb343c\">大量并发的 I/O，应用程序内部并不需要进行非常复杂的处理。</span></li><li fid=\"ubdeab944\" data-lake-id=\"u3b6d91a2\" id=\"u3b6d91a2\"><span data-lake-id=\"uc1cc3fe0\" id=\"uc1cc3fe0\">与 WeSocket 配合，开发长连接的实时交互应用程序。</span></li></ul><p data-lake-id=\"u365d8cdd\" id=\"u365d8cdd\"><br></p><p data-lake-id=\"u979124e4\" id=\"u979124e4\"><span data-lake-id=\"ue34c8ff3\" id=\"ue34c8ff3\">具体的使用场景如下：</span></p><p data-lake-id=\"ucf1a2c9b\" id=\"ucf1a2c9b\"><br></p><ol list=\"ua254c546\"><li fid=\"u9cfee5d2\" data-lake-id=\"u8a90dba1\" id=\"u8a90dba1\"><span data-lake-id=\"u198cd8b8\" id=\"u198cd8b8\">用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的 web 应用程序。</span></li><li fid=\"u9cfee5d2\" data-lake-id=\"ub09ed20b\" id=\"ub09ed20b\"><span data-lake-id=\"u1d067d33\" id=\"u1d067d33\">基于 web、canvas 等多人联网游戏。</span></li><li fid=\"u9cfee5d2\" data-lake-id=\"ua18c7755\" id=\"ua18c7755\"><span data-lake-id=\"ufc077768\" id=\"ufc077768\">基于 web 的多人实时聊天客户端、聊天室、图文直播。</span></li><li fid=\"u9cfee5d2\" data-lake-id=\"u8cd5bae1\" id=\"u8cd5bae1\"><span data-lake-id=\"u62ae9882\" id=\"u62ae9882\">单页面浏览器应用程序。</span></li><li fid=\"u9cfee5d2\" data-lake-id=\"u3230b4e9\" id=\"u3230b4e9\"><span data-lake-id=\"u51f15b40\" id=\"u51f15b40\">操作数据库、为前端和移动端提供基于 json 的 API。</span></li></ol><p data-lake-id=\"ub4e8b090\" id=\"ub4e8b090\"><br></p><h1 data-lake-id=\"706d7949\" id=\"706d7949\"><span data-lake-id=\"u251c643b\" id=\"u251c643b\">二、Node 全部对象</span></h1><p data-lake-id=\"ud2aa87fa\" id=\"ud2aa87fa\"><br></p><p data-lake-id=\"u60859149\" id=\"u60859149\"><span data-lake-id=\"uf008e4b7\" id=\"uf008e4b7\">在浏览器 JavaScript 中，window 是全局对象， 而 Nodejs 中的全局对象则是 </span><strong><span data-lake-id=\"ud5a028e6\" id=\"ud5a028e6\">global</span></strong><span data-lake-id=\"ud713834f\" id=\"ud713834f\">。<br /></span><span data-lake-id=\"u9a6698f2\" id=\"u9a6698f2\">在 NodeJS 里，是不可能在最外层定义一个变量，因为所有的用户代码都是当前模块的，只在当前模块里可用，但可以通过 exports 对象的使用将其传递给模块外部。所以，在 NodeJS 中，用 var 声明的变量并不属于全局的变量，只在当前模块生效。像上述的 global 全局对象则在全局作用域中，任何全局变量、函数、对象都是该对象的一个属性值。</span></p><p data-lake-id=\"ue31af441\" id=\"ue31af441\"><br></p><h2 data-lake-id=\"a6c8674d\" id=\"a6c8674d\"><span data-lake-id=\"u0bdf5869\" id=\"u0bdf5869\">2.1 常见全局对象</span></h2><p data-lake-id=\"u4e978d2f\" id=\"u4e978d2f\"><br></p><p data-lake-id=\"u55932616\" id=\"u55932616\"><span data-lake-id=\"ufdbfac82\" id=\"ufdbfac82\">Node 常见的全局对象有如下一些：</span></p><p data-lake-id=\"uda861901\" id=\"uda861901\"><br></p><ul list=\"u312801dc\"><li fid=\"u3a40fbee\" data-lake-id=\"u112f1fa7\" id=\"u112f1fa7\"><span data-lake-id=\"uc25bcd97\" id=\"uc25bcd97\">Class:Buffer</span></li><li fid=\"u3a40fbee\" data-lake-id=\"u5b9fb36e\" id=\"u5b9fb36e\"><span data-lake-id=\"u88a4633e\" id=\"u88a4633e\">process</span></li><li fid=\"u3a40fbee\" data-lake-id=\"u252ff90a\" id=\"u252ff90a\"><span data-lake-id=\"uf1e99e14\" id=\"uf1e99e14\">console</span></li><li fid=\"u3a40fbee\" data-lake-id=\"u76ed4277\" id=\"u76ed4277\"><span data-lake-id=\"u2c047430\" id=\"u2c047430\">clearInterval、setInterval</span></li><li fid=\"u3a40fbee\" data-lake-id=\"u60dacb54\" id=\"u60dacb54\"><span data-lake-id=\"ub3207114\" id=\"ub3207114\">clearTimeout、setTimeout</span></li><li fid=\"u3a40fbee\" data-lake-id=\"udbf2db48\" id=\"udbf2db48\"><span data-lake-id=\"u7fd006b7\" id=\"u7fd006b7\">global</span></li></ul><p data-lake-id=\"ua5f5d6fd\" id=\"ua5f5d6fd\"><br></p><p data-lake-id=\"u8aac44c6\" id=\"u8aac44c6\"><code data-lake-id=\"u4317b278\" id=\"u4317b278\"><span data-lake-id=\"u8c868782\" id=\"u8c868782\">Class:Buffer</span></code><span data-lake-id=\"ufe13b8a9\" id=\"ufe13b8a9\"> 可以用来处理二进制以及非 </span><code data-lake-id=\"u4d56bf57\" id=\"u4d56bf57\"><span data-lake-id=\"u4e781328\" id=\"u4e781328\">Unicode</span></code><span data-lake-id=\"u7f3ed6a5\" id=\"u7f3ed6a5\"> 编码的数据，在 </span><code data-lake-id=\"ua98e3f23\" id=\"ua98e3f23\"><span data-lake-id=\"u5469f7cc\" id=\"u5469f7cc\">Buffer</span></code><span data-lake-id=\"u8463f2d7\" id=\"u8463f2d7\"> 类实例化中存储了原始数据。</span><code data-lake-id=\"u99dde793\" id=\"u99dde793\"><span data-lake-id=\"u41147736\" id=\"u41147736\">Buffer</span></code><span data-lake-id=\"u890773d4\" id=\"u890773d4\"> 类似于一个整数数组，在 </span><code data-lake-id=\"ub137586a\" id=\"ub137586a\"><span data-lake-id=\"ue996f742\" id=\"ue996f742\">V8</span></code><span data-lake-id=\"uf7c0930c\" id=\"uf7c0930c\"> 堆原始存储空间给它分配了内存，一旦创建了 </span><code data-lake-id=\"uf5bb3407\" id=\"uf5bb3407\"><span data-lake-id=\"u8211e35a\" id=\"u8211e35a\">Buffer</span></code><span data-lake-id=\"uacaf2c22\" id=\"uacaf2c22\"> 实例，则无法改变大小。</span></p><p data-lake-id=\"u4bde522d\" id=\"u4bde522d\"><br></p><p data-lake-id=\"ua72a02de\" id=\"ua72a02de\"><code data-lake-id=\"u5c0b66c3\" id=\"u5c0b66c3\"><span data-lake-id=\"u18075ba4\" id=\"u18075ba4\">process</span></code><span data-lake-id=\"u70251824\" id=\"u70251824\"> 表示进程对象，提供有关当前过程的信息和控制。包括在执行 </span><code data-lake-id=\"u99f4fb37\" id=\"u99f4fb37\"><span data-lake-id=\"u9dc3a381\" id=\"u9dc3a381\">node</span></code><span data-lake-id=\"ueeb8ef76\" id=\"ueeb8ef76\"> 程序的过程中，如果需要传递参数，我们想要获取这个参数需要在 </span><code data-lake-id=\"u419d4c94\" id=\"u419d4c94\"><span data-lake-id=\"u7cab68fe\" id=\"u7cab68fe\">process</span></code><span data-lake-id=\"u8da0deb6\" id=\"u8da0deb6\"> 内置对象中。比如，我们有如下一个文件：</span></p><p data-lake-id=\"u5505d1d0\" id=\"u5505d1d0\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22process.argv.forEach((val%2C%20index)%20%3D%3E%20%7B%5Cn%20%20%20%20console.log(%60%24%7Bindex%7D%3A%20%24%7Bval%7D%60)%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22fce1321b%22%7D\"></card><p data-lake-id=\"uaeb1cf8c\" id=\"uaeb1cf8c\"><br></p><p data-lake-id=\"u2a95db76\" id=\"u2a95db76\"><span data-lake-id=\"uf0c2c29d\" id=\"uf0c2c29d\">当我们需要启动一个进程时，可以使用下面的命令：</span></p><p data-lake-id=\"u637163cd\" id=\"u637163cd\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22shell%22%2C%22code%22%3A%22node%20index.js%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22f1f483f1%22%7D\"></card><p data-lake-id=\"u576c6d3b\" id=\"u576c6d3b\"><br></p><p data-lake-id=\"u328e70e1\" id=\"u328e70e1\"><code data-lake-id=\"u2a78090d\" id=\"u2a78090d\"><span data-lake-id=\"u6a2d2100\" id=\"u6a2d2100\">console</span></code><span data-lake-id=\"uce5fab0b\" id=\"uce5fab0b\"> 主要用来打印 </span><code data-lake-id=\"u263f57ce\" id=\"u263f57ce\"><span data-lake-id=\"ufe342d36\" id=\"ufe342d36\">stdout</span></code><span data-lake-id=\"u678734a3\" id=\"u678734a3\"> 和 </span><code data-lake-id=\"uf314f1e1\" id=\"uf314f1e1\"><span data-lake-id=\"u2852360b\" id=\"u2852360b\">stderr</span></code><span data-lake-id=\"u0c8759a4\" id=\"u0c8759a4\">，最常用的比如日志输出：</span><code data-lake-id=\"ua948b57e\" id=\"ua948b57e\"><span data-lake-id=\"ue85dd145\" id=\"ue85dd145\">console.log</span></code><span data-lake-id=\"ude77ffe1\" id=\"ude77ffe1\">。清空控制台的命令为：</span><code data-lake-id=\"uc85363a1\" id=\"uc85363a1\"><span data-lake-id=\"u25379fff\" id=\"u25379fff\">console.clear</span></code><span data-lake-id=\"u59098f78\" id=\"u59098f78\">。如果需要打印函数的调用栈，可以使用命令 </span><code data-lake-id=\"ufc7593ee\" id=\"ufc7593ee\"><span data-lake-id=\"ud1dc7abe\" id=\"ud1dc7abe\">console.trace</span></code><span data-lake-id=\"u53258e5f\" id=\"u53258e5f\">。</span></p><p data-lake-id=\"ub6676466\" id=\"ub6676466\"><br></p><p data-lake-id=\"ua35af201\" id=\"ua35af201\"><code data-lake-id=\"u9b37cdf6\" id=\"u9b37cdf6\"><span data-lake-id=\"ue2eab5f5\" id=\"ue2eab5f5\">setInterval</span></code><span data-lake-id=\"u16a8dc3f\" id=\"u16a8dc3f\"> 用于设置定时器，语法格式如下：</span></p><p data-lake-id=\"u197c15cd\" id=\"u197c15cd\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22setInterval(callback%2C%20delay%5B%2C%20...args%5D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2229f31e79%22%7D\"></card><p data-lake-id=\"u4f364e59\" id=\"u4f364e59\"><br></p><p data-lake-id=\"udba108a3\" id=\"udba108a3\"><code data-lake-id=\"uafacaad8\" id=\"uafacaad8\"><span data-lake-id=\"uf7cec122\" id=\"uf7cec122\">clearInterval</span></code><span data-lake-id=\"u6271719d\" id=\"u6271719d\"> 则用于清除定时器，</span><code data-lake-id=\"u44948ace\" id=\"u44948ace\"><span data-lake-id=\"u5383723a\" id=\"u5383723a\">callback</span></code><span data-lake-id=\"u6d903c93\" id=\"u6d903c93\"> 每 </span><code data-lake-id=\"u574baaa4\" id=\"u574baaa4\"><span data-lake-id=\"ub3eba18f\" id=\"ub3eba18f\">delay</span></code><span data-lake-id=\"u2e5089d2\" id=\"u2e5089d2\"> 毫秒重复执行一次。</span></p><p data-lake-id=\"u8d6746d9\" id=\"u8d6746d9\"><span data-lake-id=\"ubffa94f5\" id=\"ubffa94f5\"><br /></span><span data-lake-id=\"ud401b1d6\" id=\"ud401b1d6\">和 </span><code data-lake-id=\"ubab27ab0\" id=\"ubab27ab0\"><span data-lake-id=\"ub3b58e72\" id=\"ub3b58e72\">setInterval</span></code><span data-lake-id=\"u7ea97d6e\" id=\"u7ea97d6e\"> 一样，</span><code data-lake-id=\"u975a558a\" id=\"u975a558a\"><span data-lake-id=\"ua17a3abd\" id=\"ua17a3abd\">setTimeout</span></code><span data-lake-id=\"u6bd07d11\" id=\"u6bd07d11\"> 主要用于设置延时器，而 </span><code data-lake-id=\"u9c359c90\" id=\"u9c359c90\"><span data-lake-id=\"ufc68e41f\" id=\"ufc68e41f\">clearTimeout</span></code><span data-lake-id=\"u1743e167\" id=\"u1743e167\"> 则用于清除设置的延时器。</span></p><p data-lake-id=\"u7c86fe6f\" id=\"u7c86fe6f\"><br></p><p data-lake-id=\"u214b9ce1\" id=\"u214b9ce1\"><code data-lake-id=\"u95359eda\" id=\"u95359eda\"><span data-lake-id=\"u4817df1c\" id=\"u4817df1c\">global</span></code><span data-lake-id=\"u852344cb\" id=\"u852344cb\"> 是一个全局命名空间对象，前面讲到的 </span><code data-lake-id=\"ud451bf68\" id=\"ud451bf68\"><span data-lake-id=\"ud28df21b\" id=\"ud28df21b\">process</span></code><span data-lake-id=\"u5690cb7b\" id=\"u5690cb7b\">、</span><code data-lake-id=\"ufdde2e66\" id=\"ufdde2e66\"><span data-lake-id=\"u6bd3cf1d\" id=\"u6bd3cf1d\">console</span></code><span data-lake-id=\"ue4cb76f0\" id=\"ue4cb76f0\">、</span><code data-lake-id=\"u832c43dd\" id=\"u832c43dd\"><span data-lake-id=\"u85820f0b\" id=\"u85820f0b\">setTimeout</span></code><span data-lake-id=\"u2f4ae15f\" id=\"u2f4ae15f\"> 等可以放到 </span><code data-lake-id=\"ua430e80a\" id=\"ua430e80a\"><span data-lake-id=\"uffb62fa7\" id=\"uffb62fa7\">global</span></code><span data-lake-id=\"u10f2c11a\" id=\"u10f2c11a\"> 中，例如：</span></p><p data-lake-id=\"u5850fc65\" id=\"u5850fc65\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(process%20%3D%3D%3D%20global.process)%20%2F%2F%E8%BE%93%E5%87%BA%20true%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%228ecc2035%22%7D\"></card><p data-lake-id=\"ub9a8f12e\" id=\"ub9a8f12e\"><br></p><h2 data-lake-id=\"a987960b\" id=\"a987960b\"><span data-lake-id=\"u4fe59658\" id=\"u4fe59658\">2.2 模块中的全局对象</span></h2><p data-lake-id=\"u0b8a164b\" id=\"u0b8a164b\"><br></p><p data-lake-id=\"u99f5b4bd\" id=\"u99f5b4bd\"><span data-lake-id=\"ub33c2745\" id=\"ub33c2745\">除了系统提供的全局对象外，还有一些只是在模块中出现，看起来像全局变量，如下所示：</span></p><p data-lake-id=\"ud0a327d2\" id=\"ud0a327d2\"><br></p><ul list=\"ub917f180\"><li fid=\"u26205cbd\" data-lake-id=\"u02e037f7\" id=\"u02e037f7\"><code data-lake-id=\"ua647f53c\" id=\"ua647f53c\"><span data-lake-id=\"u21263756\" id=\"u21263756\">__dirname</span></code></li><li fid=\"u26205cbd\" data-lake-id=\"ua7542ff8\" id=\"ua7542ff8\"><code data-lake-id=\"ue4cca4ad\" id=\"ue4cca4ad\"><span data-lake-id=\"uacba3aa8\" id=\"uacba3aa8\">__filename</span></code></li><li fid=\"u26205cbd\" data-lake-id=\"ufa497932\" id=\"ufa497932\"><code data-lake-id=\"u53f6801c\" id=\"u53f6801c\"><span data-lake-id=\"u0ce41aba\" id=\"u0ce41aba\">exports</span></code></li><li fid=\"u26205cbd\" data-lake-id=\"uc3e46d56\" id=\"uc3e46d56\"><code data-lake-id=\"u978db326\" id=\"u978db326\"><span data-lake-id=\"uc2ef917e\" id=\"uc2ef917e\">module</span></code></li><li fid=\"u26205cbd\" data-lake-id=\"u311778ca\" id=\"u311778ca\"><code data-lake-id=\"u42f25f12\" id=\"u42f25f12\"><span data-lake-id=\"udd7cabc5\" id=\"udd7cabc5\">require</span></code></li></ul><p data-lake-id=\"u4bdab3ce\" id=\"u4bdab3ce\"><br></p><p data-lake-id=\"ued8eada2\" id=\"ued8eada2\"><code data-lake-id=\"u9e930e01\" id=\"u9e930e01\"><span data-lake-id=\"u92b3a1c7\" id=\"u92b3a1c7\">__dirname</span></code><span data-lake-id=\"u1596880d\" id=\"u1596880d\"> 主要用于获取当前文件所在的路径，不包括后面的文件名。比如，在 </span><code data-lake-id=\"u729b6bb9\" id=\"u729b6bb9\"><span data-lake-id=\"u6452a384\" id=\"u6452a384\">/Users/mjr</span></code><span data-lake-id=\"u940f3750\" id=\"u940f3750\"> 中运行 </span><code data-lake-id=\"ufab93549\" id=\"ufab93549\"><span data-lake-id=\"u8dede655\" id=\"u8dede655\">node example.js</span></code><span data-lake-id=\"u98390995\" id=\"u98390995\">，打印结果如下：</span></p><p data-lake-id=\"u734f6d4b\" id=\"u734f6d4b\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(__dirname)%20%2F%2F%20%E6%89%93%E5%8D%B0%3A%20%2FUsers%2Fmjr%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2238091a85%22%7D\"></card><p data-lake-id=\"u8d81068b\" id=\"u8d81068b\"><br></p><p data-lake-id=\"u33751a80\" id=\"u33751a80\"><code data-lake-id=\"u31074f3f\" id=\"u31074f3f\"><span data-lake-id=\"u9662ffd6\" id=\"u9662ffd6\">__filename</span></code><span data-lake-id=\"u789e8637\" id=\"u789e8637\"> 用于获取当前文件所在的路径和文件名称，包括后面的文件名称。比如，在 </span><code data-lake-id=\"ubedf3475\" id=\"ubedf3475\"><span data-lake-id=\"u660a8afe\" id=\"u660a8afe\">/Users/mjr</span></code><span data-lake-id=\"uaffa59ba\" id=\"uaffa59ba\"> 中运行 </span><code data-lake-id=\"u6eef3a4c\" id=\"u6eef3a4c\"><span data-lake-id=\"u5e67c82b\" id=\"u5e67c82b\">node example.js</span></code><span data-lake-id=\"u8aedc09c\" id=\"u8aedc09c\">，打印的结果如下：</span></p><p data-lake-id=\"ub01a60a3\" id=\"ub01a60a3\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(__filename)%20%2F%2F%20%E6%89%93%E5%8D%B0%3A%20%2FUsers%2Fmjr%2Fexample.js%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%221dcd1f92%22%7D\"></card><p data-lake-id=\"u4247212f\" id=\"u4247212f\"><br></p><p data-lake-id=\"u182a1c2f\" id=\"u182a1c2f\"><code data-lake-id=\"u61f80409\" id=\"u61f80409\"><span data-lake-id=\"ufed79716\" id=\"ufed79716\">module.exports</span></code><span data-lake-id=\"u867d665c\" id=\"u867d665c\"> 用于导出一个指定模块所的内容，然后也可以使用 </span><code data-lake-id=\"uc16aa20d\" id=\"uc16aa20d\"><span data-lake-id=\"u8766c252\" id=\"u8766c252\">require()</span></code><span data-lake-id=\"ub662ee00\" id=\"ub662ee00\"> 访问里面的内容。</span></p><p data-lake-id=\"uf13d112d\" id=\"uf13d112d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22exports.name%20%3D%20name%5Cnexports.age%20%3D%20age%5Cnexports.sayHello%20%3D%20sayHello%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%223163e268%22%7D\"></card><p data-lake-id=\"u10aff8f2\" id=\"u10aff8f2\"><br></p><p data-lake-id=\"u35c9f072\" id=\"u35c9f072\"><code data-lake-id=\"u11e3ff0f\" id=\"u11e3ff0f\"><span data-lake-id=\"u7e68d330\" id=\"u7e68d330\">require</span></code><span data-lake-id=\"ub9a633eb\" id=\"ub9a633eb\"> 主要用于引入模块、</span><code data-lake-id=\"u0f60c786\" id=\"u0f60c786\"><span data-lake-id=\"u7dbeef36\" id=\"u7dbeef36\">JSON</span></code><span data-lake-id=\"u214711d2\" id=\"u214711d2\">、或本地文件， 可以从 </span><code data-lake-id=\"ud8a5f223\" id=\"ud8a5f223\"><span data-lake-id=\"u7090ff0f\" id=\"u7090ff0f\">node_modules</span></code><span data-lake-id=\"ucb3e8d7c\" id=\"ucb3e8d7c\"> 引入模块。可以使用相对路径引入本地模块或 </span><code data-lake-id=\"u6025a8ae\" id=\"u6025a8ae\"><span data-lake-id=\"ue663ad86\" id=\"ue663ad86\">JSON</span></code><span data-lake-id=\"u4cd658ee\" id=\"u4cd658ee\"> 文件，路径会根据 </span><code data-lake-id=\"u8a0e8912\" id=\"u8a0e8912\"><span data-lake-id=\"u9fe8f8ee\" id=\"u9fe8f8ee\">__dirname</span></code><span data-lake-id=\"ubed7f533\" id=\"ubed7f533\"> 定义的目录名或当前工作目录进行处理。</span></p><p data-lake-id=\"u351a5a0b\" id=\"u351a5a0b\"><br></p><h1 data-lake-id=\"7a19c723\" id=\"7a19c723\"><span data-lake-id=\"u25855408\" id=\"u25855408\">三、谈谈对 process 的理解</span></h1><p data-lake-id=\"u4d84c3b0\" id=\"u4d84c3b0\"><br></p><h2 data-lake-id=\"fcea9dd2\" id=\"fcea9dd2\"><span data-lake-id=\"u62602938\" id=\"u62602938\">3.1 基本概念</span></h2><p data-lake-id=\"u9ab3c044\" id=\"u9ab3c044\"><br></p><p data-lake-id=\"u68e8b091\" id=\"u68e8b091\"><span data-lake-id=\"uf9d4b0c1\" id=\"uf9d4b0c1\">我们知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器。当我们启动一个 js 文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享。<br /></span><span data-lake-id=\"uf23aa041\" id=\"uf23aa041\">process 对象是 Node 的一个全局变量，提供了有关当前 Node.js 进程的信息并对其进行控制。 由于 JavaScript 是一个单线程语言，所以通过 node xxx 启动一个文件后，只有一条主线程。</span></p><p data-lake-id=\"ub9823731\" id=\"ub9823731\"><br></p><h2 data-lake-id=\"46d5f104\" id=\"46d5f104\"><span data-lake-id=\"uc35b0d3d\" id=\"uc35b0d3d\">3.2 常用属性和方法</span></h2><p data-lake-id=\"u05039696\" id=\"u05039696\"><br></p><p data-lake-id=\"u38bf5062\" id=\"u38bf5062\"><span data-lake-id=\"u07f74763\" id=\"u07f74763\">process 的常见属性如下：</span></p><p data-lake-id=\"u45864067\" id=\"u45864067\"><br></p><ul list=\"u32e3eb9e\"><li fid=\"uc6ac7bd3\" data-lake-id=\"u4f7bd424\" id=\"u4f7bd424\"><span data-lake-id=\"u20c49da2\" id=\"u20c49da2\">process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息</span></li><li fid=\"uc6ac7bd3\" data-lake-id=\"uf17edf82\" id=\"uf17edf82\"><span data-lake-id=\"u90f32c4e\" id=\"u90f32c4e\">process.nextTick：这个在谈及 EventLoop 时经常为会提到</span></li><li fid=\"uc6ac7bd3\" data-lake-id=\"ud57b18a7\" id=\"ud57b18a7\"><span data-lake-id=\"uf67c5414\" id=\"uf67c5414\">process.pid：获取当前进程 id</span></li><li fid=\"uc6ac7bd3\" data-lake-id=\"udf33339a\" id=\"udf33339a\"><span data-lake-id=\"ub2d7b9a8\" id=\"ub2d7b9a8\">process.ppid：当前进程对应的父进程</span></li><li fid=\"uc6ac7bd3\" data-lake-id=\"ue4593f7e\" id=\"ue4593f7e\"><span data-lake-id=\"u45da9782\" id=\"u45da9782\">process.cwd()：获取当前进程工作目录</span></li><li fid=\"uc6ac7bd3\" data-lake-id=\"u5dbade7a\" id=\"u5dbade7a\"><span data-lake-id=\"ucbb2d87d\" id=\"ucbb2d87d\">process.platform：获取当前进程运行的操作系统平台</span></li><li fid=\"uc6ac7bd3\" data-lake-id=\"u071cc581\" id=\"u071cc581\"><span data-lake-id=\"ua2a9a601\" id=\"ua2a9a601\">process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</span></li></ul><p data-lake-id=\"u9d5c57f0\" id=\"u9d5c57f0\"><br></p><p data-lake-id=\"u022d8288\" id=\"u022d8288\"><span data-lake-id=\"u3ce63c2d\" id=\"u3ce63c2d\">进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</span></p><p data-lake-id=\"u05921653\" id=\"u05921653\"><br></p><ul list=\"ueb737d2c\"><li fid=\"u67b7f018\" data-lake-id=\"u25e9c331\" id=\"u25e9c331\"><span data-lake-id=\"u3e3ba072\" id=\"u3e3ba072\">三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</span></li><li fid=\"u67b7f018\" data-lake-id=\"u0a26c586\" id=\"u0a26c586\"><span data-lake-id=\"u35b2d553\" id=\"u35b2d553\">process.title：用于指定进程名称，有的时候需要给进程指定一个名称</span></li></ul><p data-lake-id=\"u35d98953\" id=\"u35d98953\"><br></p><h1 data-lake-id=\"d381b7d6\" id=\"d381b7d6\"><span data-lake-id=\"uc554a9d4\" id=\"uc554a9d4\">四、谈谈你对 fs 模块的理解</span></h1><p data-lake-id=\"u5f7dee6c\" id=\"u5f7dee6c\"><br></p><h2 data-lake-id=\"9ea26fe6\" id=\"9ea26fe6\"><span data-lake-id=\"u5dc6e5cc\" id=\"u5dc6e5cc\">4.1 fs 是什么</span></h2><p data-lake-id=\"ue92d397a\" id=\"ue92d397a\"><br></p><p data-lake-id=\"u28210b1d\" id=\"u28210b1d\"><span data-lake-id=\"u29532563\" id=\"u29532563\">fs（filesystem）是文件系统模块，该模块提供本地文件的读写能力，基本上是 POSIX 文件操作命令的简单包装。可以说，所有与文件的操作都是通过 fs 核心模块来实现的。<br /></span><span data-lake-id=\"u0778c371\" id=\"u0778c371\">使用之前，需要先导入 fs 模块，如下：</span></p><p data-lake-id=\"ud77b833d\" id=\"ud77b833d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22fc960e73%22%7D\"></card><p data-lake-id=\"ua1ca2482\" id=\"ua1ca2482\"><br></p><h2 data-lake-id=\"83aa8750\" id=\"83aa8750\"><span data-lake-id=\"u6e0ca8cb\" id=\"u6e0ca8cb\">4.2 文件基础知识</span></h2><p data-lake-id=\"u93144b7f\" id=\"u93144b7f\"><br></p><p data-lake-id=\"u9179c1d2\" id=\"u9179c1d2\"><span data-lake-id=\"u32813813\" id=\"u32813813\">在计算机中，有关于文件的基础知识有如下一些：</span></p><p data-lake-id=\"uc641b6fd\" id=\"uc641b6fd\"><br></p><ul list=\"u1f165acb\"><li fid=\"u1c33496d\" data-lake-id=\"u14c6cbfb\" id=\"u14c6cbfb\"><span data-lake-id=\"u31382289\" id=\"u31382289\">权限位 mode</span></li><li fid=\"u1c33496d\" data-lake-id=\"ud47d7640\" id=\"ud47d7640\"><span data-lake-id=\"u6d57ca03\" id=\"u6d57ca03\">标识位 flag</span></li><li fid=\"u1c33496d\" data-lake-id=\"uf5ed3c2d\" id=\"uf5ed3c2d\"><span data-lake-id=\"ua55513de\" id=\"ua55513de\">文件描述为 fd</span></li></ul><p data-lake-id=\"uc3ef17aa\" id=\"uc3ef17aa\"><br></p><h3 data-lake-id=\"8b15b7d7\" id=\"8b15b7d7\"><span data-lake-id=\"ua623ce29\" id=\"ua623ce29\">4.2.1 权限位 mode</span></h3><p data-lake-id=\"u84abc37a\" id=\"u84abc37a\"><br></p><p data-lake-id=\"u5e54ecd8\" id=\"u5e54ecd8\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776369-f24a77ac-46e8-4d3b-8060-cb87862d35d5.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Du9d544723%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D208%26originWidth%3D935%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Du466a6cd9-2a76-4ae7-864f-0863d99a4a6%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A935%2C%22originHeight%22%3A208%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f3f3f3%22%2C%22id%22%3A%22cioq6%22%7D\"></card><span data-lake-id=\"ude101c5f\" id=\"ude101c5f\"> 针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位 4、2、1，不具备权限为 0。如在 linux 查看文件权限位的命令如下：</span></p><p data-lake-id=\"ufa720d03\" id=\"ufa720d03\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22markdown%22%2C%22code%22%3A%22drwxr-xr-x%E2%80%831%E2%80%83PandaShen%E2%80%83197121%E2%80%830%E2%80%83Jun%2028%2014%3A41%E2%80%83core%20-rw-r--r--%E2%80%831%E2%80%83PandaShen%E2%80%83197121%E2%80%83293%E2%80%83Jun%2023%2017%3A44%E2%80%83index.md%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22f25f6fb4%22%7D\"></card><p data-lake-id=\"u9ace4341\" id=\"u9ace4341\"><br></p><p data-lake-id=\"u7e11099d\" id=\"u7e11099d\"><span data-lake-id=\"u593517c5\" id=\"u593517c5\">在开头前十位中，d 为文件夹，-为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限。</span></p><p data-lake-id=\"u257c9d83\" id=\"u257c9d83\"><br></p><h3 data-lake-id=\"d1a14988\" id=\"d1a14988\"><span data-lake-id=\"ue280aa6d\" id=\"ue280aa6d\">4.2.2 标识位</span></h3><p data-lake-id=\"uce21a724\" id=\"uce21a724\"><br></p><p data-lake-id=\"uc2fe8d33\" id=\"uc2fe8d33\"><span data-lake-id=\"u14338f4a\" id=\"u14338f4a\">标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示： </span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776337-d3459565-762c-4ad9-893d-a8182c7fad6b.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Dua982a818%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D846%26originWidth%3D982%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Du8906bb54-c483-46c9-9748-373ba87bc40%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A982%2C%22originHeight%22%3A846%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22xiyc9%22%7D\"></card></p><p data-lake-id=\"u72c4d4b6\" id=\"u72c4d4b6\"><br></p><h3 data-lake-id=\"c39a80ba\" id=\"c39a80ba\"><span data-lake-id=\"ud9583054\" id=\"ud9583054\">4.2.3 文件描述 fd</span></h3><p data-lake-id=\"ud7d03fe6\" id=\"ud7d03fe6\"><br></p><p data-lake-id=\"u2744058b\" id=\"u2744058b\"><span data-lake-id=\"uf6982a05\" id=\"uf6982a05\">操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件。</span></p><p data-lake-id=\"u6fbabc16\" id=\"u6fbabc16\"><span data-lake-id=\"uf1ea8c86\" id=\"uf1ea8c86\"><br /></span><span data-lake-id=\"u84ba6b9f\" id=\"u84ba6b9f\">Window 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。</span></p><p data-lake-id=\"ue921f6ea\" id=\"ue921f6ea\"><span data-lake-id=\"u173ffa68\" id=\"u173ffa68\"><br /></span><span data-lake-id=\"u01882099\" id=\"u01882099\">在 NodeJS 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2 三个比较特殊的描述符，分别代表 process.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出）。</span></p><p data-lake-id=\"uac3bf9ef\" id=\"uac3bf9ef\"><br></p><h2 data-lake-id=\"dea7c041\" id=\"dea7c041\"><span data-lake-id=\"u6feb884b\" id=\"u6feb884b\">4.3 常用方法</span></h2><p data-lake-id=\"ud31947db\" id=\"ud31947db\"><br></p><p data-lake-id=\"u3fb437ac\" id=\"u3fb437ac\"><span data-lake-id=\"u9eeb74a3\" id=\"u9eeb74a3\">由于 fs 模块主要是操作文件的，所以常见的文件操作方法有如下一些：</span></p><p data-lake-id=\"u2d06bcf1\" id=\"u2d06bcf1\"><br></p><ul list=\"ud9c5283b\"><li fid=\"uf48387b2\" data-lake-id=\"u71f623cd\" id=\"u71f623cd\"><span data-lake-id=\"u13fc3e98\" id=\"u13fc3e98\">文件读取</span></li><li fid=\"uf48387b2\" data-lake-id=\"u0f2a0e87\" id=\"u0f2a0e87\"><span data-lake-id=\"ub999fa6f\" id=\"ub999fa6f\">文件写入</span></li><li fid=\"uf48387b2\" data-lake-id=\"u86306ae3\" id=\"u86306ae3\"><span data-lake-id=\"u94feab2c\" id=\"u94feab2c\">文件追加写入</span></li><li fid=\"uf48387b2\" data-lake-id=\"ua56d60da\" id=\"ua56d60da\"><span data-lake-id=\"u543b98b0\" id=\"u543b98b0\">文件拷贝</span></li><li fid=\"uf48387b2\" data-lake-id=\"u7294f407\" id=\"u7294f407\"><span data-lake-id=\"ud99b65dd\" id=\"ud99b65dd\">创建目录</span></li></ul><p data-lake-id=\"uf2fd284a\" id=\"uf2fd284a\"><br></p><h3 data-lake-id=\"f0ae08e8\" id=\"f0ae08e8\"><span data-lake-id=\"u8f830e02\" id=\"u8f830e02\">4.3.1 文件读取</span></h3><p data-lake-id=\"uc182b34f\" id=\"uc182b34f\"><br></p><p data-lake-id=\"u02fa3fca\" id=\"u02fa3fca\"><span data-lake-id=\"u4744c557\" id=\"u4744c557\">常用的文件读取有 readFileSync 和 readFile 两个方法。其中，readFileSync 表示同步读取，如下：</span></p><p data-lake-id=\"ucc4c3fad\" id=\"ucc4c3fad\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cnlet%20buf%20%3D%20fs.readFileSync(%5C%221.txt%5C%22)%5Cnlet%20data%20%3D%20fs.readFileSync(%5C%221.txt%5C%22%2C%20%5C%22utf8%5C%22)%5Cnconsole.log(buf)%20%2F%2F%20%3CBuffer%2048%2065%206c%206c%206f%3E%5Cnconsole.log(data)%20%2F%2F%20Hello%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22b56d8f1c%22%7D\"></card><p data-lake-id=\"ue8976a18\" id=\"ue8976a18\"><br></p><ul list=\"u1a668e59\"><li fid=\"u76b00c21\" data-lake-id=\"u08a2deb0\" id=\"u08a2deb0\"><span data-lake-id=\"u06733a77\" id=\"u06733a77\">第一个参数为读取文件的路径或文件描述符。</span></li><li fid=\"u76b00c21\" data-lake-id=\"u7db3db71\" id=\"u7db3db71\"><span data-lake-id=\"uece6a4b0\" id=\"uece6a4b0\">第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding。</span></li></ul><p data-lake-id=\"u0785fc77\" id=\"u0785fc77\"><br></p><p data-lake-id=\"u8ede1d05\" id=\"u8ede1d05\"><span data-lake-id=\"u2b592504\" id=\"u2b592504\">readFile 为异步读取方法， readFile 与 readFileSync 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 err（错误）和 data（数据），该方法没有返回值，回调函数在读取文件成功后执行。</span></p><p data-lake-id=\"u4f936a2e\" id=\"u4f936a2e\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cnfs.readFile(%5C%221.txt%5C%22%2C%20%5C%22utf8%5C%22%2C%20(err%2C%20data)%20%3D%3E%20%7B%5Cn%20%20%20%20if%20(!err)%20%7B%5Cn%20%20%20%20%20%20%20%20console.log(data)%5Cn%20%20%20%20%20%20%20%20%2F%2F%20Hello%5Cn%20%20%20%20%7D%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22e0379f45%22%7D\"></card><p data-lake-id=\"u8ecc006a\" id=\"u8ecc006a\"><br></p><h3 data-lake-id=\"78888f32\" id=\"78888f32\"><span data-lake-id=\"uc8eb78bc\" id=\"uc8eb78bc\">4.3.2 文件写入</span></h3><p data-lake-id=\"u2b9b128d\" id=\"u2b9b128d\"><br></p><p data-lake-id=\"ue404e8bb\" id=\"ue404e8bb\"><span data-lake-id=\"u20fd61fc\" id=\"u20fd61fc\">文件写入需要用到 writeFileSync 和 writeFile 两个方法。writeFileSync 表示同步写入，如下所示。</span></p><p data-lake-id=\"ue67094e8\" id=\"ue67094e8\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cnfs.writeFileSync(%5C%222.txt%5C%22%2C%20%5C%22Hello%20world%5C%22)%5Cnlet%20data%20%3D%20fs.readFileSync(%5C%222.txt%5C%22%2C%20%5C%22utf8%5C%22)%5Cnconsole.log(data)%20%2F%2F%20Hello%20world%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22389de4e2%22%7D\"></card><p data-lake-id=\"uc62ec377\" id=\"uc62ec377\"><br></p><ul list=\"uf5b60d95\"><li fid=\"u4d4fee96\" data-lake-id=\"u5e8dcee9\" id=\"u5e8dcee9\"><span data-lake-id=\"u03574dad\" id=\"u03574dad\">第一个参数为写入文件的路径或文件描述符。</span></li><li fid=\"u4d4fee96\" data-lake-id=\"u2a8f6fbb\" id=\"u2a8f6fbb\"><span data-lake-id=\"u63a37989\" id=\"u63a37989\">第二个参数为写入的数据，类型为 String 或 Buffer。</span></li><li fid=\"u4d4fee96\" data-lake-id=\"u946e8eff\" id=\"u946e8eff\"><span data-lake-id=\"u93c2ce3b\" id=\"u93c2ce3b\">第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding。</span></li></ul><p data-lake-id=\"uc7da433d\" id=\"uc7da433d\"><br></p><p data-lake-id=\"u0dfac5fd\" id=\"u0dfac5fd\"><span data-lake-id=\"u1a7cb759\" id=\"u1a7cb759\">writeFile 表示异步写入，writeFile 与 writeFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件写入数据成功后执行。</span></p><p data-lake-id=\"u7df698e1\" id=\"u7df698e1\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cnfs.writeFile(%5C%222.txt%5C%22%2C%20%5C%22Hello%20world%5C%22%2C%20err%20%3D%3E%20%7B%5Cn%20%20%20%20if%20(!err)%20%7B%5Cn%20%20%20%20%20%20%20%20fs.readFile(%5C%222.txt%5C%22%2C%20%5C%22utf8%5C%22%2C%20(err%2C%20data)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20console.log(data)%20%2F%2F%20Hello%20world%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%7D%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22fa2ec1ae%22%7D\"></card><p data-lake-id=\"u17ebc7d3\" id=\"u17ebc7d3\"><br></p><h3 data-lake-id=\"5b6754f5\" id=\"5b6754f5\"><span data-lake-id=\"ua7f58d26\" id=\"ua7f58d26\">4.3.3 文件追加写入</span></h3><p data-lake-id=\"u50fe4bfe\" id=\"u50fe4bfe\"><br></p><p data-lake-id=\"ue8900591\" id=\"ue8900591\"><span data-lake-id=\"uc37e69c3\" id=\"uc37e69c3\">文件追加写入需要用到 appendFileSync 和 appendFile 两个方法。appendFileSync 表示同步写入，如下。</span></p><p data-lake-id=\"ub8188dd7\" id=\"ub8188dd7\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cnfs.appendFileSync(%5C%223.txt%5C%22%2C%20%5C%22%20world%5C%22)%5Cnlet%20data%20%3D%20fs.readFileSync(%5C%223.txt%5C%22%2C%20%5C%22utf8%5C%22)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22b539a81c%22%7D\"></card><p data-lake-id=\"u9f61f95c\" id=\"u9f61f95c\"><br></p><ul list=\"u7e462bce\"><li fid=\"u6409ddfa\" data-lake-id=\"u1613e319\" id=\"u1613e319\"><span data-lake-id=\"uac20eb6b\" id=\"uac20eb6b\">第一个参数为写入文件的路径或文件描述符。</span></li><li fid=\"u6409ddfa\" data-lake-id=\"u47e32315\" id=\"u47e32315\"><span data-lake-id=\"u79c2f947\" id=\"u79c2f947\">第二个参数为写入的数据，类型为 String 或 Buffer。</span></li><li fid=\"u6409ddfa\" data-lake-id=\"uc77d87e5\" id=\"uc77d87e5\"><span data-lake-id=\"u1013d3ce\" id=\"u1013d3ce\">第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding。</span></li></ul><p data-lake-id=\"u88e776c2\" id=\"u88e776c2\"><br></p><p data-lake-id=\"uc3c60ba0\" id=\"uc3c60ba0\"><span data-lake-id=\"uec54a76b\" id=\"uec54a76b\">appendFile 表示异步追加写入，方法 appendFile 与 appendFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件追加写入数据成功后执行，如下所示。</span></p><p data-lake-id=\"u5daf20d0\" id=\"u5daf20d0\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cnfs.appendFile(%5C%223.txt%5C%22%2C%20%5C%22%20world%5C%22%2C%20err%20%3D%3E%20%7B%5Cn%20%20%20%20if%20(!err)%20%7B%5Cn%20%20%20%20%20%20%20%20fs.readFile(%5C%223.txt%5C%22%2C%20%5C%22utf8%5C%22%2C%20(err%2C%20data)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20console.log(data)%20%2F%2F%20Hello%20world%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%7D%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22dd90beea%22%7D\"></card><p data-lake-id=\"ua904b351\" id=\"ua904b351\"><br></p><h3 data-lake-id=\"b936db03\" id=\"b936db03\"><span data-lake-id=\"u18ceccc6\" id=\"u18ceccc6\">4.3.4 创建目录</span></h3><p data-lake-id=\"uae5e94e3\" id=\"uae5e94e3\"><br></p><p data-lake-id=\"u05efe491\" id=\"u05efe491\"><span data-lake-id=\"u951f3e1d\" id=\"u951f3e1d\">创建目录主要有 mkdirSync 和 mkdir 两个方法。其中，mkdirSync 为同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常。</span></p><p data-lake-id=\"uba872c08\" id=\"uba872c08\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%81%87%E8%AE%BE%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%BA%86%20a%20%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%20a%20%E4%B8%8B%E7%9A%84%20b%20%E6%96%87%E4%BB%B6%E5%A4%B9%5Cnfs.mkdirSync(%5C%22a%2Fb%2Fc%5C%22)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2239b76651%22%7D\"></card><p data-lake-id=\"u9f17a9e0\" id=\"u9f17a9e0\"><br></p><p data-lake-id=\"u8caed4fd\" id=\"u8caed4fd\"><span data-lake-id=\"u0aeaf419\" id=\"u0aeaf419\">mkdir 为异步创建，第二个参数为回调函数，如下所示。</span></p><p data-lake-id=\"u2ab7556f\" id=\"u2ab7556f\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22fs.mkdir(%5C%22a%2Fb%2Fc%5C%22%2C%20err%20%3D%3E%20%7B%5Cn%20%20%20%20if%20(!err)%20console.log(%5C%22%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F%5C%22)%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22dc45f69e%22%7D\"></card><p data-lake-id=\"u056123dc\" id=\"u056123dc\"><br></p><h1 data-lake-id=\"3d21eed3\" id=\"3d21eed3\"><span data-lake-id=\"u4f3adec3\" id=\"u4f3adec3\">五、谈谈你对 Stream 的理解</span></h1><p data-lake-id=\"ub85b833b\" id=\"ub85b833b\"><br></p><h2 data-lake-id=\"d4b7a6c3\" id=\"d4b7a6c3\"><span data-lake-id=\"u1810ec4b\" id=\"u1810ec4b\">5.1 基本概念</span></h2><p data-lake-id=\"u0c7baaaa\" id=\"u0c7baaaa\"><br></p><p data-lake-id=\"u8f9fb53c\" id=\"u8f9fb53c\"><span data-lake-id=\"ua2b35a74\" id=\"ua2b35a74\">流（Stream）是一种数据传输的手段，是一种端到端信息交换的方式，而且是有顺序的，是逐块读取数据、处理内容，用于顺序读取输入或写入输出。在 Node 中，Stream 分成三部分：source、dest、pipe。</span></p><p data-lake-id=\"u86a8f7a8\" id=\"u86a8f7a8\"><span data-lake-id=\"u23da6b4e\" id=\"u23da6b4e\"><br /></span><span data-lake-id=\"ue06f728e\" id=\"ue06f728e\">其中，在 source 和 dest 之间有一个连接的管道 pipe，它的基本语法是 source.pipe(dest)，source 和 dest 就是通过 pipe 连接，让数据从 source 流向 dest，如下图所示：</span></p><p data-lake-id=\"u49eefe9e\" id=\"u49eefe9e\"><span data-lake-id=\"u1ec5ebab\" id=\"u1ec5ebab\"> </span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776316-ec2753d3-05e5-475e-987b-b79ac8d11923.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Du0f84404c%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D311%26originWidth%3D352%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Du1b177b68-1c96-4214-87fa-097ee0ec21f%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A352%2C%22originHeight%22%3A311%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22e7iAA%22%7D\"></card></p><p data-lake-id=\"u78a6d595\" id=\"u78a6d595\"><br></p><h2 data-lake-id=\"d52b149f\" id=\"d52b149f\"><span data-lake-id=\"u5f5518ab\" id=\"u5f5518ab\">5.2 流的分类</span></h2><p data-lake-id=\"uecd686f8\" id=\"uecd686f8\"><br></p><p data-lake-id=\"uaa3b2116\" id=\"uaa3b2116\"><span data-lake-id=\"ua6367e3c\" id=\"ua6367e3c\">在 Node，流可以分成四个种类：</span></p><p data-lake-id=\"u4d292dc7\" id=\"u4d292dc7\"><br></p><ul list=\"u3ff3d978\"><li fid=\"u53deafe2\" data-lake-id=\"ud98cea51\" id=\"ud98cea51\"><strong><span data-lake-id=\"ua010d8a9\" id=\"ua010d8a9\">可写流</span></strong><span data-lake-id=\"ufca71c19\" id=\"ufca71c19\">：可写入数据的流，例如 fs.createWriteStream() 可以使用流将数据写入文件。</span></li><li fid=\"u53deafe2\" data-lake-id=\"u878829c1\" id=\"u878829c1\"><strong><span data-lake-id=\"uf2dbacfd\" id=\"uf2dbacfd\">可读流</span></strong><span data-lake-id=\"ueac9fb8f\" id=\"ueac9fb8f\">： 可读取数据的流，例如 fs.createReadStream() 可以从文件读取内容。</span></li><li fid=\"u53deafe2\" data-lake-id=\"ua660b003\" id=\"ua660b003\"><strong><span data-lake-id=\"u3e90b41e\" id=\"u3e90b41e\">双工流</span></strong><span data-lake-id=\"u89b4cb38\" id=\"u89b4cb38\">： 既可读又可写的流，例如 net.Socket。</span></li><li fid=\"u53deafe2\" data-lake-id=\"u95aa2584\" id=\"u95aa2584\"><strong><span data-lake-id=\"u5bdc265c\" id=\"u5bdc265c\">转换流</span></strong><span data-lake-id=\"u7bbdf0a4\" id=\"u7bbdf0a4\">： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据。</span></li></ul><p data-lake-id=\"u01862e3e\" id=\"u01862e3e\"><br></p><p data-lake-id=\"u720d84d2\" id=\"u720d84d2\"><span data-lake-id=\"u26ecc251\" id=\"u26ecc251\">在 Node 的 HTTP 服务器模块中，request 是可读流，response 是可写流。对于 fs 模块来说，能同时处理可读和可写文件流可读流和可写流都是单向的，比较容易理解。而 Socket 是双向的，可读可写。</span></p><p data-lake-id=\"u83469b7a\" id=\"u83469b7a\"><br></p><h3 data-lake-id=\"9c010904\" id=\"9c010904\"><span data-lake-id=\"u475d4e0e\" id=\"u475d4e0e\">5.2.1 双工流</span></h3><p data-lake-id=\"u12b4624b\" id=\"u12b4624b\"><br></p><p data-lake-id=\"ua8e6477e\" id=\"ua8e6477e\"><span data-lake-id=\"uae5de2f5\" id=\"uae5de2f5\">在 Node 中，比较的常见的全双工通信就是 websocket，因为发送方和接受方都是各自独立的方法，发送和接收都没有任何关系。 </span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776316-96152afb-5799-49e4-ac4a-c792f1da517c.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Duf71601d0%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D191%26originWidth%3D500%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Duc8cbaf81-b3a4-4be0-9bb8-87d66a6e85c%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A500%2C%22originHeight%22%3A191%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22DyHvq%22%7D\"></card><span data-lake-id=\"u4aa07ff5\" id=\"u4aa07ff5\"> 基本的使用方法如下：</span></p><p data-lake-id=\"uefafeb9d\" id=\"uefafeb9d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20%7B%20Duplex%20%7D%20%3D%20require(%5C%22stream%5C%22)%5Cn%5Cnconst%20myDuplex%20%3D%20new%20Duplex(%7B%5Cn%20%20%20%20read(size)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20...%5Cn%20%20%20%20%7D%2C%5Cn%20%20%20%20write(chunk%2C%20encoding%2C%20callback)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20...%5Cn%20%20%20%20%7D%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2216e17564%22%7D\"></card><p data-lake-id=\"ua61c7713\" id=\"ua61c7713\"><br></p><h2 data-lake-id=\"513831a5\" id=\"513831a5\"><span data-lake-id=\"ua963318b\" id=\"ua963318b\">5.3 使用场景</span></h2><p data-lake-id=\"u272088f8\" id=\"u272088f8\"><br></p><p data-lake-id=\"u3e074365\" id=\"u3e074365\"><span data-lake-id=\"u5ff0d4d2\" id=\"u5ff0d4d2\">流的常见使用场景有：</span></p><p data-lake-id=\"u765e2372\" id=\"u765e2372\"><br></p><ul list=\"u5e8707aa\"><li fid=\"ua081cfa2\" data-lake-id=\"u80a304e6\" id=\"u80a304e6\"><span data-lake-id=\"ubfceda10\" id=\"ubfceda10\">get 请求返回文件给客户端</span></li><li fid=\"ua081cfa2\" data-lake-id=\"u85075518\" id=\"u85075518\"><span data-lake-id=\"u12825b1d\" id=\"u12825b1d\">文件操作</span></li><li fid=\"ua081cfa2\" data-lake-id=\"u5c1247e8\" id=\"u5c1247e8\"><span data-lake-id=\"ubb2ce02a\" id=\"ubb2ce02a\">一些打包工具的底层操作</span></li></ul><p data-lake-id=\"u430e2555\" id=\"u430e2555\"><br></p><h3 data-lake-id=\"fe9be06e\" id=\"fe9be06e\"><span data-lake-id=\"uff75ae98\" id=\"uff75ae98\">5.3.1 网络请求</span></h3><p data-lake-id=\"u23ef2900\" id=\"u23ef2900\"><br></p><p data-lake-id=\"ud3a89473\" id=\"ud3a89473\"><span data-lake-id=\"ue889f7c8\" id=\"ue889f7c8\">流一个常见的使用场景就是网络请求，比如使用 stream 流返回文件，res 也是一个 stream 对象，通过 pipe 管道将文件数据返回。</span></p><p data-lake-id=\"ud1588f48\" id=\"ud1588f48\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20server%20%3D%20http.createServer(function%20(req%2C%20res)%20%7B%5Cn%20%20%20%20const%20method%20%3D%20req.method%5Cn%20%20%20%20%2F%2F%20get%20%E8%AF%B7%E6%B1%82%5Cn%20%20%20%20if%20(method%20%3D%3D%3D%20%5C%22GET%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20const%20fileName%20%3D%20path.resolve(__dirname%2C%20%5C%22data.txt%5C%22)%5Cn%20%20%20%20%20%20%20%20let%20stream%20%3D%20fs.createReadStream(fileName)%5Cn%20%20%20%20%20%20%20%20stream.pipe(res)%5Cn%20%20%20%20%7D%5Cn%7D)%5Cnserver.listen(8080)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%225365cf98%22%7D\"></card><p data-lake-id=\"u0a8afbfa\" id=\"u0a8afbfa\"><br></p><h3 data-lake-id=\"e4795cb4\" id=\"e4795cb4\"><span data-lake-id=\"u39dbbc8b\" id=\"u39dbbc8b\">5.3.2 文件操作</span></h3><p data-lake-id=\"u76d86c2e\" id=\"u76d86c2e\"><br></p><p data-lake-id=\"ub3f45a95\" id=\"ub3f45a95\"><span data-lake-id=\"u4a469e24\" id=\"u4a469e24\">文件的读取也是流操作，创建一个可读数据流 readStream，一个可写数据流 writeStream，通过 pipe 管道把数据流转过去。</span></p><p data-lake-id=\"u9ac859ba\" id=\"u9ac859ba\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cnconst%20path%20%3D%20require(%5C%22path%5C%22)%5Cn%5Cn%2F%2F%20%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%90%8D%5Cnconst%20fileName1%20%3D%20path.resolve(__dirname%2C%20%5C%22data.txt%5C%22)%5Cnconst%20fileName2%20%3D%20path.resolve(__dirname%2C%20%5C%22data-bak.txt%5C%22)%5Cn%2F%2F%20%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%20stream%20%E5%AF%B9%E8%B1%A1%5Cnconst%20readStream%20%3D%20fs.createReadStream(fileName1)%5Cn%2F%2F%20%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E7%9A%84%20stream%20%E5%AF%B9%E8%B1%A1%5Cnconst%20writeStream%20%3D%20fs.createWriteStream(fileName2)%5Cn%2F%2F%20%E9%80%9A%E8%BF%87%20pipe%E6%89%A7%E8%A1%8C%E6%8B%B7%E8%B4%9D%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC%5CnreadStream.pipe(writeStream)%5Cn%2F%2F%20%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E5%AE%8C%E6%88%90%E7%9B%91%E5%90%AC%EF%BC%8C%E5%8D%B3%E6%8B%B7%E8%B4%9D%E5%AE%8C%E6%88%90%5CnreadStream.on(%5C%22end%5C%22%2C%20function%20()%20%7B%5Cn%20%20%20%20console.log(%5C%22%E6%8B%B7%E8%B4%9D%E5%AE%8C%E6%88%90%5C%22)%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%223c9cc257%22%7D\"></card><p data-lake-id=\"u510a54ba\" id=\"u510a54ba\"><br></p><p data-lake-id=\"u05457edf\" id=\"u05457edf\"><span data-lake-id=\"u0fd46cdc\" id=\"u0fd46cdc\">另外，一些打包工具，Webpack 和 Vite 等都涉及很多流的操作。</span></p><p data-lake-id=\"udd643c2c\" id=\"udd643c2c\"><br></p><h1 data-lake-id=\"7dea4013\" id=\"7dea4013\"><span data-lake-id=\"ucd6f2e54\" id=\"ucd6f2e54\">六、事件循环机制</span></h1><p data-lake-id=\"u4a8e6a08\" id=\"u4a8e6a08\"><br></p><h2 data-lake-id=\"31308610\" id=\"31308610\"><span data-lake-id=\"u37f864d8\" id=\"u37f864d8\">6.1 什么是浏览器事件循环</span></h2><p data-lake-id=\"uf702f07f\" id=\"uf702f07f\"><br></p><p data-lake-id=\"u941a8dec\" id=\"u941a8dec\"><span data-lake-id=\"u5e12701c\" id=\"u5e12701c\">Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</span></p><p data-lake-id=\"ub9e94e4c\" id=\"ub9e94e4c\"><span data-lake-id=\"u4ee8355e\" id=\"u4ee8355e\"><br /></span><span data-lake-id=\"ued735da6\" id=\"ued735da6\">当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)，其运行原理如下图所示。<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776762-39a74481-73e0-45f4-b0a7-c509ef0b3358.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Du0c77ed56%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D316%26originWidth%3D800%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Ducae1209f-930b-4741-820d-2ffe75c4935%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A800%2C%22originHeight%22%3A316%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22cKJ7V%22%7D\"></card><span data-lake-id=\"u008a5553\" id=\"u008a5553\"> 从左到右，从上到下，Node.js 被分为了四层，分别是 应用层、V8 引擎层、Node API 层 和 LIBUV 层。</span></p><p data-lake-id=\"u14c998eb\" id=\"u14c998eb\"><br></p><ul list=\"u332d82a3\"><li fid=\"u8eaa42bc\" data-lake-id=\"u67b2837a\" id=\"u67b2837a\"><strong><span data-lake-id=\"ua75503af\" id=\"ua75503af\">应用层</span></strong><span data-lake-id=\"u12af369d\" id=\"u12af369d\">： 即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 http，fs</span></li><li fid=\"u8eaa42bc\" data-lake-id=\"u644f869e\" id=\"u644f869e\"><strong><span data-lake-id=\"u5efc0a9f\" id=\"u5efc0a9f\">V8 引擎层</span></strong><span data-lake-id=\"ub8cacf99\" id=\"ub8cacf99\">： 即利用 V8 引擎来解析 JavaScript 语法，进而和下层 API 交互</span></li><li fid=\"u8eaa42bc\" data-lake-id=\"u2a9031ed\" id=\"u2a9031ed\"><strong><span data-lake-id=\"u849d8b6c\" id=\"u849d8b6c\">Node API 层</span></strong><span data-lake-id=\"u71045d76\" id=\"u71045d76\">： 为上层模块提供系统调用，一般是由 C 语言来实现，和操作系统进行交互 。</span></li><li fid=\"u8eaa42bc\" data-lake-id=\"u3997af0d\" id=\"u3997af0d\"><strong><span data-lake-id=\"u49e1dc8c\" id=\"u49e1dc8c\">LIBUV 层</span></strong><span data-lake-id=\"udb8020b2\" id=\"udb8020b2\">： 是跨平台的底层封装，实现了 事件循环、文件操作等，是 Node.js 实现异步的核心 。</span></li></ul><p data-lake-id=\"uf39bf341\" id=\"uf39bf341\"><br></p><p data-lake-id=\"ucba1aa91\" id=\"ucba1aa91\"><span data-lake-id=\"u8f3b2e06\" id=\"u8f3b2e06\">在 Node 中，我们所说的事件循环是基于 libuv 实现的，libuv 是一个多平台的专注于异步 IO 的库。上图的 EVENT_QUEUE 给人看起来只有一个队列，但事实上 EventLoop 存在 6 个阶段，每个阶段都有对应的一个先进先出的回调队列。</span></p><p data-lake-id=\"u76812caa\" id=\"u76812caa\"><br></p><h2 data-lake-id=\"fd2efd28\" id=\"fd2efd28\"><span data-lake-id=\"ub1448b3b\" id=\"ub1448b3b\">6.2 事件循环的六个阶段</span></h2><p data-lake-id=\"uf5590380\" id=\"uf5590380\"><br></p><p data-lake-id=\"u4a58bc3f\" id=\"u4a58bc3f\"><span data-lake-id=\"u79404df6\" id=\"u79404df6\">事件循环一共可以分成了六个阶段，如下图所示。 </span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776842-ddc16b06-3ced-4c9d-af77-41a1bef3eed7.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Duc1b560a1%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D414%26originWidth%3D670%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Du0abf45b3-21f7-4925-9910-0ccee24f01f%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A670%2C%22originHeight%22%3A414%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22k48OI%22%7D\"></card></p><p data-lake-id=\"ubf13a481\" id=\"ubf13a481\"><br></p><ul list=\"uc7c7e3e5\"><li fid=\"u1ade3262\" data-lake-id=\"uaa144ec1\" id=\"uaa144ec1\"><span data-lake-id=\"u04c75357\" id=\"u04c75357\">timers 阶段：此阶段主要执行 timer（setTimeout、setInterval）的回调。</span></li><li fid=\"u1ade3262\" data-lake-id=\"u2fd2a3cd\" id=\"u2fd2a3cd\"><span data-lake-id=\"uc900895a\" id=\"uc900895a\">I/O 事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些 I/O 回调。</span></li><li fid=\"u1ade3262\" data-lake-id=\"u8714a9f7\" id=\"u8714a9f7\"><span data-lake-id=\"u35ff846e\" id=\"u35ff846e\">闲置阶段(idle、prepare)：仅系统内部使用。</span></li><li fid=\"u1ade3262\" data-lake-id=\"ube39f2fb\" id=\"ube39f2fb\"><span data-lake-id=\"u2b14c4c8\" id=\"u2b14c4c8\">轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</span></li><li fid=\"u1ade3262\" data-lake-id=\"u70b4d556\" id=\"u70b4d556\"><span data-lake-id=\"u43176239\" id=\"u43176239\">检查阶段(check)：setImmediate() 回调函数在这里执行</span></li><li fid=\"u1ade3262\" data-lake-id=\"u80854589\" id=\"u80854589\"><span data-lake-id=\"u7dac4209\" id=\"u7dac4209\">关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)</span></li></ul><p data-lake-id=\"u6c219dd5\" id=\"u6c219dd5\"><br></p><p data-lake-id=\"u9f4eb7bd\" id=\"u9f4eb7bd\"><span data-lake-id=\"u68388762\" id=\"u68388762\">每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段，如下图所示。 </span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776814-ea6ed8b4-5eb8-44f7-ba02-ffc37686b00f.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Dub6591ff1%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D613%26originWidth%3D703%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Du5750c350-d871-4e63-861a-a422c186d3a%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A703%2C%22originHeight%22%3A613%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22gmy0w%22%7D\"></card></p><p data-lake-id=\"uee1d5529\" id=\"uee1d5529\"><br></p><h1 data-lake-id=\"50dfc512\" id=\"50dfc512\"><span data-lake-id=\"uf0cf8db5\" id=\"uf0cf8db5\">七、EventEmitter</span></h1><p data-lake-id=\"udd35618f\" id=\"udd35618f\"><br></p><h2 data-lake-id=\"9729e412\" id=\"9729e412\"><span data-lake-id=\"u43ccf264\" id=\"u43ccf264\">7.1 基本概念</span></h2><p data-lake-id=\"u7f67d359\" id=\"u7f67d359\"><br></p><p data-lake-id=\"uaa19f13a\" id=\"uaa19f13a\"><span data-lake-id=\"u9f050c57\" id=\"u9f050c57\">前文说过，Node 采用了事件驱动机制，而 EventEmitter 就是 Node 实现事件驱动的基础。在 EventEmitter 的基础上，Node 几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定、触发监听器，实现了异步操作。</span></p><p data-lake-id=\"ucf208608\" id=\"ucf208608\"><span data-lake-id=\"u355e4454\" id=\"u355e4454\"><br /></span><span data-lake-id=\"uaae97c69\" id=\"uaae97c69\">Node.js 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件，这些产生事件的对象都是 events.EventEmitter 的实例，用于将一个或多个函数绑定到命名事件上。</span></p><p data-lake-id=\"ua8250389\" id=\"ua8250389\"><br></p><h2 data-lake-id=\"80390061\" id=\"80390061\"><span data-lake-id=\"u557abcdf\" id=\"u557abcdf\">7.2 基本使用</span></h2><p data-lake-id=\"u869dc699\" id=\"u869dc699\"><br></p><p data-lake-id=\"u4163e078\" id=\"u4163e078\"><span data-lake-id=\"uba727b27\" id=\"uba727b27\">Node 的 events 模块只提供了一个 EventEmitter 类，这个类实现了 Node 异步事件驱动架构的基本模式：观察者模式。</span></p><p data-lake-id=\"u429935dc\" id=\"u429935dc\"><span data-lake-id=\"u80b15553\" id=\"u80b15553\"><br /></span><span data-lake-id=\"ubb68aeea\" id=\"ubb68aeea\">在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新会依次通知观察者，使用方式如下。</span></p><p data-lake-id=\"uc0a3dfc3\" id=\"uc0a3dfc3\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20EventEmitter%20%3D%20require(%5C%22events%5C%22)%5Cn%5Cnclass%20MyEmitter%20extends%20EventEmitter%20%7B%7D%5Cnconst%20myEmitter%20%3D%20new%20MyEmitter()%5Cn%5Cnfunction%20callback()%20%7B%5Cn%20%20%20%20console.log(%5C%22%E8%A7%A6%E5%8F%91%E4%BA%86event%E4%BA%8B%E4%BB%B6%EF%BC%81%5C%22)%5Cn%7D%5CnmyEmitter.on(%5C%22event%5C%22%2C%20callback)%5CnmyEmitter.emit(%5C%22event%5C%22)%5CnmyEmitter.removeListener(%5C%22event%5C%22%2C%20callback)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22fdbfe087%22%7D\"></card><p data-lake-id=\"u4cdafbc6\" id=\"u4cdafbc6\"><br></p><p data-lake-id=\"u26d7727c\" id=\"u26d7727c\"><span data-lake-id=\"u3b76c4f2\" id=\"u3b76c4f2\">在上面的代码中，我们通过实例对象的 on 方法注册一个名为 event 的事件，通过 emit 方法触发该事件，而 removeListener 用于取消事件的监听。<br /></span><span data-lake-id=\"u8195ade8\" id=\"u8195ade8\">除了上面介绍的一些方法外，其他常用的方法还有如下一些：</span></p><p data-lake-id=\"u06b2e808\" id=\"u06b2e808\"><br></p><ul list=\"u84a385a1\"><li fid=\"u25f33bc7\" data-lake-id=\"ubd6135e7\" id=\"ubd6135e7\"><span data-lake-id=\"u7fb0f7b6\" id=\"u7fb0f7b6\">emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部。</span></li><li fid=\"u25f33bc7\" data-lake-id=\"uc889b39d\" id=\"uc889b39d\"><span data-lake-id=\"ua9245036\" id=\"ua9245036\">emitter.prependListener(eventName, listener)</span><span data-lake-id=\"uf3488796\" id=\"uf3488796\">：添加类型为 eventName 的监听事件到事件数组头部。</span></li><li fid=\"u25f33bc7\" data-lake-id=\"ud938db95\" id=\"ud938db95\"><span data-lake-id=\"u85f5c8f8\" id=\"u85f5c8f8\">emitter.emit(eventName[, ...args])</span><span data-lake-id=\"ueaeb1317\" id=\"ueaeb1317\">：触发类型为 eventName 的监听事件。</span></li><li fid=\"u25f33bc7\" data-lake-id=\"u56f407e9\" id=\"u56f407e9\"><span data-lake-id=\"ua8e478de\" id=\"ua8e478de\">emitter.removeListener/off(eventName, listener)</span><span data-lake-id=\"u9dcee64c\" id=\"u9dcee64c\">：移除类型为 eventName 的监听事件。</span></li><li fid=\"u25f33bc7\" data-lake-id=\"u9fa75ca3\" id=\"u9fa75ca3\"><span data-lake-id=\"u7f178324\" id=\"u7f178324\">emitter.once(eventName, listener)</span><span data-lake-id=\"ubbede486\" id=\"ubbede486\">：添加类型为 eventName 的监听事件，以后只能执行一次并删除。</span></li><li fid=\"u25f33bc7\" data-lake-id=\"u6e047d53\" id=\"u6e047d53\"><span data-lake-id=\"uf606636f\" id=\"uf606636f\">emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件。</span></li></ul><p data-lake-id=\"u8af3d3cc\" id=\"u8af3d3cc\"><br></p><h2 data-lake-id=\"a25f2215\" id=\"a25f2215\"><span data-lake-id=\"udf77eed6\" id=\"udf77eed6\">7.3 实现原理</span></h2><p data-lake-id=\"u7893785f\" id=\"u7893785f\"><br></p><p data-lake-id=\"ub03d1e66\" id=\"ub03d1e66\"><span data-lake-id=\"u220720cf\" id=\"u220720cf\">EventEmitter 其实是一个构造函数，内部存在一个包含所有事件的对象。</span></p><p data-lake-id=\"u12dac5cf\" id=\"u12dac5cf\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20EventEmitter%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20this.events%20%3D%20%7B%7D%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%225b5ba724%22%7D\"></card><p data-lake-id=\"uc992c1a9\" id=\"uc992c1a9\"><br></p><p data-lake-id=\"u207f2713\" id=\"u207f2713\"><span data-lake-id=\"ueace7175\" id=\"ueace7175\">其中，events 存放的监听事件的函数的结构如下：</span></p><p data-lake-id=\"ucba412f5\" id=\"ucba412f5\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%7B%5Cn%20%20%5C%22event1%5C%22%3A%20%5Bf1%2Cf2%2Cf3%5D%EF%BC%8C%5Cn%20%20%5C%22event2%5C%22%3A%20%5Bf4%2Cf5%5D%EF%BC%8C%5Cn%20%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22984aa5f0%22%7D\"></card><p data-lake-id=\"u9b59b320\" id=\"u9b59b320\"><br></p><p data-lake-id=\"u4401338c\" id=\"u4401338c\"><span data-lake-id=\"u87606f77\" id=\"u87606f77\">然后，开始一步步实现实例方法，首先是 emit，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</span></p><p data-lake-id=\"ue535ee73\" id=\"ue535ee73\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22emit(type%2C%20...args)%20%7B%5Cn%20%20%20%20this.events%5Btype%5D.forEach((item)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20Reflect.apply(item%2C%20this%2C%20args)%3B%5Cn%20%20%20%20%7D)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2234d6f80c%22%7D\"></card><p data-lake-id=\"u740ef1a5\" id=\"u740ef1a5\"><br></p><p data-lake-id=\"u70e45741\" id=\"u70e45741\"><span data-lake-id=\"u9094ad4f\" id=\"u9094ad4f\">实现了 emit 方法之后，然后依次实现 on、addListener、prependListener 这三个实例方法，它们都是添加事件监听触发函数的。</span></p><p data-lake-id=\"u1ca01caa\" id=\"u1ca01caa\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22on(type%2C%20handler)%20%7B%5Cn%20%20%20%20if%20(!this.events%5Btype%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20this.events%5Btype%5D%20%3D%20%5B%5D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.events%5Btype%5D.push(handler)%3B%5Cn%7D%5Cn%5CnaddListener(type%2Chandler)%7B%5Cn%20%20%20%20this.on(type%2Chandler)%5Cn%7D%5Cn%5CnprependListener(type%2C%20handler)%20%7B%5Cn%20%20%20%20if%20(!this.events%5Btype%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20this.events%5Btype%5D%20%3D%20%5B%5D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.events%5Btype%5D.unshift(handler)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%220a88d6df%22%7D\"></card><p data-lake-id=\"u067e6b17\" id=\"u067e6b17\"><br></p><p data-lake-id=\"ueb653963\" id=\"ueb653963\"><span data-lake-id=\"u159d37b5\" id=\"u159d37b5\">实现 once 方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过 fired 属性值判断事件函数是否执行过。</span></p><p data-lake-id=\"uecd9a49e\" id=\"uecd9a49e\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22removeListener(type%2C%20handler)%20%7B%5Cn%20%20%20%20if%20(!this.events%5Btype%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20return%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.events%5Btype%5D%20%3D%20this.events%5Btype%5D.filter(item%20%3D%3E%20item%20!%3D%3D%20handler)%5Cn%7D%5Cn%5Cnoff(type%2Chandler)%7B%5Cn%20%20%20%20this.removeListener(type%2Chandler)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%223be3c752%22%7D\"></card><p data-lake-id=\"u6a848d68\" id=\"u6a848d68\"><br></p><p data-lake-id=\"u2b361610\" id=\"u2b361610\"><span data-lake-id=\"ua520aa81\" id=\"ua520aa81\">下面是完成的测试代码：</span></p><p data-lake-id=\"ubefe39ae\" id=\"ubefe39ae\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20EventEmitter%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20this.events%20%3D%20%7B%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20on(type%2C%20handler)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(!this.events%5Btype%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.events%5Btype%5D%20%3D%20%5B%5D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20this.events%5Btype%5D.push(handler)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20addListener(type%2C%20handler)%20%7B%5Cn%20%20%20%20%20%20%20%20this.on(type%2C%20handler)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20prependListener(type%2C%20handler)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(!this.events%5Btype%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.events%5Btype%5D%20%3D%20%5B%5D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20this.events%5Btype%5D.unshift(handler)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20removeListener(type%2C%20handler)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(!this.events%5Btype%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20this.events%5Btype%5D%20%3D%20this.events%5Btype%5D.filter(item%20%3D%3E%20item%20!%3D%3D%20handler)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20off(type%2C%20handler)%20%7B%5Cn%20%20%20%20%20%20%20%20this.removeListener(type%2C%20handler)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20emit(type%2C%20...args)%20%7B%5Cn%20%20%20%20%20%20%20%20this.events%5Btype%5D.forEach(item%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20Reflect.apply(item%2C%20this%2C%20args)%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20once(type%2C%20handler)%20%7B%5Cn%20%20%20%20%20%20%20%20this.on(type%2C%20this._onceWrap(type%2C%20handler%2C%20this))%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20_onceWrap(type%2C%20handler%2C%20target)%20%7B%5Cn%20%20%20%20%20%20%20%20const%20state%20%3D%20%7B%20fired%3A%20false%2C%20handler%2C%20type%2C%20target%20%7D%5Cn%20%20%20%20%20%20%20%20const%20wrapFn%20%3D%20this._onceWrapper.bind(state)%5Cn%20%20%20%20%20%20%20%20state.wrapFn%20%3D%20wrapFn%5Cn%20%20%20%20%20%20%20%20return%20wrapFn%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20_onceWrapper(...args)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(!this.fired)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.fired%20%3D%20true%5Cn%20%20%20%20%20%20%20%20%20%20%20%20Reflect.apply(this.handler%2C%20this.target%2C%20args)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.target.off(this.type%2C%20this.wrapFn)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2268459fc6%22%7D\"></card><p data-lake-id=\"u37b279ae\" id=\"u37b279ae\"><br></p><h1 data-lake-id=\"097f5f61\" id=\"097f5f61\"><span data-lake-id=\"ueb0a47ad\" id=\"ueb0a47ad\">八、中间件</span></h1><p data-lake-id=\"u9c1b83b6\" id=\"u9c1b83b6\"><br></p><h2 data-lake-id=\"54ec71ce\" id=\"54ec71ce\"><span data-lake-id=\"u45e77e1d\" id=\"u45e77e1d\">8.1 基本概念</span></h2><p data-lake-id=\"u0c7c8630\" id=\"u0c7c8630\"><br></p><p data-lake-id=\"u45a79b57\" id=\"u45a79b57\"><span data-lake-id=\"u93a0b141\" id=\"u93a0b141\">中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。 在 Node 中，中间件主要是指封装 http 请求细节处理的方法。例如，在 express、koa 等 web 框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数，架构示意图如下。<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776860-f2586f50-2de4-4f9b-b56e-7082c70b5070.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Du4c39c39c%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D412%26originWidth%3D913%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Du724dc371-8c3c-4fa1-83fe-2736bef4a90%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A913%2C%22originHeight%22%3A412%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22N5GxZ%22%7D\"></card><span data-lake-id=\"u2977ace5\" id=\"u2977ace5\"><br /></span><span data-lake-id=\"ue0956987\" id=\"ue0956987\">通常，在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作。</span></p><p data-lake-id=\"u5cb74889\" id=\"u5cb74889\"><br></p><h2 data-lake-id=\"7c87a55a\" id=\"7c87a55a\"><span data-lake-id=\"u757363b3\" id=\"u757363b3\">8.2 koa</span></h2><p data-lake-id=\"ufe2f3ef5\" id=\"ufe2f3ef5\"><br></p><p data-lake-id=\"u2158aa2f\" id=\"u2158aa2f\"><span data-lake-id=\"u083bd452\" id=\"u083bd452\">Koa 是基于 Node 当前比较流行的 web 框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助开发者快速而愉快地编写服务端应用程序。 </span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828776892-bff5e920-ac91-481f-9f57-4acf8664a57a.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Duc6948f4d%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D620%26originWidth%3D699%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Du20597ab3-78c2-4ca2-b232-c8b5c3caba6%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A699%2C%22originHeight%22%3A620%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22AZXtr%22%7D\"></card><span data-lake-id=\"u0d2d57b8\" id=\"u0d2d57b8\"><br /></span><span data-lake-id=\"u3d915821\" id=\"u3d915821\">Koa 中间件采用的是洋葱圈模型，每次执行下一个中间件都传入两个参数：</span></p><p data-lake-id=\"ud8762759\" id=\"ud8762759\"><br></p><ul list=\"u88b6d134\"><li fid=\"ued4087c8\" data-lake-id=\"u747c5e45\" id=\"u747c5e45\"><span data-lake-id=\"u2435dd45\" id=\"u2435dd45\">ctx ：封装了 request 和 response 的变量</span></li><li fid=\"ued4087c8\" data-lake-id=\"u25f71760\" id=\"u25f71760\"><span data-lake-id=\"uc909e759\" id=\"uc909e759\">next ：进入下一个要执行的中间件的函数</span></li></ul><p data-lake-id=\"ub3e1b64e\" id=\"ub3e1b64e\"><br></p><p data-lake-id=\"u77318e3f\" id=\"u77318e3f\"><span data-lake-id=\"u548358d5\" id=\"u548358d5\">通过前面的介绍，我们知道了 Koa 中间件本质上就是一个函数，可以是 async 函数，也可以是普通函数。下面就针对 koa 进行中间件的封装：</span></p><p data-lake-id=\"u65d13cf4\" id=\"u65d13cf4\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20async%20%E5%87%BD%E6%95%B0%5Cnapp.use(async%20(ctx%2C%20next)%20%3D%3E%20%7B%5Cn%20%20%20%20const%20start%20%3D%20Date.now()%5Cn%20%20%20%20await%20next()%5Cn%20%20%20%20const%20ms%20%3D%20Date.now()%20-%20start%5Cn%20%20%20%20console.log(%60%24%7Bctx.method%7D%20%24%7Bctx.url%7D%20-%20%24%7Bms%7Dms%60)%5Cn%7D)%5Cn%5Cn%2F%2F%20%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%5Cnapp.use((ctx%2C%20next)%20%3D%3E%20%7B%5Cn%20%20%20%20const%20start%20%3D%20Date.now()%5Cn%20%20%20%20return%20next().then(()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20const%20ms%20%3D%20Date.now()%20-%20start%5Cn%20%20%20%20%20%20%20%20console.log(%60%24%7Bctx.method%7D%20%24%7Bctx.url%7D%20-%20%24%7Bms%7Dms%60)%5Cn%20%20%20%20%7D)%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2208f263d6%22%7D\"></card><p data-lake-id=\"u6322cd89\" id=\"u6322cd89\"><br></p><p data-lake-id=\"u6d14e79e\" id=\"u6d14e79e\"><span data-lake-id=\"u8bc926aa\" id=\"u8bc926aa\">当然，我们还可以通过中间件封装 http 请求过程中几个常用的功能：</span></p><p data-lake-id=\"u0d9293cf\" id=\"u0d9293cf\"><br></p><p data-lake-id=\"ud27106d0\" id=\"ud27106d0\"><strong><span data-lake-id=\"uf872f3bb\" id=\"uf872f3bb\">token 校验</span></strong></p><p data-lake-id=\"u489c14a6\" id=\"u489c14a6\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22module.exports%20%3D%20(options)%20%3D%3E%20async%20(ctx%2C%20next)%20%7B%5Cn%20%20try%20%7B%5Cn%20%20%20%20%2F%2F%20%E8%8E%B7%E5%8F%96%20token%5Cn%20%20%20%20const%20token%20%3D%20ctx.header.authorization%5Cn%20%20%20%20if%20(token)%20%7B%5Cn%20%20%20%20%20%20try%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%2F%2F%20verify%20%E5%87%BD%E6%95%B0%E9%AA%8C%E8%AF%81%20token%EF%BC%8C%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%5Cn%20%20%20%20%20%20%20%20%20%20await%20verify(token)%5Cn%20%20%20%20%20%20%7D%20catch%20(err)%20%7B%5Cn%20%20%20%20%20%20%20%20console.log(err)%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F%2F%20%E8%BF%9B%E5%85%A5%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%B8%AD%E9%97%B4%E4%BB%B6%5Cn%20%20%20%20await%20next()%5Cn%20%20%7D%20catch%20(err)%20%7B%5Cn%20%20%20%20console.log(err)%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22543e5fd3%22%7D\"></card><p data-lake-id=\"uf03be165\" id=\"uf03be165\"><br></p><p data-lake-id=\"ub677f475\" id=\"ub677f475\"><strong><span data-lake-id=\"u84dccb03\" id=\"u84dccb03\">日志模块</span></strong></p><p data-lake-id=\"u0904a739\" id=\"u0904a739\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cnmodule.exports%20%3D%20options%20%3D%3E%20async%20(ctx%2C%20next)%20%3D%3E%20%7B%5Cn%20%20%20%20const%20startTime%20%3D%20Date.now()%5Cn%20%20%20%20const%20requestTime%20%3D%20new%20Date()%5Cn%20%20%20%20await%20next()%5Cn%20%20%20%20const%20ms%20%3D%20Date.now()%20-%20startTime%5Cn%20%20%20%20let%20logout%20%3D%20%60%24%7Bctx.request.ip%7D%20--%20%24%7BrequestTime%7D%20--%20%24%7Bctx.method%7D%20--%20%24%7Bctx.url%7D%20--%20%24%7Bms%7Dms%60%5Cn%20%20%20%20%2F%2F%20%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%5Cn%20%20%20%20fs.appendFileSync(%5C%22.%2Flog.txt%5C%22%2C%20logout%20%2B%20%5C%22%5C%5Cn%5C%22)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22ec4d92c5%22%7D\"></card><p data-lake-id=\"ud7262d99\" id=\"ud7262d99\"><br></p><p data-lake-id=\"u41e8e461\" id=\"u41e8e461\"><span data-lake-id=\"ua6035076\" id=\"ua6035076\">Koa 存在很多第三方的中间件，如 koa-bodyparser、koa-static 等。</span></p><p data-lake-id=\"u5a8e13a7\" id=\"u5a8e13a7\"><br></p><h2 data-lake-id=\"9edbeff9\" id=\"9edbeff9\"><span data-lake-id=\"u73517bd1\" id=\"u73517bd1\">8.3 Koa 中间件</span></h2><p data-lake-id=\"u4653f80e\" id=\"u4653f80e\"><br></p><p data-lake-id=\"ua725a010\" id=\"ua725a010\"><strong><span data-lake-id=\"u9ff476fd\" id=\"u9ff476fd\">koa-bodyparser</span></strong><span data-lake-id=\"u374ddc9d\" id=\"u374ddc9d\"> koa-bodyparser 中间件是将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body 上，方便我们在其他中间件或接口处取值。</span></p><p data-lake-id=\"u17d7e680\" id=\"u17d7e680\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E6%96%87%E4%BB%B6%EF%BC%9Amy-koa-bodyparser.js%5Cnconst%20querystring%20%3D%20require(%5C%22querystring%5C%22)%5Cn%5Cnmodule.exports%20%3D%20function%20bodyParser()%20%7B%5Cn%20%20%20%20return%20async%20(ctx%2C%20next)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20await%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E7%BB%84%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20dataArr%20%3D%20%5B%5D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%5Cn%20%20%20%20%20%20%20%20%20%20%20%20ctx.req.on(%5C%22data%5C%22%2C%20data%20%3D%3E%20dataArr.push(data))%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E6%95%B4%E5%90%88%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BD%BF%E7%94%A8%20Promise%20%E6%88%90%E5%8A%9F%5Cn%20%20%20%20%20%20%20%20%20%20%20%20ctx.req.on(%5C%22end%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%20json%20%E6%88%96%E8%A1%A8%E5%8D%95%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20contentType%20%3D%20ctx.get(%5C%22Content-Type%5C%22)%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%20Buffer%20%E6%A0%BC%E5%BC%8F%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20data%20%3D%20Buffer.concat(dataArr).toString()%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(contentType%20%3D%3D%3D%20%5C%22application%2Fx-www-form-urlencoded%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E6%98%AF%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%EF%BC%8C%E5%88%99%E5%B0%86%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E7%BB%99%20ctx.request.body%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ctx.request.body%20%3D%20querystring.parse(data)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20if%20(contentType%20%3D%3D%3D%20%5C%22applaction%2Fjson%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E6%98%AF%20json%EF%BC%8C%E5%88%99%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E7%BB%99%20ctx.request.body%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ctx.request.body%20%3D%20JSON.parse(data)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E6%89%A7%E8%A1%8C%E6%88%90%E5%8A%9F%E7%9A%84%E5%9B%9E%E8%B0%83%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20resolve()%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E7%BB%A7%E7%BB%AD%E5%90%91%E4%B8%8B%E6%89%A7%E8%A1%8C%5Cn%20%20%20%20%20%20%20%20await%20next()%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22481698ce%22%7D\"></card><p data-lake-id=\"u45be4a62\" id=\"u45be4a62\"><br></p><p data-lake-id=\"u723a589a\" id=\"u723a589a\"><strong><span data-lake-id=\"u067cbbeb\" id=\"u067cbbeb\">koa-static</span></strong><span data-lake-id=\"u27eb6821\" id=\"u27eb6821\"> koa-static 中间件的作用是在服务器接到请求时，帮我们处理静态文件，比如。</span></p><p data-lake-id=\"u440305fc\" id=\"u440305fc\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cnconst%20path%20%3D%20require(%5C%22path%5C%22)%5Cnconst%20mime%20%3D%20require(%5C%22mime%5C%22)%5Cnconst%20%7B%20promisify%20%7D%20%3D%20require(%5C%22util%5C%22)%5Cn%5Cn%2F%2F%20%E5%B0%86%20stat%20%E5%92%8C%20access%20%E8%BD%AC%E6%8D%A2%E6%88%90%20Promise%5Cnconst%20stat%20%3D%20promisify(fs.stat)%5Cnconst%20access%20%3D%20promisify(fs.access)%5Cn%5Cnmodule.exports%20%3D%20function%20(dir)%20%7B%5Cn%20%20%20%20return%20async%20(ctx%2C%20next)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%B0%86%E8%AE%BF%E9%97%AE%E7%9A%84%E8%B7%AF%E7%94%B1%E5%A4%84%E7%90%86%E6%88%90%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%8C%E8%BF%99%E9%87%8C%E8%A6%81%E4%BD%BF%E7%94%A8%20join%20%E5%9B%A0%E4%B8%BA%E6%9C%89%E5%8F%AF%E8%83%BD%E6%98%AF%20%2F%5Cn%20%20%20%20%20%20%20%20let%20realPath%20%3D%20path.join(dir%2C%20ctx.path)%5Cn%5Cn%20%20%20%20%20%20%20%20try%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%8E%B7%E5%8F%96%20stat%20%E5%AF%B9%E8%B1%A1%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20statObj%20%3D%20await%20stat(realPath)%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E6%98%AF%E6%96%87%E4%BB%B6%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%B9%B6%E7%9B%B4%E6%8E%A5%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9%EF%BC%8C%E5%90%A6%E5%88%99%E5%BD%93%E4%BD%9C%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AF%BB%E6%89%BE%20index.html%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(statObj.isFile())%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ctx.set(%5C%22Content-Type%5C%22%2C%20%60%24%7Bmime.getType()%7D%3Bcharset%3Dutf8%60)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ctx.body%20%3D%20fs.createReadStream(realPath)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20filename%20%3D%20path.join(realPath%2C%20%5C%22index.html%5C%22)%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%AF%A5%E6%96%87%E4%BB%B6%E5%88%99%E6%89%A7%E8%A1%8C%20catch%20%E4%B8%AD%E7%9A%84%20next%20%E4%BA%A4%E7%BB%99%E5%85%B6%E4%BB%96%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A4%84%E7%90%86%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20await%20access(filename)%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%AD%98%E5%9C%A8%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%B9%B6%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ctx.set(%5C%22Content-Type%5C%22%2C%20%5C%22text%2Fhtml%3Bcharset%3Dutf8%5C%22)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ctx.body%20%3D%20fs.createReadStream(filename)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%20catch%20(e)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20await%20next()%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22bdf862b0%22%7D\"></card><p data-lake-id=\"uda667179\" id=\"uda667179\"><br></p><p data-lake-id=\"u4b6b0d79\" id=\"u4b6b0d79\"><span data-lake-id=\"u4faa8f93\" id=\"u4faa8f93\">总的来说，在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据。</span></p><p data-lake-id=\"u39754fce\" id=\"u39754fce\"><br></p><h1 data-lake-id=\"480ee596\" id=\"480ee596\"><span data-lake-id=\"uc26fec41\" id=\"uc26fec41\">九、如何设计并实现 JWT 鉴权</span></h1><p data-lake-id=\"ube8d085c\" id=\"ube8d085c\"><br></p><h2 data-lake-id=\"7d9bbac5\" id=\"7d9bbac5\"><span data-lake-id=\"ue8861937\" id=\"ue8861937\">9.1 JWT 是什么</span></h2><p data-lake-id=\"u672962b6\" id=\"u672962b6\"><br></p><p data-lake-id=\"u2c40d786\" id=\"u2c40d786\"><span data-lake-id=\"u907d10ee\" id=\"u907d10ee\">JWT（JSON Web Token），本质就是一个字符串书写规范，作用是用来在用户和服务器之间传递安全可靠的，如下图。</span></p><p data-lake-id=\"ud33500c2\" id=\"ud33500c2\"><span data-lake-id=\"u50653316\" id=\"u50653316\">​</span><br></p><p data-lake-id=\"u9bdc02a4\" id=\"u9bdc02a4\"><span data-lake-id=\"uabc59800\" id=\"uabc59800\"> </span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828777364-f26cadff-b496-4390-888c-f915db496f3b.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Dudcd225de%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D166%26originWidth%3D695%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Du838a29dd-cbf2-4cbd-937d-afffc146266%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A695%2C%22originHeight%22%3A166%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22GT4zu%22%7D\"></card><span data-lake-id=\"uae1ac4eb\" id=\"uae1ac4eb\"> </span></p><p data-lake-id=\"u7330e614\" id=\"u7330e614\"><span data-lake-id=\"u597d6359\" id=\"u597d6359\">​</span><br></p><p data-lake-id=\"udecbbfea\" id=\"udecbbfea\"><span data-lake-id=\"uba907124\" id=\"uba907124\">在目前前后端分离的开发过程中，使用 token 鉴权机制用于身份验证是最常见的方案，流程如下：</span></p><p data-lake-id=\"u1be76739\" id=\"u1be76739\"><br></p><ul list=\"u42febac9\"><li fid=\"uf0f5a726\" data-lake-id=\"uf662ebc3\" id=\"uf662ebc3\"><span data-lake-id=\"ufad69fce\" id=\"ufad69fce\">服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证。</span></li><li fid=\"uf0f5a726\" data-lake-id=\"uba743b35\" id=\"uba743b35\"><span data-lake-id=\"ud726c462\" id=\"ud726c462\">后续访问会根据这个令牌判断用户时候有权限进行访问。</span></li></ul><p data-lake-id=\"u453322da\" id=\"u453322da\"><br></p><p data-lake-id=\"u619a497c\" id=\"u619a497c\"><span data-lake-id=\"u00cab533\" id=\"u00cab533\">Token，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以.进行拼接。其中头部和载荷都是以 JSON 格式存放数据，只是进行了编码，示意图如下。 </span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fwebp%2F732231%2F1648828777403-f4df86c4-d16b-4f91-bae8-e6e5b727bb53.webp%23clientId%3Duc25a66e0-829f-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26id%3Du9f25c564%26margin%3D%255Bobject%2520Object%255D%26originHeight%3D637%26originWidth%3D574%26originalType%3Durl%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26status%3Ddone%26style%3Dnone%26taskId%3Dua6a8a38c-f0bb-4346-aee1-9cbde264cb8%26title%3D%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A574%2C%22originHeight%22%3A637%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22AHjxY%22%7D\"></card></p><p data-lake-id=\"ube789f93\" id=\"ube789f93\"><br></p><h3 data-lake-id=\"bf7e3d7b\" id=\"bf7e3d7b\"><span data-lake-id=\"u8fd06bc3\" id=\"u8fd06bc3\">9.1.1 header</span></h3><p data-lake-id=\"u90935813\" id=\"u90935813\"><br></p><p data-lake-id=\"ud2f45240\" id=\"ud2f45240\"><span data-lake-id=\"u2c867bea\" id=\"u2c867bea\">每个 JWT 都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为 alg，同时还有一个 typ 的字段，默认 JWT 即可。以下示例中算法为 HS256：</span></p><p data-lake-id=\"ufbdf210d\" id=\"ufbdf210d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22json%22%2C%22code%22%3A%22%7B%20%5C%22alg%5C%22%3A%20%5C%22HS256%5C%22%2C%20%5C%22typ%5C%22%3A%20%5C%22JWT%5C%22%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%227d32605f%22%7D\"></card><p data-lake-id=\"u52d5b94e\" id=\"u52d5b94e\"><br></p><p data-lake-id=\"ufba4ffb8\" id=\"ufba4ffb8\"><span data-lake-id=\"u23a3d45d\" id=\"u23a3d45d\">因为 JWT 是字符串，所以我们还需要对以上内容进行 Base64 编码，编码后字符串如下：</span></p><p data-lake-id=\"udb039908\" id=\"udb039908\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22json%22%2C%22code%22%3A%22%7B%20%5C%22alg%5C%22%3A%20%5C%22HS256%5C%22%2C%20%5C%22typ%5C%22%3A%20%5C%22JWT%5C%22%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%227d32605f-1%22%7D\"></card><p data-lake-id=\"ua3697713\" id=\"ua3697713\"><br></p><h3 data-lake-id=\"74a378af\" id=\"74a378af\"><span data-lake-id=\"ua241602d\" id=\"ua241602d\">9.1.2 payload</span></h3><p data-lake-id=\"u7e5a0e28\" id=\"u7e5a0e28\"><br></p><p data-lake-id=\"u8619b589\" id=\"u8619b589\"><span data-lake-id=\"u5ba3699e\" id=\"u5ba3699e\">载荷即消息体，这里会存放实际的内容，也就是 Token 的数据声明，例如用户的 id 和 name，默认情况下也会携带令牌的签发时间 iat，通过还可以设置过期时间，如下：</span></p><p data-lake-id=\"u0a273a1c\" id=\"u0a273a1c\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22json%22%2C%22code%22%3A%22%7B%5Cn%20%20%20%20%5C%22sub%5C%22%3A%20%5C%221234567890%5C%22%2C%5Cn%20%20%20%20%5C%22name%5C%22%3A%20%5C%22John%20Doe%5C%22%2C%5Cn%20%20%20%20%5C%22iat%5C%22%3A%201516239022%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%223045a387%22%7D\"></card><p data-lake-id=\"u18125f8c\" id=\"u18125f8c\"><br></p><p data-lake-id=\"u5d6798d4\" id=\"u5d6798d4\"><span data-lake-id=\"u9260b308\" id=\"u9260b308\">同样进行 Base64 编码后，字符串如下：</span></p><p data-lake-id=\"uf4819c81\" id=\"uf4819c81\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22e70d9f83%22%7D\"></card><p data-lake-id=\"uc0961802\" id=\"uc0961802\"><br></p><h3 data-lake-id=\"7c0a4684\" id=\"7c0a4684\"><span data-lake-id=\"uddb0b2ef\" id=\"uddb0b2ef\">9.1.3 Signature</span></h3><p data-lake-id=\"udf686bd6\" id=\"udf686bd6\"><br></p><p data-lake-id=\"u08c0071b\" id=\"u08c0071b\"><span data-lake-id=\"u5612101f\" id=\"u5612101f\">签名是对头部和载荷内容进行签名，一般情况，设置一个 secretKey，对前两个的结果进行 HMACSHA25 算法，公式如下：</span></p><p data-lake-id=\"ubb4cbe5c\" id=\"ubb4cbe5c\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22Signature%20%3D%20HMACSHA256(base64Url(header)%2B.%2Bbase64Url(payload)%2CsecretKey)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22573cf1a4%22%7D\"></card><p data-lake-id=\"ue4b99c8b\" id=\"ue4b99c8b\"><br></p><p data-lake-id=\"u32f0faab\" id=\"u32f0faab\"><span data-lake-id=\"u6ed11395\" id=\"u6ed11395\">因此，就算前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名也是不一致的。</span></p><p data-lake-id=\"ub95754c3\" id=\"ub95754c3\"><br></p><h2 data-lake-id=\"fc688326\" id=\"fc688326\"><span data-lake-id=\"ucf31701a\" id=\"ucf31701a\">9.2 设计实现</span></h2><p data-lake-id=\"u9e2ac86d\" id=\"u9e2ac86d\"><br></p><p data-lake-id=\"u3feb99c6\" id=\"u3feb99c6\"><span data-lake-id=\"ufab81ff8\" id=\"ufab81ff8\">通常，Token 的使用分成了两部分：生成 token 和校验 token。</span></p><p data-lake-id=\"u4f260c7c\" id=\"u4f260c7c\"><br></p><ul list=\"u68186ece\"><li fid=\"u31bbcb40\" data-lake-id=\"ubbfe75bf\" id=\"ubbfe75bf\"><strong><span data-lake-id=\"u09eceed5\" id=\"u09eceed5\">生成 token</span></strong><span data-lake-id=\"uc3fb011f\" id=\"uc3fb011f\">：登录成功的时候，颁发 token。</span></li><li fid=\"u31bbcb40\" data-lake-id=\"uf51afa03\" id=\"uf51afa03\"><strong><span data-lake-id=\"u91403c58\" id=\"u91403c58\">验证 token</span></strong><span data-lake-id=\"u9cafdcc8\" id=\"u9cafdcc8\">：访问某些资源或者接口时，验证 token。</span></li></ul><p data-lake-id=\"u703be6e0\" id=\"u703be6e0\"><br></p><h3 data-lake-id=\"b311b79d\" id=\"b311b79d\"><span data-lake-id=\"u592726b4\" id=\"u592726b4\">9.2.1 生成 token</span></h3><p data-lake-id=\"u7535a6a5\" id=\"u7535a6a5\"><br></p><p data-lake-id=\"u884ddcf3\" id=\"u884ddcf3\"><span data-lake-id=\"uce12d745\" id=\"uce12d745\">借助第三方库 jsonwebtoken，通过 jsonwebtoken 的 sign 方法生成一个 token。sign 有三个参数：</span></p><p data-lake-id=\"u8a266f5d\" id=\"u8a266f5d\"><br></p><ul list=\"u9070ff1c\"><li fid=\"u58deea0f\" data-lake-id=\"ub02a9506\" id=\"ub02a9506\"><span data-lake-id=\"u38e461ec\" id=\"u38e461ec\">第一个参数指的是 Payload。</span></li><li fid=\"u58deea0f\" data-lake-id=\"uc9f66bdc\" id=\"uc9f66bdc\"><span data-lake-id=\"ucee604db\" id=\"ucee604db\">第二个是秘钥，服务端特有。</span></li><li fid=\"u58deea0f\" data-lake-id=\"uf5a900b4\" id=\"uf5a900b4\"><span data-lake-id=\"u33699158\" id=\"u33699158\">第三个参数是 option，可以定义 token 过期时间。</span></li></ul><p data-lake-id=\"uea43f2cb\" id=\"uea43f2cb\"><br></p><p data-lake-id=\"uda25de59\" id=\"uda25de59\"><span data-lake-id=\"ub660c6d4\" id=\"ub660c6d4\">下面是一个前端生成 token 的例子：</span></p><p data-lake-id=\"ub0212067\" id=\"ub0212067\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20crypto%20%3D%20require(%5C%22crypto%5C%22)%2C%5Cn%20%20%20%20jwt%20%3D%20require(%5C%22jsonwebtoken%5C%22)%5Cn%2F%2F%20TODO%3A%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%5Cn%2F%2F%20%E8%BF%99%E9%87%8C%E5%BA%94%E8%AF%A5%E6%98%AF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AA%E6%98%AF%E6%BC%94%E7%A4%BA%E7%94%A8%5Cnlet%20userList%20%3D%20%5B%5D%5Cn%5Cnclass%20UserController%20%7B%5Cn%20%20%20%20%2F%2F%20%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%5Cn%20%20%20%20static%20async%20login(ctx)%20%7B%5Cn%20%20%20%20%20%20%20%20const%20data%20%3D%20ctx.request.body%5Cn%20%20%20%20%20%20%20%20if%20(!data.name%20%7C%7C%20!data.password)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20(ctx.body%20%3D%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20code%3A%20%5C%22000002%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20message%3A%20%5C%22%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%88%E6%B3%95%5C%22%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20const%20result%20%3D%20userList.find(%5Cn%20%20%20%20%20%20%20%20%20%20%20%20item%20%3D%3E%20item.name%20%3D%3D%3D%20data.name%20%26%26%20item.password%20%3D%3D%3D%20crypto.createHash(%5C%22md5%5C%22).update(data.password).digest(%5C%22hex%5C%22)%5Cn%20%20%20%20%20%20%20%20)%5Cn%20%20%20%20%20%20%20%20if%20(result)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E7%94%9F%E6%88%90token%5Cn%20%20%20%20%20%20%20%20%20%20%20%20const%20token%20%3D%20jwt.sign(%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20result.name%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5C%22test_token%5C%22%2C%20%2F%2F%20secret%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%20expiresIn%3A%2060%20*%2060%20%7D%20%2F%2F%20%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%9A60%20*%2060%20s%5Cn%20%20%20%20%20%20%20%20%20%20%20%20)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20(ctx.body%20%3D%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20code%3A%20%5C%220%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20message%3A%20%5C%22%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20data%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20token%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20(ctx.body%20%3D%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20code%3A%20%5C%22000002%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20message%3A%20%5C%22%E7%94%A8%E6%88%B7%E5%90%8D%E6%88%96%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF%5C%22%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnmodule.exports%20%3D%20UserController%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22b252c82b%22%7D\"></card><p data-lake-id=\"ud3bd8f98\" id=\"ud3bd8f98\"><br></p><h3 data-lake-id=\"6bcae3ff\" id=\"6bcae3ff\"><span data-lake-id=\"uccc973c0\" id=\"uccc973c0\">9.2.2 校验 token</span></h3><p data-lake-id=\"u9edcea43\" id=\"u9edcea43\"><br></p><p data-lake-id=\"ucd7721fb\" id=\"ucd7721fb\"><span data-lake-id=\"ue62cc757\" id=\"ue62cc757\">首先，我们需要使用 koa-jwt 中间件进行验证，方式比较简单，在路由跳转前校验即可，如下。</span></p><p data-lake-id=\"u5b53d61a\" id=\"u5b53d61a\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22app.use(%5Cn%20%20%20%20koajwt(%7B%5Cn%20%20%20%20%20%20%20%20secret%3A%20%5C%22test_token%5C%22%5Cn%20%20%20%20%7D).unless(%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E9%85%8D%E7%BD%AE%E7%99%BD%E5%90%8D%E5%8D%95%5Cn%20%20%20%20%20%20%20%20path%3A%20%5B%2F%5C%5C%2Fapi%5C%5C%2Fregister%2F%2C%20%2F%5C%5C%2Fapi%5C%5C%2Flogin%2F%5D%5Cn%20%20%20%20%7D)%5Cn)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%220029f779%22%7D\"></card><p data-lake-id=\"ud6ff238a\" id=\"ud6ff238a\"><br></p><p data-lake-id=\"ub3dca904\" id=\"ub3dca904\"><span data-lake-id=\"u85f4ed3b\" id=\"u85f4ed3b\">使用 koa-jwt 中间件进行校验时，需要注意以下几点：</span></p><p data-lake-id=\"u4ecd6d3d\" id=\"u4ecd6d3d\"><br></p><ul list=\"u07dcd7a6\"><li fid=\"ucc40e84b\" data-lake-id=\"u56e219fe\" id=\"u56e219fe\"><span data-lake-id=\"uacd1dab2\" id=\"uacd1dab2\">secret 必须和 sign 时候保持一致。</span></li><li fid=\"ucc40e84b\" data-lake-id=\"u47ad6b0c\" id=\"u47ad6b0c\"><span data-lake-id=\"u15464781\" id=\"u15464781\">可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆/注册都可以不用校验。</span></li><li fid=\"ucc40e84b\" data-lake-id=\"u24b76e0e\" id=\"u24b76e0e\"><span data-lake-id=\"u17568b2b\" id=\"u17568b2b\">校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验。</span></li></ul><p data-lake-id=\"ub4fb2d29\" id=\"ub4fb2d29\"><br></p><p data-lake-id=\"u34d0b6a9\" id=\"u34d0b6a9\"><span data-lake-id=\"u12d1646b\" id=\"u12d1646b\">获取用户 token 信息的方法如下：</span></p><p data-lake-id=\"uc9ea7eb6\" id=\"uc9ea7eb6\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22router.get('%2Fapi%2FuserInfo'%2Casync%20(ctx%2Cnext)%20%3D%3E%20%7B%5Cn%20const%20authorization%20%3D%20%20ctx.header.authorization%20%2F%2F%20%E8%8E%B7%E5%8F%96jwt%5Cn%20const%20token%20%3D%20authorization.replace('Beraer%20'%2C'')%5Cn%20const%20result%20%3D%20jwt.verify(token%2C'test_token')%5Cn%20ctx.body%20%3D%20result%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22ef9091ac%22%7D\"></card><p data-lake-id=\"ua6a02d13\" id=\"ua6a02d13\"><br></p><p data-lake-id=\"u389b0595\" id=\"u389b0595\"><strong><span data-lake-id=\"u43bcbfe0\" id=\"u43bcbfe0\">注意</span></strong><span data-lake-id=\"u8ca323d5\" id=\"u8ca323d5\">：上述的 HMA256 加密算法为单秘钥的形式，一旦泄露后果非常的危险。</span></p><p data-lake-id=\"ub616d4b3\" id=\"ub616d4b3\"><span data-lake-id=\"u5b8e2cf2\" id=\"u5b8e2cf2\"><br /></span><span data-lake-id=\"u53329e8a\" id=\"u53329e8a\">在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌。这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择 RS256 等非对称算法。</span></p><p data-lake-id=\"ufa374397\" id=\"ufa374397\"><span data-lake-id=\"u6a1730ad\" id=\"u6a1730ad\">Ï<br /></span><span data-lake-id=\"u07a332e9\" id=\"u07a332e9\">除此之外，JWT 鉴权还需要注意以下几点：</span></p><p data-lake-id=\"u3f608e92\" id=\"u3f608e92\"><br></p><ul list=\"ud98804b6\"><li fid=\"uedd7b9c6\" data-lake-id=\"ufbda8ac8\" id=\"ufbda8ac8\"><span data-lake-id=\"u532346eb\" id=\"u532346eb\">payload 部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息。</span></li><li fid=\"uedd7b9c6\" data-lake-id=\"u0c5bec28\" id=\"u0c5bec28\"><span data-lake-id=\"ud3bc39cb\" id=\"ud3bc39cb\">需要保护好加密密钥，一旦泄露后果不堪设想。</span></li><li fid=\"uedd7b9c6\" data-lake-id=\"ucbb2b1ee\" id=\"ucbb2b1ee\"><span data-lake-id=\"u855758de\" id=\"u855758de\">为避免 token 被劫持，最好使用 https 协议。</span></li></ul><p data-lake-id=\"u9ffc68e2\" id=\"u9ffc68e2\"><br></p><h1 data-lake-id=\"15496b07\" id=\"15496b07\"><span data-lake-id=\"u29caf253\" id=\"u29caf253\">十、Node 性能监控与优化</span></h1><p data-lake-id=\"u91356be8\" id=\"u91356be8\"><br></p><h2 data-lake-id=\"d54e2d41\" id=\"d54e2d41\"><span data-lake-id=\"ufe2e90d6\" id=\"ufe2e90d6\">10.1 Node 优化点</span></h2><p data-lake-id=\"u7608e4bc\" id=\"u7608e4bc\"><br></p><p data-lake-id=\"u46b20a0e\" id=\"u46b20a0e\"><span data-lake-id=\"u384309e4\" id=\"u384309e4\">Node 作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下几点：</span></p><p data-lake-id=\"ufb157cd3\" id=\"ufb157cd3\"><br></p><ul list=\"u30ee43eb\"><li fid=\"u321e3069\" data-lake-id=\"ub9e132f0\" id=\"ub9e132f0\"><span data-lake-id=\"u55924977\" id=\"u55924977\">CPU</span></li><li fid=\"u321e3069\" data-lake-id=\"u671759d1\" id=\"u671759d1\"><span data-lake-id=\"u9e0198f7\" id=\"u9e0198f7\">内存</span></li><li fid=\"u321e3069\" data-lake-id=\"u6b88f444\" id=\"u6b88f444\"><span data-lake-id=\"u53fc6f71\" id=\"u53fc6f71\">I/O</span></li><li fid=\"u321e3069\" data-lake-id=\"u5fb5a7ca\" id=\"u5fb5a7ca\"><span data-lake-id=\"u31b76b57\" id=\"u31b76b57\">网络</span></li></ul><p data-lake-id=\"u2804f05a\" id=\"u2804f05a\"><br></p><h3 data-lake-id=\"20eb2623\" id=\"20eb2623\"><span data-lake-id=\"u1df6d111\" id=\"u1df6d111\">10.1.1 CPU</span></h3><p data-lake-id=\"u8d0ed5da\" id=\"u8d0ed5da\"><br></p><p data-lake-id=\"u9e8f5532\" id=\"u9e8f5532\"><span data-lake-id=\"uaa1cb593\" id=\"uaa1cb593\">对于 CPU 的指标，主要关注如下两点：</span></p><p data-lake-id=\"u02e35ea2\" id=\"u02e35ea2\"><br></p><ul list=\"u58a14847\"><li fid=\"u870b04bd\" data-lake-id=\"u509939db\" id=\"u509939db\"><strong><span data-lake-id=\"u0cf8271e\" id=\"u0cf8271e\">CPU 负载</span></strong><span data-lake-id=\"u1ceae174\" id=\"u1ceae174\">：在某个时间段内，占用以及等待 CPU 的进程总数。</span></li><li fid=\"u870b04bd\" data-lake-id=\"u6817b691\" id=\"u6817b691\"><strong><span data-lake-id=\"uabec40f0\" id=\"uabec40f0\">CPU 使用率</span></strong><span data-lake-id=\"u6aaa5729\" id=\"u6aaa5729\">：CPU 时间占用状况，等于 1 - 空闲 CPU 时间(idle time) / CPU 总时间。</span></li></ul><p data-lake-id=\"u8675e87d\" id=\"u8675e87d\"><br></p><p data-lake-id=\"uc7be4886\" id=\"uc7be4886\"><span data-lake-id=\"u7a8ecf2e\" id=\"u7a8ecf2e\">这两个指标都是用来评估系统当前 CPU 的繁忙程度的量化指标。Node 应用一般不会消耗很多的 CPU，如果 CPU 占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞。</span></p><p data-lake-id=\"u00e85346\" id=\"u00e85346\"><br></p><h3 data-lake-id=\"f7c41a62\" id=\"f7c41a62\"><span data-lake-id=\"u58f50137\" id=\"u58f50137\">10.1.2 内存指标</span></h3><p data-lake-id=\"u4e3f1d05\" id=\"u4e3f1d05\"><br></p><p data-lake-id=\"u4f7a9679\" id=\"u4f7a9679\"><span data-lake-id=\"u20dcc94a\" id=\"u20dcc94a\">内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于 Node 来说，内部内存堆栈的使用状态也是一个可以量化的指标，可以使用下面的代码来获取内存的相关数据：</span></p><p data-lake-id=\"u23c29eda\" id=\"u23c29eda\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%2Fapp%2Flib%2Fmemory.js%5Cnconst%20os%20%3D%20require(%5C%22os%5C%22)%5Cn%2F%2F%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8DNode%E5%86%85%E5%AD%98%E5%A0%86%E6%A0%88%E6%83%85%E5%86%B5%5Cnconst%20%7B%20rss%2C%20heapUsed%2C%20heapTotal%20%7D%20%3D%20process.memoryUsage()%5Cn%2F%2F%20%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%5Cnconst%20sysFree%20%3D%20os.freemem()%5Cn%2F%2F%20%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%80%BB%E5%86%85%E5%AD%98%5Cnconst%20sysTotal%20%3D%20os.totalmem()%5Cn%5Cnmodule.exports%20%3D%20%7B%5Cn%20%20%20%20memory%3A%20()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20sys%3A%201%20-%20sysFree%20%2F%20sysTotal%2C%20%2F%2F%20%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%8E%87%5Cn%20%20%20%20%20%20%20%20%20%20%20%20heap%3A%20heapUsed%20%2F%20headTotal%2C%20%2F%2F%20Node%E5%A0%86%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%8E%87%5Cn%20%20%20%20%20%20%20%20%20%20%20%20node%3A%20rss%20%2F%20sysTotal%20%2F%2F%20Node%E5%8D%A0%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%AF%94%E4%BE%8B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%229d2c014d%22%7D\"></card><p data-lake-id=\"u0a9be450\" id=\"u0a9be450\"><br></p><ul list=\"u23c1fd9e\"><li fid=\"u7100ce47\" data-lake-id=\"u0dab4a20\" id=\"u0dab4a20\"><span data-lake-id=\"uc99136d1\" id=\"uc99136d1\">rss：表示 node 进程占用的内存总量。</span></li><li fid=\"u7100ce47\" data-lake-id=\"ufba67b5b\" id=\"ufba67b5b\"><span data-lake-id=\"u47d7dd88\" id=\"u47d7dd88\">heapTotal：表示堆内存的总量。</span></li><li fid=\"u7100ce47\" data-lake-id=\"ua63e4e48\" id=\"ua63e4e48\"><span data-lake-id=\"u524e9717\" id=\"u524e9717\">heapUsed：实际堆内存的使用量。</span></li><li fid=\"u7100ce47\" data-lake-id=\"u1b7a74cd\" id=\"u1b7a74cd\"><span data-lake-id=\"uef750ffd\" id=\"uef750ffd\">external ：外部程序的内存使用量，包含 Node 核心的 C++程序的内存使用量。</span></li></ul><p data-lake-id=\"uf5e5a8e1\" id=\"uf5e5a8e1\"><br></p><p data-lake-id=\"ubd14796b\" id=\"ubd14796b\"><span data-lake-id=\"u064b311c\" id=\"u064b311c\">在 Node 中，一个进程的最大内存容量为 1.5GB，因此在实际使用时请合理控制内存的使用。</span></p><p data-lake-id=\"ucd289114\" id=\"ucd289114\"><br></p><h3 data-lake-id=\"ab218129\" id=\"ab218129\"><span data-lake-id=\"u001c05f6\" id=\"u001c05f6\">10.13 磁盘 I/O</span></h3><p data-lake-id=\"uf3489877\" id=\"uf3489877\"><br></p><p data-lake-id=\"ued811ac2\" id=\"ued811ac2\"><span data-lake-id=\"uef945bfc\" id=\"uef945bfc\">硬盘的 IO 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍。内存 IO 比磁盘 IO 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 redis、memcached 等。</span></p><p data-lake-id=\"ub96a039e\" id=\"ub96a039e\"><span data-lake-id=\"ua8e5793c\" id=\"ua8e5793c\"><br /></span><span data-lake-id=\"u23bf41dc\" id=\"u23bf41dc\">并且，并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决。</span></p><p data-lake-id=\"u784e48f9\" id=\"u784e48f9\"><br></p><h2 data-lake-id=\"11a4576d\" id=\"11a4576d\"><span data-lake-id=\"u038e135c\" id=\"u038e135c\">10.2 如何监控</span></h2><p data-lake-id=\"uddd37c84\" id=\"uddd37c84\"><br></p><p data-lake-id=\"ud92bbe02\" id=\"ud92bbe02\"><span data-lake-id=\"ucad850de\" id=\"ucad850de\">关于性能方面的监控，一般情况都需要借助工具来实现，比如 Easy-Monitor、阿里 Node 性能平台等。<br /></span><span data-lake-id=\"ue3f0a9db\" id=\"ue3f0a9db\">这里采用 Easy-Monitor 2.0，其是轻量级的 Node.js 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 require 一次，无需改动任何业务代码即可开启内核级别的性能监控分析。</span></p><p data-lake-id=\"u32ec0599\" id=\"u32ec0599\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20easyMonitor%20%3D%20require(%5C%22easy-monitor%5C%22)%5CneasyMonitor(%5C%22%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%5C%22)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22d15ec2d6%22%7D\"></card><p data-lake-id=\"u501904b1\" id=\"u501904b1\"><br></p><p data-lake-id=\"u30901bad\" id=\"u30901bad\"><span data-lake-id=\"ue8ab1ace\" id=\"ue8ab1ace\">打开你的浏览器，访问 </span><a href=\"https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A12333\" target=\"_blank\" data-lake-id=\"ud6d29b27\" id=\"ud6d29b27\"><span data-lake-id=\"u64b66de1\" id=\"u64b66de1\">http://localhost:12333</span></a><span data-lake-id=\"uf21bd4a5\" id=\"uf21bd4a5\"> ，即可看到进程界面，更详细的内容请参考</span><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feasy-monitor\" target=\"_blank\" data-lake-id=\"u8fb4e18b\" id=\"u8fb4e18b\"><span data-lake-id=\"u66682203\" id=\"u66682203\">官网</span></a></p><p data-lake-id=\"u79397f1d\" id=\"u79397f1d\"><br></p><h2 data-lake-id=\"959cf5c2\" id=\"959cf5c2\"><span data-lake-id=\"u2427702e\" id=\"u2427702e\">10.3 Node 性能优化</span></h2><p data-lake-id=\"ue6a9ad18\" id=\"ue6a9ad18\"><br></p><p data-lake-id=\"u52a64bef\" id=\"u52a64bef\"><span data-lake-id=\"u46264d3f\" id=\"u46264d3f\">关于 Node 的性能优化的方式有如下几个：</span></p><p data-lake-id=\"u7d906e77\" id=\"u7d906e77\"><br></p><ul list=\"ua248573e\"><li fid=\"ued5b1e52\" data-lake-id=\"uc899c481\" id=\"uc899c481\"><span data-lake-id=\"u48b3ea41\" id=\"u48b3ea41\">使用最新版本 Node.js</span></li><li fid=\"ued5b1e52\" data-lake-id=\"ud1aeac8a\" id=\"ud1aeac8a\"><span data-lake-id=\"u6a85f8a4\" id=\"u6a85f8a4\">正确使用流 Stream</span></li><li fid=\"ued5b1e52\" data-lake-id=\"u3f92ee64\" id=\"u3f92ee64\"><span data-lake-id=\"u8b06a226\" id=\"u8b06a226\">代码层面优化</span></li><li fid=\"ued5b1e52\" data-lake-id=\"u87ace8e0\" id=\"u87ace8e0\"><span data-lake-id=\"uf5314044\" id=\"uf5314044\">内存管理优化</span></li></ul><p data-lake-id=\"u05403980\" id=\"u05403980\"><br></p><h3 data-lake-id=\"04ddb6f6\" id=\"04ddb6f6\"><span data-lake-id=\"u9ad4813d\" id=\"u9ad4813d\">10.3.1 使用最新版本 Node.js</span></h3><p data-lake-id=\"u8a89061e\" id=\"u8a89061e\"><br></p><p data-lake-id=\"u91cde639\" id=\"u91cde639\"><span data-lake-id=\"u075a4c13\" id=\"u075a4c13\">每个版本的性能提升主要来自于两个方面：</span></p><p data-lake-id=\"uf41c8172\" id=\"uf41c8172\"><br></p><ul list=\"u032ba52a\"><li fid=\"u648e6009\" data-lake-id=\"uec3a6434\" id=\"uec3a6434\"><span data-lake-id=\"uca415aa3\" id=\"uca415aa3\">V8 的版本更新</span></li><li fid=\"u648e6009\" data-lake-id=\"uf7b273df\" id=\"uf7b273df\"><span data-lake-id=\"uf8a298ba\" id=\"uf8a298ba\">Node.js 内部代码的更新优化</span></li></ul><p data-lake-id=\"ud0e88893\" id=\"ud0e88893\"><br></p><h3 data-lake-id=\"8888e1ce\" id=\"8888e1ce\"><span data-lake-id=\"u61c6f797\" id=\"u61c6f797\">10.3.2 正确使用流</span></h3><p data-lake-id=\"ube1db77f\" id=\"ube1db77f\"><br></p><p data-lake-id=\"u3e5d51de\" id=\"u3e5d51de\"><span data-lake-id=\"uf7b4d702\" id=\"uf7b4d702\">在 Node 中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存。</span></p><p data-lake-id=\"u2d28352b\" id=\"u2d28352b\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20http%20%3D%20require(%5C%22http%5C%22)%5Cnconst%20fs%20%3D%20require(%5C%22fs%5C%22)%5Cn%5Cn%2F%2F%20%E9%94%99%E8%AF%AF%E6%96%B9%E5%BC%8F%5Cnhttp.createServer(function%20(req%2C%20res)%20%7B%5Cn%20%20%20%20fs.readFile(__dirname%20%2B%20%5C%22%2Fdata.txt%5C%22%2C%20function%20(err%2C%20data)%20%7B%5Cn%20%20%20%20%20%20%20%20res.end(data)%5Cn%20%20%20%20%7D)%5Cn%7D)%5Cn%5Cn%2F%2F%20%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F%5Cnhttp.createServer(function%20(req%2C%20res)%20%7B%5Cn%20%20%20%20const%20stream%20%3D%20fs.createReadStream(__dirname%20%2B%20%5C%22%2Fdata.txt%5C%22)%5Cn%20%20%20%20stream.pipe(res)%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22fe2e83be%22%7D\"></card><p data-lake-id=\"u92286467\" id=\"u92286467\"><br></p><h3 data-lake-id=\"7d90ae5d\" id=\"7d90ae5d\"><span data-lake-id=\"u13d83f47\" id=\"u13d83f47\">10.3.3 代码层面优化</span></h3><p data-lake-id=\"ud027b63c\" id=\"ud027b63c\"><br></p><p data-lake-id=\"ue063a655\" id=\"ue063a655\"><span data-lake-id=\"uefafc3c0\" id=\"uefafc3c0\">合并查询，将多次查询合并一次，减少数据库的查询次数。</span></p><p data-lake-id=\"u27c03f42\" id=\"u27c03f42\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E9%94%99%E8%AF%AF%E6%96%B9%E5%BC%8F%5Cnfor%20user_id%20in%20userIds%5Cn%20%20%20%20%20let%20account%20%3D%20user_account.findOne(user_id)%5Cn%5Cn%2F%2F%20%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F%5Cnconst%20user_account_map%20%3D%20%7B%7D%5Cn%20%2F%2F%20%E6%B3%A8%E6%84%8F%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%B0%86%E4%BC%9A%E6%B6%88%E8%80%97%E5%A4%A7%E9%87%8F%E5%86%85%E5%AD%98%E3%80%82%5Cnuser_account.find(user_id%20in%20user_ids).forEach(account)%7B%5Cn%20%20%20%20user_account_map%5Baccount.user_id%5D%20%3D%20%20account%5Cn%7D%5Cnfor%20user_id%20in%20userIds%5Cn%20%20%20%20var%20account%20%3D%20user_account_map%5Buser_id%5D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%220cf13494%22%7D\"></card><p data-lake-id=\"u3aba27a1\" id=\"u3aba27a1\"><br></p><h3 data-lake-id=\"b7d743b1\" id=\"b7d743b1\"><span data-lake-id=\"udda026d3\" id=\"udda026d3\">10.3.4 内存管理优化</span></h3><p data-lake-id=\"uc975815b\" id=\"uc975815b\"><br></p><p data-lake-id=\"u5bd7ad55\" id=\"u5bd7ad55\"><span data-lake-id=\"u9d890e9b\" id=\"u9d890e9b\">在 V8 中，主要将内存分为新生代和老生代两代：</span></p><p data-lake-id=\"u9706ae7e\" id=\"u9706ae7e\"><br></p><ul list=\"u21e9322c\"><li fid=\"u2b5ebf90\" data-lake-id=\"u3039acfb\" id=\"u3039acfb\"><strong><span data-lake-id=\"u20bc6f8d\" id=\"u20bc6f8d\">新生代</span></strong><span data-lake-id=\"u4b32b7cb\" id=\"u4b32b7cb\">：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。</span></li><li fid=\"u2b5ebf90\" data-lake-id=\"ue2297c0d\" id=\"ue2297c0d\"><strong><span data-lake-id=\"ue444b22a\" id=\"ue444b22a\">老生代</span></strong><span data-lake-id=\"u4f98dfce\" id=\"u4f98dfce\">：对象存活时间较长。经历过一次或多次垃圾回收的对象。</span></li></ul><p data-lake-id=\"u2e8f46f5\" id=\"u2e8f46f5\"><br></p><p data-lake-id=\"uababed11\" id=\"uababed11\"><span data-lake-id=\"u84227232\" id=\"u84227232\">若新生代内存空间不够，直接分配到老生代。通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低，比如下面的例子。</span></p><p data-lake-id=\"u11b08290\" id=\"u11b08290\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20buffer%20%3D%20fs.readFileSync(__dirname%20%2B%20%5C%22%2Fsource%2Findex.htm%5C%22)%5Cn%5Cnapp.use(%5Cn%20%20%20%20mount(%5C%22%2F%5C%22%2C%20async%20ctx%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20ctx.status%20%3D%20200%5Cn%20%20%20%20%20%20%20%20ctx.type%20%3D%20%5C%22html%5C%22%5Cn%20%20%20%20%20%20%20%20ctx.body%20%3D%20buffer%5Cn%20%20%20%20%20%20%20%20leak.push(fs.readFileSync(__dirname%20%2B%20%5C%22%2Fsource%2Findex.htm%5C%22))%5Cn%20%20%20%20%7D)%5Cn)%5Cn%5Cnconst%20leak%20%3D%20%5B%5D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22327efb1f%22%7D\"></card><p data-lake-id=\"uda449fd5\" id=\"uda449fd5\"><br></p><p data-lake-id=\"udb6bb60e\" id=\"udb6bb60e\"><span data-lake-id=\"uef21854e\" id=\"uef21854e\">当 leak 的内存非常大的时候，就有可能造成内存泄露，应当避免这样的操作。</span></p><p data-lake-id=\"u3fa9f528\" id=\"u3fa9f528\"><span data-lake-id=\"ud04d2da6\" id=\"ud04d2da6\"><br /></span><span data-lake-id=\"u935706bf\" id=\"u935706bf\">减少内存使用，可以明显的提高服务性能。而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作。例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新 new 这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动。而使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中，从而避免重读的初始化操作，从而提高框架的性能。</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2023-11-09T16:35:46.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:34:12.000Z",
  "updated_at": "2023-11-09T16:35:47.000Z",
  "published_at": "2023-11-09T16:35:46.000Z",
  "first_published_at": "2022-04-04T11:34:12.073Z",
  "word_count": 10139,
  "cover": null,
  "description": "一、Node 基础概念1.1 Node 是什么Node.js 是一个开源与跨平台的 JavaScript 运行时环境。在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能。我们可以理解为：Node.js 就...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}