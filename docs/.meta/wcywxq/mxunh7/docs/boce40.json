{
  "id": 72212079,
  "slug": "boce40",
  "title": "浏览器缓存",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"Hcavq\"></a>\n## http 缓存\n浏览器中的缓存作用分为两种情况：需要发送 `http` 请求 和 不需要发送 `http` 请求。因此，会**依次检查** **强缓存策略 **和 **协商缓存策略**。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647329182885-d009e7fa-9dc1-45ad-9420-27eb01c05b48.png#clientId=u42ae1cda-cfa5-4&from=paste&height=462&id=twhQ5&originHeight=462&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&size=222431&status=done&style=none&taskId=ud8251a17-a49b-466c-a55b-5dc1eaafae7&title=&width=519)\n<a name=\"VvZQw\"></a>\n### 强缓存\n强缓存表示在缓存期间不需要发送 http 请求，因此它的 http 状态码为 200。\n\n强缓存主要通过请求头中的相应字段来进行检查。\n\n- http/1.0：Expires\n- http/1.1：Cache-Control\n\n:::tips\n优先级：Cache-Control > Expires\n:::\n<a name=\"fyH3X\"></a>\n#### Expires\nExpires 即过期时间。存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里获取数据，无需再次请求\n```\n// 例子：资源会在 2022-11-22 08:41 过期\nExpires: Wed, 22 Nov 2022 08:41:00 GMT\n```\n:::danger\n缺陷：服务器时间和浏览器时间可能不一致，那么服务器返回的这个过期时间可能就是不准确的。\n:::\n<a name=\"zxsvk\"></a>\n#### Cache-Control\n在 http/1.1 中，采用了一个非常关键的字段：Cache-Control。这个字段也是存在于服务端返回的响应头中\n\n它和 Expires 本质的不同在于它并没有采用**具体的过期时间点**这个方式，而是**采用过期时长**来控制缓存，对应的字段是 `max-age`\n```\n// 例子：在一个小时内可以直接使用缓存\nCache-Contorl:max-age=3600\n```\n<a name=\"SuHOm\"></a>\n#### Cache-Control 的其他属性\n\n- **no-cache**：可以在本地进行缓存，但每次请求时，都需要向服务器进行验证，若服务器允许，才可使用本地缓存(缓存服务器在进行缓存前，必须校验是否过期)\n- **no-store**：响应报文中可能存在机密信息，不可缓存\n- public：明确指明缓存可以给所有用户使用\n- private：明确知名缓存不可以给其他用户使用\n- must-revalidate：如果缓存未过期则返回；否则代理在返回缓存数据之前，必须想源服务器发起请求，验证缓存是否有效。如果无法连接上源服务器，则返回 504 网关超时\n- proxy-revalidate：所有缓存服务器在返回缓存数据前，都要向源服务器发起请求验证有效性\n- s-maxage=[秒]：缓存资源的时间小于指定时间时，直接返回缓存\n<a name=\"oHYS7\"></a>\n### 协商缓存\n强缓存失效之后，浏览器在**请求头携带相应的缓存 tag** 来向服务器发请求，由服务器根据这个 tag 来决定是否使用缓存，这就是协商缓存。\n\n具体来说，这样的缓存 tag 分为两种：**Last-Modified** 和 **ETag**，二者各有优劣。\n\n当浏览器发送请求验证资源时，如果资源没有做改变，那么服务端会返回 304 状态码，并且更新浏览器中缓存的有效期。\n:::tips\n优先级：Etag > Last-Modified\n:::\n<a name=\"txoR6\"></a>\n#### Last-Modified\n:::tips\nLast-Modified 表示本地文件的最后修改日期。\n:::\n\n1. 浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。\n2. 浏览器接收到后，如果再次请求，会在请求头中携带 **If-Modified-Since **字段，这个字段的值也就是**服务器传来的最后修改时间**\n3. 服务器拿到请求头中的 **If-Modified-Since** 的字段后，会和这个服务器中该资源的最后修改时间进行对比。\n   - 如果请求头中 **If-Modified-Since** 的值 < 最后修改时间，说明需要更新，此时会返回新资源\n   - 反之，则返回 304，告诉浏览器直接使用缓存\n:::danger\nLast-Modified 的弊端：\n\n1. 如果本地打开缓存文件，即使没有对文件进行修改，还是会造成 Last-Modified 被修改，服务端将不能命中缓存，导致发送相同的资源\n2. 由于 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件的话，那么服务器就会认为依旧在缓存的失效内，将不会返回正确的资源\n:::\n<a name=\"Hwbgw\"></a>\n#### Etag\n:::tips\n由于 Last-Modified 的弊端，所以在 http/1.1 出现了 Etag。<br />Etag 类似于文件指纹，是服务器根据当前文件的内容，给文件生成的**唯一标识**，只要文件内容有所改动，这个值就会发生改变。\n:::\n\n1. 服务器通过响应头把这个值传递给浏览器\n2. 浏览器接收到 **Etag** 的值，会在下次请求时，将这个值作为 **If-None-Match **这个字段内容，并放到请求头中，然后发送给服务器\n3. 服务器接收到 **If-None-Match** 后，会将服务器上该资源的 **ETag** 进行比对\n   - 如果二者不相同，说明需要更新。此时会返回新资源\n   - 反之，则返回 304，告诉浏览器直接使用缓存\n<a name=\"E7lJP\"></a>\n### 不设置缓存策略\n如果什么缓存策略都没有设置，那么浏览器会采用一个启发式算法，该算法通常会取响应头中的 **Date - Last-Modified 值的 10%** 作为缓存失效时间\n<a name=\"vrUNH\"></a>\n### 三种刷新方式对 http 缓存的影响\n\n- 正常操作：地址栏输入 url，跳转链接，前进后退等\n- 手动刷新：f5，点击刷新按钮，右键菜单刷新\n- 强制刷新：ctrl + f5，shift+command+r\n:::warning\n正常操作：强缓存有效，协商缓存有效；<br />手动刷新：强缓存失效，协商缓存有效；<br />强制刷新：强缓存失效，协商缓存失效；\n:::\n<a name=\"COxpQ\"></a>\n## 浏览器缓存机制\n\n- 通过在一段时间内保留已收到的 web 资源的一个副本，如果在有效时间内，发起了对这个资源的再一次请求，浏览器将直接使用缓存副本，而不是再次发起请求\n- 可以提高页面的打开速度，减少不必要的带宽消耗\n<a name=\"oM2nV\"></a>\n## 浏览器缓存位置\n<a name=\"SYHFm\"></a>\n### Service Worker\n:::info\nService Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件，如何匹配缓存、如何读取缓存，并且缓存是可持续性的\n:::\n<a name=\"DbXt8\"></a>\n#### 概念\nService worker 是一个服务器与浏览器之间的中间人角色，如果网站中注册了 Service worker，那么它可以拦截当前网站所有的请求，然后进行判断。\n\n如果需要向服务器发起请求，那么就转发给服务器；如果可以使用缓存，那么就直接返回缓存内容而不再转发给服务器，从而嗒哒提高浏览体验\n<a name=\"lR0tN\"></a>\n#### 生命周期\nService worker 的生命周期与 web 页面完全分离，它包含以下几个阶段：\n\n- 下载\n\n这是浏览器下载包含 Service worker 的 .js 文件的时候\n\n- 安装\n\n在安装过程中，通常需要缓存某些静态资产，如果某些资源已经成功缓存，那么 Service worker 就安装完毕；如果任何文件下载失败或缓存失败，那么安装步骤也将会失败，Service worker 也就无法激活(也就是说，不会安装)。如果发生这种情况，不必担心，它下次会再试一次\n\n- 激活\n\n安装成功之后，接下来就是激活步骤，通常会在这个阶段管理旧缓存。要为 web 应用程序安装 Service worker，必须先注册它，这一步可以在 JavaScript 代码中完成。注册 Service worker 后，它会提示浏览器在后台启动 Service worker 安装步骤。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647342652227-761c4858-30be-43b2-93a0-3cf0f0f81648.png#clientId=u42ae1cda-cfa5-4&from=paste&height=522&id=ApOtR&originHeight=522&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43941&status=done&style=none&taskId=uae31afbd-abbd-4991-9502-d203dc5ac55&title=&width=800)\n<a name=\"Mlfvm\"></a>\n#### Service worker 经常配合哪种缓存使用\n经常配合 CacheStorage 离线缓存一起使用\n```javascript\nif (\"serviceWorker\" in navigator) {\n  navigator.serviceWorker.register(\"./sw.js\");\n}\n\n// sw.js\nvar VERSION = \"v1\";\n\n// 缓存\nself.addEventListener(\"install\", function (event) {\n  event.waitUntil(\n    caches.open(VERSION).then(function (cache) {\n      return cache.addAll([\"./start.html\", \"./static/jquery.min.js\", \"./static/mm1.jpg\"]);\n    })\n  );\n});\n\n// 缓存更新\nself.addEventListener(\"activate\", function (event) {\n  event.waitUntil(\n    caches.keys().then(function (cacheNames) {\n      return Promise.all(\n        cacheNames.map(function (cacheName) {\n          // 如果当前版本和缓存版本不一致\n          if (cacheName !== VERSION) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n\n// 捕获请求并返回缓存数据\nself.addEventListener(\"fetch\", function (event) {\n  event.respondWith(\n    caches\n      .match(event.request)\n      .catch(function () {\n        return fetch(event.request);\n      })\n      .then(function (response) {\n        caches.open(VERSION).then(function (cache) {\n          cache.put(event.request, response);\n        });\n        return response.clone();\n      })\n      .catch(function () {\n        return caches.match(\"./static/mm1.jpg\");\n      })\n  );\n});\n```\n<a name=\"Sdh0F\"></a>\n### Memory Cache\n:::info\nMemory Cache 是内存中的缓存，读取内存中的数据肯定比读取磁盘中的数据快。但是内存缓存虽然读取高效，但是缓存持续性很短，会随着进程的释放而释放\n:::\n<a name=\"WVKZW\"></a>\n### DIsk Cache\n:::info\nDisk Cache 是存储在硬盘中的缓存，虽然读取速度慢，但是都可以存储到磁盘中，但是胜在容量和存储时效性上\n:::\n<a name=\"s9Hdu\"></a>\n### Push Cache\n:::info\nPush Cache 是 http/2 中的内容，当以上三种缓存都没有命中时，它才会被使用，并且缓存时间也很短暂，只在 session 会话中存在，一旦会话结束也将被释放\n:::\n<a name=\"UhvEp\"></a>\n### 网络请求\n:::info\n如果所有缓存都没有命中的话，那么只能发起请求来获取资源了\n:::\n<a name=\"hD56L\"></a>\n## indexDB\n\n- indexDB 是浏览器提供的本地数据库，它可以被网页脚本创建和操作。indexDB 允许储存大量数据，提供查找接口，还能够建立索引。\n- indexDB 不属于关系型数据库，更接近于 NoSQL 数据库\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"Hcavq\"><span class=\"ne-text\">http 缓存</span></h2><p id=\"u446d4989\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">浏览器中的缓存作用分为两种情况：需要发送 </span><code class=\"ne-code\"><span class=\"ne-text\">http</span></code><span class=\"ne-text\"> 请求 和 不需要发送 </span><code class=\"ne-code\"><span class=\"ne-text\">http</span></code><span class=\"ne-text\"> 请求。因此，会</span><strong><span class=\"ne-text\">依次检查</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">强缓存策略 </span></strong><span class=\"ne-text\">和 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">协商缓存策略</span></strong><span class=\"ne-text\">。</span></p><p id=\"u29ea682d\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647329182885-d009e7fa-9dc1-45ad-9420-27eb01c05b48.png\" width=\"519\" id=\"twhQ5\" class=\"ne-image\"></p><h3 id=\"VvZQw\"><span class=\"ne-text\">强缓存</span></h3><p id=\"u620aa3c9\" class=\"ne-p\"><span class=\"ne-text\">强缓存表示在缓存期间不需要发送 http 请求，因此它的 http 状态码为 200。</span></p><p id=\"uaa17e139\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ue413467b\" class=\"ne-p\"><span class=\"ne-text\">强缓存主要通过请求头中的相应字段来进行检查。</span></p><ul class=\"ne-ul\"><li id=\"u215a7fc2\"><span class=\"ne-text\">http/1.0：Expires</span></li><li id=\"u4b6a8335\"><span class=\"ne-text\">http/1.1：Cache-Control</span></li></ul><p id=\"u5594cc98\" class=\"ne-p\"><span class=\"ne-text\"></span></p><div data-type=\"tips\" class=\"ne-alert\"><p id=\"ub6c0a2e0\" class=\"ne-p\"><span class=\"ne-text\">优先级：Cache-Control &gt; Expires</span></p></div><h4 id=\"fyH3X\"><span class=\"ne-text\">Expires</span></h4><p id=\"uf07b44e3\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">Expires 即过期时间。存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里获取数据，无需再次请求</span></p><pre data-language=\"plain\" id=\"YIbBH\" class=\"ne-codeblock language-plain\">// 例子：资源会在 2022-11-22 08:41 过期\nExpires: Wed, 22 Nov 2022 08:41:00 GMT</pre><div data-type=\"danger\" class=\"ne-alert\"><p id=\"u861761b1\" class=\"ne-p\"><span class=\"ne-text\">缺陷：服务器时间和浏览器时间可能不一致，那么服务器返回的这个过期时间可能就是不准确的。</span></p></div><h4 id=\"zxsvk\"><span class=\"ne-text\">Cache-Control</span></h4><p id=\"u2af3fb5c\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">在 http/1.1 中，采用了一个非常关键的字段：Cache-Control。这个字段也是存在于服务端返回的响应头中</span></p><p id=\"uc53a5447\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\"></span></p><p id=\"u283e7cf3\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">它和 Expires 本质的不同在于它并没有采用</span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">具体的过期时间点</span></strong><span class=\"ne-text\">这个方式，而是</span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">采用过期时长</span></strong><span class=\"ne-text\">来控制缓存，对应的字段是 </span><code class=\"ne-code\"><span class=\"ne-text\">max-age</span></code></p><pre data-language=\"plain\" id=\"VKrTY\" class=\"ne-codeblock language-plain\">// 例子：在一个小时内可以直接使用缓存\nCache-Contorl:max-age=3600</pre><h4 id=\"SuHOm\"><span class=\"ne-text\">Cache-Control 的其他属性</span></h4><ul class=\"ne-ul\"><li id=\"u9dd34e6a\"><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">no-cache</span></strong><span class=\"ne-text\">：可以在本地进行缓存，但每次请求时，都需要向服务器进行验证，若服务器允许，才可使用本地缓存(缓存服务器在进行缓存前，必须校验是否过期)</span></li><li id=\"uad2ede89\"><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">no-store</span></strong><span class=\"ne-text\">：响应报文中可能存在机密信息，不可缓存</span></li><li id=\"u27aae275\"><span class=\"ne-text\">public：明确指明缓存可以给所有用户使用</span></li><li id=\"ueecb90a3\"><span class=\"ne-text\">private：明确知名缓存不可以给其他用户使用</span></li><li id=\"ubdf2f1ac\"><span class=\"ne-text\">must-revalidate：如果缓存未过期则返回；否则代理在返回缓存数据之前，必须想源服务器发起请求，验证缓存是否有效。如果无法连接上源服务器，则返回 504 网关超时</span></li><li id=\"u81099453\"><span class=\"ne-text\">proxy-revalidate：所有缓存服务器在返回缓存数据前，都要向源服务器发起请求验证有效性</span></li><li id=\"u23bf5aef\"><span class=\"ne-text\">s-maxage=[秒]：缓存资源的时间小于指定时间时，直接返回缓存</span></li></ul><h3 id=\"oHYS7\"><span class=\"ne-text\">协商缓存</span></h3><p id=\"u8bb5dbd6\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">强缓存失效之后，浏览器在</span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">请求头携带相应的缓存 tag</span></strong><span class=\"ne-text\"> 来向服务器发请求，由服务器根据这个 tag 来决定是否使用缓存，这就是协商缓存。</span></p><p id=\"ub5609a68\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u80783c7a\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">具体来说，这样的缓存 tag 分为两种：</span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">Last-Modified</span></strong><span class=\"ne-text\"> 和 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">ETag</span></strong><span class=\"ne-text\">，二者各有优劣。</span></p><p id=\"u27896f7e\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u801f1473\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">当浏览器发送请求验证资源时，如果资源没有做改变，那么服务端会返回 304 状态码，并且更新浏览器中缓存的有效期。</span></p><div data-type=\"tips\" class=\"ne-alert\"><p id=\"uf301490f\" class=\"ne-p\"><span class=\"ne-text\">优先级：Etag &gt; Last-Modified</span></p></div><h4 id=\"txoR6\"><span class=\"ne-text\">Last-Modified</span></h4><div data-type=\"tips\" class=\"ne-alert\"><p id=\"u5ef6edbd\" class=\"ne-p\"><span class=\"ne-text\">Last-Modified 表示本地文件的最后修改日期。</span></p></div><ol class=\"ne-ol\"><li id=\"u740a1cbb\"><span class=\"ne-text\">浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</span></li><li id=\"u717a4135\"><span class=\"ne-text\">浏览器接收到后，如果再次请求，会在请求头中携带 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">If-Modified-Since</span></strong><strong><span class=\"ne-text\"> </span></strong><span class=\"ne-text\">字段，这个字段的值也就是</span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">服务器传来的最后修改时间</span></strong></li><li id=\"ub16dda24\"><span class=\"ne-text\">服务器拿到请求头中的 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">If-Modified-Since</span></strong><span class=\"ne-text\"> 的字段后，会和这个服务器中该资源的最后修改时间进行对比。</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ufd78ea91\"><span class=\"ne-text\">如果请求头中 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">If-Modified-Since</span></strong><span class=\"ne-text\"> 的值 &lt; 最后修改时间，说明需要更新，此时会返回新资源</span></li><li id=\"u95a584ac\"><span class=\"ne-text\">反之，则返回 304，告诉浏览器直接使用缓存</span></li></ul></ul><div data-type=\"danger\" class=\"ne-alert\"><p id=\"u1e2cdd21\" class=\"ne-p\"><span class=\"ne-text\">Last-Modified 的弊端：</span></p><ol class=\"ne-ol\"><li id=\"ue7cb3619\"><span class=\"ne-text\">如果本地打开缓存文件，即使没有对文件进行修改，还是会造成 Last-Modified 被修改，服务端将不能命中缓存，导致发送相同的资源</span></li><li id=\"uddd45d58\"><span class=\"ne-text\">由于 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件的话，那么服务器就会认为依旧在缓存的失效内，将不会返回正确的资源</span></li></ol></div><h4 id=\"Hwbgw\"><span class=\"ne-text\">Etag</span></h4><div data-type=\"tips\" class=\"ne-alert\"><p id=\"uf07e05ba\" class=\"ne-p\"><span class=\"ne-text\">由于 Last-Modified 的弊端，所以在 http/1.1 出现了 Etag。</span></p><p id=\"u7439cc0d\" class=\"ne-p\"><span class=\"ne-text\">Etag 类似于文件指纹，是服务器根据当前文件的内容，给文件生成的</span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">唯一标识</span></strong><span class=\"ne-text\">，只要文件内容有所改动，这个值就会发生改变。</span></p></div><ol class=\"ne-ol\"><li id=\"uc8d273ff\"><span class=\"ne-text\">服务器通过响应头把这个值传递给浏览器</span></li><li id=\"uddb6f13d\"><span class=\"ne-text\">浏览器接收到 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">Etag</span></strong><span class=\"ne-text\"> 的值，会在下次请求时，将这个值作为 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">If-None-Match</span></strong><strong><span class=\"ne-text\"> </span></strong><span class=\"ne-text\">这个字段内容，并放到请求头中，然后发送给服务器</span></li><li id=\"u63b92db0\"><span class=\"ne-text\">服务器接收到 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">If-None-Match</span></strong><span class=\"ne-text\"> 后，会将服务器上该资源的 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">ETag</span></strong><span class=\"ne-text\"> 进行比对</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u6311f03c\"><span class=\"ne-text\">如果二者不相同，说明需要更新。此时会返回新资源</span></li><li id=\"u74aac6fb\"><span class=\"ne-text\">反之，则返回 304，告诉浏览器直接使用缓存</span></li></ul></ul><h3 id=\"E7lJP\"><span class=\"ne-text\">不设置缓存策略</span></h3><p id=\"ua9876809\" class=\"ne-p\"><span class=\"ne-text\">如果什么缓存策略都没有设置，那么浏览器会采用一个启发式算法，该算法通常会取响应头中的 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">Date - Last-Modified 值的 10%</span></strong><span class=\"ne-text\"> 作为缓存失效时间</span></p><h3 id=\"vrUNH\"><span class=\"ne-text\">三种刷新方式对 http 缓存的影响</span></h3><ul class=\"ne-ul\"><li id=\"uf77a4824\"><span class=\"ne-text\">正常操作：地址栏输入 url，跳转链接，前进后退等</span></li><li id=\"u659401d9\"><span class=\"ne-text\">手动刷新：f5，点击刷新按钮，右键菜单刷新</span></li><li id=\"u916e64ce\"><span class=\"ne-text\">强制刷新：ctrl + f5，shift+command+r</span></li></ul><div data-type=\"warning\" class=\"ne-alert\"><p id=\"ue5a48cb3\" class=\"ne-p\"><span class=\"ne-text\">正常操作：强缓存有效，协商缓存有效；</span></p><p id=\"u86b150f7\" class=\"ne-p\"><span class=\"ne-text\">手动刷新：强缓存失效，协商缓存有效；</span></p><p id=\"u4536a251\" class=\"ne-p\"><span class=\"ne-text\">强制刷新：强缓存失效，协商缓存失效；</span></p></div><h2 id=\"COxpQ\"><span class=\"ne-text\">浏览器缓存机制</span></h2><ul class=\"ne-ul\"><li id=\"u2b46bf87\"><span class=\"ne-text\">通过在一段时间内保留已收到的 web 资源的一个副本，如果在有效时间内，发起了对这个资源的再一次请求，浏览器将直接使用缓存副本，而不是再次发起请求</span></li><li id=\"u348cac90\"><span class=\"ne-text\">可以提高页面的打开速度，减少不必要的带宽消耗</span></li></ul><h2 id=\"oM2nV\"><span class=\"ne-text\">浏览器缓存位置</span></h2><h3 id=\"SYHFm\"><span class=\"ne-text\">Service Worker</span></h3><div data-type=\"info\" class=\"ne-alert\"><p id=\"u5ead21cd\" class=\"ne-p\"><span class=\"ne-text\">Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件，如何匹配缓存、如何读取缓存，并且缓存是可持续性的</span></p></div><h4 id=\"DbXt8\"><span class=\"ne-text\">概念</span></h4><p id=\"ud6fd5c5e\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">Service worker 是一个服务器与浏览器之间的中间人角色，如果网站中注册了 Service worker，那么它可以拦截当前网站所有的请求，然后进行判断。</span></p><p id=\"ub8bf702c\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ubbb9f73c\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">如果需要向服务器发起请求，那么就转发给服务器；如果可以使用缓存，那么就直接返回缓存内容而不再转发给服务器，从而嗒哒提高浏览体验</span></p><h4 id=\"lR0tN\"><span class=\"ne-text\">生命周期</span></h4><p id=\"uaa264488\" class=\"ne-p\"><span class=\"ne-text\">Service worker 的生命周期与 web 页面完全分离，它包含以下几个阶段：</span></p><ul class=\"ne-ul\"><li id=\"u8363aeb2\"><span class=\"ne-text\">下载</span></li></ul><p id=\"u4a26e90b\" class=\"ne-p\"><span class=\"ne-text\">这是浏览器下载包含 Service worker 的 .js 文件的时候</span></p><ul class=\"ne-ul\"><li id=\"ucf115a70\"><span class=\"ne-text\">安装</span></li></ul><p id=\"u090b3bdd\" class=\"ne-p\"><span class=\"ne-text\">在安装过程中，通常需要缓存某些静态资产，如果某些资源已经成功缓存，那么 Service worker 就安装完毕；如果任何文件下载失败或缓存失败，那么安装步骤也将会失败，Service worker 也就无法激活(也就是说，不会安装)。如果发生这种情况，不必担心，它下次会再试一次</span></p><ul class=\"ne-ul\"><li id=\"u6e894117\"><span class=\"ne-text\">激活</span></li></ul><p id=\"ud1d89f19\" class=\"ne-p\"><span class=\"ne-text\">安装成功之后，接下来就是激活步骤，通常会在这个阶段管理旧缓存。要为 web 应用程序安装 Service worker，必须先注册它，这一步可以在 JavaScript 代码中完成。注册 Service worker 后，它会提示浏览器在后台启动 Service worker 安装步骤。</span></p><p id=\"uc0b18d08\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647342652227-761c4858-30be-43b2-93a0-3cf0f0f81648.png\" width=\"800\" id=\"ApOtR\" class=\"ne-image\"></p><h4 id=\"Mlfvm\"><span class=\"ne-text\">Service worker 经常配合哪种缓存使用</span></h4><p id=\"u634edcbf\" class=\"ne-p\"><span class=\"ne-text\">经常配合 CacheStorage 离线缓存一起使用</span></p><pre data-language=\"javascript\" id=\"Hqpaz\" class=\"ne-codeblock language-javascript\">if (&quot;serviceWorker&quot; in navigator) {\n  navigator.serviceWorker.register(&quot;./sw.js&quot;);\n}\n\n// sw.js\nvar VERSION = &quot;v1&quot;;\n\n// 缓存\nself.addEventListener(&quot;install&quot;, function (event) {\n  event.waitUntil(\n    caches.open(VERSION).then(function (cache) {\n      return cache.addAll([&quot;./start.html&quot;, &quot;./static/jquery.min.js&quot;, &quot;./static/mm1.jpg&quot;]);\n    })\n  );\n});\n\n// 缓存更新\nself.addEventListener(&quot;activate&quot;, function (event) {\n  event.waitUntil(\n    caches.keys().then(function (cacheNames) {\n      return Promise.all(\n        cacheNames.map(function (cacheName) {\n          // 如果当前版本和缓存版本不一致\n          if (cacheName !== VERSION) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n\n// 捕获请求并返回缓存数据\nself.addEventListener(&quot;fetch&quot;, function (event) {\n  event.respondWith(\n    caches\n      .match(event.request)\n      .catch(function () {\n        return fetch(event.request);\n      })\n      .then(function (response) {\n        caches.open(VERSION).then(function (cache) {\n          cache.put(event.request, response);\n        });\n        return response.clone();\n      })\n      .catch(function () {\n        return caches.match(&quot;./static/mm1.jpg&quot;);\n      })\n  );\n});</pre><h3 id=\"Sdh0F\"><span class=\"ne-text\">Memory Cache</span></h3><div data-type=\"info\" class=\"ne-alert\"><p id=\"udefad1f1\" class=\"ne-p\"><span class=\"ne-text\">Memory Cache 是内存中的缓存，读取内存中的数据肯定比读取磁盘中的数据快。但是内存缓存虽然读取高效，但是缓存持续性很短，会随着进程的释放而释放</span></p></div><h3 id=\"WVKZW\"><span class=\"ne-text\">DIsk Cache</span></h3><div data-type=\"info\" class=\"ne-alert\"><p id=\"u2cb23c8b\" class=\"ne-p\"><span class=\"ne-text\">Disk Cache 是存储在硬盘中的缓存，虽然读取速度慢，但是都可以存储到磁盘中，但是胜在容量和存储时效性上</span></p></div><h3 id=\"s9Hdu\"><span class=\"ne-text\">Push Cache</span></h3><div data-type=\"info\" class=\"ne-alert\"><p id=\"ub5cf6996\" class=\"ne-p\"><span class=\"ne-text\">Push Cache 是 http/2 中的内容，当以上三种缓存都没有命中时，它才会被使用，并且缓存时间也很短暂，只在 session 会话中存在，一旦会话结束也将被释放</span></p></div><h3 id=\"UhvEp\"><span class=\"ne-text\">网络请求</span></h3><div data-type=\"info\" class=\"ne-alert\"><p id=\"u0603f7c3\" class=\"ne-p\"><span class=\"ne-text\">如果所有缓存都没有命中的话，那么只能发起请求来获取资源了</span></p></div><h2 id=\"hD56L\"><span class=\"ne-text\">indexDB</span></h2><ul class=\"ne-ul\"><li id=\"u148dc6f4\"><span class=\"ne-text\">indexDB 是浏览器提供的本地数据库，它可以被网页脚本创建和操作。indexDB 允许储存大量数据，提供查找接口，还能够建立索引。</span></li></ul><ul class=\"ne-ul\"><li id=\"u3bdc54d5\"><span class=\"ne-text\">indexDB 不属于关系型数据库，更接近于 NoSQL 数据库</span></li></ul></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"Hcavq\" id=\"Hcavq\"><span data-lake-id=\"u48677387\" id=\"u48677387\">http 缓存</span></h2><p data-lake-id=\"u446d4989\" id=\"u446d4989\" style=\"text-indent: 2em\"><span data-lake-id=\"u464a8b86\" id=\"u464a8b86\">浏览器中的缓存作用分为两种情况：需要发送 </span><code data-lake-id=\"u419882ec\" id=\"u419882ec\"><span data-lake-id=\"u8b0adc9a\" id=\"u8b0adc9a\">http</span></code><span data-lake-id=\"ueda47f29\" id=\"ueda47f29\"> 请求 和 不需要发送 </span><code data-lake-id=\"uc005915b\" id=\"uc005915b\"><span data-lake-id=\"u66e4a155\" id=\"u66e4a155\">http</span></code><span data-lake-id=\"uad86d25d\" id=\"uad86d25d\"> 请求。因此，会</span><strong><span data-lake-id=\"ue6303e3a\" id=\"ue6303e3a\">依次检查</span></strong><span data-lake-id=\"u98697301\" id=\"u98697301\"> </span><strong><span data-lake-id=\"u3ddc4953\" id=\"u3ddc4953\" style=\"color: rgba(255,103,0,1)\">强缓存策略 </span></strong><span data-lake-id=\"u6606d8ec\" id=\"u6606d8ec\">和 </span><strong><span data-lake-id=\"u2786c6c8\" id=\"u2786c6c8\" style=\"color: rgba(255,103,0,1)\">协商缓存策略</span></strong><span data-lake-id=\"u3b5ab170\" id=\"u3b5ab170\">。</span></p><p data-lake-id=\"u29ea682d\" id=\"u29ea682d\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647329182885-d009e7fa-9dc1-45ad-9420-27eb01c05b48.png%22%2C%22taskId%22%3A%22ud8251a17-a49b-466c-a55b-5dc1eaafae7%22%2C%22clientId%22%3A%22u42ae1cda-cfa5-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A519%2C%22height%22%3A462%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A222431%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A519%2C%22originHeight%22%3A462%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E6%B5%8F%E8%A7%88%E5%99%A8%20%E6%B3%A8%3A1.CACHECONTROL%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E4%BA%8EEXPINES%3B%202.ETAG%2FLF-NONE.MATCH%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E4%BA%8ELAST%20MODIFIED%20%2F%20MODIFIED-SINCE%20%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F(EXPIRES%E5%92%8CCACHE.%20%E8%AF%BB%E5%8F%96%E7%BC%93%E5%AD%98%20%E6%9C%89%E7%BC%93%E5%AD%98%3F%20CONTROL)%20%E6%90%BA%E5%B8%A6%E6%A0%87%E8%AF%86(IFMODIFIED.SINCE%E5%92%8CIF%20%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%20NONE-MATCH)%2C%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%20304%2C%E7%BB%A7%E7%BB%AD%20%E8%B5%84%E6%BA%90%E6%98%AF%E5%90%A6%E6%9C%89%E6%9B%B4%E6%96%B0%20%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%20%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%9C%20%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%A0%87%20%E8%AF%86%2C%E5%AD%98%E5%85%A5%E7%BC%93%E5%AD%98%20%E9%87%8D%E6%96%B0%E8%BF%94%E5%9B%9E%E8%B5%84%E6%BA%90%E5%92%8C%20%E7%BC%93%E5%AD%98%E6%A0%87%E8%AF%86%2C200%20%E5%B9%B6%E5%AD%98%E5%85%A5%E7%BC%93%E5%AD%98%E4%B8%AD%20%E8%BF%94%E5%9B%9E%E7%BC%93%E5%AD%98%20%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A36.191345%2C%22y%22%3A9.999997%2C%22width%22%3A30.377350000000007%2C%22height%22%3A11.369325%2C%22text%22%3A%22%E6%B5%8F%E8%A7%88%E5%99%A8%22%7D%2C%7B%22x%22%3A221.1899%2C%22y%22%3A11.970741%2C%22width%22%3A179.50032000000002%2C%22height%22%3A11.804673000000001%2C%22text%22%3A%22%E6%B3%A8%3A1.CACHECONTROL%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E4%BA%8EEXPINES%3B%22%7D%2C%7B%22x%22%3A237.93037%2C%22y%22%3A23.700785%2C%22width%22%3A171.09295%2C%22height%22%3A9.735429%2C%22text%22%3A%222.ETAG%2FLF-NONE.MATCH%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E4%BA%8ELAST%22%7D%2C%7B%22x%22%3A250.30574%2C%22y%22%3A35.106716%2C%22width%22%3A123.97438000000002%2C%22height%22%3A9.816689000000004%2C%22text%22%3A%22MODIFIED%20%2F%20MODIFIED-SINCE%22%7D%2C%7B%22x%22%3A188.50385%2C%22y%22%3A79.736534%2C%22width%22%3A114.33639%2C%22height%22%3A12.368302%2C%22text%22%3A%22%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F(EXPIRES%E5%92%8CCACHE.%22%7D%2C%7B%22x%22%3A450.0704%2C%22y%22%3A85.98224%2C%22width%22%3A39.15055000000001%2C%22height%22%3A11.952919999999992%2C%22text%22%3A%22%E8%AF%BB%E5%8F%96%E7%BC%93%E5%AD%98%22%7D%2C%7B%22x%22%3A31.776098%2C%22y%22%3A86.88263%2C%22width%22%3A36.951387999999994%2C%22height%22%3A10.45877999999999%2C%22text%22%3A%22%E6%9C%89%E7%BC%93%E5%AD%98%3F%22%7D%2C%7B%22x%22%3A223.68907%2C%22y%22%3A93.010155%2C%22width%22%3A42.21077%2C%22height%22%3A10.243445000000008%2C%22text%22%3A%22CONTROL)%22%7D%2C%7B%22x%22%3A174.40465%2C%22y%22%3A169.96844%2C%22width%22%3A142.53789%2C%22height%22%3A11.012820000000005%2C%22text%22%3A%22%E6%90%BA%E5%B8%A6%E6%A0%87%E8%AF%86(IFMODIFIED.SINCE%E5%92%8CIF%22%7D%2C%7B%22x%22%3A22.708364%2C%22y%22%3A174.41907%2C%22width%22%3A57.877506%2C%22height%22%3A11.512280000000004%2C%22text%22%3A%22%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%22%7D%2C%7B%22x%22%3A179.83519%2C%22y%22%3A180.21858%2C%22width%22%3A131.94991%2C%22height%22%3A12.21042%2C%22text%22%3A%22NONE-MATCH)%2C%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%22%7D%2C%7B%22x%22%3A358.03528%2C%22y%22%3A257.28925%2C%22width%22%3A44.45254%2C%22height%22%3A11.344330000000014%2C%22text%22%3A%22304%2C%E7%BB%A7%E7%BB%AD%22%7D%2C%7B%22x%22%3A212.24113%2C%22y%22%3A262.44644%2C%22width%22%3A67.95506999999998%2C%22height%22%3A11.34662000000003%2C%22text%22%3A%22%E8%B5%84%E6%BA%90%E6%98%AF%E5%90%A6%E6%9C%89%E6%9B%B4%E6%96%B0%22%7D%2C%7B%22x%22%3A359.90646%2C%22y%22%3A268.64053%2C%22width%22%3A40.022940000000006%2C%22height%22%3A11.999030000000005%2C%22text%22%3A%22%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%22%7D%2C%7B%22x%22%3A24.385466%2C%22y%22%3A279.18576%2C%22width%22%3A55.51261399999999%2C%22height%22%3A10.85757000000001%2C%22text%22%3A%22%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%9C%22%7D%2C%7B%22x%22%3A25.816666%2C%22y%22%3A290.38535%2C%22width%22%3A51.067964%2C%22height%22%3A10.769979999999975%2C%22text%22%3A%22%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%A0%87%22%7D%2C%7B%22x%22%3A23.157385%2C%22y%22%3A301.07846%2C%22width%22%3A56.368624999999994%2C%22height%22%3A11.571379999999976%2C%22text%22%3A%22%E8%AF%86%2C%E5%AD%98%E5%85%A5%E7%BC%93%E5%AD%98%22%7D%2C%7B%22x%22%3A213.54802%2C%22y%22%3A322.84195%2C%22width%22%3A65.24381999999997%2C%22height%22%3A11.66131999999999%2C%22text%22%3A%22%E9%87%8D%E6%96%B0%E8%BF%94%E5%9B%9E%E8%B5%84%E6%BA%90%E5%92%8C%22%7D%2C%7B%22x%22%3A211.28777%2C%22y%22%3A335.2655%2C%22width%22%3A64.41740000000001%2C%22height%22%3A10.204230000000052%2C%22text%22%3A%22%E7%BC%93%E5%AD%98%E6%A0%87%E8%AF%86%2C200%22%7D%2C%7B%22x%22%3A216.58742%2C%22y%22%3A346.62964%2C%22width%22%3A58.771979999999985%2C%22height%22%3A10.503080000000011%2C%22text%22%3A%22%E5%B9%B6%E5%AD%98%E5%85%A5%E7%BC%93%E5%AD%98%E4%B8%AD%22%7D%2C%7B%22x%22%3A449.5897%2C%22y%22%3A383.8192%2C%22width%22%3A39.25870000000003%2C%22height%22%3A11.25279999999998%2C%22text%22%3A%22%E8%BF%94%E5%9B%9E%E7%BC%93%E5%AD%98%22%7D%2C%7B%22x%22%3A217.21631%2C%22y%22%3A431.78873%2C%22width%22%3A57.67958999999999%2C%22height%22%3A12.318690000000004%2C%22text%22%3A%22%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22twhQ5%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h3 data-lake-id=\"VvZQw\" id=\"VvZQw\"><span data-lake-id=\"u50b09df9\" id=\"u50b09df9\">强缓存</span></h3><p data-lake-id=\"u620aa3c9\" id=\"u620aa3c9\"><span data-lake-id=\"u34bc30d6\" id=\"u34bc30d6\">强缓存表示在缓存期间不需要发送 http 请求，因此它的 http 状态码为 200。</span></p><p data-lake-id=\"uaa17e139\" id=\"uaa17e139\"><span data-lake-id=\"uded96d71\" id=\"uded96d71\">​</span><br></p><p data-lake-id=\"ue413467b\" id=\"ue413467b\"><span data-lake-id=\"ue423daa4\" id=\"ue423daa4\">强缓存主要通过请求头中的相应字段来进行检查。</span></p><ul list=\"ucdbd89c2\"><li fid=\"ud329bf24\" data-lake-id=\"u215a7fc2\" id=\"u215a7fc2\"><span data-lake-id=\"u436037b7\" id=\"u436037b7\">http/1.0：Expires</span></li><li fid=\"ud329bf24\" data-lake-id=\"u4b6a8335\" id=\"u4b6a8335\"><span data-lake-id=\"u9c6d0779\" id=\"u9c6d0779\">http/1.1：Cache-Control</span></li></ul><p data-lake-id=\"u5594cc98\" id=\"u5594cc98\"><span data-lake-id=\"ud57b3473\" id=\"ud57b3473\">​</span><br></p><blockquote data-lake-id=\"u3f9933dc\" id=\"u3f9933dc\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"ub6c0a2e0\" id=\"ub6c0a2e0\"><span data-lake-id=\"u5190866a\" id=\"u5190866a\">优先级：Cache-Control &gt; Expires</span></p></blockquote><h4 data-lake-id=\"fyH3X\" id=\"fyH3X\"><span data-lake-id=\"udb00458b\" id=\"udb00458b\">Expires</span></h4><p data-lake-id=\"uf07b44e3\" id=\"uf07b44e3\" style=\"text-indent: 2em\"><span data-lake-id=\"u1173b77c\" id=\"u1173b77c\">Expires 即过期时间。存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里获取数据，无需再次请求</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%2F%2F%20%E4%BE%8B%E5%AD%90%EF%BC%9A%E8%B5%84%E6%BA%90%E4%BC%9A%E5%9C%A8%202022-11-22%2008%3A41%20%E8%BF%87%E6%9C%9F%5CnExpires%3A%20Wed%2C%2022%20Nov%202022%2008%3A41%3A00%20GMT%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22YIbBH%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><blockquote data-lake-id=\"ud4e68a1f\" id=\"ud4e68a1f\" class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"u861761b1\" id=\"u861761b1\"><span data-lake-id=\"u55c3dcc5\" id=\"u55c3dcc5\">缺陷：服务器时间和浏览器时间可能不一致，那么服务器返回的这个过期时间可能就是不准确的。</span></p></blockquote><h4 data-lake-id=\"zxsvk\" id=\"zxsvk\"><span data-lake-id=\"ue33ce6e9\" id=\"ue33ce6e9\">Cache-Control</span></h4><p data-lake-id=\"u2af3fb5c\" id=\"u2af3fb5c\" style=\"text-indent: 2em\"><span data-lake-id=\"uc841c495\" id=\"uc841c495\">在 http/1.1 中，采用了一个非常关键的字段：Cache-Control。这个字段也是存在于服务端返回的响应头中</span></p><p data-lake-id=\"uc53a5447\" id=\"uc53a5447\" style=\"text-indent: 2em\"><span data-lake-id=\"uee50499b\" id=\"uee50499b\">​</span><br></p><p data-lake-id=\"u283e7cf3\" id=\"u283e7cf3\" style=\"text-indent: 2em\"><span data-lake-id=\"uac9ff4e9\" id=\"uac9ff4e9\">它和 Expires 本质的不同在于它并没有采用</span><strong><span data-lake-id=\"u17e82078\" id=\"u17e82078\" style=\"color: rgba(255,103,0,1)\">具体的过期时间点</span></strong><span data-lake-id=\"u85a4b368\" id=\"u85a4b368\">这个方式，而是</span><strong><span data-lake-id=\"ufba5fcc9\" id=\"ufba5fcc9\" style=\"color: rgba(255,103,0,1)\">采用过期时长</span></strong><span data-lake-id=\"u41a2f99f\" id=\"u41a2f99f\">来控制缓存，对应的字段是 </span><code data-lake-id=\"u6aa84a16\" id=\"u6aa84a16\"><span data-lake-id=\"uc7c59837\" id=\"uc7c59837\">max-age</span></code></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%2F%2F%20%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%86%85%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%5CnCache-Contorl%3Amax-age%3D3600%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22VKrTY%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h4 data-lake-id=\"SuHOm\" id=\"SuHOm\"><span data-lake-id=\"u4b0148b8\" id=\"u4b0148b8\">Cache-Control 的其他属性</span></h4><ul list=\"u5b05b39d\"><li fid=\"u82e54299\" data-lake-id=\"u9dd34e6a\" id=\"u9dd34e6a\"><strong><span data-lake-id=\"uc1d2ef98\" id=\"uc1d2ef98\" style=\"color: rgba(255,103,0,1)\">no-cache</span></strong><span data-lake-id=\"uc5089903\" id=\"uc5089903\">：可以在本地进行缓存，但每次请求时，都需要向服务器进行验证，若服务器允许，才可使用本地缓存(缓存服务器在进行缓存前，必须校验是否过期)</span></li><li fid=\"u82e54299\" data-lake-id=\"uad2ede89\" id=\"uad2ede89\"><strong><span data-lake-id=\"uac84583e\" id=\"uac84583e\" style=\"color: rgba(255,103,0,1)\">no-store</span></strong><span data-lake-id=\"u268d3a55\" id=\"u268d3a55\">：响应报文中可能存在机密信息，不可缓存</span></li><li fid=\"u82e54299\" data-lake-id=\"u27aae275\" id=\"u27aae275\"><span data-lake-id=\"u9761b1d6\" id=\"u9761b1d6\">public：明确指明缓存可以给所有用户使用</span></li><li fid=\"u82e54299\" data-lake-id=\"ueecb90a3\" id=\"ueecb90a3\"><span data-lake-id=\"u20a890c0\" id=\"u20a890c0\">private：明确知名缓存不可以给其他用户使用</span></li><li fid=\"u82e54299\" data-lake-id=\"ubdf2f1ac\" id=\"ubdf2f1ac\"><span data-lake-id=\"u87d00ef9\" id=\"u87d00ef9\">must-revalidate：如果缓存未过期则返回；否则代理在返回缓存数据之前，必须想源服务器发起请求，验证缓存是否有效。如果无法连接上源服务器，则返回 504 网关超时</span></li><li fid=\"u82e54299\" data-lake-id=\"u81099453\" id=\"u81099453\"><span data-lake-id=\"ua45f4e8d\" id=\"ua45f4e8d\">proxy-revalidate：所有缓存服务器在返回缓存数据前，都要向源服务器发起请求验证有效性</span></li><li fid=\"u82e54299\" data-lake-id=\"u23bf5aef\" id=\"u23bf5aef\"><span data-lake-id=\"u1bab6c15\" id=\"u1bab6c15\">s-maxage=[秒]：缓存资源的时间小于指定时间时，直接返回缓存</span></li></ul><h3 data-lake-id=\"oHYS7\" id=\"oHYS7\"><span data-lake-id=\"udd252c4c\" id=\"udd252c4c\">协商缓存</span></h3><p data-lake-id=\"u8bb5dbd6\" id=\"u8bb5dbd6\" style=\"text-indent: 2em\"><span data-lake-id=\"ubf9f0dc7\" id=\"ubf9f0dc7\">强缓存失效之后，浏览器在</span><strong><span data-lake-id=\"u617f6f55\" id=\"u617f6f55\" style=\"color: rgba(255,103,0,1)\">请求头携带相应的缓存 tag</span></strong><span data-lake-id=\"u6f39af03\" id=\"u6f39af03\"> 来向服务器发请求，由服务器根据这个 tag 来决定是否使用缓存，这就是协商缓存。</span></p><p data-lake-id=\"ub5609a68\" id=\"ub5609a68\"><span data-lake-id=\"ue250644b\" id=\"ue250644b\">​</span><br></p><p data-lake-id=\"u80783c7a\" id=\"u80783c7a\" style=\"text-indent: 2em\"><span data-lake-id=\"u4da22369\" id=\"u4da22369\">具体来说，这样的缓存 tag 分为两种：</span><strong><span data-lake-id=\"uc3159c7f\" id=\"uc3159c7f\" style=\"color: rgba(255,103,0,1)\">Last-Modified</span></strong><span data-lake-id=\"uf51f4f39\" id=\"uf51f4f39\"> 和 </span><strong><span data-lake-id=\"ude9db9be\" id=\"ude9db9be\" style=\"color: rgba(255,103,0,1)\">ETag</span></strong><span data-lake-id=\"ub082bb74\" id=\"ub082bb74\">，二者各有优劣。</span></p><p data-lake-id=\"u27896f7e\" id=\"u27896f7e\"><span data-lake-id=\"u955127fd\" id=\"u955127fd\">​</span><br></p><p data-lake-id=\"u801f1473\" id=\"u801f1473\" style=\"text-indent: 2em\"><span data-lake-id=\"u57768747\" id=\"u57768747\">当浏览器发送请求验证资源时，如果资源没有做改变，那么服务端会返回 304 状态码，并且更新浏览器中缓存的有效期。</span></p><blockquote data-lake-id=\"u99867d80\" id=\"u99867d80\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"uf301490f\" id=\"uf301490f\"><span data-lake-id=\"ua8ae2c47\" id=\"ua8ae2c47\">优先级：Etag &gt; Last-Modified</span></p></blockquote><h4 data-lake-id=\"txoR6\" id=\"txoR6\"><span data-lake-id=\"ue0bf0177\" id=\"ue0bf0177\">Last-Modified</span></h4><blockquote data-lake-id=\"uc45c9d2b\" id=\"uc45c9d2b\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"u5ef6edbd\" id=\"u5ef6edbd\"><span data-lake-id=\"u267374a2\" id=\"u267374a2\">Last-Modified 表示本地文件的最后修改日期。</span></p></blockquote><ol list=\"u0f1d299f\"><li fid=\"ub6060b17\" data-lake-id=\"u740a1cbb\" id=\"u740a1cbb\"><span data-lake-id=\"uab2fcbbe\" id=\"uab2fcbbe\">浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</span></li><li fid=\"ub6060b17\" data-lake-id=\"u717a4135\" id=\"u717a4135\"><span data-lake-id=\"u85d90704\" id=\"u85d90704\">浏览器接收到后，如果再次请求，会在请求头中携带 </span><strong><span data-lake-id=\"uf90e67de\" id=\"uf90e67de\" style=\"color: rgba(255,103,0,1)\">If-Modified-Since</span></strong><strong><span data-lake-id=\"u56203ca8\" id=\"u56203ca8\"> </span></strong><span data-lake-id=\"u77fb8eb9\" id=\"u77fb8eb9\">字段，这个字段的值也就是</span><strong><span data-lake-id=\"u82176cfa\" id=\"u82176cfa\" style=\"color: rgba(255,103,0,1)\">服务器传来的最后修改时间</span></strong></li><li fid=\"ub6060b17\" data-lake-id=\"ub16dda24\" id=\"ub16dda24\"><span data-lake-id=\"ufb959b82\" id=\"ufb959b82\">服务器拿到请求头中的 </span><strong><span data-lake-id=\"ub8bf8738\" id=\"ub8bf8738\" style=\"color: rgba(255,103,0,1)\">If-Modified-Since</span></strong><span data-lake-id=\"ua33fdd3e\" id=\"ua33fdd3e\"> 的字段后，会和这个服务器中该资源的最后修改时间进行对比。</span></li></ol><ul list=\"u64f491ca\" data-lake-indent=\"1\"><li fid=\"u39d70637\" data-lake-id=\"ufd78ea91\" id=\"ufd78ea91\"><span data-lake-id=\"ud073632b\" id=\"ud073632b\">如果请求头中 </span><strong><span data-lake-id=\"u8d7d5927\" id=\"u8d7d5927\" style=\"color: rgba(255,103,0,1)\">If-Modified-Since</span></strong><span data-lake-id=\"uc362b619\" id=\"uc362b619\"> 的值 &lt; 最后修改时间，说明需要更新，此时会返回新资源</span></li><li fid=\"u39d70637\" data-lake-id=\"u95a584ac\" id=\"u95a584ac\"><span data-lake-id=\"u2e419a18\" id=\"u2e419a18\">反之，则返回 304，告诉浏览器直接使用缓存</span></li></ul><blockquote data-lake-id=\"u345201ed\" id=\"u345201ed\" class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"u1e2cdd21\" id=\"u1e2cdd21\"><span data-lake-id=\"u3fdead0a\" id=\"u3fdead0a\">Last-Modified 的弊端：</span></p><ol list=\"uf1a88a33\"><li fid=\"u94fe0c8c\" data-lake-id=\"ue7cb3619\" id=\"ue7cb3619\"><span data-lake-id=\"ud1494e3f\" id=\"ud1494e3f\">如果本地打开缓存文件，即使没有对文件进行修改，还是会造成 Last-Modified 被修改，服务端将不能命中缓存，导致发送相同的资源</span></li><li fid=\"u94fe0c8c\" data-lake-id=\"uddd45d58\" id=\"uddd45d58\"><span data-lake-id=\"u355361e0\" id=\"u355361e0\">由于 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件的话，那么服务器就会认为依旧在缓存的失效内，将不会返回正确的资源</span></li></ol></blockquote><h4 data-lake-id=\"Hwbgw\" id=\"Hwbgw\"><span data-lake-id=\"uda69bd4d\" id=\"uda69bd4d\">Etag</span></h4><blockquote data-lake-id=\"ud67c267b\" id=\"ud67c267b\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"uf07e05ba\" id=\"uf07e05ba\"><span data-lake-id=\"u2672c6d5\" id=\"u2672c6d5\">由于 Last-Modified 的弊端，所以在 http/1.1 出现了 Etag。</span></p><p data-lake-id=\"u7439cc0d\" id=\"u7439cc0d\"><span data-lake-id=\"u21121eed\" id=\"u21121eed\">Etag 类似于文件指纹，是服务器根据当前文件的内容，给文件生成的</span><strong><span data-lake-id=\"u1dac6c13\" id=\"u1dac6c13\" style=\"color: rgba(255,103,0,1)\">唯一标识</span></strong><span data-lake-id=\"u3c7b9d68\" id=\"u3c7b9d68\">，只要文件内容有所改动，这个值就会发生改变。</span></p></blockquote><ol list=\"ua8a97192\"><li fid=\"u90912266\" data-lake-id=\"uc8d273ff\" id=\"uc8d273ff\"><span data-lake-id=\"u53942bfa\" id=\"u53942bfa\">服务器通过响应头把这个值传递给浏览器</span></li><li fid=\"u90912266\" data-lake-id=\"uddb6f13d\" id=\"uddb6f13d\"><span data-lake-id=\"u9d97f9de\" id=\"u9d97f9de\">浏览器接收到 </span><strong><span data-lake-id=\"ubf2b1483\" id=\"ubf2b1483\" style=\"color: rgba(255,103,0,1)\">Etag</span></strong><span data-lake-id=\"u5ccee3da\" id=\"u5ccee3da\"> 的值，会在下次请求时，将这个值作为 </span><strong><span data-lake-id=\"uf2d5d3d5\" id=\"uf2d5d3d5\" style=\"color: rgba(255,103,0,1)\">If-None-Match</span></strong><strong><span data-lake-id=\"u58417f0b\" id=\"u58417f0b\"> </span></strong><span data-lake-id=\"uecbebe29\" id=\"uecbebe29\">这个字段内容，并放到请求头中，然后发送给服务器</span></li><li fid=\"u90912266\" data-lake-id=\"u63b92db0\" id=\"u63b92db0\"><span data-lake-id=\"u1de57faa\" id=\"u1de57faa\">服务器接收到 </span><strong><span data-lake-id=\"u94ca3ef1\" id=\"u94ca3ef1\" style=\"color: rgba(255,103,0,1)\">If-None-Match</span></strong><span data-lake-id=\"ue74e37b9\" id=\"ue74e37b9\"> 后，会将服务器上该资源的 </span><strong><span data-lake-id=\"u0fc872ca\" id=\"u0fc872ca\" style=\"color: rgba(255,103,0,1)\">ETag</span></strong><span data-lake-id=\"ucf8d0550\" id=\"ucf8d0550\"> 进行比对</span></li></ol><ul list=\"u0d0aba59\" data-lake-indent=\"1\"><li fid=\"ub6529b25\" data-lake-id=\"u6311f03c\" id=\"u6311f03c\"><span data-lake-id=\"ue37e2c93\" id=\"ue37e2c93\">如果二者不相同，说明需要更新。此时会返回新资源</span></li><li fid=\"ub6529b25\" data-lake-id=\"u74aac6fb\" id=\"u74aac6fb\"><span data-lake-id=\"u85594552\" id=\"u85594552\">反之，则返回 304，告诉浏览器直接使用缓存</span></li></ul><h3 data-lake-id=\"E7lJP\" id=\"E7lJP\"><span data-lake-id=\"u36c71a5e\" id=\"u36c71a5e\">不设置缓存策略</span></h3><p data-lake-id=\"ua9876809\" id=\"ua9876809\"><span data-lake-id=\"u77f4d3d4\" id=\"u77f4d3d4\">如果什么缓存策略都没有设置，那么浏览器会采用一个启发式算法，该算法通常会取响应头中的 </span><strong><span data-lake-id=\"ua2ffaa07\" id=\"ua2ffaa07\" style=\"color: rgba(255,103,0,1)\">Date - Last-Modified 值的 10%</span></strong><span data-lake-id=\"u3688ab0d\" id=\"u3688ab0d\"> 作为缓存失效时间</span></p><h3 data-lake-id=\"vrUNH\" id=\"vrUNH\"><span data-lake-id=\"u2fb39933\" id=\"u2fb39933\">三种刷新方式对 http 缓存的影响</span></h3><ul list=\"uaebb0b76\"><li fid=\"u226c7d70\" data-lake-id=\"uf77a4824\" id=\"uf77a4824\"><span data-lake-id=\"u735dd9d4\" id=\"u735dd9d4\">正常操作：地址栏输入 url，跳转链接，前进后退等</span></li><li fid=\"u226c7d70\" data-lake-id=\"u659401d9\" id=\"u659401d9\"><span data-lake-id=\"uf29d201e\" id=\"uf29d201e\">手动刷新：f5，点击刷新按钮，右键菜单刷新</span></li><li fid=\"u226c7d70\" data-lake-id=\"u916e64ce\" id=\"u916e64ce\"><span data-lake-id=\"ue22a94a7\" id=\"ue22a94a7\">强制刷新：ctrl + f5，shift+command+r</span></li></ul><blockquote data-lake-id=\"ud9b299fa\" id=\"ud9b299fa\" class=\"lake-alert lake-alert-warning\"><p data-lake-id=\"ue5a48cb3\" id=\"ue5a48cb3\"><span data-lake-id=\"uc9afb75d\" id=\"uc9afb75d\">正常操作：强缓存有效，协商缓存有效；</span></p><p data-lake-id=\"u86b150f7\" id=\"u86b150f7\"><span data-lake-id=\"u0f7f60fe\" id=\"u0f7f60fe\">手动刷新：强缓存失效，协商缓存有效；</span></p><p data-lake-id=\"u4536a251\" id=\"u4536a251\"><span data-lake-id=\"u5fefc335\" id=\"u5fefc335\">强制刷新：强缓存失效，协商缓存失效；</span></p></blockquote><h2 data-lake-id=\"COxpQ\" id=\"COxpQ\"><span data-lake-id=\"u35348d45\" id=\"u35348d45\">浏览器缓存机制</span></h2><ul list=\"u082914bf\"><li fid=\"u596e5ff1\" data-lake-id=\"u2b46bf87\" id=\"u2b46bf87\"><span data-lake-id=\"u974327a5\" id=\"u974327a5\">通过在一段时间内保留已收到的 web 资源的一个副本，如果在有效时间内，发起了对这个资源的再一次请求，浏览器将直接使用缓存副本，而不是再次发起请求</span></li><li fid=\"u596e5ff1\" data-lake-id=\"u348cac90\" id=\"u348cac90\"><span data-lake-id=\"u768c7239\" id=\"u768c7239\">可以提高页面的打开速度，减少不必要的带宽消耗</span></li></ul><h2 data-lake-id=\"oM2nV\" id=\"oM2nV\"><span data-lake-id=\"ua589738d\" id=\"ua589738d\">浏览器缓存位置</span></h2><h3 data-lake-id=\"SYHFm\" id=\"SYHFm\"><span data-lake-id=\"u40763522\" id=\"u40763522\">Service Worker</span></h3><blockquote data-lake-id=\"ub9f8e6d1\" id=\"ub9f8e6d1\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u5ead21cd\" id=\"u5ead21cd\"><span data-lake-id=\"u48a7d704\" id=\"u48a7d704\">Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件，如何匹配缓存、如何读取缓存，并且缓存是可持续性的</span></p></blockquote><h4 data-lake-id=\"DbXt8\" id=\"DbXt8\"><span data-lake-id=\"u38039f32\" id=\"u38039f32\">概念</span></h4><p data-lake-id=\"ud6fd5c5e\" id=\"ud6fd5c5e\" style=\"text-indent: 2em\"><span data-lake-id=\"ucf077ce3\" id=\"ucf077ce3\">Service worker 是一个服务器与浏览器之间的中间人角色，如果网站中注册了 Service worker，那么它可以拦截当前网站所有的请求，然后进行判断。</span></p><p data-lake-id=\"ub8bf702c\" id=\"ub8bf702c\"><span data-lake-id=\"u036ba043\" id=\"u036ba043\">​</span><br></p><p data-lake-id=\"ubbb9f73c\" id=\"ubbb9f73c\" style=\"text-indent: 2em\"><span data-lake-id=\"u826b650b\" id=\"u826b650b\">如果需要向服务器发起请求，那么就转发给服务器；如果可以使用缓存，那么就直接返回缓存内容而不再转发给服务器，从而嗒哒提高浏览体验</span></p><h4 data-lake-id=\"lR0tN\" id=\"lR0tN\"><span data-lake-id=\"u9ad2f4a0\" id=\"u9ad2f4a0\">生命周期</span></h4><p data-lake-id=\"uaa264488\" id=\"uaa264488\"><span data-lake-id=\"ud587de2b\" id=\"ud587de2b\">Service worker 的生命周期与 web 页面完全分离，它包含以下几个阶段：</span></p><ul list=\"u79ba7b93\"><li fid=\"u3784edf3\" data-lake-id=\"u8363aeb2\" id=\"u8363aeb2\"><span data-lake-id=\"ua4a8d538\" id=\"ua4a8d538\">下载</span></li></ul><p data-lake-id=\"u4a26e90b\" id=\"u4a26e90b\"><span data-lake-id=\"ub2f1efc6\" id=\"ub2f1efc6\">这是浏览器下载包含 Service worker 的 .js 文件的时候</span></p><ul list=\"u79ba7b93\" start=\"2\"><li fid=\"u3784edf3\" data-lake-id=\"ucf115a70\" id=\"ucf115a70\"><span data-lake-id=\"u88445c9c\" id=\"u88445c9c\">安装</span></li></ul><p data-lake-id=\"u090b3bdd\" id=\"u090b3bdd\"><span data-lake-id=\"u3a88199b\" id=\"u3a88199b\">在安装过程中，通常需要缓存某些静态资产，如果某些资源已经成功缓存，那么 Service worker 就安装完毕；如果任何文件下载失败或缓存失败，那么安装步骤也将会失败，Service worker 也就无法激活(也就是说，不会安装)。如果发生这种情况，不必担心，它下次会再试一次</span></p><ul list=\"u79ba7b93\" start=\"3\"><li fid=\"u3784edf3\" data-lake-id=\"u6e894117\" id=\"u6e894117\"><span data-lake-id=\"u6bf9bdd3\" id=\"u6bf9bdd3\">激活</span></li></ul><p data-lake-id=\"ud1d89f19\" id=\"ud1d89f19\"><span data-lake-id=\"u2fe7b5ec\" id=\"u2fe7b5ec\">安装成功之后，接下来就是激活步骤，通常会在这个阶段管理旧缓存。要为 web 应用程序安装 Service worker，必须先注册它，这一步可以在 JavaScript 代码中完成。注册 Service worker 后，它会提示浏览器在后台启动 Service worker 安装步骤。</span></p><p data-lake-id=\"uc0b18d08\" id=\"uc0b18d08\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647342652227-761c4858-30be-43b2-93a0-3cf0f0f81648.png%22%2C%22taskId%22%3A%22uae31afbd-abbd-4991-9502-d203dc5ac55%22%2C%22clientId%22%3A%22u42ae1cda-cfa5-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A800%2C%22height%22%3A522%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A43941%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A800%2C%22originHeight%22%3A522%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22INSTALLING%20ERROR%20ACTIVATED%20IDLE%20FETCH%20%2F%20MESSAGE%20TERMINATED%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A439.92496%2C%22y%22%3A101.629295%2C%22width%22%3A79.56383999999997%2C%22height%22%3A19.256505000000004%2C%22text%22%3A%22INSTALLING%22%7D%2C%7B%22x%22%3A626.37054%2C%22y%22%3A204.21153%2C%22width%22%3A45.969119999999975%2C%22height%22%3A16.819829999999996%2C%22text%22%3A%22ERROR%22%7D%2C%7B%22x%22%3A271.42532%2C%22y%22%3A205.57391%2C%22width%22%3A83.91590000000002%2C%22height%22%3A16.82056%2C%22text%22%3A%22ACTIVATED%22%7D%2C%7B%22x%22%3A297.1282%2C%22y%22%3A321.12537%2C%22width%22%3A33.827499999999986%2C%22height%22%3A17.171600000000012%2C%22text%22%3A%22IDLE%22%7D%2C%7B%22x%22%3A401.7576%2C%22y%22%3A429.08847%2C%22width%22%3A150.57754%2C%22height%22%3A20.15527000000003%2C%22text%22%3A%22FETCH%20%2F%20MESSAGE%22%7D%2C%7B%22x%22%3A98.38967%2C%22y%22%3A429.63498%2C%22width%22%3A103.66741000000002%2C%22height%22%3A17.027980000000014%2C%22text%22%3A%22TERMINATED%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22ApOtR%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h4 data-lake-id=\"Mlfvm\" id=\"Mlfvm\"><span data-lake-id=\"uffcea031\" id=\"uffcea031\">Service worker 经常配合哪种缓存使用</span></h4><p data-lake-id=\"u634edcbf\" id=\"u634edcbf\"><span data-lake-id=\"u448f26a8\" id=\"u448f26a8\">经常配合 CacheStorage 离线缓存一起使用</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22if%20(%5C%22serviceWorker%5C%22%20in%20navigator)%20%7B%5Cn%20%20navigator.serviceWorker.register(%5C%22.%2Fsw.js%5C%22)%3B%5Cn%7D%5Cn%5Cn%2F%2F%20sw.js%5Cnvar%20VERSION%20%3D%20%5C%22v1%5C%22%3B%5Cn%5Cn%2F%2F%20%E7%BC%93%E5%AD%98%5Cnself.addEventListener(%5C%22install%5C%22%2C%20function%20(event)%20%7B%5Cn%20%20event.waitUntil(%5Cn%20%20%20%20caches.open(VERSION).then(function%20(cache)%20%7B%5Cn%20%20%20%20%20%20return%20cache.addAll(%5B%5C%22.%2Fstart.html%5C%22%2C%20%5C%22.%2Fstatic%2Fjquery.min.js%5C%22%2C%20%5C%22.%2Fstatic%2Fmm1.jpg%5C%22%5D)%3B%5Cn%20%20%20%20%7D)%5Cn%20%20)%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%5Cnself.addEventListener(%5C%22activate%5C%22%2C%20function%20(event)%20%7B%5Cn%20%20event.waitUntil(%5Cn%20%20%20%20caches.keys().then(function%20(cacheNames)%20%7B%5Cn%20%20%20%20%20%20return%20Promise.all(%5Cn%20%20%20%20%20%20%20%20cacheNames.map(function%20(cacheName)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E7%89%88%E6%9C%AC%E5%92%8C%E7%BC%93%E5%AD%98%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E8%87%B4%5Cn%20%20%20%20%20%20%20%20%20%20if%20(cacheName%20!%3D%3D%20VERSION)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20caches.delete(cacheName)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20)%3B%5Cn%20%20%20%20%7D)%5Cn%20%20)%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20%E6%8D%95%E8%8E%B7%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%5Cnself.addEventListener(%5C%22fetch%5C%22%2C%20function%20(event)%20%7B%5Cn%20%20event.respondWith(%5Cn%20%20%20%20caches%5Cn%20%20%20%20%20%20.match(event.request)%5Cn%20%20%20%20%20%20.catch(function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20fetch(event.request)%3B%5Cn%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20.then(function%20(response)%20%7B%5Cn%20%20%20%20%20%20%20%20caches.open(VERSION).then(function%20(cache)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20cache.put(event.request%2C%20response)%3B%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%20%20%20%20return%20response.clone()%3B%5Cn%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20.catch(function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20caches.match(%5C%22.%2Fstatic%2Fmm1.jpg%5C%22)%3B%5Cn%20%20%20%20%20%20%7D)%5Cn%20%20)%3B%5Cn%7D)%3B%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22Hqpaz%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h3 data-lake-id=\"Sdh0F\" id=\"Sdh0F\"><span data-lake-id=\"u053114ed\" id=\"u053114ed\">Memory Cache</span></h3><blockquote data-lake-id=\"ub5d002d2\" id=\"ub5d002d2\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"udefad1f1\" id=\"udefad1f1\"><span data-lake-id=\"ued90c7b1\" id=\"ued90c7b1\">Memory Cache 是内存中的缓存，读取内存中的数据肯定比读取磁盘中的数据快。但是内存缓存虽然读取高效，但是缓存持续性很短，会随着进程的释放而释放</span></p></blockquote><h3 data-lake-id=\"WVKZW\" id=\"WVKZW\"><span data-lake-id=\"u98f08996\" id=\"u98f08996\">DIsk Cache</span></h3><blockquote data-lake-id=\"u39db2c2e\" id=\"u39db2c2e\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u2cb23c8b\" id=\"u2cb23c8b\"><span data-lake-id=\"ucc2515e8\" id=\"ucc2515e8\">Disk Cache 是存储在硬盘中的缓存，虽然读取速度慢，但是都可以存储到磁盘中，但是胜在容量和存储时效性上</span></p></blockquote><h3 data-lake-id=\"s9Hdu\" id=\"s9Hdu\"><span data-lake-id=\"ucbe293d2\" id=\"ucbe293d2\">Push Cache</span></h3><blockquote data-lake-id=\"u34580b0a\" id=\"u34580b0a\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"ub5cf6996\" id=\"ub5cf6996\"><span data-lake-id=\"u08797275\" id=\"u08797275\">Push Cache 是 http/2 中的内容，当以上三种缓存都没有命中时，它才会被使用，并且缓存时间也很短暂，只在 session 会话中存在，一旦会话结束也将被释放</span></p></blockquote><h3 data-lake-id=\"UhvEp\" id=\"UhvEp\"><span data-lake-id=\"ueffc6aa9\" id=\"ueffc6aa9\">网络请求</span></h3><blockquote data-lake-id=\"uad1a5b09\" id=\"uad1a5b09\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u0603f7c3\" id=\"u0603f7c3\"><span data-lake-id=\"u5dfe028a\" id=\"u5dfe028a\">如果所有缓存都没有命中的话，那么只能发起请求来获取资源了</span></p></blockquote><h2 data-lake-id=\"hD56L\" id=\"hD56L\"><span data-lake-id=\"uc09f8d39\" id=\"uc09f8d39\">indexDB</span></h2><ul list=\"u61022776\"><li fid=\"uef7db9f2\" data-lake-id=\"u148dc6f4\" id=\"u148dc6f4\"><span data-lake-id=\"u5ef6dc21\" id=\"u5ef6dc21\">indexDB 是浏览器提供的本地数据库，它可以被网页脚本创建和操作。indexDB 允许储存大量数据，提供查找接口，还能够建立索引。</span></li></ul><ul list=\"u82041752\"><li fid=\"u27701355\" data-lake-id=\"u3bdc54d5\" id=\"u3bdc54d5\"><span data-lake-id=\"ud9fb593a\" id=\"ud9fb593a\">indexDB 不属于关系型数据库，更接近于 NoSQL 数据库</span></li></ul>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-06-30T07:11:24.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:54.000Z",
  "updated_at": "2022-06-30T07:11:25.000Z",
  "published_at": "2022-06-30T07:11:24.000Z",
  "first_published_at": "2022-04-04T11:32:53.653Z",
  "word_count": 2419,
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1647329182885-d009e7fa-9dc1-45ad-9420-27eb01c05b48.png",
  "description": "http 缓存浏览器中的缓存作用分为两种情况：需要发送 http 请求 和 不需要发送 http 请求。因此，会依次检查 强缓存策略 和 协商缓存策略。强缓存强缓存表示在缓存期间不需要发送 http 请求，因此它的 http 状态码为 200。强缓存主要通过请求头中的相应字段来进行检查。htt...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}