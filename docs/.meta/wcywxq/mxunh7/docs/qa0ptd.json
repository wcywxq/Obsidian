{
  "id": 72212250,
  "slug": "qa0ptd",
  "title": "vite 的实现原理",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "vite 的基本实现原理，就是启动一个 Koa 服务器拦截由浏览器请求 ESM 的请求。通过请求的路径找到目录下对应的文件做一定的处理最终以 ESM 的格式返回给客户端。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1648048501247-7e333445-3645-4812-8f41-1640bd010757.png#clientId=u2d1aa443-6142-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=493&id=u19d3f0d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=493&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=154180&status=done&style=none&taskId=ua01edec7-e77b-4199-83a0-570bf7c0c6f&title=&width=720#id=ipLEc&originHeight=493&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n<a name=\"fe289ed9\"></a>\n### 依赖处理\n\nvite 通过在一开始将应用中的模块区分为依赖和源码两类，改进了开发服务器启动时间。依赖大多为在开发时不会变动的纯 javaScript。一些较大的依赖(例如有上百个模块的组件库)处理的代价也很高。\n\n- 依赖解析\n\n以 Vite 官方 demo 为例，当我们请求 localhost:3000 时，Vite 默认返回 localhost:3000/index.html 的代码。而后发送请求 src/main.js。\n\n```javascript\nimport { createApp } from \"vue\"\nimport App from \"./App.vue\"\nimport \"./index.css\"\n\ncreateApp(App).mount(\"#app\")\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1648095490663-b1a8aa61-105a-4084-8af9-9f3dc069adb2.png#clientId=u09aca2d8-0600-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u6a3c84d1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=185&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69038&status=done&style=none&taskId=ubc158b0c-b429-490b-857d-8384513ec11&title=&width=720#id=sbvqS&originHeight=185&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />可以观察到浏览器请求 vue.js 时， 请求路径是 @modules/vue.js。在 Vite 中约定若 path 的请求路径满足 /^/@modules// 格式时，被认为是一个 node_modules 模块。\n\n平时开发中，webpack & rollup(rollup 有对应插件) 等打包工具会帮我们找到模块的路径，但浏览器只能通过相对路径去寻找，而如果是直接使用模块名比如：import vue from 'vue'，浏览器就会报错，这个时候就需要一个三方包进行处理。Vite 对 ESM 形式的 js 文件模块使用了 ES Module Lexer 处理。Lexer 会找到代码中以 import 语法导入的模块并以数组形式返回。Vite 通过该数组的值获取判断是否为一个 node_modules 模块。若是则进行对应改写成 @modules/:id 的写法。\n\n重写完路径后，浏览器会发送 path 为 /@modules/:id 的对应请求，接下来会被 Vite 客户端做一层拦截来解析模块的真实位置。\n\n首先正则匹配请求路径，如果是/@modules  开头就进行后续处理，否则就跳过。若是，会设置响应类型为 js，读取真实模块路径内容，返回给客户端。 \n\n客户端注入本质上是创建一个 script 标签（type='module'），然后将其插入到 head 中，这样客户端在解析 html 是就可以执行代码了\n\n```javascript\nexport const moduleRE = /^\\/@modules\\//\n// plugin for resolving /@modules/:id requests.\napp.use(async (ctx, next) => {\n  if (!moduleRE.test(ctx.path)) {\n    return next()\n  }\n  // path maybe contain encode chars\n  const id = decodeURIComponent(ctx.path.replace(moduleRE, ''))\n  ctx.type = 'js'\n  const serve = async (id: string, file: string, type: string) => {\n    // 在代码中做一个缓存，下次访问相同路径直接从 map 中获取 304 返回\n    moduleIdToFileMap.set(id, file)\n    moduleFileToIdMap.set(file, ctx.path)\n    debug(`(${type}) ${id} -> ${getDebugPath(root, file)}`)\n    await ctx.read(file)\n    return next()\n  }\n }\n  // 兼容 alias 情况\n  const importerFilePath = importer ? resolver.requestToFile(importer) : root\n  const nodeModulePath = resolveNodeModuleFile(importerFilePath, id)\n  // 如果是个 node_modules 的模块，读取文件。\n  if (nodeModulePath) {\n   return serve(id, nodeModulePath, 'node_modules')\n  }\n})\n```\n\n- 依赖预构建\n\n依赖预构建主要有两个目的：\n\n1. CommonJS 和 UMD 兼容性:：开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。\n2. 性能： Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。\n\nVite 使用 esbuild 在初次启动开发服务器前把检测到的依赖进行预构建。Vite 基于 ESM，在使用某些模块时，由于模块依赖了另一些模块，依赖的模块又基于另一些模块。会出现页面初始化时一次发送数百个模块请求的情况。\n\n以 lodash-es 为例，代码中以 import { debounce } from 'lodash' 导入一个命名函数时候，并不是只下载包含这个函数的文件，而是有一个依赖图。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1648095603671-d483a48d-2ce0-4764-9a46-3116f6a04122.png#clientId=u09aca2d8-0600-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=430&id=u1edba0ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80511&status=done&style=none&taskId=u10275e88-57a9-4d44-877d-b39b7cfe305&title=&width=720#id=MKRr8&originHeight=430&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)可以看到一共发送了 651 个请求。一共花费 1.53s。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1648095614338-a79c2580-8d9f-417d-a5c5-dee598d9912b.png#clientId=u09aca2d8-0600-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=57&id=u03a2960a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=57&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34677&status=done&style=none&taskId=u36c22dbb-6483-41a4-ba57-2c8ea0e14e5&title=&width=720#id=dvO8L&originHeight=57&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />Vite 为了优化这个情况，利用 esbuild 在启动的时候预先把 debounce 用到的所有内部模块全部打包成一个 bundle，这样就浏览器在请求 debounce 时，便只需要发送一次请求了\n\n可以看到预构建后，只发送了 14 个请求。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1648095626604-d851b686-16ed-4a53-9be4-53b72581ea9d.png#clientId=u09aca2d8-0600-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=u82d1960e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=219&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118304&status=done&style=none&taskId=u4237b6fe-9f85-44a9-b8d7-fbe09163a86&title=&width=720#id=YDYT2&originHeight=219&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n<a name=\"3c87507c\"></a>\n### 静态资源加载\n\n当请求的路径符合 imageRE, mediaRE, fontsRE 或 JSON 格式，会被认为是一个静态资源。静态资源将处理成 ESM 模块返回。\n\n```typescript\n// src/node/utils/pathUtils.ts\nconst imageRE = /\\.(png|jpe?g|gif|svg|ico|webp)(\\?.*)?$/\nconst mediaRE = /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/\nconst fontsRE = /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/i\nexport const isStaticAsset = (file: string) => {\n  return imageRE.test(file) || mediaRE.test(file) || fontsRE.test(file)\n}\n\n// src/node/server/serverPluginAssets.ts\napp.use(async (ctx, next) => {\n  if (isStaticAsset(ctx.path) && isImportRequest(ctx)) {\n    ctx.type = 'js'\n    ctx.body = export default ${JSON.stringify(ctx.path)} // 输出是path\n    return\n  }\n  return next()\n})\n\nexport const jsonPlugin: ServerPlugin = ({ app }) => {\n  app.use(async (ctx, next) => {\n    await next()\n    // handle .json imports\n    // note ctx.body could be null if upstream set status to 304\n    if (ctx.path.endsWith('.json') && isImportRequest(ctx) && ctx.body) {\n      ctx.type = 'js'\n      ctx.body = dataToEsm(JSON.parse((await readBody(ctx.body))!), {\n        namedExports: true,\n        preferConst: true\n      })\n    }\n  })\n}\n```\n\n<a name=\"534a9bc8\"></a>\n### 文件缓存\n\n当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template, css, script 模块三个模块进行分别处理。最后会对 script, template, css 发送多个请求获取<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1648095741580-fc3847de-27f9-4134-a8a5-cd3c73eeb714.png#clientId=u09aca2d8-0600-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=100&id=ue10e68e9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=100&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48444&status=done&style=none&taskId=udade0525-0474-452c-af90-0549edf8c53&title=&width=720#id=Ao8Po&originHeight=100&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />如上图中请求 App.vue 获取 script 代码 , App.vue?type=template 获取 template, App.vue?type=style。这些代码都被插入在 App.vue 返回的代码中。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1648095751740-682b5c79-dd4f-4379-a1c9-9e2b63b9b6fe.png#clientId=u09aca2d8-0600-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u1d0b07e4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=243&originWidth=719&originalType=binary&ratio=1&rotation=0&showTitle=false&size=173646&status=done&style=none&taskId=ub5e34bae-8ddb-4090-a401-9cc4130380b&title=&width=719#id=FNAYG&originHeight=243&originWidth=719&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n<a name=\"0ce1095c\"></a>\n### js/ts 处理\n\nvite 使用 esbuild 将 ts 转译到 js，约是 tsc 速度的 20 ～ 30 倍，同时 hmr 更新反应到浏览器的时间会小于 50ms。但是，由于 esbuild 转换 ts 到 js 对于类型操作仅仅是擦除，所以完全保证不了类型正确，因此需要额外校验类型，比如使用：tsc --noEmit。\n\n将 ts 转译成 js 后，浏览器便可以利用 ESM 直接拿到 js 资源。\n\n<a name=\"d41d8cd9\"></a>\n## \n",
  "body_draft": "",
  "body_html": "<!doctype html><p data-lake-id=\"u27e3dbe6\"><span>vite 的基本实现原理，就是启动一个 Koa 服务器拦截由浏览器请求 ESM 的请求。通过请求的路径找到目录下对应的文件做一定的处理最终以 ESM 的格式返回给客户端。<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1648048501247-7e333445-3645-4812-8f41-1640bd010757.png#clientId=u2d1aa443-6142-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=493&amp;id=u19d3f0d0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=493&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=154180&amp;status=done&amp;style=none&amp;taskId=ua01edec7-e77b-4199-83a0-570bf7c0c6f&amp;title=&amp;width=720#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=ipLEc&amp;originHeight=493&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /></p><p data-lake-id=\"ue74cd8a1\"><br /></p><h3 id=\"fe289ed9\"><span>依赖处理</span></h3><p data-lake-id=\"ue7390f93\"><br /></p><p data-lake-id=\"u926b46f6\"><span>vite 通过在一开始将应用中的模块区分为依赖和源码两类，改进了开发服务器启动时间。依赖大多为在开发时不会变动的纯 javaScript。一些较大的依赖(例如有上百个模块的组件库)处理的代价也很高。</span></p><p data-lake-id=\"ufb44e83b\"><br /></p><ul><li><span>依赖解析</span></li></ul><p data-lake-id=\"u3f8a07de\"><br /></p><p data-lake-id=\"ub02bc8a6\"><span>以 Vite 官方 demo 为例，当我们请求 localhost:3000 时，Vite 默认返回 localhost:3000/index.html 的代码。而后发送请求 src/main.js。</span></p><p data-lake-id=\"u027e3319\"><br /></p><pre data-lang=\"javascript\"><code>import { createApp } from &quot;vue&quot;\nimport App from &quot;./App.vue&quot;\nimport &quot;./index.css&quot;\n\ncreateApp(App).mount(&quot;#app&quot;)</code></pre><p data-lake-id=\"ubcad45ce\"><br /></p><p data-lake-id=\"ue5457be6\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1648095490663-b1a8aa61-105a-4084-8af9-9f3dc069adb2.png#clientId=u09aca2d8-0600-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=185&amp;id=u6a3c84d1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=185&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=69038&amp;status=done&amp;style=none&amp;taskId=ubc158b0c-b429-490b-857d-8384513ec11&amp;title=&amp;width=720#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=sbvqS&amp;originHeight=185&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>可以观察到浏览器请求 vue.js 时， 请求路径是 @modules/vue.js。在 Vite 中约定若 path 的请求路径满足 /^/@modules// 格式时，被认为是一个 node_modules 模块。</span></p><p data-lake-id=\"u4546a34c\"><br /></p><p data-lake-id=\"ube351d31\"><span>平时开发中，webpack &amp; rollup(rollup 有对应插件) 等打包工具会帮我们找到模块的路径，但浏览器只能通过相对路径去寻找，而如果是直接使用模块名比如：import vue from 'vue'，浏览器就会报错，这个时候就需要一个三方包进行处理。Vite 对 ESM 形式的 js 文件模块使用了 ES Module Lexer 处理。Lexer 会找到代码中以 import 语法导入的模块并以数组形式返回。Vite 通过该数组的值获取判断是否为一个 node_modules 模块。若是则进行对应改写成 @modules/:id 的写法。</span></p><p data-lake-id=\"u661253dd\"><br /></p><p data-lake-id=\"ub880d1b8\"><span>重写完路径后，浏览器会发送 path 为 /@modules/:id 的对应请求，接下来会被 Vite 客户端做一层拦截来解析模块的真实位置。</span></p><p data-lake-id=\"ub41e9d1b\"><br /></p><p data-lake-id=\"ua8d53800\"><span>首先正则匹配请求路径，如果是/</span><span>@modules </span><span> 开头就进行后续处理，否则就跳过。若是，会设置响应类型为 js，读取真实模块路径内容，返回给客户端。 </span></p><p data-lake-id=\"u663fc5e9\"><br /></p><p data-lake-id=\"u3984a3d9\"><span>客户端注入本质上是创建一个 script 标签（type='module'），然后将其插入到 head 中，这样客户端在解析 html 是就可以执行代码了</span></p><p data-lake-id=\"uc1b349d2\"><br /></p><pre data-lang=\"javascript\"><code>export const moduleRE = /^\\/@modules\\//\n// plugin for resolving /@modules/:id requests.\napp.use(async (ctx, next) =&gt; {\n  if (!moduleRE.test(ctx.path)) {\n    return next()\n  }\n  // path maybe contain encode chars\n  const id = decodeURIComponent(ctx.path.replace(moduleRE, ''))\n  ctx.type = 'js'\n  const serve = async (id: string, file: string, type: string) =&gt; {\n    // 在代码中做一个缓存，下次访问相同路径直接从 map 中获取 304 返回\n    moduleIdToFileMap.set(id, file)\n    moduleFileToIdMap.set(file, ctx.path)\n    debug(`(${type}) ${id} -&gt; ${getDebugPath(root, file)}`)\n    await ctx.read(file)\n    return next()\n  }\n }\n  // 兼容 alias 情况\n  const importerFilePath = importer ? resolver.requestToFile(importer) : root\n  const nodeModulePath = resolveNodeModuleFile(importerFilePath, id)\n  // 如果是个 node_modules 的模块，读取文件。\n  if (nodeModulePath) {\n   return serve(id, nodeModulePath, 'node_modules')\n  }\n})</code></pre><p data-lake-id=\"ub5660395\"><br /></p><ul><li><span>依赖预构建</span></li></ul><p data-lake-id=\"u1a8e0f37\"><br /></p><p data-lake-id=\"ub1fb5c7d\"><span>依赖预构建主要有两个目的：</span></p><p data-lake-id=\"u9439fed8\"><br /></p><ol><li><span>CommonJS 和 UMD 兼容性:：开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。</span></li><li><span>性能： Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</span></li></ol><p data-lake-id=\"ud97c7cb3\"><br /></p><p data-lake-id=\"u5da1428f\"><span>Vite 使用 esbuild 在初次启动开发服务器前把检测到的依赖进行预构建。Vite 基于 ESM，在使用某些模块时，由于模块依赖了另一些模块，依赖的模块又基于另一些模块。会出现页面初始化时一次发送数百个模块请求的情况。</span></p><p data-lake-id=\"u6147e44d\"><br /></p><p data-lake-id=\"u54fd843c\"><span>以 lodash-es 为例，代码中以 import { debounce } from 'lodash' 导入一个命名函数时候，并不是只下载包含这个函数的文件，而是有一个依赖图。<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1648095603671-d483a48d-2ce0-4764-9a46-3116f6a04122.png#clientId=u09aca2d8-0600-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=430&amp;id=u1edba0ca&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=430&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80511&amp;status=done&amp;style=none&amp;taskId=u10275e88-57a9-4d44-877d-b39b7cfe305&amp;title=&amp;width=720#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=MKRr8&amp;originHeight=430&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span>可以看到一共发送了 651 个请求。一共花费 1.53s。<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1648095614338-a79c2580-8d9f-417d-a5c5-dee598d9912b.png#clientId=u09aca2d8-0600-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=57&amp;id=u03a2960a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=57&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34677&amp;status=done&amp;style=none&amp;taskId=u36c22dbb-6483-41a4-ba57-2c8ea0e14e5&amp;title=&amp;width=720#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=dvO8L&amp;originHeight=57&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>Vite 为了优化这个情况，利用 esbuild 在启动的时候预先把 debounce 用到的所有内部模块全部打包成一个 bundle，这样就浏览器在请求 debounce 时，便只需要发送一次请求了</span></p><p data-lake-id=\"uc2111551\"><br /></p><p data-lake-id=\"u9b85c921\"><span>可以看到预构建后，只发送了 14 个请求。<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1648095626604-d851b686-16ed-4a53-9be4-53b72581ea9d.png#clientId=u09aca2d8-0600-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=u82d1960e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=219&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=118304&amp;status=done&amp;style=none&amp;taskId=u4237b6fe-9f85-44a9-b8d7-fbe09163a86&amp;title=&amp;width=720#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=YDYT2&amp;originHeight=219&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /></p><p data-lake-id=\"ubb559af6\"><br /></p><h3 id=\"3c87507c\"><span>静态资源加载</span></h3><p data-lake-id=\"ucd5fc058\"><br /></p><p data-lake-id=\"u61a3e54c\"><span>当请求的路径符合 imageRE, mediaRE, fontsRE 或 JSON 格式，会被认为是一个静态资源。静态资源将处理成 ESM 模块返回。</span></p><p data-lake-id=\"u801edb52\"><br /></p><pre data-lang=\"typescript\"><code>// src/node/utils/pathUtils.ts\nconst imageRE = /\\.(png|jpe?g|gif|svg|ico|webp)(\\?.*)?$/\nconst mediaRE = /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/\nconst fontsRE = /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/i\nexport const isStaticAsset = (file: string) =&gt; {\n  return imageRE.test(file) || mediaRE.test(file) || fontsRE.test(file)\n}\n\n// src/node/server/serverPluginAssets.ts\napp.use(async (ctx, next) =&gt; {\n  if (isStaticAsset(ctx.path) &amp;&amp; isImportRequest(ctx)) {\n    ctx.type = 'js'\n    ctx.body = export default ${JSON.stringify(ctx.path)} // 输出是path\n    return\n  }\n  return next()\n})\n\nexport const jsonPlugin: ServerPlugin = ({ app }) =&gt; {\n  app.use(async (ctx, next) =&gt; {\n    await next()\n    // handle .json imports\n    // note ctx.body could be null if upstream set status to 304\n    if (ctx.path.endsWith('.json') &amp;&amp; isImportRequest(ctx) &amp;&amp; ctx.body) {\n      ctx.type = 'js'\n      ctx.body = dataToEsm(JSON.parse((await readBody(ctx.body))!), {\n        namedExports: true,\n        preferConst: true\n      })\n    }\n  })\n}</code></pre><p data-lake-id=\"u57810cc8\"><br /></p><h3 id=\"534a9bc8\"><span>文件缓存</span></h3><p data-lake-id=\"u7ec04486\"><br /></p><p data-lake-id=\"u5e711763\"><span>当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template, css, script 模块三个模块进行分别处理。最后会对 script, template, css 发送多个请求获取<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1648095741580-fc3847de-27f9-4134-a8a5-cd3c73eeb714.png#clientId=u09aca2d8-0600-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=100&amp;id=ue10e68e9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=100&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=48444&amp;status=done&amp;style=none&amp;taskId=udade0525-0474-452c-af90-0549edf8c53&amp;title=&amp;width=720#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=Ao8Po&amp;originHeight=100&amp;originWidth=720&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>如上图中请求 App.vue 获取 script 代码 , App.vue?type=template 获取 template, App.vue?type=style。这些代码都被插入在 App.vue 返回的代码中。<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1648095751740-682b5c79-dd4f-4379-a1c9-9e2b63b9b6fe.png#clientId=u09aca2d8-0600-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u1d0b07e4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=243&amp;originWidth=719&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=173646&amp;status=done&amp;style=none&amp;taskId=ub5e34bae-8ddb-4090-a401-9cc4130380b&amp;title=&amp;width=719#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=FNAYG&amp;originHeight=243&amp;originWidth=719&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /></p><p data-lake-id=\"u4120a95b\"><br /></p><h3 id=\"0ce1095c\"><span>js/ts 处理</span></h3><p data-lake-id=\"ud213bcb2\"><br /></p><p data-lake-id=\"u8db1dade\"><span>vite 使用 esbuild 将 ts 转译到 js，约是 tsc 速度的 20 ～ 30 倍，同时 hmr 更新反应到浏览器的时间会小于 50ms。但是，由于 esbuild 转换 ts 到 js 对于类型操作仅仅是擦除，所以完全保证不了类型正确，因此需要额外校验类型，比如使用：tsc --noEmit。</span></p><p data-lake-id=\"u561cd1e6\"><br /></p><p data-lake-id=\"uf8b3d9e1\"><span>将 ts 转译成 js 后，浏览器便可以利用 ESM 直接拿到 js 资源。</span></p><p data-lake-id=\"u9234f3a7\"><br /></p><h2 id=\"d41d8cd9\"><br /></h2>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u27e3dbe6\" id=\"u27e3dbe6\"><span data-lake-id=\"u6a25e130\" id=\"u6a25e130\">vite 的基本实现原理，就是启动一个 Koa 服务器拦截由浏览器请求 ESM 的请求。通过请求的路径找到目录下对应的文件做一定的处理最终以 ESM 的格式返回给客户端。<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1648048501247-7e333445-3645-4812-8f41-1640bd010757.png%23clientId%3Du2d1aa443-6142-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26height%3D493%26id%3Du19d3f0d0%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D493%26originWidth%3D720%26originalType%3Dbinary%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26size%3D154180%26status%3Ddone%26style%3Dnone%26taskId%3Dua01edec7-e77b-4199-83a0-570bf7c0c6f%26title%3D%26width%3D720%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A493%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22ipLEc%22%7D\"></card></p><p data-lake-id=\"ue74cd8a1\" id=\"ue74cd8a1\"><br></p><h3 data-lake-id=\"fe289ed9\" id=\"fe289ed9\"><span data-lake-id=\"u2d9ec675\" id=\"u2d9ec675\">依赖处理</span></h3><p data-lake-id=\"ue7390f93\" id=\"ue7390f93\"><br></p><p data-lake-id=\"u926b46f6\" id=\"u926b46f6\"><span data-lake-id=\"u6b92e619\" id=\"u6b92e619\">vite 通过在一开始将应用中的模块区分为依赖和源码两类，改进了开发服务器启动时间。依赖大多为在开发时不会变动的纯 javaScript。一些较大的依赖(例如有上百个模块的组件库)处理的代价也很高。</span></p><p data-lake-id=\"ufb44e83b\" id=\"ufb44e83b\"><br></p><ul list=\"ubd1a542d\"><li fid=\"u55543d89\" data-lake-id=\"u848a33ff\" id=\"u848a33ff\"><span data-lake-id=\"ued8cd804\" id=\"ued8cd804\">依赖解析</span></li></ul><p data-lake-id=\"u3f8a07de\" id=\"u3f8a07de\"><br></p><p data-lake-id=\"ub02bc8a6\" id=\"ub02bc8a6\"><span data-lake-id=\"ubc458ba7\" id=\"ubc458ba7\">以 Vite 官方 demo 为例，当我们请求 localhost:3000 时，Vite 默认返回 localhost:3000/index.html 的代码。而后发送请求 src/main.js。</span></p><p data-lake-id=\"u027e3319\" id=\"u027e3319\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22import%20%7B%20createApp%20%7D%20from%20%5C%22vue%5C%22%5Cnimport%20App%20from%20%5C%22.%2FApp.vue%5C%22%5Cnimport%20%5C%22.%2Findex.css%5C%22%5Cn%5CncreateApp(App).mount(%5C%22%23app%5C%22)%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22main.js%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%228ea7b73d%22%7D\"></card><p data-lake-id=\"ubcad45ce\" id=\"ubcad45ce\"><br></p><p data-lake-id=\"ue5457be6\" id=\"ue5457be6\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1648095490663-b1a8aa61-105a-4084-8af9-9f3dc069adb2.png%23clientId%3Du09aca2d8-0600-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26height%3D185%26id%3Du6a3c84d1%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D185%26originWidth%3D720%26originalType%3Dbinary%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26size%3D69038%26status%3Ddone%26style%3Dnone%26taskId%3Dubc158b0c-b429-490b-857d-8384513ec11%26title%3D%26width%3D720%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A185%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22sbvqS%22%7D\"></card><span data-lake-id=\"uc0ebcdff\" id=\"uc0ebcdff\"><br /></span><span data-lake-id=\"ud40e2114\" id=\"ud40e2114\">可以观察到浏览器请求 vue.js 时， 请求路径是 @modules/vue.js。在 Vite 中约定若 path 的请求路径满足 /^/@modules// 格式时，被认为是一个 node_modules 模块。</span></p><p data-lake-id=\"u4546a34c\" id=\"u4546a34c\"><br></p><p data-lake-id=\"ube351d31\" id=\"ube351d31\"><span data-lake-id=\"ubac79186\" id=\"ubac79186\">平时开发中，webpack &amp; rollup(rollup 有对应插件) 等打包工具会帮我们找到模块的路径，但浏览器只能通过相对路径去寻找，而如果是直接使用模块名比如：import vue from 'vue'，浏览器就会报错，这个时候就需要一个三方包进行处理。Vite 对 ESM 形式的 js 文件模块使用了 ES Module Lexer 处理。Lexer 会找到代码中以 import 语法导入的模块并以数组形式返回。Vite 通过该数组的值获取判断是否为一个 node_modules 模块。若是则进行对应改写成 @modules/:id 的写法。</span></p><p data-lake-id=\"u661253dd\" id=\"u661253dd\"><br></p><p data-lake-id=\"ub880d1b8\" id=\"ub880d1b8\"><span data-lake-id=\"u2470daa4\" id=\"u2470daa4\">重写完路径后，浏览器会发送 path 为 /@modules/:id 的对应请求，接下来会被 Vite 客户端做一层拦截来解析模块的真实位置。</span></p><p data-lake-id=\"ub41e9d1b\" id=\"ub41e9d1b\"><br></p><p data-lake-id=\"ua8d53800\" id=\"ua8d53800\"><span data-lake-id=\"u62721f4b\" id=\"u62721f4b\">首先正则匹配请求路径，如果是/</span><span data-lake-id=\"u9885ac36\" id=\"u9885ac36\">@modules </span><span data-lake-id=\"u07481b75\" id=\"u07481b75\"> 开头就进行后续处理，否则就跳过。若是，会设置响应类型为 js，读取真实模块路径内容，返回给客户端。 </span></p><p data-lake-id=\"u663fc5e9\" id=\"u663fc5e9\"><br></p><p data-lake-id=\"u3984a3d9\" id=\"u3984a3d9\"><span data-lake-id=\"u9dea59c0\" id=\"u9dea59c0\">客户端注入本质上是创建一个 script 标签（type='module'），然后将其插入到 head 中，这样客户端在解析 html 是就可以执行代码了</span></p><p data-lake-id=\"uc1b349d2\" id=\"uc1b349d2\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22export%20const%20moduleRE%20%3D%20%2F%5E%5C%5C%2F%40modules%5C%5C%2F%2F%5Cn%2F%2F%20plugin%20for%20resolving%20%2F%40modules%2F%3Aid%20requests.%5Cnapp.use(async%20(ctx%2C%20next)%20%3D%3E%20%7B%5Cn%20%20if%20(!moduleRE.test(ctx.path))%20%7B%5Cn%20%20%20%20return%20next()%5Cn%20%20%7D%5Cn%20%20%2F%2F%20path%20maybe%20contain%20encode%20chars%5Cn%20%20const%20id%20%3D%20decodeURIComponent(ctx.path.replace(moduleRE%2C%20''))%5Cn%20%20ctx.type%20%3D%20'js'%5Cn%20%20const%20serve%20%3D%20async%20(id%3A%20string%2C%20file%3A%20string%2C%20type%3A%20string)%20%3D%3E%20%7B%5Cn%20%20%20%20%2F%2F%20%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%EF%BC%8C%E4%B8%8B%E6%AC%A1%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E8%B7%AF%E5%BE%84%E7%9B%B4%E6%8E%A5%E4%BB%8E%20map%20%E4%B8%AD%E8%8E%B7%E5%8F%96%20304%20%E8%BF%94%E5%9B%9E%5Cn%20%20%20%20moduleIdToFileMap.set(id%2C%20file)%5Cn%20%20%20%20moduleFileToIdMap.set(file%2C%20ctx.path)%5Cn%20%20%20%20debug(%60(%24%7Btype%7D)%20%24%7Bid%7D%20-%3E%20%24%7BgetDebugPath(root%2C%20file)%7D%60)%5Cn%20%20%20%20await%20ctx.read(file)%5Cn%20%20%20%20return%20next()%5Cn%20%20%7D%5Cn%20%7D%5Cn%20%20%2F%2F%20%E5%85%BC%E5%AE%B9%20alias%20%E6%83%85%E5%86%B5%5Cn%20%20const%20importerFilePath%20%3D%20importer%20%3F%20resolver.requestToFile(importer)%20%3A%20root%5Cn%20%20const%20nodeModulePath%20%3D%20resolveNodeModuleFile(importerFilePath%2C%20id)%5Cn%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E6%98%AF%E4%B8%AA%20node_modules%20%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%8C%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E3%80%82%5Cn%20%20if%20(nodeModulePath)%20%7B%5Cn%20%20%20return%20serve(id%2C%20nodeModulePath%2C%20'node_modules')%5Cn%20%20%7D%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%225d27b4fa%22%7D\"></card><p data-lake-id=\"ub5660395\" id=\"ub5660395\"><br></p><ul list=\"uba64665b\"><li fid=\"ud1705b9f\" data-lake-id=\"uc7f7335c\" id=\"uc7f7335c\"><span data-lake-id=\"u2eb5cf32\" id=\"u2eb5cf32\">依赖预构建</span></li></ul><p data-lake-id=\"u1a8e0f37\" id=\"u1a8e0f37\"><br></p><p data-lake-id=\"ub1fb5c7d\" id=\"ub1fb5c7d\"><span data-lake-id=\"u4b0bd696\" id=\"u4b0bd696\">依赖预构建主要有两个目的：</span></p><p data-lake-id=\"u9439fed8\" id=\"u9439fed8\"><br></p><ol list=\"uc9f5b273\"><li fid=\"ue0f53688\" data-lake-id=\"u33b84a14\" id=\"u33b84a14\"><span data-lake-id=\"u6c0ae34a\" id=\"u6c0ae34a\">CommonJS 和 UMD 兼容性:：开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。</span></li><li fid=\"ue0f53688\" data-lake-id=\"ua6d1bdb9\" id=\"ua6d1bdb9\"><span data-lake-id=\"u713f457a\" id=\"u713f457a\">性能： Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</span></li></ol><p data-lake-id=\"ud97c7cb3\" id=\"ud97c7cb3\"><br></p><p data-lake-id=\"u5da1428f\" id=\"u5da1428f\"><span data-lake-id=\"u0322e929\" id=\"u0322e929\">Vite 使用 esbuild 在初次启动开发服务器前把检测到的依赖进行预构建。Vite 基于 ESM，在使用某些模块时，由于模块依赖了另一些模块，依赖的模块又基于另一些模块。会出现页面初始化时一次发送数百个模块请求的情况。</span></p><p data-lake-id=\"u6147e44d\" id=\"u6147e44d\"><br></p><p data-lake-id=\"u54fd843c\" id=\"u54fd843c\"><span data-lake-id=\"uc52fdd0b\" id=\"uc52fdd0b\">以 lodash-es 为例，代码中以 import { debounce } from 'lodash' 导入一个命名函数时候，并不是只下载包含这个函数的文件，而是有一个依赖图。<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1648095603671-d483a48d-2ce0-4764-9a46-3116f6a04122.png%23clientId%3Du09aca2d8-0600-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26height%3D430%26id%3Du1edba0ca%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D430%26originWidth%3D720%26originalType%3Dbinary%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26size%3D80511%26status%3Ddone%26style%3Dnone%26taskId%3Du10275e88-57a9-4d44-877d-b39b7cfe305%26title%3D%26width%3D720%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A430%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22MKRr8%22%7D\"></card><span data-lake-id=\"u7102a0b8\" id=\"u7102a0b8\">可以看到一共发送了 651 个请求。一共花费 1.53s。<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1648095614338-a79c2580-8d9f-417d-a5c5-dee598d9912b.png%23clientId%3Du09aca2d8-0600-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26height%3D57%26id%3Du03a2960a%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D57%26originWidth%3D720%26originalType%3Dbinary%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26size%3D34677%26status%3Ddone%26style%3Dnone%26taskId%3Du36c22dbb-6483-41a4-ba57-2c8ea0e14e5%26title%3D%26width%3D720%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A57%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22dvO8L%22%7D\"></card><span data-lake-id=\"u969a905b\" id=\"u969a905b\"><br /></span><span data-lake-id=\"uacb35ff9\" id=\"uacb35ff9\">Vite 为了优化这个情况，利用 esbuild 在启动的时候预先把 debounce 用到的所有内部模块全部打包成一个 bundle，这样就浏览器在请求 debounce 时，便只需要发送一次请求了</span></p><p data-lake-id=\"uc2111551\" id=\"uc2111551\"><br></p><p data-lake-id=\"u9b85c921\" id=\"u9b85c921\"><span data-lake-id=\"uce4c022a\" id=\"uce4c022a\">可以看到预构建后，只发送了 14 个请求。<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1648095626604-d851b686-16ed-4a53-9be4-53b72581ea9d.png%23clientId%3Du09aca2d8-0600-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26height%3D219%26id%3Du82d1960e%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D219%26originWidth%3D720%26originalType%3Dbinary%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26size%3D118304%26status%3Ddone%26style%3Dnone%26taskId%3Du4237b6fe-9f85-44a9-b8d7-fbe09163a86%26title%3D%26width%3D720%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A219%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22YDYT2%22%7D\"></card></p><p data-lake-id=\"ubb559af6\" id=\"ubb559af6\"><br></p><h3 data-lake-id=\"3c87507c\" id=\"3c87507c\"><span data-lake-id=\"u7b6d6f49\" id=\"u7b6d6f49\">静态资源加载</span></h3><p data-lake-id=\"ucd5fc058\" id=\"ucd5fc058\"><br></p><p data-lake-id=\"u61a3e54c\" id=\"u61a3e54c\"><span data-lake-id=\"uf98730ec\" id=\"uf98730ec\">当请求的路径符合 imageRE, mediaRE, fontsRE 或 JSON 格式，会被认为是一个静态资源。静态资源将处理成 ESM 模块返回。</span></p><p data-lake-id=\"u801edb52\" id=\"u801edb52\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22%2F%2F%20src%2Fnode%2Futils%2FpathUtils.ts%5Cnconst%20imageRE%20%3D%20%2F%5C%5C.(png%7Cjpe%3Fg%7Cgif%7Csvg%7Cico%7Cwebp)(%5C%5C%3F.*)%3F%24%2F%5Cnconst%20mediaRE%20%3D%20%2F%5C%5C.(mp4%7Cwebm%7Cogg%7Cmp3%7Cwav%7Cflac%7Caac)(%5C%5C%3F.*)%3F%24%2F%5Cnconst%20fontsRE%20%3D%20%2F%5C%5C.(woff2%3F%7Ceot%7Cttf%7Cotf)(%5C%5C%3F.*)%3F%24%2Fi%5Cnexport%20const%20isStaticAsset%20%3D%20(file%3A%20string)%20%3D%3E%20%7B%5Cn%20%20return%20imageRE.test(file)%20%7C%7C%20mediaRE.test(file)%20%7C%7C%20fontsRE.test(file)%5Cn%7D%5Cn%5Cn%2F%2F%20src%2Fnode%2Fserver%2FserverPluginAssets.ts%5Cnapp.use(async%20(ctx%2C%20next)%20%3D%3E%20%7B%5Cn%20%20if%20(isStaticAsset(ctx.path)%20%26%26%20isImportRequest(ctx))%20%7B%5Cn%20%20%20%20ctx.type%20%3D%20'js'%5Cn%20%20%20%20ctx.body%20%3D%20export%20default%20%24%7BJSON.stringify(ctx.path)%7D%20%2F%2F%20%E8%BE%93%E5%87%BA%E6%98%AFpath%5Cn%20%20%20%20return%5Cn%20%20%7D%5Cn%20%20return%20next()%5Cn%7D)%5Cn%5Cnexport%20const%20jsonPlugin%3A%20ServerPlugin%20%3D%20(%7B%20app%20%7D)%20%3D%3E%20%7B%5Cn%20%20app.use(async%20(ctx%2C%20next)%20%3D%3E%20%7B%5Cn%20%20%20%20await%20next()%5Cn%20%20%20%20%2F%2F%20handle%20.json%20imports%5Cn%20%20%20%20%2F%2F%20note%20ctx.body%20could%20be%20null%20if%20upstream%20set%20status%20to%20304%5Cn%20%20%20%20if%20(ctx.path.endsWith('.json')%20%26%26%20isImportRequest(ctx)%20%26%26%20ctx.body)%20%7B%5Cn%20%20%20%20%20%20ctx.type%20%3D%20'js'%5Cn%20%20%20%20%20%20ctx.body%20%3D%20dataToEsm(JSON.parse((await%20readBody(ctx.body))!)%2C%20%7B%5Cn%20%20%20%20%20%20%20%20namedExports%3A%20true%2C%5Cn%20%20%20%20%20%20%20%20preferConst%3A%20true%5Cn%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%7D%5Cn%20%20%7D)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22src%2Fnode%2Futils%2FpathUtils.ts%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%224a83b73b%22%7D\"></card><p data-lake-id=\"u57810cc8\" id=\"u57810cc8\"><br></p><h3 data-lake-id=\"534a9bc8\" id=\"534a9bc8\"><span data-lake-id=\"u8cf240ac\" id=\"u8cf240ac\">文件缓存</span></h3><p data-lake-id=\"u7ec04486\" id=\"u7ec04486\"><br></p><p data-lake-id=\"u5e711763\" id=\"u5e711763\"><span data-lake-id=\"u2e0fbef8\" id=\"u2e0fbef8\">当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template, css, script 模块三个模块进行分别处理。最后会对 script, template, css 发送多个请求获取<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1648095741580-fc3847de-27f9-4134-a8a5-cd3c73eeb714.png%23clientId%3Du09aca2d8-0600-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26height%3D100%26id%3Due10e68e9%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D100%26originWidth%3D720%26originalType%3Dbinary%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26size%3D48444%26status%3Ddone%26style%3Dnone%26taskId%3Dudade0525-0474-452c-af90-0549edf8c53%26title%3D%26width%3D720%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A100%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22Ao8Po%22%7D\"></card><span data-lake-id=\"ub46a883e\" id=\"ub46a883e\"><br /></span><span data-lake-id=\"ua91d4ce6\" id=\"ua91d4ce6\">如上图中请求 App.vue 获取 script 代码 , App.vue?type=template 获取 template, App.vue?type=style。这些代码都被插入在 App.vue 返回的代码中。<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1648095751740-682b5c79-dd4f-4379-a1c9-9e2b63b9b6fe.png%23clientId%3Du09aca2d8-0600-4%26crop%3D0%26crop%3D0%26crop%3D1%26crop%3D1%26from%3Dpaste%26height%3D243%26id%3Du1d0b07e4%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D243%26originWidth%3D719%26originalType%3Dbinary%26ratio%3D1%26rotation%3D0%26showTitle%3Dfalse%26size%3D173646%26status%3Ddone%26style%3Dnone%26taskId%3Dub5e34bae-8ddb-4090-a401-9cc4130380b%26title%3D%26width%3D719%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A719%2C%22originHeight%22%3A243%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22FNAYG%22%7D\"></card></p><p data-lake-id=\"u4120a95b\" id=\"u4120a95b\"><br></p><h3 data-lake-id=\"0ce1095c\" id=\"0ce1095c\"><span data-lake-id=\"u34037a9d\" id=\"u34037a9d\">js/ts 处理</span></h3><p data-lake-id=\"ud213bcb2\" id=\"ud213bcb2\"><br></p><p data-lake-id=\"u8db1dade\" id=\"u8db1dade\"><span data-lake-id=\"u50e0aa76\" id=\"u50e0aa76\">vite 使用 esbuild 将 ts 转译到 js，约是 tsc 速度的 20 ～ 30 倍，同时 hmr 更新反应到浏览器的时间会小于 50ms。但是，由于 esbuild 转换 ts 到 js 对于类型操作仅仅是擦除，所以完全保证不了类型正确，因此需要额外校验类型，比如使用：tsc --noEmit。</span></p><p data-lake-id=\"u561cd1e6\" id=\"u561cd1e6\"><br></p><p data-lake-id=\"uf8b3d9e1\" id=\"uf8b3d9e1\"><span data-lake-id=\"uad484954\" id=\"uad484954\">将 ts 转译成 js 后，浏览器便可以利用 ESM 直接拿到 js 资源。</span></p><p data-lake-id=\"u9234f3a7\" id=\"u9234f3a7\"><br></p><h2 data-lake-id=\"d41d8cd9\" id=\"d41d8cd9\"><br></h2>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:51.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:51.000Z",
  "updated_at": "2022-05-10T15:12:33.000Z",
  "published_at": "2022-04-04T11:33:51.000Z",
  "first_published_at": "2022-04-04T11:33:50.928Z",
  "word_count": 1474,
  "cover": null,
  "description": "vite 的基本实现原理，就是启动一个 Koa 服务器拦截由浏览器请求 ESM 的请求。通过请求的路径找到目录下对应的文件做一定的处理最终以 ESM 的格式返回给客户端。依赖处理vite 通过在一开始将应用中的模块区分为依赖和源码两类，改进了开发服务器启动时间。依赖大多为在开发时不会变动的纯 ...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}