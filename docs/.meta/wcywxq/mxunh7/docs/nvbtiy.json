{
  "id": 72212269,
  "slug": "nvbtiy",
  "title": "npm、yarn、pnpm",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"pnyR9\"></a>\n## npm\n`package-lock.json`采用的是`JSON`的结构\n\n- `npm v2`\n\n`npm v2`会安装每一个包所依赖的所有依赖项，然而这个结构可能会很长。这对于基于`unix`的操作系统来说只不过是一个小烦恼，但对于`windows`来说是个破坏性的东西，因为有很多程序无法处理超过`260`个字符的文件路径名\n\n- `npm v3`\n\n`npm v3`采用了扁平依赖关系树来解决`npm v2`的问题。但这种做法的缺点是，`npm`必须首先遍历所有的项目依赖关系，然后再决定如何扁平的`node_modules`目录结构，`npm`必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，也是`npm`安装速度慢的一个很重要的原因。\n\n- `npm v5`\n\n`npm v5`使`npm`向前迈进了一大步，在几乎所有常见情况下显著提高了其性能，重写了 `cache`，支持并发访问，对离线模式及缓存安装进行了优化\n<a name=\"ohw07\"></a>\n## yarn\n`yarn`最开始的主要目标是解决`npm v3`中由于语义版本控制而导致的`npm`安装的不确定性问题，虽然可以使用`npm shrinkwrap`来实现可预测的依赖关系树，但它并不是默认选项，而是需要手动开启这个选项。\n\n`yarn`采用了不同的做法，每个`yarn`安装都会生成一个类似于`npm-shrinkwrap.json`的`yarn.lock`文件，而且它是默认创建的，除了常规信息之外，`yarn.lock`文件还包含要安装的内容校验和，以确保使用的库和版本相同\n\n和`npm`一样，`yarn`使用本地缓存，与`npm`不同的是，`yarn`无需互联网连接就能安装本地缓存的依赖项，它提供了**离线模式**。\n\n`yarn`还提供了一些其他改进，它允许合并项目中使用到的所有的包的许可证\n<a name=\"ebbiJ\"></a>\n## pnpm\n`pnpm`利用硬链接和符号链接来避免复制所有本地缓存源文件，这是`yarn`的最大性能弱点之一\n<a name=\"JCiw1\"></a>\n## 对比\n\n- npm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。\n- npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。\n- pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"pnyR9\"><span class=\"ne-text\">npm</span></h2><p id=\"u999a0f6a\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">package-lock.json</span></code><span class=\"ne-text\">采用的是</span><code class=\"ne-code\"><span class=\"ne-text\">JSON</span></code><span class=\"ne-text\">的结构</span></p><ul class=\"ne-ul\"><li id=\"uf8425735\"><code class=\"ne-code\"><span class=\"ne-text\">npm v2</span></code></li></ul><p id=\"u0dba368d\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">npm v2</span></code><span class=\"ne-text\">会安装每一个包所依赖的所有依赖项，然而这个结构可能会很长。这对于基于</span><code class=\"ne-code\"><span class=\"ne-text\">unix</span></code><span class=\"ne-text\">的操作系统来说只不过是一个小烦恼，但对于</span><code class=\"ne-code\"><span class=\"ne-text\">windows</span></code><span class=\"ne-text\">来说是个破坏性的东西，因为有很多程序无法处理超过</span><code class=\"ne-code\"><span class=\"ne-text\">260</span></code><span class=\"ne-text\">个字符的文件路径名</span></p><ul class=\"ne-ul\"><li id=\"u8a8a310c\"><code class=\"ne-code\"><span class=\"ne-text\">npm v3</span></code></li></ul><p id=\"u1368a69e\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">npm v3</span></code><span class=\"ne-text\">采用了扁平依赖关系树来解决</span><code class=\"ne-code\"><span class=\"ne-text\">npm v2</span></code><span class=\"ne-text\">的问题。但这种做法的缺点是，</span><code class=\"ne-code\"><span class=\"ne-text\">npm</span></code><span class=\"ne-text\">必须首先遍历所有的项目依赖关系，然后再决定如何扁平的</span><code class=\"ne-code\"><span class=\"ne-text\">node_modules</span></code><span class=\"ne-text\">目录结构，</span><code class=\"ne-code\"><span class=\"ne-text\">npm</span></code><span class=\"ne-text\">必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，也是</span><code class=\"ne-code\"><span class=\"ne-text\">npm</span></code><span class=\"ne-text\">安装速度慢的一个很重要的原因。</span></p><ul class=\"ne-ul\"><li id=\"u8bb93ec6\"><code class=\"ne-code\"><span class=\"ne-text\">npm v5</span></code></li></ul><p id=\"u2681b206\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">npm v5</span></code><span class=\"ne-text\">使</span><code class=\"ne-code\"><span class=\"ne-text\">npm</span></code><span class=\"ne-text\">向前迈进了一大步，在几乎所有常见情况下显著提高了其性能，重写了 </span><code class=\"ne-code\"><span class=\"ne-text\">cache</span></code><span class=\"ne-text\">，支持并发访问，对离线模式及缓存安装进行了优化</span></p><h2 id=\"ohw07\"><span class=\"ne-text\">yarn</span></h2><p id=\"u6f40cb47\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">yarn</span></code><span class=\"ne-text\">最开始的主要目标是解决</span><code class=\"ne-code\"><span class=\"ne-text\">npm v3</span></code><span class=\"ne-text\">中由于语义版本控制而导致的</span><code class=\"ne-code\"><span class=\"ne-text\">npm</span></code><span class=\"ne-text\">安装的不确定性问题，虽然可以使用</span><code class=\"ne-code\"><span class=\"ne-text\">npm shrinkwrap</span></code><span class=\"ne-text\">来实现可预测的依赖关系树，但它并不是默认选项，而是需要手动开启这个选项。</span></p><p id=\"ud40bcc3d\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ud6345f34\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">yarn</span></code><span class=\"ne-text\">采用了不同的做法，每个</span><code class=\"ne-code\"><span class=\"ne-text\">yarn</span></code><span class=\"ne-text\">安装都会生成一个类似于</span><code class=\"ne-code\"><span class=\"ne-text\">npm-shrinkwrap.json</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">yarn.lock</span></code><span class=\"ne-text\">文件，而且它是默认创建的，除了常规信息之外，</span><code class=\"ne-code\"><span class=\"ne-text\">yarn.lock</span></code><span class=\"ne-text\">文件还包含要安装的内容校验和，以确保使用的库和版本相同</span></p><p id=\"u122002f9\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u503cb1a8\" class=\"ne-p\"><span class=\"ne-text\">和</span><code class=\"ne-code\"><span class=\"ne-text\">npm</span></code><span class=\"ne-text\">一样，</span><code class=\"ne-code\"><span class=\"ne-text\">yarn</span></code><span class=\"ne-text\">使用本地缓存，与</span><code class=\"ne-code\"><span class=\"ne-text\">npm</span></code><span class=\"ne-text\">不同的是，</span><code class=\"ne-code\"><span class=\"ne-text\">yarn</span></code><span class=\"ne-text\">无需互联网连接就能安装本地缓存的依赖项，它提供了</span><strong><span class=\"ne-text\">离线模式</span></strong><span class=\"ne-text\">。</span></p><p id=\"u5d836517\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ua6885e0d\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">yarn</span></code><span class=\"ne-text\">还提供了一些其他改进，它允许合并项目中使用到的所有的包的许可证</span></p><h2 id=\"ebbiJ\"><span class=\"ne-text\">pnpm</span></h2><p id=\"uc82c19e2\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">pnpm</span></code><span class=\"ne-text\">利用硬链接和符号链接来避免复制所有本地缓存源文件，这是</span><code class=\"ne-code\"><span class=\"ne-text\">yarn</span></code><span class=\"ne-text\">的最大性能弱点之一</span></p><h2 id=\"JCiw1\"><span class=\"ne-text\">对比</span></h2><ul class=\"ne-ul\"><li id=\"udc547258\"><span class=\"ne-text\">npm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。</span></li><li id=\"u9fa64f94\"><span class=\"ne-text\">npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。</span></li><li id=\"u5f1b0c07\"><span class=\"ne-text\">pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</span></li></ul></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"pnyR9\" id=\"pnyR9\"><span data-lake-id=\"u048889e0\" id=\"u048889e0\">npm</span></h2><p data-lake-id=\"u999a0f6a\" id=\"u999a0f6a\"><code data-lake-id=\"u02b02f20\" id=\"u02b02f20\"><span data-lake-id=\"u75233641\" id=\"u75233641\">package-lock.json</span></code><span data-lake-id=\"ucc0e28d5\" id=\"ucc0e28d5\">采用的是</span><code data-lake-id=\"u2b30ecc9\" id=\"u2b30ecc9\"><span data-lake-id=\"u70e1f04c\" id=\"u70e1f04c\">JSON</span></code><span data-lake-id=\"ub699c578\" id=\"ub699c578\">的结构</span></p><ul list=\"u99489108\"><li fid=\"u42587c6c\" data-lake-id=\"uf8425735\" id=\"uf8425735\"><code data-lake-id=\"ud6ec05bb\" id=\"ud6ec05bb\"><span data-lake-id=\"ue056e03b\" id=\"ue056e03b\">npm v2</span></code></li></ul><p data-lake-id=\"u0dba368d\" id=\"u0dba368d\"><code data-lake-id=\"u7aa6210d\" id=\"u7aa6210d\"><span data-lake-id=\"u8b1e896f\" id=\"u8b1e896f\">npm v2</span></code><span data-lake-id=\"u22ac8ad9\" id=\"u22ac8ad9\">会安装每一个包所依赖的所有依赖项，然而这个结构可能会很长。这对于基于</span><code data-lake-id=\"ufc498d79\" id=\"ufc498d79\"><span data-lake-id=\"ud11b1f6c\" id=\"ud11b1f6c\">unix</span></code><span data-lake-id=\"u215baf9d\" id=\"u215baf9d\">的操作系统来说只不过是一个小烦恼，但对于</span><code data-lake-id=\"ud572e398\" id=\"ud572e398\"><span data-lake-id=\"u55fca2ef\" id=\"u55fca2ef\">windows</span></code><span data-lake-id=\"uc61f6de2\" id=\"uc61f6de2\">来说是个破坏性的东西，因为有很多程序无法处理超过</span><code data-lake-id=\"u4e67743c\" id=\"u4e67743c\"><span data-lake-id=\"uf7a5d2c5\" id=\"uf7a5d2c5\">260</span></code><span data-lake-id=\"ucbd9532e\" id=\"ucbd9532e\">个字符的文件路径名</span></p><ul list=\"u99489108\" start=\"2\"><li fid=\"u42587c6c\" data-lake-id=\"u8a8a310c\" id=\"u8a8a310c\"><code data-lake-id=\"ua1d0f457\" id=\"ua1d0f457\"><span data-lake-id=\"u82e922ee\" id=\"u82e922ee\">npm v3</span></code></li></ul><p data-lake-id=\"u1368a69e\" id=\"u1368a69e\"><code data-lake-id=\"u809ef4cb\" id=\"u809ef4cb\"><span data-lake-id=\"u6b8f3f31\" id=\"u6b8f3f31\">npm v3</span></code><span data-lake-id=\"ud5a859bf\" id=\"ud5a859bf\">采用了扁平依赖关系树来解决</span><code data-lake-id=\"ua4355af5\" id=\"ua4355af5\"><span data-lake-id=\"u82f4947f\" id=\"u82f4947f\">npm v2</span></code><span data-lake-id=\"ue1d79311\" id=\"ue1d79311\">的问题。但这种做法的缺点是，</span><code data-lake-id=\"u7f991f59\" id=\"u7f991f59\"><span data-lake-id=\"u53ed5dbd\" id=\"u53ed5dbd\">npm</span></code><span data-lake-id=\"u9ae79c49\" id=\"u9ae79c49\">必须首先遍历所有的项目依赖关系，然后再决定如何扁平的</span><code data-lake-id=\"u682a65ab\" id=\"u682a65ab\"><span data-lake-id=\"u22429c8f\" id=\"u22429c8f\">node_modules</span></code><span data-lake-id=\"ua874f564\" id=\"ua874f564\">目录结构，</span><code data-lake-id=\"ube16d8a5\" id=\"ube16d8a5\"><span data-lake-id=\"u1e0368b7\" id=\"u1e0368b7\">npm</span></code><span data-lake-id=\"uc423dff2\" id=\"uc423dff2\">必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，也是</span><code data-lake-id=\"u24e5bb2d\" id=\"u24e5bb2d\"><span data-lake-id=\"u69a53a13\" id=\"u69a53a13\">npm</span></code><span data-lake-id=\"ueafdcb08\" id=\"ueafdcb08\">安装速度慢的一个很重要的原因。</span></p><ul list=\"ufa4d8cb3\"><li fid=\"u3d36c526\" data-lake-id=\"u8bb93ec6\" id=\"u8bb93ec6\"><code data-lake-id=\"u228d9220\" id=\"u228d9220\"><span data-lake-id=\"u65c85119\" id=\"u65c85119\">npm v5</span></code></li></ul><p data-lake-id=\"u2681b206\" id=\"u2681b206\"><code data-lake-id=\"ueadbe12d\" id=\"ueadbe12d\"><span data-lake-id=\"uca56360e\" id=\"uca56360e\">npm v5</span></code><span data-lake-id=\"uc9090b96\" id=\"uc9090b96\">使</span><code data-lake-id=\"uc802eda8\" id=\"uc802eda8\"><span data-lake-id=\"u720068b6\" id=\"u720068b6\">npm</span></code><span data-lake-id=\"ub622aa6c\" id=\"ub622aa6c\">向前迈进了一大步，在几乎所有常见情况下显著提高了其性能，重写了 </span><code data-lake-id=\"u81f9fe9a\" id=\"u81f9fe9a\"><span data-lake-id=\"ua9224cb1\" id=\"ua9224cb1\">cache</span></code><span data-lake-id=\"u1a8b2768\" id=\"u1a8b2768\">，支持并发访问，对离线模式及缓存安装进行了优化</span></p><h2 data-lake-id=\"ohw07\" id=\"ohw07\"><span data-lake-id=\"u172a3f6b\" id=\"u172a3f6b\">yarn</span></h2><p data-lake-id=\"u6f40cb47\" id=\"u6f40cb47\"><code data-lake-id=\"ub210166c\" id=\"ub210166c\"><span data-lake-id=\"u5f5a8254\" id=\"u5f5a8254\">yarn</span></code><span data-lake-id=\"uec212ce4\" id=\"uec212ce4\">最开始的主要目标是解决</span><code data-lake-id=\"u14727e8c\" id=\"u14727e8c\"><span data-lake-id=\"u99c0eb09\" id=\"u99c0eb09\">npm v3</span></code><span data-lake-id=\"u71bf541e\" id=\"u71bf541e\">中由于语义版本控制而导致的</span><code data-lake-id=\"ue7a788cb\" id=\"ue7a788cb\"><span data-lake-id=\"u9e2103f3\" id=\"u9e2103f3\">npm</span></code><span data-lake-id=\"ubc6ef9d8\" id=\"ubc6ef9d8\">安装的不确定性问题，虽然可以使用</span><code data-lake-id=\"u443747f0\" id=\"u443747f0\"><span data-lake-id=\"u30e505f0\" id=\"u30e505f0\">npm shrinkwrap</span></code><span data-lake-id=\"u5e5d0f5a\" id=\"u5e5d0f5a\">来实现可预测的依赖关系树，但它并不是默认选项，而是需要手动开启这个选项。</span></p><p data-lake-id=\"ud40bcc3d\" id=\"ud40bcc3d\"><span data-lake-id=\"uc04752e4\" id=\"uc04752e4\">​</span><br></p><p data-lake-id=\"ud6345f34\" id=\"ud6345f34\"><code data-lake-id=\"udfc1ea72\" id=\"udfc1ea72\"><span data-lake-id=\"u883b0930\" id=\"u883b0930\">yarn</span></code><span data-lake-id=\"u1814a444\" id=\"u1814a444\">采用了不同的做法，每个</span><code data-lake-id=\"u06478c16\" id=\"u06478c16\"><span data-lake-id=\"u00d339cd\" id=\"u00d339cd\">yarn</span></code><span data-lake-id=\"u381064f4\" id=\"u381064f4\">安装都会生成一个类似于</span><code data-lake-id=\"u74059abe\" id=\"u74059abe\"><span data-lake-id=\"ua574412a\" id=\"ua574412a\">npm-shrinkwrap.json</span></code><span data-lake-id=\"ud1959b0b\" id=\"ud1959b0b\">的</span><code data-lake-id=\"u2770203a\" id=\"u2770203a\"><span data-lake-id=\"uc883dec7\" id=\"uc883dec7\">yarn.lock</span></code><span data-lake-id=\"u6cd2ac23\" id=\"u6cd2ac23\">文件，而且它是默认创建的，除了常规信息之外，</span><code data-lake-id=\"ue05062dd\" id=\"ue05062dd\"><span data-lake-id=\"u21acc320\" id=\"u21acc320\">yarn.lock</span></code><span data-lake-id=\"ua6d45815\" id=\"ua6d45815\">文件还包含要安装的内容校验和，以确保使用的库和版本相同</span></p><p data-lake-id=\"u122002f9\" id=\"u122002f9\"><span data-lake-id=\"u5c6042c4\" id=\"u5c6042c4\">​</span><br></p><p data-lake-id=\"u503cb1a8\" id=\"u503cb1a8\"><span data-lake-id=\"ub2ebedd8\" id=\"ub2ebedd8\">和</span><code data-lake-id=\"u523e02de\" id=\"u523e02de\"><span data-lake-id=\"u561aa633\" id=\"u561aa633\">npm</span></code><span data-lake-id=\"u2e415739\" id=\"u2e415739\">一样，</span><code data-lake-id=\"u6ad2f5d1\" id=\"u6ad2f5d1\"><span data-lake-id=\"u2c6505cf\" id=\"u2c6505cf\">yarn</span></code><span data-lake-id=\"u741a2696\" id=\"u741a2696\">使用本地缓存，与</span><code data-lake-id=\"u0a3e139f\" id=\"u0a3e139f\"><span data-lake-id=\"ub03333f1\" id=\"ub03333f1\">npm</span></code><span data-lake-id=\"u318a3593\" id=\"u318a3593\">不同的是，</span><code data-lake-id=\"u302c49db\" id=\"u302c49db\"><span data-lake-id=\"u398830c9\" id=\"u398830c9\">yarn</span></code><span data-lake-id=\"ucd10eaa2\" id=\"ucd10eaa2\">无需互联网连接就能安装本地缓存的依赖项，它提供了</span><strong><span data-lake-id=\"u9fde66be\" id=\"u9fde66be\">离线模式</span></strong><span data-lake-id=\"ud0cf3212\" id=\"ud0cf3212\">。</span></p><p data-lake-id=\"u5d836517\" id=\"u5d836517\"><span data-lake-id=\"u606593b3\" id=\"u606593b3\">​</span><br></p><p data-lake-id=\"ua6885e0d\" id=\"ua6885e0d\"><code data-lake-id=\"u6a326b7e\" id=\"u6a326b7e\"><span data-lake-id=\"u7de30fd4\" id=\"u7de30fd4\">yarn</span></code><span data-lake-id=\"u14c3ee7a\" id=\"u14c3ee7a\">还提供了一些其他改进，它允许合并项目中使用到的所有的包的许可证</span></p><h2 data-lake-id=\"ebbiJ\" id=\"ebbiJ\"><span data-lake-id=\"ube24b0d2\" id=\"ube24b0d2\">pnpm</span></h2><p data-lake-id=\"uc82c19e2\" id=\"uc82c19e2\"><code data-lake-id=\"u62135599\" id=\"u62135599\"><span data-lake-id=\"u8f0f11f5\" id=\"u8f0f11f5\">pnpm</span></code><span data-lake-id=\"ub5bfbaed\" id=\"ub5bfbaed\">利用硬链接和符号链接来避免复制所有本地缓存源文件，这是</span><code data-lake-id=\"u53ffc581\" id=\"u53ffc581\"><span data-lake-id=\"u42631fd1\" id=\"u42631fd1\">yarn</span></code><span data-lake-id=\"u55b57811\" id=\"u55b57811\">的最大性能弱点之一</span></p><h2 data-lake-id=\"JCiw1\" id=\"JCiw1\"><span data-lake-id=\"u94407741\" id=\"u94407741\">对比</span></h2><ul list=\"ude62dd20\"><li fid=\"ue1a7456f\" data-lake-id=\"udc547258\" id=\"udc547258\"><span data-lake-id=\"ue6d11573\" id=\"ue6d11573\">npm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。</span></li><li fid=\"ue1a7456f\" data-lake-id=\"u9fa64f94\" id=\"u9fa64f94\"><span data-lake-id=\"u6268750e\" id=\"u6268750e\">npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。</span></li><li fid=\"ue1a7456f\" data-lake-id=\"u5f1b0c07\" id=\"u5f1b0c07\"><span data-lake-id=\"u5734b3fa\" id=\"u5734b3fa\">pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</span></li></ul>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-08-09T10:27:03.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:57.000Z",
  "updated_at": "2022-08-09T10:27:03.000Z",
  "published_at": "2022-08-09T10:27:03.000Z",
  "first_published_at": "2022-04-04T11:33:57.159Z",
  "word_count": 759,
  "cover": null,
  "description": "npmpackage-lock.json采用的是JSON的结构npm v2npm v2会安装每一个包所依赖的所有依赖项，然而这个结构可能会很长。这对于基于unix的操作系统来说只不过是一个小烦恼，但对于windows来说是个破坏性的东西，因为有很多程序无法处理超过260个字符的文件路径名npm...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}