{
  "id": 72212203,
  "slug": "gbrvz9",
  "title": "有状态组件和无状态组件的理解及使用场景",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"P9aL3\"></a>\n## 有状态组件\n**特点：**\n\n- 是类组件\n- 有继承\n- 可以使用this\n- 可以使用react的生命周期\n- 使用较多，容易频繁触发生命周期钩子函数，影响性能\n- 内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。\n\n**使用场景：**\n\n- 需要使用到状态的。\n- 需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）\n:::info\n总结： 类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。\n:::\n<a name=\"E0piY\"></a>\n## 无状态组件\n**特点：**\n\n- 不依赖自身的状态state\n- 可以是类组件或者函数组件。\n- 可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）\n- 有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件\n- 组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。\n\n**使用场景：**\n\n- 组件不需要管理 state，纯展示\n\n**优点：**\n\n- 简化代码、专注于 render\n- 组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用\n- 视图和数据的解耦分离\n\n**缺点：**\n\n- 无法使用 ref\n- 无生命周期方法\n- 无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染\n:::info\n总结： 组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 <Button/>、 <Input /> 等组件。\n:::\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"P9aL3\"><span>有状态组件</span></h2><p data-lake-id=\"u21f1e67d\"><strong><span>特点：</span></strong></p><ul><li><span>是类组件</span></li><li><span>有继承</span></li><li><span>可以使用this</span></li><li><span>可以使用react的生命周期</span></li><li><span>使用较多，容易频繁触发生命周期钩子函数，影响性能</span></li><li><span>内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。</span></li></ul><p data-lake-id=\"u7e680faf\"><strong><span>使用场景：</span></strong></p><ul><li><span>需要使用到状态的。</span></li><li><span>需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）</span></li></ul><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u8a47d999\"><span>总结： 类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。</span></p></blockquote><h2 id=\"E0piY\"><span>无状态组件</span></h2><p data-lake-id=\"ua325ab8f\"><strong><span>特点：</span></strong></p><ul><li><span>不依赖自身的状态state</span></li><li><span>可以是类组件或者函数组件。</span></li><li><span>可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）</span></li><li><span>有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件</span></li><li><span>组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。</span></li></ul><p data-lake-id=\"ub530b15a\"><strong><span>使用场景：</span></strong></p><ul><li><span>组件不需要管理 state，纯展示</span></li></ul><p data-lake-id=\"u5b9726c1\"><strong><span>优点：</span></strong></p><ul><li><span>简化代码、专注于 render</span></li><li><span>组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用</span></li><li><span>视图和数据的解耦分离</span></li></ul><p data-lake-id=\"u96acf0e3\"><strong><span>缺点：</span></strong></p><ul><li><span>无法使用 ref</span></li><li><span>无生命周期方法</span></li><li><span>无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染</span></li></ul><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u52708b95\"><span>总结： 组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 &lt;Button/&gt;、 &lt;Input /&gt; 等组件。</span></p></blockquote>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"P9aL3\" id=\"P9aL3\"><span data-lake-id=\"u7bdf60ad\" id=\"u7bdf60ad\">有状态组件</span></h2><p data-lake-id=\"u21f1e67d\" id=\"u21f1e67d\"><strong><span data-lake-id=\"ua80eee4e\" id=\"ua80eee4e\">特点：</span></strong></p><ul list=\"uf2eb78c1\"><li fid=\"u268b472b\" data-lake-id=\"ua82f8736\" id=\"ua82f8736\"><span data-lake-id=\"u3cc61492\" id=\"u3cc61492\">是类组件</span></li><li fid=\"u268b472b\" data-lake-id=\"uf48ff593\" id=\"uf48ff593\"><span data-lake-id=\"u76f8a016\" id=\"u76f8a016\">有继承</span></li><li fid=\"u268b472b\" data-lake-id=\"uee681206\" id=\"uee681206\"><span data-lake-id=\"u1cacb24a\" id=\"u1cacb24a\">可以使用this</span></li><li fid=\"u268b472b\" data-lake-id=\"u1149ee34\" id=\"u1149ee34\"><span data-lake-id=\"u1c5b73cb\" id=\"u1c5b73cb\">可以使用react的生命周期</span></li><li fid=\"u268b472b\" data-lake-id=\"u4390e14b\" id=\"u4390e14b\"><span data-lake-id=\"uba867add\" id=\"uba867add\">使用较多，容易频繁触发生命周期钩子函数，影响性能</span></li><li fid=\"u268b472b\" data-lake-id=\"ubcbab164\" id=\"ubcbab164\"><span data-lake-id=\"u3e3bc367\" id=\"u3e3bc367\">内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。</span></li></ul><p data-lake-id=\"u7e680faf\" id=\"u7e680faf\"><strong><span data-lake-id=\"u5e662c11\" id=\"u5e662c11\">使用场景：</span></strong></p><ul list=\"u907ed843\"><li fid=\"ub2fef5d1\" data-lake-id=\"ue932bb78\" id=\"ue932bb78\"><span data-lake-id=\"uc1584a66\" id=\"uc1584a66\">需要使用到状态的。</span></li><li fid=\"ub2fef5d1\" data-lake-id=\"u81f82e22\" id=\"u81f82e22\"><span data-lake-id=\"u23081d2c\" id=\"u23081d2c\">需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）</span></li></ul><blockquote data-lake-id=\"u9678b420\" id=\"u9678b420\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u8a47d999\" id=\"u8a47d999\"><span data-lake-id=\"u85680ef5\" id=\"u85680ef5\">总结： 类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。</span></p></blockquote><h2 data-lake-id=\"E0piY\" id=\"E0piY\"><span data-lake-id=\"ue4a48a1c\" id=\"ue4a48a1c\">无状态组件</span></h2><p data-lake-id=\"ua325ab8f\" id=\"ua325ab8f\"><strong><span data-lake-id=\"ub49b8b23\" id=\"ub49b8b23\">特点：</span></strong></p><ul list=\"udd430c54\"><li fid=\"u4159bea1\" data-lake-id=\"u77266b39\" id=\"u77266b39\"><span data-lake-id=\"u1910f8d7\" id=\"u1910f8d7\">不依赖自身的状态state</span></li><li fid=\"u4159bea1\" data-lake-id=\"udcde531e\" id=\"udcde531e\"><span data-lake-id=\"u57d75803\" id=\"u57d75803\">可以是类组件或者函数组件。</span></li><li fid=\"u4159bea1\" data-lake-id=\"u4f26f850\" id=\"u4f26f850\"><span data-lake-id=\"u7f798b9c\" id=\"u7f798b9c\">可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）</span></li><li fid=\"u4159bea1\" data-lake-id=\"ub2ab8d8c\" id=\"ub2ab8d8c\"><span data-lake-id=\"u40d3e79e\" id=\"u40d3e79e\">有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件</span></li><li fid=\"u4159bea1\" data-lake-id=\"u74c7baae\" id=\"u74c7baae\"><span data-lake-id=\"ud97bffb5\" id=\"ud97bffb5\">组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。</span></li></ul><p data-lake-id=\"ub530b15a\" id=\"ub530b15a\"><strong><span data-lake-id=\"u7249d989\" id=\"u7249d989\">使用场景：</span></strong></p><ul list=\"u24caf505\"><li fid=\"u343b27aa\" data-lake-id=\"ucc4e5fb4\" id=\"ucc4e5fb4\"><span data-lake-id=\"u8e3e0a34\" id=\"u8e3e0a34\">组件不需要管理 state，纯展示</span></li></ul><p data-lake-id=\"u5b9726c1\" id=\"u5b9726c1\"><strong><span data-lake-id=\"ub5bcdb75\" id=\"ub5bcdb75\">优点：</span></strong></p><ul list=\"u6d089bbf\"><li fid=\"uff87806f\" data-lake-id=\"ue26f1280\" id=\"ue26f1280\"><span data-lake-id=\"ub90716eb\" id=\"ub90716eb\">简化代码、专注于 render</span></li><li fid=\"uff87806f\" data-lake-id=\"u95a11b6c\" id=\"u95a11b6c\"><span data-lake-id=\"ua4e2b18d\" id=\"ua4e2b18d\">组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用</span></li><li fid=\"uff87806f\" data-lake-id=\"u523d6f08\" id=\"u523d6f08\"><span data-lake-id=\"ub863f013\" id=\"ub863f013\">视图和数据的解耦分离</span></li></ul><p data-lake-id=\"u96acf0e3\" id=\"u96acf0e3\"><strong><span data-lake-id=\"u4301a3a2\" id=\"u4301a3a2\">缺点：</span></strong></p><ul list=\"ue43060f8\"><li fid=\"u364d7b9c\" data-lake-id=\"u0c61df2c\" id=\"u0c61df2c\"><span data-lake-id=\"udd6d9221\" id=\"udd6d9221\">无法使用 ref</span></li><li fid=\"u364d7b9c\" data-lake-id=\"ua7ae3705\" id=\"ua7ae3705\"><span data-lake-id=\"u0e321292\" id=\"u0e321292\">无生命周期方法</span></li><li fid=\"u364d7b9c\" data-lake-id=\"u6fddd968\" id=\"u6fddd968\"><span data-lake-id=\"u25059968\" id=\"u25059968\">无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染</span></li></ul><blockquote data-lake-id=\"u5f4f65db\" id=\"u5f4f65db\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u52708b95\" id=\"u52708b95\"><span data-lake-id=\"uae3ee7f1\" id=\"uae3ee7f1\">总结： 组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 &lt;Button/&gt;、 &lt;Input /&gt; 等组件。</span></p></blockquote>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:36.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:36.000Z",
  "updated_at": "2022-05-10T15:12:35.000Z",
  "published_at": "2022-04-04T11:33:36.000Z",
  "first_published_at": "2022-04-04T11:33:35.975Z",
  "word_count": 641,
  "cover": null,
  "description": "有状态组件特点：是类组件有继承可以使用this可以使用react的生命周期使用较多，容易频繁触发生命周期钩子函数，影响性能内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。使用场景：需要使用到状态的。需要使用状态操作组件的（无状态...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}