{
  "id": 72212223,
  "slug": "kdnt9x",
  "title": "composition API 与 react hook 区别",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制\n\n- 不能在循环、条件、嵌套函数中调用Hook\n- 必须确保总是在你的React函数的顶层调用Hook\n- useEffect、useMemo等函数必须手动确定依赖关系\n\n而Composition API是基于Vue的响应式系统实现的，与React Hook的相比\n\n- 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢\n- Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用\n- 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。\n\n虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。\n",
  "body_draft": "",
  "body_html": "<!doctype html><p data-lake-id=\"u9060b7e3\"><span>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</span></p><ul><li><span>不能在循环、条件、嵌套函数中调用Hook</span></li><li><span>必须确保总是在你的React函数的顶层调用Hook</span></li><li><span>useEffect、useMemo等函数必须手动确定依赖关系</span></li></ul><p data-lake-id=\"u9270e57d\"><span>​</span><br /></p><p data-lake-id=\"ufb611115\"><span>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</span></p><ul><li><span>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</span></li><li><span>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</span></li><li><span>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</span></li></ul><p data-lake-id=\"u34107c31\"><span>​</span><br /></p><p data-lake-id=\"u192a6187\"><span>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</span></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u9060b7e3\" id=\"u9060b7e3\"><span data-lake-id=\"u84f41d47\" id=\"u84f41d47\">从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</span></p><ul list=\"udefc50aa\"><li fid=\"ua717ff74\" data-lake-id=\"uc6350ce8\" id=\"uc6350ce8\"><span data-lake-id=\"ubd5a97d4\" id=\"ubd5a97d4\">不能在循环、条件、嵌套函数中调用Hook</span></li><li fid=\"ua717ff74\" data-lake-id=\"u11240cea\" id=\"u11240cea\"><span data-lake-id=\"ua3c841ca\" id=\"ua3c841ca\">必须确保总是在你的React函数的顶层调用Hook</span></li><li fid=\"ua717ff74\" data-lake-id=\"u0de51c75\" id=\"u0de51c75\"><span data-lake-id=\"u62103b49\" id=\"u62103b49\">useEffect、useMemo等函数必须手动确定依赖关系</span></li></ul><p data-lake-id=\"u9270e57d\" id=\"u9270e57d\"><span data-lake-id=\"uba38eefc\" id=\"uba38eefc\">​</span><br></p><p data-lake-id=\"ufb611115\" id=\"ufb611115\"><span data-lake-id=\"u338ef4aa\" id=\"u338ef4aa\">而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</span></p><ul list=\"ua229ed92\"><li fid=\"ud7b17949\" data-lake-id=\"u8f726b70\" id=\"u8f726b70\"><span data-lake-id=\"ubf6bed90\" id=\"ubf6bed90\">声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</span></li><li fid=\"ud7b17949\" data-lake-id=\"u55f223b6\" id=\"u55f223b6\"><span data-lake-id=\"u92c2c00d\" id=\"u92c2c00d\">Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</span></li><li fid=\"ud7b17949\" data-lake-id=\"ube28ce50\" id=\"ube28ce50\"><span data-lake-id=\"u647952c1\" id=\"u647952c1\">响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</span></li></ul><p data-lake-id=\"u34107c31\" id=\"u34107c31\"><span data-lake-id=\"ub179ca5d\" id=\"ub179ca5d\">​</span><br></p><p data-lake-id=\"u192a6187\" id=\"u192a6187\"><span data-lake-id=\"u4856e42f\" id=\"u4856e42f\">虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:43.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:43.000Z",
  "updated_at": "2022-05-10T15:12:34.000Z",
  "published_at": "2022-04-04T11:33:43.000Z",
  "first_published_at": "2022-04-04T11:33:42.502Z",
  "word_count": 343,
  "cover": null,
  "description": "从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制不能在循环、条件、嵌套函数中调用Hook必须确保总是在你的React函数的顶层调用HookuseEffect、useMemo等...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}