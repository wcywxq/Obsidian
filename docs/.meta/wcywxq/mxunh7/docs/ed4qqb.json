{
  "id": 72212050,
  "slug": "ed4qqb",
  "title": "事件相关问题",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"kK7Bh\"></a>\n## 事件合成机制\n\nreact 根据 w3c 规范定义了每个事件处理函数的参数，即合成事件。react 在合成事件中做了两件事：**事件委派** 和 **自动绑定**\n<a name=\"TigwJ\"></a>\n### 事件委派\n事件处理程序将会传递 SyntheticEvent(事件合成) 的实例。这是一个**跨浏览器原生事件包装器**，它**具有与浏览器原生事件相同的接口**，支持 stopProgation 和 preventDefault。可以通过使用 nativeEvent 属性来访问原生事件对象，同时在所有浏览器中，它们的工作方式都相同<br />react 合成的 SyntheticEvent 采用了 **事件池**，这样做可以大大节省内存，同时不会频繁的创建和销毁事件对象\n\n- react 并不会把事件处理函数直接绑定到真实节点上，而是把所有事件放到统一的事件队列中，用监听器做监听。\n- 通过监听器上的映射来保存所有组件内部的事件监听和处理函数。\n- 在组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象。\n- 事件触发时会先被监听器处理，然后通过映射调用真正的事件处理函数。\n:::success\n**这样做的优点：**<br />解决了兼容性问题，并且简化了事件处理和回收机制(不需要手动解绑事件，react 已经在内部处理了)\n:::\n<a name=\"k3bxz\"></a>\n### 自动绑定\n\n1. 在 react 组件中，每个方法的上下文都会指向该组件的实例，即自动将上下文 this 指向当前组件\n2. react 会对这种引用方式做缓存，从而优化 cpu 和 内存\n3. 在使用 class 或 function 组件时，需要手动实现 this 绑定\n<a name=\"sXERu\"></a>\n## react 事件与原生事件的区别\n\n1. 事件传播与阻止事件传播：react 合成事件并没有实现事件捕获，只支持了事件冒泡。阻止事件传播 react 做了兼容性处理，只需要使用 e.preventDefault 即可，原生方法存在兼容性问题。\n2. 事件类型：react 是原生事件类型的一个子集。阻止 react 事件冒泡的行为只能用于 react 事件合成系统，但是在原生事件中的阻止冒泡行为，却可以阻止 react 合成事件的传播\n3. 事件的绑定方式：原生事件系统中支持多种不同的绑定事件的方式，react 只有一种\n4. 事件对象：原生事件存在兼容性问题，react 做了兼容性处理\n<a name=\"CjKqq\"></a>\n## react 事件和原生事件的执行顺序\n\n1. 原生事件，依次冒泡执行\n2. `react` 合成事件，依次冒泡执行\n3. `document` 上挂载的事件执行\n```shell\n# 1. dom child\n# 2. dom parent\n# 3. react child\n# 4. react parent\n# 5. dom document\n```\n<a name=\"gAGP9\"></a>\n## react 事件与原生事件可以混用么\n`react` 事件和原生事件最好不要混用。原生事件中如果执行了 `stopPropagation` 方法，则会导致其他 `react` 事件失效。因为所有元素的事件将无法冒泡到 `document` 上，导致所有的 `react` 事件都将无法被触发\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"kK7Bh\"><span class=\"ne-text\">事件合成机制</span></h2><p id=\"ud6bfeaed\" class=\"ne-p\"><br></p><p id=\"u4f76dcfc\" class=\"ne-p\"><span class=\"ne-text\">react 根据 w3c 规范定义了每个事件处理函数的参数，即合成事件。react 在合成事件中做了两件事：</span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">事件委派</span></strong><span class=\"ne-text\"> 和 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">自动绑定</span></strong></p><h3 id=\"TigwJ\"><span class=\"ne-text\">事件委派</span></h3><p id=\"ufabb3c86\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">事件处理程序将会传递 SyntheticEvent(事件合成) 的实例。这是一个</span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">跨浏览器原生事件包装器</span></strong><span class=\"ne-text\">，它</span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">具有与浏览器原生事件相同的接口</span></strong><span class=\"ne-text\">，支持 stopProgation 和 preventDefault。可以通过使用 nativeEvent 属性来访问原生事件对象，同时在所有浏览器中，它们的工作方式都相同</span></p><p id=\"u6be455aa\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">react 合成的 SyntheticEvent 采用了 </span><strong><span class=\"ne-text\" style=\"color: rgba(255,103,0,1)\">事件池</span></strong><span class=\"ne-text\">，这样做可以大大节省内存，同时不会频繁的创建和销毁事件对象</span></p><p id=\"u8edb67a2\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\"></span></p><ul class=\"ne-ul\"><li id=\"u0f066981\"><span class=\"ne-text\">react 并不会把事件处理函数直接绑定到真实节点上，而是把所有事件放到统一的事件队列中，用监听器做监听。</span></li><li id=\"u46533892\"><span class=\"ne-text\">通过监听器上的映射来保存所有组件内部的事件监听和处理函数。</span></li><li id=\"ua524dcda\"><span class=\"ne-text\">在组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象。</span></li><li id=\"u4373b4b2\"><span class=\"ne-text\">事件触发时会先被监听器处理，然后通过映射调用真正的事件处理函数。</span></li></ul><div data-type=\"success\" class=\"ne-alert\"><p id=\"uad53f7e2\" class=\"ne-p\"><strong><span class=\"ne-text\">这样做的优点：</span></strong></p><p id=\"u575810bb\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">解决了兼容性问题，并且简化了事件处理和回收机制(不需要手动解绑事件，react 已经在内部处理了)</span></p></div><h3 id=\"k3bxz\"><span class=\"ne-text\">自动绑定</span></h3><ol class=\"ne-ol\"><li id=\"u0352c7b4\"><span class=\"ne-text\">在 react 组件中，每个方法的上下文都会指向该组件的实例，即自动将上下文 this 指向当前组件</span></li><li id=\"u5b2650a6\"><span class=\"ne-text\">react 会对这种引用方式做缓存，从而优化 cpu 和 内存</span></li><li id=\"u69befa50\"><span class=\"ne-text\">在使用 class 或 function 组件时，需要手动实现 this 绑定</span></li></ol><h2 id=\"sXERu\"><span class=\"ne-text\">react 事件与原生事件的区别</span></h2><ol class=\"ne-ol\"><li id=\"u978ce344\"><span class=\"ne-text\">事件传播与阻止事件传播：react 合成事件并没有实现事件捕获，只支持了事件冒泡。阻止事件传播 react 做了兼容性处理，只需要使用 e.preventDefault 即可，原生方法存在兼容性问题。</span></li><li id=\"u3ef4e8dd\"><span class=\"ne-text\">事件类型：react 是原生事件类型的一个子集。阻止 react 事件冒泡的行为只能用于 react 事件合成系统，但是在原生事件中的阻止冒泡行为，却可以阻止 react 合成事件的传播</span></li><li id=\"u839e4cb9\"><span class=\"ne-text\">事件的绑定方式：原生事件系统中支持多种不同的绑定事件的方式，react 只有一种</span></li><li id=\"u1d8238c4\"><span class=\"ne-text\">事件对象：原生事件存在兼容性问题，react 做了兼容性处理</span></li></ol><h2 id=\"CjKqq\"><span class=\"ne-text\">react 事件和原生事件的执行顺序</span></h2><ol class=\"ne-ol\"><li id=\"u21e4bd7f\"><span class=\"ne-text\">原生事件，依次冒泡执行</span></li><li id=\"u5a5406f0\"><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 合成事件，依次冒泡执行</span></li><li id=\"u7825660c\"><code class=\"ne-code\"><span class=\"ne-text\">document</span></code><span class=\"ne-text\"> 上挂载的事件执行</span></li></ol><pre data-language=\"shell\" id=\"hCju3\" class=\"ne-codeblock language-shell\"># 1. dom child\n# 2. dom parent\n# 3. react child\n# 4. react parent\n# 5. dom document</pre><h2 id=\"gAGP9\"><span class=\"ne-text\">react 事件与原生事件可以混用么</span></h2><p id=\"ud887c9c9\" class=\"ne-p\" style=\"text-indent: 2em\"><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 事件和原生事件最好不要混用。原生事件中如果执行了 </span><code class=\"ne-code\"><span class=\"ne-text\">stopPropagation</span></code><span class=\"ne-text\"> 方法，则会导致其他 </span><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 事件失效。因为所有元素的事件将无法冒泡到 </span><code class=\"ne-code\"><span class=\"ne-text\">document</span></code><span class=\"ne-text\"> 上，导致所有的 </span><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 事件都将无法被触发</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"kK7Bh\" id=\"kK7Bh\"><span data-lake-id=\"u6839bd61\" id=\"u6839bd61\">事件合成机制</span></h2><p data-lake-id=\"ud6bfeaed\" id=\"ud6bfeaed\"><br></p><p data-lake-id=\"u4f76dcfc\" id=\"u4f76dcfc\"><span data-lake-id=\"u30bea356\" id=\"u30bea356\">react 根据 w3c 规范定义了每个事件处理函数的参数，即合成事件。react 在合成事件中做了两件事：</span><strong><span data-lake-id=\"ub4fb9d42\" id=\"ub4fb9d42\" style=\"color: rgba(255,103,0,1)\">事件委派</span></strong><span data-lake-id=\"ud348c318\" id=\"ud348c318\"> 和 </span><strong><span data-lake-id=\"u0f7cea3e\" id=\"u0f7cea3e\" style=\"color: rgba(255,103,0,1)\">自动绑定</span></strong></p><h3 data-lake-id=\"TigwJ\" id=\"TigwJ\"><span data-lake-id=\"u0b341e23\" id=\"u0b341e23\">事件委派</span></h3><p data-lake-id=\"ufabb3c86\" id=\"ufabb3c86\" style=\"text-indent: 2em\"><span data-lake-id=\"u7dab5fdc\" id=\"u7dab5fdc\">事件处理程序将会传递 SyntheticEvent(事件合成) 的实例。这是一个</span><strong><span data-lake-id=\"u5606d65b\" id=\"u5606d65b\" style=\"color: rgba(255,103,0,1)\">跨浏览器原生事件包装器</span></strong><span data-lake-id=\"u4362d34a\" id=\"u4362d34a\">，它</span><strong><span data-lake-id=\"u90260965\" id=\"u90260965\" style=\"color: rgba(255,103,0,1)\">具有与浏览器原生事件相同的接口</span></strong><span data-lake-id=\"u3a11c659\" id=\"u3a11c659\">，支持 stopProgation 和 preventDefault。可以通过使用 nativeEvent 属性来访问原生事件对象，同时在所有浏览器中，它们的工作方式都相同</span></p><p data-lake-id=\"u6be455aa\" id=\"u6be455aa\" style=\"text-indent: 2em\"><span data-lake-id=\"u6c51c97f\" id=\"u6c51c97f\">react 合成的 SyntheticEvent 采用了 </span><strong><span data-lake-id=\"ufe29fbd1\" id=\"ufe29fbd1\" style=\"color: rgba(255,103,0,1)\">事件池</span></strong><span data-lake-id=\"ua0957dee\" id=\"ua0957dee\">，这样做可以大大节省内存，同时不会频繁的创建和销毁事件对象</span></p><p data-lake-id=\"u8edb67a2\" id=\"u8edb67a2\" style=\"text-indent: 2em\"><span data-lake-id=\"u3ea55010\" id=\"u3ea55010\">​</span><br></p><ul list=\"uc3c9b4f6\"><li fid=\"u354de596\" data-lake-id=\"u0f066981\" id=\"u0f066981\"><span data-lake-id=\"u4928a2da\" id=\"u4928a2da\">react 并不会把事件处理函数直接绑定到真实节点上，而是把所有事件放到统一的事件队列中，用监听器做监听。</span></li><li fid=\"u354de596\" data-lake-id=\"u46533892\" id=\"u46533892\"><span data-lake-id=\"u91cdc39d\" id=\"u91cdc39d\">通过监听器上的映射来保存所有组件内部的事件监听和处理函数。</span></li><li fid=\"u354de596\" data-lake-id=\"ua524dcda\" id=\"ua524dcda\"><span data-lake-id=\"u2413dca7\" id=\"u2413dca7\">在组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象。</span></li><li fid=\"u354de596\" data-lake-id=\"u4373b4b2\" id=\"u4373b4b2\"><span data-lake-id=\"u85cedcf3\" id=\"u85cedcf3\">事件触发时会先被监听器处理，然后通过映射调用真正的事件处理函数。</span></li></ul><blockquote data-lake-id=\"u65db8a11\" id=\"u65db8a11\" class=\"lake-alert lake-alert-success\"><p data-lake-id=\"uad53f7e2\" id=\"uad53f7e2\"><strong><span data-lake-id=\"uc86ab1c6\" id=\"uc86ab1c6\">这样做的优点：</span></strong></p><p data-lake-id=\"u575810bb\" id=\"u575810bb\" style=\"text-indent: 2em\"><span data-lake-id=\"uaaed30e8\" id=\"uaaed30e8\">解决了兼容性问题，并且简化了事件处理和回收机制(不需要手动解绑事件，react 已经在内部处理了)</span></p></blockquote><h3 data-lake-id=\"k3bxz\" id=\"k3bxz\"><span data-lake-id=\"uc87a5070\" id=\"uc87a5070\">自动绑定</span></h3><ol list=\"u6f831bde\"><li fid=\"u231259f5\" data-lake-id=\"u0352c7b4\" id=\"u0352c7b4\"><span data-lake-id=\"u69d3ec3f\" id=\"u69d3ec3f\">在 react 组件中，每个方法的上下文都会指向该组件的实例，即自动将上下文 this 指向当前组件</span></li><li fid=\"u231259f5\" data-lake-id=\"u5b2650a6\" id=\"u5b2650a6\"><span data-lake-id=\"u97015234\" id=\"u97015234\">react 会对这种引用方式做缓存，从而优化 cpu 和 内存</span></li><li fid=\"u231259f5\" data-lake-id=\"u69befa50\" id=\"u69befa50\"><span data-lake-id=\"u71d28839\" id=\"u71d28839\">在使用 class 或 function 组件时，需要手动实现 this 绑定</span></li></ol><h2 data-lake-id=\"sXERu\" id=\"sXERu\"><span data-lake-id=\"u4789a3c7\" id=\"u4789a3c7\">react 事件与原生事件的区别</span></h2><ol list=\"ucf2caec3\"><li fid=\"uad36c696\" data-lake-id=\"u978ce344\" id=\"u978ce344\"><span data-lake-id=\"u53457acc\" id=\"u53457acc\">事件传播与阻止事件传播：react 合成事件并没有实现事件捕获，只支持了事件冒泡。阻止事件传播 react 做了兼容性处理，只需要使用 e.preventDefault 即可，原生方法存在兼容性问题。</span></li><li fid=\"uad36c696\" data-lake-id=\"u3ef4e8dd\" id=\"u3ef4e8dd\"><span data-lake-id=\"u9997e7b2\" id=\"u9997e7b2\">事件类型：react 是原生事件类型的一个子集。阻止 react 事件冒泡的行为只能用于 react 事件合成系统，但是在原生事件中的阻止冒泡行为，却可以阻止 react 合成事件的传播</span></li><li fid=\"uad36c696\" data-lake-id=\"u839e4cb9\" id=\"u839e4cb9\"><span data-lake-id=\"u1d81bee2\" id=\"u1d81bee2\">事件的绑定方式：原生事件系统中支持多种不同的绑定事件的方式，react 只有一种</span></li><li fid=\"uad36c696\" data-lake-id=\"u1d8238c4\" id=\"u1d8238c4\"><span data-lake-id=\"ub491bb3b\" id=\"ub491bb3b\">事件对象：原生事件存在兼容性问题，react 做了兼容性处理</span></li></ol><h2 data-lake-id=\"CjKqq\" id=\"CjKqq\"><span data-lake-id=\"u8309d2a7\" id=\"u8309d2a7\">react 事件和原生事件的执行顺序</span></h2><ol list=\"u6b2aa7b7\"><li fid=\"uf4294e51\" data-lake-id=\"u21e4bd7f\" id=\"u21e4bd7f\"><span data-lake-id=\"u33ab3e5b\" id=\"u33ab3e5b\">原生事件，依次冒泡执行</span></li><li fid=\"uf4294e51\" data-lake-id=\"u5a5406f0\" id=\"u5a5406f0\"><code data-lake-id=\"u17d3cc48\" id=\"u17d3cc48\"><span data-lake-id=\"ufb266a43\" id=\"ufb266a43\">react</span></code><span data-lake-id=\"u32e77d24\" id=\"u32e77d24\"> 合成事件，依次冒泡执行</span></li><li fid=\"uf4294e51\" data-lake-id=\"u7825660c\" id=\"u7825660c\"><code data-lake-id=\"u032c1fef\" id=\"u032c1fef\"><span data-lake-id=\"ue904d5ee\" id=\"ue904d5ee\">document</span></code><span data-lake-id=\"uee6d413e\" id=\"uee6d413e\"> 上挂载的事件执行</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22shell%22%2C%22code%22%3A%22%23%201.%20dom%20child%5Cn%23%202.%20dom%20parent%5Cn%23%203.%20react%20child%5Cn%23%204.%20react%20parent%5Cn%23%205.%20dom%20document%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22One%20Dark%20Pro%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22hCju3%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"gAGP9\" id=\"gAGP9\"><span data-lake-id=\"ud2de765c\" id=\"ud2de765c\">react 事件与原生事件可以混用么</span></h2><p data-lake-id=\"ud887c9c9\" id=\"ud887c9c9\" style=\"text-indent: 2em\"><code data-lake-id=\"ub3f731dc\" id=\"ub3f731dc\"><span data-lake-id=\"u9e82340e\" id=\"u9e82340e\">react</span></code><span data-lake-id=\"u9e6b82a6\" id=\"u9e6b82a6\"> 事件和原生事件最好不要混用。原生事件中如果执行了 </span><code data-lake-id=\"u4b3cc06d\" id=\"u4b3cc06d\"><span data-lake-id=\"u286b0bbf\" id=\"u286b0bbf\">stopPropagation</span></code><span data-lake-id=\"udd7d1df9\" id=\"udd7d1df9\"> 方法，则会导致其他 </span><code data-lake-id=\"u034a3060\" id=\"u034a3060\"><span data-lake-id=\"ua38d2e4f\" id=\"ua38d2e4f\">react</span></code><span data-lake-id=\"u4d78a716\" id=\"u4d78a716\"> 事件失效。因为所有元素的事件将无法冒泡到 </span><code data-lake-id=\"u2014e25a\" id=\"u2014e25a\"><span data-lake-id=\"u2f7631fa\" id=\"u2f7631fa\">document</span></code><span data-lake-id=\"u6acfc01f\" id=\"u6acfc01f\"> 上，导致所有的 </span><code data-lake-id=\"u2632777c\" id=\"u2632777c\"><span data-lake-id=\"ud2555a16\" id=\"ud2555a16\">react</span></code><span data-lake-id=\"u23c3a28b\" id=\"u23c3a28b\"> 事件都将无法被触发</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-05-29T20:46:27.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:44.000Z",
  "updated_at": "2022-05-29T20:46:27.000Z",
  "published_at": "2022-05-29T20:46:27.000Z",
  "first_published_at": "2022-04-04T11:32:43.997Z",
  "word_count": 839,
  "cover": null,
  "description": "事件合成机制react 根据 w3c 规范定义了每个事件处理函数的参数，即合成事件。react 在合成事件中做了两件事：事件委派 和 自动绑定事件委派事件处理程序将会传递 SyntheticEvent(事件合成) 的实例。这是一个跨浏览器原生事件包装器，它具有与浏览器原生事件相同的接口，支持 ...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}