{
  "id": 72212064,
  "slug": "ka9kuf",
  "title": "实现继承的几种方式",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"a9eF8\"></a>\n## 原型链继承\n:::info\n**核心**：将父类实例作为子类实例<br />**优点**：因为方法定义在原型上，所以可以做到方法复用<br />**问题**：子类实例化时不能给父类构造函数传递参数，原型包含的引用类型的属性将被所有实例所共享\n:::\n```javascript\nfunction Animal() {\n\tthis.colors = ['black', white]\n}\n\nAnimal.prototype.getColor = function() {\n\treturn this.colors\n}\n\nfunction Dog() {}\n\nDog.prototype = new Animal()\n\nvar husky = new Dog()\nhusky.colors.push('gray')\nvar corgi = new Dog()\nconsole.log(husky.getColors(), corgi.getColors())\n```\n<a name=\"zLYaC\"></a>\n## 借用构造函数继承\n:::info\n**核心**：借用父类的构造函数来增强子类实例 = 复制父类的实例属性给子类<br />**优点**：实例之间相互独立，可以向父类构造函数传参，解决了引用类型的属性被所有实例所共享的问题<br />**问题**：方法都定义在构造函数中，无法进行复用；子类实例无法继承父类原型上的属性。\n:::\n```javascript\nfunction Animal() {\n\tthis.colors =  ['black', 'white']\n  this.getColors = function() {\n  \treturn this.colors\n  }\n}\n\nfunction Dog() {\n\tAnimal.call(this)\n}\n\nvar husky = new Dog()\nhusky.colors.push('gray')\nvar corgi = new Dog()\nconsole.log(husky.getColors(), corgi.getColors())\n```\n<a name=\"mOl0Z\"></a>\n## 组合式继承\n:::info\n**核心**：通过调用父类构造函数，继承父类的属性并保留传参的优点；然后通过将父类实例作为子类的原型，实现函数复用<br />**优点**：保留构造函数的优点，创建子类实例，可以向父类构造函数传参；保留原型链的优点，父类的实例方法定义在父类的原型对象上，可以实现方法的复用。不会共享父类引用类型的属性<br />**问题**：由于调用了 2 次父类的构造方法，会存在一份多余的父类实例方法。(第一次：`父类.call(this)`，第二次：`子类.prototype = new 父类` )\n:::\n```javascript\nfunction Animal(name) {\n\tthis.name = name\n  this.colors = ['black', 'white']\n}\n\nAnimal.prototype.getName = function() {\n\treturn this.name\n}\n\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n  this.age = age\n}\n\nDog.prototype = new Animal()\nDog.prototype.constructor = Dog\n```\n<a name=\"ONJ3p\"></a>\n## 寄生组合继承\n:::info\n为了解决组合式继承调用两次构造函数的问题<br />解决方案：不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本\n:::\n```javascript\nfunction Animal(name) {\n\tthis.name = name\n  this.colors = ['black', 'white']\n}\n\nAnimal.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n  this.age = age\n}\n\n// 最简单的替换\nDog.prototype = Object.create(Animal.prototype)\nDog.prototype.constructor = Dog\n\nvar husky = new Dog('哈士奇', 2)\nhusky.colors.push('gray')\nvar corgi = new Dog('柯基', 1)\nconsole.log(husky, corgi)\n```\n<a name=\"Ru130\"></a>\n## es6 继承\n```javascript\nclass Animal {\n\tconstructor(name) {\n  \tthis.name = name\n    this.colors = ['black', 'white']\n  }\n  getColors() {\n  \treturn this.colors\n  }\n}\n\nclass Dog extends Animal {\n\tconstructor(name, age) {\n  \tthis.name = name\n    this.age = age\n  }\n}\n\nvar husky = new Dog('哈士奇', 2)\nhusky.colors.push('gray')\nvar corgi = new Dog('柯基', 1)\nconsole.log(husky, corgi)\n```\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"a9eF8\"><span>原型链继承</span></h2><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u4eac00fe\"><strong><span>核心</span></strong><span>：将父类实例作为子类实例</span></p><p data-lake-id=\"u95259cdd\"><strong><span>优点</span></strong><span>：因为方法定义在原型上，所以可以做到方法复用</span></p><p data-lake-id=\"uf4bbbdda\"><strong><span>问题</span></strong><span>：子类实例化时不能给父类构造函数传递参数，原型包含的引用类型的属性将被所有实例所共享</span></p></blockquote><pre data-lang=\"javascript\"><code>function Animal() {\n\tthis.colors = ['black', white]\n}\n\nAnimal.prototype.getColor = function() {\n\treturn this.colors\n}\n\nfunction Dog() {}\n\nDog.prototype = new Animal()\n\nvar husky = new Dog()\nhusky.colors.push('gray')\nvar corgi = new Dog()\nconsole.log(husky.getColors(), corgi.getColors())</code></pre><h2 id=\"zLYaC\"><span>借用构造函数继承</span></h2><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u5934bdf4\"><strong><span>核心</span></strong><span>：借用父类的构造函数来增强子类实例 = 复制父类的实例属性给子类</span></p><p data-lake-id=\"u64857148\"><strong><span>优点</span></strong><span>：实例之间相互独立，可以向父类构造函数传参，解决了引用类型的属性被所有实例所共享的问题</span></p><p data-lake-id=\"u7c550888\"><strong><span>问题</span></strong><span>：方法都定义在构造函数中，无法进行复用；子类实例无法继承父类原型上的属性。</span></p></blockquote><pre data-lang=\"javascript\"><code>function Animal() {\n\tthis.colors =  ['black', 'white']\n  this.getColors = function() {\n  \treturn this.colors\n  }\n}\n\nfunction Dog() {\n\tAnimal.call(this)\n}\n\nvar husky = new Dog()\nhusky.colors.push('gray')\nvar corgi = new Dog()\nconsole.log(husky.getColors(), corgi.getColors())</code></pre><h2 id=\"mOl0Z\"><span>组合式继承</span></h2><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u3fafa6ef\"><strong><span>核心</span></strong><span>：通过调用父类构造函数，继承父类的属性并保留传参的优点；然后通过将父类实例作为子类的原型，实现函数复用</span></p><p data-lake-id=\"u04744097\"><strong><span>优点</span></strong><span>：保留构造函数的优点，创建子类实例，可以向父类构造函数传参；保留原型链的优点，父类的实例方法定义在父类的原型对象上，可以实现方法的复用。不会共享父类引用类型的属性</span></p><p data-lake-id=\"ue1a3b696\"><strong><span>问题</span></strong><span>：由于调用了 2 次父类的构造方法，会存在一份多余的父类实例方法。(第一次：</span><code><span>父类.call(this)</span></code><span>，第二次：</span><code><span>子类.prototype = new 父类</span></code><span> )</span></p></blockquote><pre data-lang=\"javascript\"><code>function Animal(name) {\n\tthis.name = name\n  this.colors = ['black', 'white']\n}\n\nAnimal.prototype.getName = function() {\n\treturn this.name\n}\n\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n  this.age = age\n}\n\nDog.prototype = new Animal()\nDog.prototype.constructor = Dog</code></pre><h2 id=\"ONJ3p\"><span>寄生组合继承</span></h2><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"ufd9048b0\"><span>为了解决组合式继承调用两次构造函数的问题</span></p><p data-lake-id=\"ud6aa0c73\"><span>解决方案：不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本</span></p></blockquote><pre data-lang=\"javascript\"><code>function Animal(name) {\n\tthis.name = name\n  this.colors = ['black', 'white']\n}\n\nAnimal.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n  this.age = age\n}\n\n// 最简单的替换\nDog.prototype = Object.create(Animal.prototype)\nDog.prototype.constructor = Dog\n\nvar husky = new Dog('哈士奇', 2)\nhusky.colors.push('gray')\nvar corgi = new Dog('柯基', 1)\nconsole.log(husky, corgi)</code></pre><h2 id=\"Ru130\"><span>es6 继承</span></h2><pre data-lang=\"javascript\"><code>class Animal {\n\tconstructor(name) {\n  \tthis.name = name\n    this.colors = ['black', 'white']\n  }\n  getColors() {\n  \treturn this.colors\n  }\n}\n\nclass Dog extends Animal {\n\tconstructor(name, age) {\n  \tthis.name = name\n    this.age = age\n  }\n}\n\nvar husky = new Dog('哈士奇', 2)\nhusky.colors.push('gray')\nvar corgi = new Dog('柯基', 1)\nconsole.log(husky, corgi)</code></pre>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"a9eF8\" id=\"a9eF8\"><span data-lake-id=\"u8c3108c6\" id=\"u8c3108c6\">原型链继承</span></h2><blockquote data-lake-id=\"uf8872cd4\" id=\"uf8872cd4\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u4eac00fe\" id=\"u4eac00fe\"><strong><span data-lake-id=\"uc2ce58a1\" id=\"uc2ce58a1\">核心</span></strong><span data-lake-id=\"ue5b5b0ac\" id=\"ue5b5b0ac\">：将父类实例作为子类实例</span></p><p data-lake-id=\"u95259cdd\" id=\"u95259cdd\"><strong><span data-lake-id=\"u7af79f85\" id=\"u7af79f85\">优点</span></strong><span data-lake-id=\"ua7f498e8\" id=\"ua7f498e8\">：因为方法定义在原型上，所以可以做到方法复用</span></p><p data-lake-id=\"uf4bbbdda\" id=\"uf4bbbdda\"><strong><span data-lake-id=\"u614e0992\" id=\"u614e0992\">问题</span></strong><span data-lake-id=\"ue7e87913\" id=\"ue7e87913\">：子类实例化时不能给父类构造函数传递参数，原型包含的引用类型的属性将被所有实例所共享</span></p></blockquote><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20Animal()%20%7B%5Cn%5Ctthis.colors%20%3D%20%5B'black'%2C%20white%5D%5Cn%7D%5Cn%5CnAnimal.prototype.getColor%20%3D%20function()%20%7B%5Cn%5Ctreturn%20this.colors%5Cn%7D%5Cn%5Cnfunction%20Dog()%20%7B%7D%5Cn%5CnDog.prototype%20%3D%20new%20Animal()%5Cn%5Cnvar%20husky%20%3D%20new%20Dog()%5Cnhusky.colors.push('gray')%5Cnvar%20corgi%20%3D%20new%20Dog()%5Cnconsole.log(husky.getColors()%2C%20corgi.getColors())%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22xQx2y%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"zLYaC\" id=\"zLYaC\"><span data-lake-id=\"u91a3b149\" id=\"u91a3b149\">借用构造函数继承</span></h2><blockquote data-lake-id=\"uecc2bcbd\" id=\"uecc2bcbd\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u5934bdf4\" id=\"u5934bdf4\"><strong><span data-lake-id=\"u473b6227\" id=\"u473b6227\">核心</span></strong><span data-lake-id=\"u289074f6\" id=\"u289074f6\">：借用父类的构造函数来增强子类实例 = 复制父类的实例属性给子类</span></p><p data-lake-id=\"u64857148\" id=\"u64857148\"><strong><span data-lake-id=\"u36384ebd\" id=\"u36384ebd\">优点</span></strong><span data-lake-id=\"uf57536ba\" id=\"uf57536ba\">：实例之间相互独立，可以向父类构造函数传参，解决了引用类型的属性被所有实例所共享的问题</span></p><p data-lake-id=\"u7c550888\" id=\"u7c550888\"><strong><span data-lake-id=\"ubc7cd97e\" id=\"ubc7cd97e\">问题</span></strong><span data-lake-id=\"ud27bb9b3\" id=\"ud27bb9b3\">：方法都定义在构造函数中，无法进行复用；子类实例无法继承父类原型上的属性。</span></p></blockquote><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20Animal()%20%7B%5Cn%5Ctthis.colors%20%3D%20%20%5B'black'%2C%20'white'%5D%5Cn%20%20this.getColors%20%3D%20function()%20%7B%5Cn%20%20%5Ctreturn%20this.colors%5Cn%20%20%7D%5Cn%7D%5Cn%5Cnfunction%20Dog()%20%7B%5Cn%5CtAnimal.call(this)%5Cn%7D%5Cn%5Cnvar%20husky%20%3D%20new%20Dog()%5Cnhusky.colors.push('gray')%5Cnvar%20corgi%20%3D%20new%20Dog()%5Cnconsole.log(husky.getColors()%2C%20corgi.getColors())%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22E3vf9%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"mOl0Z\" id=\"mOl0Z\"><span data-lake-id=\"u7566d164\" id=\"u7566d164\">组合式继承</span></h2><blockquote data-lake-id=\"ubf791318\" id=\"ubf791318\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u3fafa6ef\" id=\"u3fafa6ef\"><strong><span data-lake-id=\"u8e2fecc8\" id=\"u8e2fecc8\">核心</span></strong><span data-lake-id=\"ud5c8002b\" id=\"ud5c8002b\">：通过调用父类构造函数，继承父类的属性并保留传参的优点；然后通过将父类实例作为子类的原型，实现函数复用</span></p><p data-lake-id=\"u04744097\" id=\"u04744097\"><strong><span data-lake-id=\"u3370e72e\" id=\"u3370e72e\">优点</span></strong><span data-lake-id=\"u088a502c\" id=\"u088a502c\">：保留构造函数的优点，创建子类实例，可以向父类构造函数传参；保留原型链的优点，父类的实例方法定义在父类的原型对象上，可以实现方法的复用。不会共享父类引用类型的属性</span></p><p data-lake-id=\"ue1a3b696\" id=\"ue1a3b696\"><strong><span data-lake-id=\"u2ec0ecc0\" id=\"u2ec0ecc0\">问题</span></strong><span data-lake-id=\"uee8acb6f\" id=\"uee8acb6f\">：由于调用了 2 次父类的构造方法，会存在一份多余的父类实例方法。(第一次：</span><code data-lake-id=\"u8c93d6c7\" id=\"u8c93d6c7\"><span data-lake-id=\"ua4d8befe\" id=\"ua4d8befe\">父类.call(this)</span></code><span data-lake-id=\"u5242f63b\" id=\"u5242f63b\">，第二次：</span><code data-lake-id=\"u16617550\" id=\"u16617550\"><span data-lake-id=\"ud7745133\" id=\"ud7745133\">子类.prototype = new 父类</span></code><span data-lake-id=\"u4a37952d\" id=\"u4a37952d\"> )</span></p></blockquote><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20Animal(name)%20%7B%5Cn%5Ctthis.name%20%3D%20name%5Cn%20%20this.colors%20%3D%20%5B'black'%2C%20'white'%5D%5Cn%7D%5Cn%5CnAnimal.prototype.getName%20%3D%20function()%20%7B%5Cn%5Ctreturn%20this.name%5Cn%7D%5Cn%5Cnfunction%20Dog(name%2C%20age)%20%7B%5Cn%5CtAnimal.call(this%2C%20name)%5Cn%20%20this.age%20%3D%20age%5Cn%7D%5Cn%5CnDog.prototype%20%3D%20new%20Animal()%5CnDog.prototype.constructor%20%3D%20Dog%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22nIPYX%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"ONJ3p\" id=\"ONJ3p\"><span data-lake-id=\"u8a1bb656\" id=\"u8a1bb656\">寄生组合继承</span></h2><blockquote data-lake-id=\"u0fedfac5\" id=\"u0fedfac5\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"ufd9048b0\" id=\"ufd9048b0\"><span data-lake-id=\"u80af2ed6\" id=\"u80af2ed6\">为了解决组合式继承调用两次构造函数的问题</span></p><p data-lake-id=\"ud6aa0c73\" id=\"ud6aa0c73\"><span data-lake-id=\"u7bb12ab7\" id=\"u7bb12ab7\">解决方案：不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本</span></p></blockquote><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20Animal(name)%20%7B%5Cn%5Ctthis.name%20%3D%20name%5Cn%20%20this.colors%20%3D%20%5B'black'%2C%20'white'%5D%5Cn%7D%5Cn%5CnAnimal.prototype.getName%20%3D%20function()%7B%5Cn%5Ctreturn%20this.name%5Cn%7D%5Cn%5Cnfunction%20Dog(name%2C%20age)%20%7B%5Cn%5CtAnimal.call(this%2C%20name)%5Cn%20%20this.age%20%3D%20age%5Cn%7D%5Cn%5Cn%2F%2F%20%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9B%BF%E6%8D%A2%5CnDog.prototype%20%3D%20Object.create(Animal.prototype)%5CnDog.prototype.constructor%20%3D%20Dog%5Cn%5Cnvar%20husky%20%3D%20new%20Dog('%E5%93%88%E5%A3%AB%E5%A5%87'%2C%202)%5Cnhusky.colors.push('gray')%5Cnvar%20corgi%20%3D%20new%20Dog('%E6%9F%AF%E5%9F%BA'%2C%201)%5Cnconsole.log(husky%2C%20corgi)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22GnIDg%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"Ru130\" id=\"Ru130\"><span data-lake-id=\"uff11de12\" id=\"uff11de12\">es6 继承</span></h2><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20Animal%20%7B%5Cn%5Ctconstructor(name)%20%7B%5Cn%20%20%5Ctthis.name%20%3D%20name%5Cn%20%20%20%20this.colors%20%3D%20%5B'black'%2C%20'white'%5D%5Cn%20%20%7D%5Cn%20%20getColors()%20%7B%5Cn%20%20%5Ctreturn%20this.colors%5Cn%20%20%7D%5Cn%7D%5Cn%5Cnclass%20Dog%20extends%20Animal%20%7B%5Cn%5Ctconstructor(name%2C%20age)%20%7B%5Cn%20%20%5Ctthis.name%20%3D%20name%5Cn%20%20%20%20this.age%20%3D%20age%5Cn%20%20%7D%5Cn%7D%5Cn%5Cnvar%20husky%20%3D%20new%20Dog('%E5%93%88%E5%A3%AB%E5%A5%87'%2C%202)%5Cnhusky.colors.push('gray')%5Cnvar%20corgi%20%3D%20new%20Dog('%E6%9F%AF%E5%9F%BA'%2C%201)%5Cnconsole.log(husky%2C%20corgi)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22Xq12m%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:32:49.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:49.000Z",
  "updated_at": "2022-05-10T15:12:42.000Z",
  "published_at": "2022-04-04T11:32:49.000Z",
  "first_published_at": "2022-04-04T11:32:48.816Z",
  "word_count": 700,
  "cover": null,
  "description": "原型链继承核心：将父类实例作为子类实例优点：因为方法定义在原型上，所以可以做到方法复用问题：子类实例化时不能给父类构造函数传递参数，原型包含的引用类型的属性将被所有实例所共享function Animal() { \tthis.colors = ['black', white] }  Anima...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}