{
  "id": 72212057,
  "slug": "gq900o",
  "title": "react hooks 相关问题",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"t4vQD\"></a>\n## react 解决代码复用的主要方式\n1. 高阶组件\n2. `render props`\n3. `react hooks`\n<a name=\"zMjPV\"></a>\n## 对 react hooks 的理解\n<a name=\"PK1TM\"></a>\n### 没有提出 hooks 前存在的问题\n\n- 在组件之间复用状态逻辑很难\n\n`hook` 使你在无需修改组件结构的情况下复用状态逻辑\n\n- 复杂组件变得难以理解\n\n`hook` 将组件中相互关联的部分拆分成更小的函数(如：设置订阅或数据请求)\n\n- 难以理解的 `class`\n\n`hook` 使你在非 `class` 的情况下可以使用更多的 `react` 特性\n<a name=\"yKncd\"></a>\n### react hooks 带来的便利\n\n1. 跨组件复用变得更简单\n2. 状态与 `ui` 隔离\n<a name=\"lOzIh\"></a>\n### hook 使用规则\n`hook` 就是 `javaScript` 函数，但是使用它们会有两个额外的规则：\n\n1. 只能在函数最外层调用 `hook`。不要在循环、条件判断或者子函数中调用\n:::info\n因为 react hooks 内部是通过单向链表实现的，其内部的顺序是极其关键的，如果不按照规则使用，就会造成取值出现偏移的问题\n:::\n\n2. 只能在 `react` 的函数组件中调用 `hook`。不要在其它 `javaScript` 函数中调用\n3. 类组件不会被替换或废弃，不需要强制改造类组件，两种方式可以并存\n\n<a name=\"NwYst\"></a>\n### 没有 hooks 之前，react 团队提出了哪些解决方法\n\n- `render props` 和 高阶组件\n:::danger\n问题：但这种方式会很麻烦，使你的代码难以理解\n:::\n\n- `mixin` 函数是复用类代码的一种途径，本质上可理解为类功能的扩展\n:::danger\n问题：\n\n1. `mixins` 引入了不清晰的依赖关系\n2. 会导致命名空间的冲突问题\n3. 复杂度过高\n:::\n<a name=\"uS1sI\"></a>\n### react hooks 如何保存状态\n\n- `react hooks` 和类组件的状态值都被挂载到组件实例对象 `FirberNode` 和 `memorizedState` 属性中\n\n`react hooks` 和类组件的数据结构完全不同，类组件是直接把 `state` 属性中挂载的这个开发者自定义的对象给保存到 `memorizedState` 属性中；而 `react hooks` 是用链表来保存状态的，`memorizedState` 属性保存的实际上是这个链表的头指针\n\n- 所有的 `hooks` 都以**链表**的形式挂载在 `FiberNode.updateQueue` 中\n<a name=\"akGBz\"></a>\n### HOC 和 hook 的区别\n`HOC` 可以复用逻辑和视图，`hook` 只能复用逻辑\n<a name=\"rEXAC\"></a>\n## react hooks 常用 api\n<a name=\"tn70i\"></a>\n### 基础 hooks\n\n1. useState：状态钩子，为函数组件提供内部状态\n2. useEffect：副作用钩子，可以看作是 componentDidMount、componentDidUpdate 和 componentWillUnmount 的结合\n3. useContext：共享钩子，在组件之间共享状态，可以解决 react 逐层通过 props 传递数据\n<a name=\"mmsp9\"></a>\n### 额外的 hooks\n\n1. useReducer：action 钩子，提供了状态管理，其基本原理是通过用户在页面上发起的 action，从而通过 reducer 方法来改变 state，从而实现页面和状态的通信，使用起来与 redux 类似\n2. useCallback：缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果\n3. useMemo：把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时重新计算，可以作为性能优化的手段\n4. useRef：获取组件的实例，返回一个可变的 ref 对象，返回的 ref 对象在组件的整个生命周期内保持不变\n5. useLayoutEffect：它会在所有 dom 变更后同步调用 effect\n<a name=\"pWIlT\"></a>\n## 常见问题\n<a name=\"lrAUQ\"></a>\n### useState 使用浅析\n\n- 使用方法\n```javascript\nconst [state, setState] = useState(initialValue);\n```\n**每次渲染具有独立的状态值**（毕竟每次渲染都是完全独立的嘛）。也就是说，每个函数中的 state 变量只是一个简单的**常量**，每次渲染时从钩子中获取到的常量，并没有附着数据绑定之类的神奇魔法。\n<a name=\"NlhjI\"></a>\n### useEffect 使用浅析\nReact 会在**每次渲染后都运行 Effect**。而依赖数组就是用来控制是否应该触发 Effect，从而能够减少不必要的计算，从而优化了性能。具体而言，只要依赖数组中的每一项与上一次渲染相比都没有改变，那么就跳过本次 Effect 的执行。\n<a name=\"js4V1\"></a>\n### useCallback 使用浅析\n为了解决函数在多次渲染中的引用相等（Referential Equality）问题，React 引入了一个重要的 Hook—— useCallback。官方文档介绍的使用方法如下：\n```javascript\nconst memoizedCallback = useCallback(callback, deps);\n```\n第一个参数 callback 就是需要记忆的函数，第二个参数就是大家熟悉的 deps 参数，同样也是一个依赖数组（有时候也被称为输入 inputs）。在 Memoization 的上下文中，这个 deps 的作用相当于缓存中的键（Key），如果键没有改变，那么就直接返回缓存中的函数，并且确保是引用相同的函数。\n\n在大多数情况下，我们都是传入空数组 [] 作为 deps 参数，这样 useCallback 返回的就**始终是同一个函数，永远不会更新**。\n:::warning\n**提示：**<br />也许在刚开始学习 useEffect 的时候就发现：我们并不需要把 useState 返回的第二个 Setter 函数作为 Effect 的依赖。实际上，React 内部已经对 Setter 函数做了 Memoization 处理，因此每次渲染拿到的 Setter 函数都是完全一样的，deps 加不加都是没有影响的。\n:::\n<a name=\"yzNnF\"></a>\n### useMemo\n我们知道 useCallback 有个好基友叫 useMemo。还记得我们之前总结了 Memoization 的两大场景吗？useCallback 主要是为了解决函数的”**引用相等**“问题，而 useMemo 则是一个”**全能型选手**“，能够同时胜任引用相等和节约计算的任务。\n\n实际上，useMemo 的功能是 useCallback 的**超集**。与 useCallback 只能缓存函数相比，useMemo 可以缓存任何类型的值（当然也包括函数）。useMemo 的使用方法如下：\n```javascript\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n```\n其中第一个参数是一个函数，这个函数返回值的返回值（也就是上面 computeExpensiveValue 的结果）将返回给 memoizedValue 。因此以下两个钩子的使用是完全等价的：\n```javascript\nuseCallback(fn, deps);\nuseMemo(() => fn, deps);\n```\n<a name=\"qWaYi\"></a>\n### useEffect 和 useLayoutEffect 的区别\n\n- useEffect 是异步执行，保证了不会阻塞浏览器进程\n- useLayoutEffect 是同步执行，会阻塞浏览器进程\n<a name=\"NkvL0\"></a>\n### useEffect dep = [] 与 componentDidMount 的区别\n在 render 执行之后，componentDidMount 会执行，如果在这个生命周期中再一次 setState ，会导致再次 render ，返回了新的值，浏览器只会渲染第二次 render 返回的值，这样可以避免闪屏。<br />但是 useEffect 是在真实的 DOM 渲染之后才会去执行，这会造成两次 render ，有可能会闪屏。<br />实际上 useLayoutEffect 会更接近 componentDidMount 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。\n<a name=\"gcqKN\"></a>\n### React.memo 和 React.useMemo 的区别\n\n- memo 是一个高阶组件，默认情况下会对 props 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。\n- useMemo 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，useMemo 是在 render 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴。\n<a name=\"wb0db\"></a>\n### React.useCallback 和 React.useMemo 的区别\n\n- useCallback 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。\n- useMemo 可缓存值。\n\n有很多时候，我们在 useEffect 中使用某个定义的外部函数，是要添加到 deps 数组中的，如果不用 useCallback 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 useEffect 总会无意义的执行。\n<a name=\"JzucX\"></a>\n### React.forwardRef\nReact.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：\n\n- 转发 refs 到 DOM 组件\n\n在高阶组件中转发 refs\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"t4vQD\"><span class=\"ne-text\">react 解决代码复用的主要方式</span></h2><ol class=\"ne-ol\"><li id=\"ub56952c6\"><span class=\"ne-text\">高阶组件</span></li><li id=\"u1281680d\"><code class=\"ne-code\"><span class=\"ne-text\">render props</span></code></li><li id=\"uf0d5b582\"><code class=\"ne-code\"><span class=\"ne-text\">react hooks</span></code></li></ol><h2 id=\"zMjPV\"><span class=\"ne-text\">对 react hooks 的理解</span></h2><h3 id=\"PK1TM\"><span class=\"ne-text\">没有提出 hooks 前存在的问题</span></h3><ul class=\"ne-ul\"><li id=\"u1291c975\"><span class=\"ne-text\">在组件之间复用状态逻辑很难</span></li></ul><p id=\"u8964916f\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">hook</span></code><span class=\"ne-text\"> 使你在无需修改组件结构的情况下复用状态逻辑</span></p><ul class=\"ne-ul\"><li id=\"u6f81111d\"><span class=\"ne-text\">复杂组件变得难以理解</span></li></ul><p id=\"u0a8b4bc2\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">hook</span></code><span class=\"ne-text\"> 将组件中相互关联的部分拆分成更小的函数(如：设置订阅或数据请求)</span></p><ul class=\"ne-ul\"><li id=\"u16a37792\"><span class=\"ne-text\">难以理解的 </span><code class=\"ne-code\"><span class=\"ne-text\">class</span></code></li></ul><p id=\"ufcce5cbd\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">hook</span></code><span class=\"ne-text\"> 使你在非 </span><code class=\"ne-code\"><span class=\"ne-text\">class</span></code><span class=\"ne-text\"> 的情况下可以使用更多的 </span><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 特性</span></p><h3 id=\"yKncd\"><span class=\"ne-text\">react hooks 带来的便利</span></h3><ol class=\"ne-ol\"><li id=\"uc226532b\"><span class=\"ne-text\">跨组件复用变得更简单</span></li><li id=\"u851ab07b\"><span class=\"ne-text\">状态与 </span><code class=\"ne-code\"><span class=\"ne-text\">ui</span></code><span class=\"ne-text\"> 隔离</span></li></ol><h3 id=\"lOzIh\"><span class=\"ne-text\">hook 使用规则</span></h3><p id=\"ub4b92771\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">hook</span></code><span class=\"ne-text\"> 就是 </span><code class=\"ne-code\"><span class=\"ne-text\">javaScript</span></code><span class=\"ne-text\"> 函数，但是使用它们会有两个额外的规则：</span></p><ol class=\"ne-ol\"><li id=\"uc7d89915\"><span class=\"ne-text\">只能在函数最外层调用 </span><code class=\"ne-code\"><span class=\"ne-text\">hook</span></code><span class=\"ne-text\">。不要在循环、条件判断或者子函数中调用</span></li></ol><div data-type=\"info\" class=\"ne-alert\"><p id=\"u08305316\" class=\"ne-p\"><span class=\"ne-text\">因为 react hooks 内部是通过单向链表实现的，其内部的顺序是极其关键的，如果不按照规则使用，就会造成取值出现偏移的问题</span></p></div><ol start=\"2\" class=\"ne-ol\"><li id=\"ude770327\"><span class=\"ne-text\">只能在 </span><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 的函数组件中调用 </span><code class=\"ne-code\"><span class=\"ne-text\">hook</span></code><span class=\"ne-text\">。不要在其它 </span><code class=\"ne-code\"><span class=\"ne-text\">javaScript</span></code><span class=\"ne-text\"> 函数中调用</span></li><li id=\"u7f8a4405\"><span class=\"ne-text\">类组件不会被替换或废弃，不需要强制改造类组件，两种方式可以并存</span></li></ol><p id=\"ud4e4ab03\" class=\"ne-p\"><span class=\"ne-text\"></span></p><h3 id=\"NwYst\"><span class=\"ne-text\">没有 hooks 之前，react 团队提出了哪些解决方法</span></h3><ul class=\"ne-ul\"><li id=\"u233f828a\"><code class=\"ne-code\"><span class=\"ne-text\">render props</span></code><span class=\"ne-text\"> 和 高阶组件</span></li></ul><div data-type=\"danger\" class=\"ne-alert\"><p id=\"u0181d9df\" class=\"ne-p\"><span class=\"ne-text\">问题：但这种方式会很麻烦，使你的代码难以理解</span></p></div><ul class=\"ne-ul\"><li id=\"ue9858405\"><code class=\"ne-code\"><span class=\"ne-text\">mixin</span></code><span class=\"ne-text\"> 函数是复用类代码的一种途径，本质上可理解为类功能的扩展</span></li></ul><div data-type=\"danger\" class=\"ne-alert\"><p id=\"ue5272280\" class=\"ne-p\"><span class=\"ne-text\">问题：</span></p><ol class=\"ne-ol\"><li id=\"u64b2f460\"><code class=\"ne-code\"><span class=\"ne-text\">mixins</span></code><span class=\"ne-text\"> 引入了不清晰的依赖关系</span></li><li id=\"uccffc8ae\"><span class=\"ne-text\">会导致命名空间的冲突问题</span></li><li id=\"u6c705f22\"><span class=\"ne-text\">复杂度过高</span></li></ol></div><h3 id=\"uS1sI\"><span class=\"ne-text\">react hooks 如何保存状态</span></h3><ul class=\"ne-ul\"><li id=\"ud7cc822f\"><code class=\"ne-code\"><span class=\"ne-text\">react hooks</span></code><span class=\"ne-text\"> 和类组件的状态值都被挂载到组件实例对象 </span><code class=\"ne-code\"><span class=\"ne-text\">FirberNode</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">memorizedState</span></code><span class=\"ne-text\"> 属性中</span></li></ul><p id=\"ue82c77f3\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">react hooks</span></code><span class=\"ne-text\"> 和类组件的数据结构完全不同，类组件是直接把 </span><code class=\"ne-code\"><span class=\"ne-text\">state</span></code><span class=\"ne-text\"> 属性中挂载的这个开发者自定义的对象给保存到 </span><code class=\"ne-code\"><span class=\"ne-text\">memorizedState</span></code><span class=\"ne-text\"> 属性中；而 </span><code class=\"ne-code\"><span class=\"ne-text\">react hooks</span></code><span class=\"ne-text\"> 是用链表来保存状态的，</span><code class=\"ne-code\"><span class=\"ne-text\">memorizedState</span></code><span class=\"ne-text\"> 属性保存的实际上是这个链表的头指针</span></p><ul class=\"ne-ul\"><li id=\"u945b62f0\"><span class=\"ne-text\">所有的 </span><code class=\"ne-code\"><span class=\"ne-text\">hooks</span></code><span class=\"ne-text\"> 都以</span><strong><span class=\"ne-text\">链表</span></strong><span class=\"ne-text\">的形式挂载在 </span><code class=\"ne-code\"><span class=\"ne-text\">FiberNode.updateQueue</span></code><span class=\"ne-text\"> 中</span></li></ul><h3 id=\"akGBz\"><span class=\"ne-text\">HOC 和 hook 的区别</span></h3><p id=\"ud35e0af8\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">HOC</span></code><span class=\"ne-text\"> 可以复用逻辑和视图，</span><code class=\"ne-code\"><span class=\"ne-text\">hook</span></code><span class=\"ne-text\"> 只能复用逻辑</span></p><h2 id=\"rEXAC\"><span class=\"ne-text\">react hooks 常用 api</span></h2><h3 id=\"tn70i\"><span class=\"ne-text\">基础 hooks</span></h3><ol class=\"ne-ol\"><li id=\"uc3c72b8f\"><span class=\"ne-text\">useState：状态钩子，为函数组件提供内部状态</span></li><li id=\"u31cbda88\"><span class=\"ne-text\">useEffect：副作用钩子，可以看作是 componentDidMount、componentDidUpdate 和 componentWillUnmount 的结合</span></li><li id=\"ue5ca3728\"><span class=\"ne-text\">useContext：共享钩子，在组件之间共享状态，可以解决 react 逐层通过 props 传递数据</span></li></ol><h3 id=\"mmsp9\"><span class=\"ne-text\">额外的 hooks</span></h3><ol class=\"ne-ol\"><li id=\"uffbe7ad5\"><span class=\"ne-text\">useReducer：action 钩子，提供了状态管理，其基本原理是通过用户在页面上发起的 action，从而通过 reducer 方法来改变 state，从而实现页面和状态的通信，使用起来与 redux 类似</span></li><li id=\"u5efd2e29\"><span class=\"ne-text\">useCallback：缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果</span></li><li id=\"u634e4ea8\"><span class=\"ne-text\">useMemo：把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时重新计算，可以作为性能优化的手段</span></li><li id=\"uddaf1ed8\"><span class=\"ne-text\">useRef：获取组件的实例，返回一个可变的 ref 对象，返回的 ref 对象在组件的整个生命周期内保持不变</span></li><li id=\"u09379496\"><span class=\"ne-text\">useLayoutEffect：它会在所有 dom 变更后同步调用 effect</span></li></ol><h2 id=\"pWIlT\"><span class=\"ne-text\">常见问题</span></h2><h3 id=\"lrAUQ\"><span class=\"ne-text\">useState 使用浅析</span></h3><ul class=\"ne-ul\"><li id=\"u2ad2e862\"><span class=\"ne-text\">使用方法</span></li></ul><pre data-language=\"javascript\" id=\"iN7l4\" class=\"ne-codeblock language-javascript\">const [state, setState] = useState(initialValue);</pre><p id=\"ucebb5674\" class=\"ne-p\"><strong><span class=\"ne-text\">每次渲染具有独立的状态值</span></strong><span class=\"ne-text\">（毕竟每次渲染都是完全独立的嘛）。也就是说，每个函数中的 state 变量只是一个简单的</span><strong><span class=\"ne-text\">常量</span></strong><span class=\"ne-text\">，每次渲染时从钩子中获取到的常量，并没有附着数据绑定之类的神奇魔法。</span></p><h3 id=\"NlhjI\"><span class=\"ne-text\">useEffect 使用浅析</span></h3><p id=\"ua8b80aa2\" class=\"ne-p\"><span class=\"ne-text\">React 会在</span><strong><span class=\"ne-text\">每次渲染后都运行 Effect</span></strong><span class=\"ne-text\">。而依赖数组就是用来控制是否应该触发 Effect，从而能够减少不必要的计算，从而优化了性能。具体而言，只要依赖数组中的每一项与上一次渲染相比都没有改变，那么就跳过本次 Effect 的执行。</span></p><h3 id=\"js4V1\"><span class=\"ne-text\">useCallback 使用浅析</span></h3><p id=\"udea3aa55\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">为了解决函数在多次渲染中的引用相等（Referential Equality）问题，React 引入了一个重要的 Hook—— useCallback。官方文档介绍的使用方法如下：</span></p><pre data-language=\"javascript\" id=\"itpGL\" class=\"ne-codeblock language-javascript\">const memoizedCallback = useCallback(callback, deps);</pre><p id=\"u97c8a8be\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">第一个参数 </span><span class=\"ne-text\">callback</span><span class=\"ne-text\"> 就是需要记忆的函数，第二个参数就是大家熟悉的 </span><span class=\"ne-text\">deps</span><span class=\"ne-text\"> 参数，同样也是一个依赖数组（有时候也被称为输入 </span><span class=\"ne-text\">inputs</span><span class=\"ne-text\">）。在 Memoization 的上下文中，这个 </span><span class=\"ne-text\">deps</span><span class=\"ne-text\"> 的作用相当于缓存中的键（Key），如果键没有改变，那么就直接返回缓存中的函数，并且确保是引用相同的函数。</span></p><p id=\"ub105401c\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u0592ce82\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">在大多数情况下，我们都是传入空数组 [] 作为 deps 参数，这样 useCallback 返回的就</span><strong><span class=\"ne-text\">始终是同一个函数，永远不会更新</span></strong><span class=\"ne-text\">。</span></p><div data-type=\"warning\" class=\"ne-alert\"><p id=\"u9ef3f830\" class=\"ne-p\"><strong><span class=\"ne-text\">提示：</span></strong></p><p id=\"u10dfab31\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">也许在刚开始学习 useEffect 的时候就发现：我们并不需要把 useState 返回的第二个 Setter 函数作为 Effect 的依赖。实际上，React 内部已经对 Setter 函数做了 Memoization 处理，因此每次渲染拿到的 Setter 函数都是完全一样的，deps 加不加都是没有影响的。</span></p></div><h3 id=\"yzNnF\"><span class=\"ne-text\">useMemo</span></h3><p id=\"u2d0bf34d\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">我们知道 </span><span class=\"ne-text\">useCallback</span><span class=\"ne-text\"> 有个好基友叫 </span><span class=\"ne-text\">useMemo</span><span class=\"ne-text\">。还记得我们之前总结了 Memoization 的两大场景吗？</span><span class=\"ne-text\">useCallback</span><span class=\"ne-text\"> 主要是为了解决函数的”</span><strong><span class=\"ne-text\">引用相等</span></strong><span class=\"ne-text\">“问题，而 </span><span class=\"ne-text\">useMemo</span><span class=\"ne-text\"> 则是一个”</span><strong><span class=\"ne-text\">全能型选手</span></strong><span class=\"ne-text\">“，能够同时胜任引用相等和节约计算的任务。</span></p><p id=\"uef6dda87\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u3612edf2\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">实际上，useMemo 的功能是 useCallback 的</span><strong><span class=\"ne-text\">超集</span></strong><span class=\"ne-text\">。与 useCallback 只能缓存函数相比，useMemo 可以缓存任何类型的值（当然也包括函数）。useMemo 的使用方法如下：</span></p><pre data-language=\"javascript\" id=\"vXYfr\" class=\"ne-codeblock language-javascript\">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</pre><p id=\"u09da1c2e\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">其中第一个参数是一个函数，这个函数返回值的返回值（也就是上面 computeExpensiveValue 的结果）将返回给 memoizedValue 。因此以下两个钩子的使用是完全等价的：</span></p><pre data-language=\"javascript\" id=\"lET1M\" class=\"ne-codeblock language-javascript\">useCallback(fn, deps);\nuseMemo(() =&gt; fn, deps);</pre><h3 id=\"qWaYi\"><span class=\"ne-text\">useEffect 和 useLayoutEffect 的区别</span></h3><ul class=\"ne-ul\"><li id=\"u14e556d6\"><span class=\"ne-text\">useEffect 是异步执行，保证了不会阻塞浏览器进程</span></li><li id=\"u0c9e7a1b\"><span class=\"ne-text\">useLayoutEffect 是同步执行，会阻塞浏览器进程</span></li></ul><h3 id=\"NkvL0\"><span class=\"ne-text\">useEffect dep = [] 与 componentDidMount 的区别</span></h3><p id=\"ue758805e\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">在 render 执行之后，componentDidMount 会执行，如果在这个生命周期中再一次 setState ，会导致再次 render ，返回了新的值，浏览器只会渲染第二次 render 返回的值，这样可以避免闪屏。</span></p><p id=\"u9f4824cc\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">但是 </span><span class=\"ne-text\">useEffect</span><span class=\"ne-text\"> 是在真实的 DOM 渲染之后才会去执行，这会造成两次 </span><span class=\"ne-text\">render</span><span class=\"ne-text\"> ，有可能会闪屏。</span></p><p id=\"udd9d0e77\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">实际上 useLayoutEffect 会更接近 componentDidMount 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。</span></p><h3 id=\"gcqKN\"><span class=\"ne-text\">React.memo 和 React.useMemo 的区别</span></h3><ul class=\"ne-ul\"><li id=\"u2352a32a\"><span class=\"ne-text\">memo 是一个高阶组件，默认情况下会对 props 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。</span></li><li id=\"u217dcca9\"><span class=\"ne-text\">useMemo 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，useMemo 是在 render 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴。</span></li></ul><h3 id=\"wb0db\"><span class=\"ne-text\">React.useCallback 和 React.useMemo 的区别</span></h3><ul class=\"ne-ul\"><li id=\"u0a8828d8\"><span class=\"ne-text\">useCallback 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。</span></li><li id=\"u3a4c4af0\"><span class=\"ne-text\">useMemo</span><span class=\"ne-text\"> 可缓存值。</span></li></ul><p id=\"u29497330\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">有很多时候，我们在 useEffect 中使用某个定义的外部函数，是要添加到 deps 数组中的，如果不用 useCallback 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 useEffect 总会无意义的执行。</span></p><h3 id=\"JzucX\"><span class=\"ne-text\">React.forwardRef</span></h3><p id=\"u570fd193\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：</span></p><ul class=\"ne-ul\"><li id=\"u91357c2d\"><span class=\"ne-text\">转发 refs 到 DOM 组件</span></li></ul><p id=\"u9b6229e4\" class=\"ne-p\"><span class=\"ne-text\">在高阶组件中转发 refs</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"t4vQD\" id=\"t4vQD\"><span data-lake-id=\"uab8300fe\" id=\"uab8300fe\">react 解决代码复用的主要方式</span></h2><ol list=\"u8b9d2eed\"><li fid=\"u0f0ce0d1\" data-lake-id=\"ub56952c6\" id=\"ub56952c6\"><span data-lake-id=\"ue1da09fc\" id=\"ue1da09fc\">高阶组件</span></li><li fid=\"u0f0ce0d1\" data-lake-id=\"u1281680d\" id=\"u1281680d\"><code data-lake-id=\"uf7f52ffb\" id=\"uf7f52ffb\"><span data-lake-id=\"u96672289\" id=\"u96672289\">render props</span></code></li><li fid=\"u0f0ce0d1\" data-lake-id=\"uf0d5b582\" id=\"uf0d5b582\"><code data-lake-id=\"u44efcef3\" id=\"u44efcef3\"><span data-lake-id=\"u00b6674f\" id=\"u00b6674f\">react hooks</span></code></li></ol><h2 data-lake-id=\"zMjPV\" id=\"zMjPV\"><span data-lake-id=\"uce8f3d31\" id=\"uce8f3d31\">对 react hooks 的理解</span></h2><h3 data-lake-id=\"PK1TM\" id=\"PK1TM\"><span data-lake-id=\"ufac10f96\" id=\"ufac10f96\">没有提出 hooks 前存在的问题</span></h3><ul list=\"u5f88da80\"><li fid=\"u1f9622e2\" data-lake-id=\"u1291c975\" id=\"u1291c975\"><span data-lake-id=\"u7edf65a3\" id=\"u7edf65a3\">在组件之间复用状态逻辑很难</span></li></ul><p data-lake-id=\"u8964916f\" id=\"u8964916f\"><code data-lake-id=\"u005804f7\" id=\"u005804f7\"><span data-lake-id=\"uf518d7c6\" id=\"uf518d7c6\">hook</span></code><span data-lake-id=\"u4e7b6d0f\" id=\"u4e7b6d0f\"> 使你在无需修改组件结构的情况下复用状态逻辑</span></p><ul list=\"u5f88da80\" start=\"2\"><li fid=\"u1f9622e2\" data-lake-id=\"u6f81111d\" id=\"u6f81111d\"><span data-lake-id=\"u97a1cc64\" id=\"u97a1cc64\">复杂组件变得难以理解</span></li></ul><p data-lake-id=\"u0a8b4bc2\" id=\"u0a8b4bc2\"><code data-lake-id=\"u6b0c8b45\" id=\"u6b0c8b45\"><span data-lake-id=\"ufe2c2e7a\" id=\"ufe2c2e7a\">hook</span></code><span data-lake-id=\"u5eac1aca\" id=\"u5eac1aca\"> 将组件中相互关联的部分拆分成更小的函数(如：设置订阅或数据请求)</span></p><ul list=\"u2df6bb63\"><li fid=\"u7263de06\" data-lake-id=\"u16a37792\" id=\"u16a37792\"><span data-lake-id=\"u73dc083d\" id=\"u73dc083d\">难以理解的 </span><code data-lake-id=\"ud0bff781\" id=\"ud0bff781\"><span data-lake-id=\"u572352d8\" id=\"u572352d8\">class</span></code></li></ul><p data-lake-id=\"ufcce5cbd\" id=\"ufcce5cbd\"><code data-lake-id=\"u05da9295\" id=\"u05da9295\"><span data-lake-id=\"u0890d18e\" id=\"u0890d18e\">hook</span></code><span data-lake-id=\"u3f2d17f5\" id=\"u3f2d17f5\"> 使你在非 </span><code data-lake-id=\"ua914e467\" id=\"ua914e467\"><span data-lake-id=\"u76b7d62d\" id=\"u76b7d62d\">class</span></code><span data-lake-id=\"uab6d21be\" id=\"uab6d21be\"> 的情况下可以使用更多的 </span><code data-lake-id=\"u05933460\" id=\"u05933460\"><span data-lake-id=\"ud282b893\" id=\"ud282b893\">react</span></code><span data-lake-id=\"uc6d2be19\" id=\"uc6d2be19\"> 特性</span></p><h3 data-lake-id=\"yKncd\" id=\"yKncd\"><span data-lake-id=\"uc5032051\" id=\"uc5032051\">react hooks 带来的便利</span></h3><ol list=\"u30153ad7\"><li fid=\"u9a760ec9\" data-lake-id=\"uc226532b\" id=\"uc226532b\"><span data-lake-id=\"u8699166e\" id=\"u8699166e\">跨组件复用变得更简单</span></li><li fid=\"u9a760ec9\" data-lake-id=\"u851ab07b\" id=\"u851ab07b\"><span data-lake-id=\"ub17418ca\" id=\"ub17418ca\">状态与 </span><code data-lake-id=\"ua0eb1611\" id=\"ua0eb1611\"><span data-lake-id=\"ub5fafca4\" id=\"ub5fafca4\">ui</span></code><span data-lake-id=\"ua8abd2c3\" id=\"ua8abd2c3\"> 隔离</span></li></ol><h3 data-lake-id=\"lOzIh\" id=\"lOzIh\"><span data-lake-id=\"u8c6e8f38\" id=\"u8c6e8f38\">hook 使用规则</span></h3><p data-lake-id=\"ub4b92771\" id=\"ub4b92771\"><code data-lake-id=\"u88397b22\" id=\"u88397b22\"><span data-lake-id=\"u365ecb6b\" id=\"u365ecb6b\">hook</span></code><span data-lake-id=\"ue219887e\" id=\"ue219887e\"> 就是 </span><code data-lake-id=\"uef69a036\" id=\"uef69a036\"><span data-lake-id=\"u427cbbbb\" id=\"u427cbbbb\">javaScript</span></code><span data-lake-id=\"u4b2b7f46\" id=\"u4b2b7f46\"> 函数，但是使用它们会有两个额外的规则：</span></p><ol list=\"u80b6e37a\"><li fid=\"u11ef2f00\" data-lake-id=\"uc7d89915\" id=\"uc7d89915\"><span data-lake-id=\"uf1e26421\" id=\"uf1e26421\">只能在函数最外层调用 </span><code data-lake-id=\"ua53e742b\" id=\"ua53e742b\"><span data-lake-id=\"u9930cb1f\" id=\"u9930cb1f\">hook</span></code><span data-lake-id=\"u6c947dbd\" id=\"u6c947dbd\">。不要在循环、条件判断或者子函数中调用</span></li></ol><blockquote data-lake-id=\"u2bdc8c3d\" id=\"u2bdc8c3d\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u08305316\" id=\"u08305316\"><span data-lake-id=\"u5be196e3\" id=\"u5be196e3\">因为 react hooks 内部是通过单向链表实现的，其内部的顺序是极其关键的，如果不按照规则使用，就会造成取值出现偏移的问题</span></p></blockquote><ol list=\"u80b6e37a\" start=\"2\"><li fid=\"u11ef2f00\" data-lake-id=\"ude770327\" id=\"ude770327\"><span data-lake-id=\"u50c95e97\" id=\"u50c95e97\">只能在 </span><code data-lake-id=\"uc98ce5c9\" id=\"uc98ce5c9\"><span data-lake-id=\"uf9202c26\" id=\"uf9202c26\">react</span></code><span data-lake-id=\"u7ad460c0\" id=\"u7ad460c0\"> 的函数组件中调用 </span><code data-lake-id=\"u15b67977\" id=\"u15b67977\"><span data-lake-id=\"ue11a0ecc\" id=\"ue11a0ecc\">hook</span></code><span data-lake-id=\"u71322e4c\" id=\"u71322e4c\">。不要在其它 </span><code data-lake-id=\"udaf3c387\" id=\"udaf3c387\"><span data-lake-id=\"uaf4f6218\" id=\"uaf4f6218\">javaScript</span></code><span data-lake-id=\"u77a61c06\" id=\"u77a61c06\"> 函数中调用</span></li><li fid=\"u11ef2f00\" data-lake-id=\"u7f8a4405\" id=\"u7f8a4405\"><span data-lake-id=\"u05d37c3a\" id=\"u05d37c3a\">类组件不会被替换或废弃，不需要强制改造类组件，两种方式可以并存</span></li></ol><p data-lake-id=\"ud4e4ab03\" id=\"ud4e4ab03\"><span data-lake-id=\"u2dd6f7c3\" id=\"u2dd6f7c3\">​</span><br></p><h3 data-lake-id=\"NwYst\" id=\"NwYst\"><span data-lake-id=\"u024480e5\" id=\"u024480e5\">没有 hooks 之前，react 团队提出了哪些解决方法</span></h3><ul list=\"u4f180959\"><li fid=\"udcc9f0c0\" data-lake-id=\"u233f828a\" id=\"u233f828a\"><code data-lake-id=\"u5b644880\" id=\"u5b644880\"><span data-lake-id=\"u073a4575\" id=\"u073a4575\">render props</span></code><span data-lake-id=\"u5138e76e\" id=\"u5138e76e\"> 和 高阶组件</span></li></ul><blockquote data-lake-id=\"u53dd3cf2\" id=\"u53dd3cf2\" class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"u0181d9df\" id=\"u0181d9df\"><span data-lake-id=\"ub4f887de\" id=\"ub4f887de\">问题：但这种方式会很麻烦，使你的代码难以理解</span></p></blockquote><ul list=\"u66b6aeb9\"><li fid=\"ue3a7cfce\" data-lake-id=\"ue9858405\" id=\"ue9858405\"><code data-lake-id=\"uee941e9c\" id=\"uee941e9c\"><span data-lake-id=\"u6f23db80\" id=\"u6f23db80\">mixin</span></code><span data-lake-id=\"u7b3206fb\" id=\"u7b3206fb\"> 函数是复用类代码的一种途径，本质上可理解为类功能的扩展</span></li></ul><blockquote data-lake-id=\"ue67294a0\" id=\"ue67294a0\" class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"ue5272280\" id=\"ue5272280\"><span data-lake-id=\"u0e5892b4\" id=\"u0e5892b4\">问题：</span></p><ol list=\"u0db3937c\"><li fid=\"u66e1e505\" data-lake-id=\"u64b2f460\" id=\"u64b2f460\"><code data-lake-id=\"u36c5bf6a\" id=\"u36c5bf6a\"><span data-lake-id=\"ud895b8bc\" id=\"ud895b8bc\">mixins</span></code><span data-lake-id=\"uf99af113\" id=\"uf99af113\"> 引入了不清晰的依赖关系</span></li><li fid=\"u66e1e505\" data-lake-id=\"uccffc8ae\" id=\"uccffc8ae\"><span data-lake-id=\"u24f6ec5a\" id=\"u24f6ec5a\">会导致命名空间的冲突问题</span></li><li fid=\"u66e1e505\" data-lake-id=\"u6c705f22\" id=\"u6c705f22\"><span data-lake-id=\"u1e470bc7\" id=\"u1e470bc7\">复杂度过高</span></li></ol></blockquote><h3 data-lake-id=\"uS1sI\" id=\"uS1sI\"><span data-lake-id=\"ucd5dde2e\" id=\"ucd5dde2e\">react hooks 如何保存状态</span></h3><ul list=\"uecb8d786\"><li fid=\"u05539923\" data-lake-id=\"ud7cc822f\" id=\"ud7cc822f\"><code data-lake-id=\"ub9fd5440\" id=\"ub9fd5440\"><span data-lake-id=\"uae676541\" id=\"uae676541\">react hooks</span></code><span data-lake-id=\"u8b0daedc\" id=\"u8b0daedc\"> 和类组件的状态值都被挂载到组件实例对象 </span><code data-lake-id=\"u53ce0426\" id=\"u53ce0426\"><span data-lake-id=\"u0f3c570e\" id=\"u0f3c570e\">FirberNode</span></code><span data-lake-id=\"u9fd4d520\" id=\"u9fd4d520\"> 和 </span><code data-lake-id=\"u29181021\" id=\"u29181021\"><span data-lake-id=\"ucbac99f9\" id=\"ucbac99f9\">memorizedState</span></code><span data-lake-id=\"u279c1e5b\" id=\"u279c1e5b\"> 属性中</span></li></ul><p data-lake-id=\"ue82c77f3\" id=\"ue82c77f3\"><code data-lake-id=\"u847274ad\" id=\"u847274ad\"><span data-lake-id=\"udcf64e50\" id=\"udcf64e50\">react hooks</span></code><span data-lake-id=\"uc4586ff1\" id=\"uc4586ff1\"> 和类组件的数据结构完全不同，类组件是直接把 </span><code data-lake-id=\"u36684987\" id=\"u36684987\"><span data-lake-id=\"ue00d7ae8\" id=\"ue00d7ae8\">state</span></code><span data-lake-id=\"u7a4ba0ea\" id=\"u7a4ba0ea\"> 属性中挂载的这个开发者自定义的对象给保存到 </span><code data-lake-id=\"u10b9847b\" id=\"u10b9847b\"><span data-lake-id=\"u0b22f19a\" id=\"u0b22f19a\">memorizedState</span></code><span data-lake-id=\"u86e6cfeb\" id=\"u86e6cfeb\"> 属性中；而 </span><code data-lake-id=\"u5881cec7\" id=\"u5881cec7\"><span data-lake-id=\"ue2e94ce8\" id=\"ue2e94ce8\">react hooks</span></code><span data-lake-id=\"ub965caf9\" id=\"ub965caf9\"> 是用链表来保存状态的，</span><code data-lake-id=\"u7cc463af\" id=\"u7cc463af\"><span data-lake-id=\"ue24c7b31\" id=\"ue24c7b31\">memorizedState</span></code><span data-lake-id=\"u4d019279\" id=\"u4d019279\"> 属性保存的实际上是这个链表的头指针</span></p><ul list=\"uecb8d786\" start=\"2\"><li fid=\"u05539923\" data-lake-id=\"u945b62f0\" id=\"u945b62f0\"><span data-lake-id=\"u7d6c6e98\" id=\"u7d6c6e98\">所有的 </span><code data-lake-id=\"uab94d5e8\" id=\"uab94d5e8\"><span data-lake-id=\"u445ce38c\" id=\"u445ce38c\">hooks</span></code><span data-lake-id=\"uc2a1482b\" id=\"uc2a1482b\"> 都以</span><strong><span data-lake-id=\"u75993a67\" id=\"u75993a67\">链表</span></strong><span data-lake-id=\"ub5518184\" id=\"ub5518184\">的形式挂载在 </span><code data-lake-id=\"u4e837760\" id=\"u4e837760\"><span data-lake-id=\"u92dd4841\" id=\"u92dd4841\">FiberNode.updateQueue</span></code><span data-lake-id=\"ucae3065c\" id=\"ucae3065c\"> 中</span></li></ul><h3 data-lake-id=\"akGBz\" id=\"akGBz\"><span data-lake-id=\"u876fad15\" id=\"u876fad15\">HOC 和 hook 的区别</span></h3><p data-lake-id=\"ud35e0af8\" id=\"ud35e0af8\"><code data-lake-id=\"uc3825cf9\" id=\"uc3825cf9\"><span data-lake-id=\"u3ba6a879\" id=\"u3ba6a879\">HOC</span></code><span data-lake-id=\"uca25b95c\" id=\"uca25b95c\"> 可以复用逻辑和视图，</span><code data-lake-id=\"u2bd49b42\" id=\"u2bd49b42\"><span data-lake-id=\"u3dcea7bd\" id=\"u3dcea7bd\">hook</span></code><span data-lake-id=\"ufc3cf95f\" id=\"ufc3cf95f\"> 只能复用逻辑</span></p><h2 data-lake-id=\"rEXAC\" id=\"rEXAC\"><span data-lake-id=\"u71aee9f7\" id=\"u71aee9f7\">react hooks 常用 api</span></h2><h3 data-lake-id=\"tn70i\" id=\"tn70i\"><span data-lake-id=\"uc18fdf0b\" id=\"uc18fdf0b\">基础 hooks</span></h3><ol list=\"ueaac90e0\"><li fid=\"u86813282\" data-lake-id=\"uc3c72b8f\" id=\"uc3c72b8f\"><span data-lake-id=\"uf390de23\" id=\"uf390de23\">useState：状态钩子，为函数组件提供内部状态</span></li><li fid=\"u86813282\" data-lake-id=\"u31cbda88\" id=\"u31cbda88\"><span data-lake-id=\"u62e40a6d\" id=\"u62e40a6d\">useEffect：副作用钩子，可以看作是 componentDidMount、componentDidUpdate 和 componentWillUnmount 的结合</span></li><li fid=\"u86813282\" data-lake-id=\"ue5ca3728\" id=\"ue5ca3728\"><span data-lake-id=\"u08c7395f\" id=\"u08c7395f\">useContext：共享钩子，在组件之间共享状态，可以解决 react 逐层通过 props 传递数据</span></li></ol><h3 data-lake-id=\"mmsp9\" id=\"mmsp9\"><span data-lake-id=\"u0a595b50\" id=\"u0a595b50\">额外的 hooks</span></h3><ol list=\"ub55db58d\"><li fid=\"ua02f52d5\" data-lake-id=\"uffbe7ad5\" id=\"uffbe7ad5\"><span data-lake-id=\"ue1a5da44\" id=\"ue1a5da44\">useReducer：action 钩子，提供了状态管理，其基本原理是通过用户在页面上发起的 action，从而通过 reducer 方法来改变 state，从而实现页面和状态的通信，使用起来与 redux 类似</span></li><li fid=\"ua02f52d5\" data-lake-id=\"u5efd2e29\" id=\"u5efd2e29\"><span data-lake-id=\"u85f6435e\" id=\"u85f6435e\">useCallback：缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果</span></li><li fid=\"ua02f52d5\" data-lake-id=\"u634e4ea8\" id=\"u634e4ea8\"><span data-lake-id=\"u56e5c63f\" id=\"u56e5c63f\">useMemo：把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时重新计算，可以作为性能优化的手段</span></li><li fid=\"ua02f52d5\" data-lake-id=\"uddaf1ed8\" id=\"uddaf1ed8\"><span data-lake-id=\"u2f698a51\" id=\"u2f698a51\">useRef：获取组件的实例，返回一个可变的 ref 对象，返回的 ref 对象在组件的整个生命周期内保持不变</span></li><li fid=\"ua02f52d5\" data-lake-id=\"u09379496\" id=\"u09379496\"><span data-lake-id=\"u0a071852\" id=\"u0a071852\">useLayoutEffect：它会在所有 dom 变更后同步调用 effect</span></li></ol><h2 data-lake-id=\"pWIlT\" id=\"pWIlT\"><span data-lake-id=\"u3bca309c\" id=\"u3bca309c\">常见问题</span></h2><h3 data-lake-id=\"lrAUQ\" id=\"lrAUQ\"><span data-lake-id=\"ud7aa2c47\" id=\"ud7aa2c47\">useState 使用浅析</span></h3><ul list=\"u59fa8d90\"><li fid=\"u6d7c9a1e\" data-lake-id=\"u2ad2e862\" id=\"u2ad2e862\"><span data-lake-id=\"uff564850\" id=\"uff564850\">使用方法</span></li></ul><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20%5Bstate%2C%20setState%5D%20%3D%20useState(initialValue)%3B%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22iN7l4%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ucebb5674\" id=\"ucebb5674\"><strong><span data-lake-id=\"u2baf0322\" id=\"u2baf0322\">每次渲染具有独立的状态值</span></strong><span data-lake-id=\"u268b5469\" id=\"u268b5469\">（毕竟每次渲染都是完全独立的嘛）。也就是说，每个函数中的 state 变量只是一个简单的</span><strong><span data-lake-id=\"u77e15f91\" id=\"u77e15f91\">常量</span></strong><span data-lake-id=\"uc13740a8\" id=\"uc13740a8\">，每次渲染时从钩子中获取到的常量，并没有附着数据绑定之类的神奇魔法。</span></p><h3 data-lake-id=\"NlhjI\" id=\"NlhjI\"><span data-lake-id=\"u451df870\" id=\"u451df870\">useEffect 使用浅析</span></h3><p data-lake-id=\"ua8b80aa2\" id=\"ua8b80aa2\"><span data-lake-id=\"u54611085\" id=\"u54611085\">React 会在</span><strong><span data-lake-id=\"ub5adf268\" id=\"ub5adf268\">每次渲染后都运行 Effect</span></strong><span data-lake-id=\"uf00b4b8d\" id=\"uf00b4b8d\">。而依赖数组就是用来控制是否应该触发 Effect，从而能够减少不必要的计算，从而优化了性能。具体而言，只要依赖数组中的每一项与上一次渲染相比都没有改变，那么就跳过本次 Effect 的执行。</span></p><h3 data-lake-id=\"js4V1\" id=\"js4V1\"><span data-lake-id=\"ucecfca15\" id=\"ucecfca15\">useCallback 使用浅析</span></h3><p data-lake-id=\"udea3aa55\" id=\"udea3aa55\" style=\"text-indent: 2em\"><span data-lake-id=\"ud481d01b\" id=\"ud481d01b\">为了解决函数在多次渲染中的引用相等（Referential Equality）问题，React 引入了一个重要的 Hook—— useCallback。官方文档介绍的使用方法如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20memoizedCallback%20%3D%20useCallback(callback%2C%20deps)%3B%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22itpGL%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u97c8a8be\" id=\"u97c8a8be\" style=\"text-indent: 2em\"><span data-lake-id=\"ucc915ac0\" id=\"ucc915ac0\">第一个参数 </span><span data-lake-id=\"ue374b5a2\" id=\"ue374b5a2\">callback</span><span data-lake-id=\"u44fd4a67\" id=\"u44fd4a67\"> 就是需要记忆的函数，第二个参数就是大家熟悉的 </span><span data-lake-id=\"u84606fd8\" id=\"u84606fd8\">deps</span><span data-lake-id=\"ud424c959\" id=\"ud424c959\"> 参数，同样也是一个依赖数组（有时候也被称为输入 </span><span data-lake-id=\"u9b50c60e\" id=\"u9b50c60e\">inputs</span><span data-lake-id=\"u7960bc2d\" id=\"u7960bc2d\">）。在 Memoization 的上下文中，这个 </span><span data-lake-id=\"u3db94836\" id=\"u3db94836\">deps</span><span data-lake-id=\"u3a3de4c8\" id=\"u3a3de4c8\"> 的作用相当于缓存中的键（Key），如果键没有改变，那么就直接返回缓存中的函数，并且确保是引用相同的函数。</span></p><p data-lake-id=\"ub105401c\" id=\"ub105401c\"><span data-lake-id=\"ude74c7bd\" id=\"ude74c7bd\">​</span><br></p><p data-lake-id=\"u0592ce82\" id=\"u0592ce82\" style=\"text-indent: 2em\"><span data-lake-id=\"u37c4cfdb\" id=\"u37c4cfdb\">在大多数情况下，我们都是传入空数组 [] 作为 deps 参数，这样 useCallback 返回的就</span><strong><span data-lake-id=\"uedbc335c\" id=\"uedbc335c\">始终是同一个函数，永远不会更新</span></strong><span data-lake-id=\"u8c6d4983\" id=\"u8c6d4983\">。</span></p><blockquote data-lake-id=\"u27243f98\" id=\"u27243f98\" class=\"lake-alert lake-alert-warning\"><p data-lake-id=\"u9ef3f830\" id=\"u9ef3f830\"><strong><span data-lake-id=\"u5d9a25bb\" id=\"u5d9a25bb\">提示：</span></strong></p><p data-lake-id=\"u10dfab31\" id=\"u10dfab31\" style=\"text-indent: 2em\"><span data-lake-id=\"ua6aaaa75\" id=\"ua6aaaa75\">也许在刚开始学习 useEffect 的时候就发现：我们并不需要把 useState 返回的第二个 Setter 函数作为 Effect 的依赖。实际上，React 内部已经对 Setter 函数做了 Memoization 处理，因此每次渲染拿到的 Setter 函数都是完全一样的，deps 加不加都是没有影响的。</span></p></blockquote><h3 data-lake-id=\"yzNnF\" id=\"yzNnF\"><span data-lake-id=\"uaa19a1b1\" id=\"uaa19a1b1\">useMemo</span></h3><p data-lake-id=\"u2d0bf34d\" id=\"u2d0bf34d\" style=\"text-indent: 2em\"><span data-lake-id=\"ue862df27\" id=\"ue862df27\">我们知道 </span><span data-lake-id=\"u3ddd5e15\" id=\"u3ddd5e15\">useCallback</span><span data-lake-id=\"uec7d0f34\" id=\"uec7d0f34\"> 有个好基友叫 </span><span data-lake-id=\"u01aeeb92\" id=\"u01aeeb92\">useMemo</span><span data-lake-id=\"u6e168546\" id=\"u6e168546\">。还记得我们之前总结了 Memoization 的两大场景吗？</span><span data-lake-id=\"u72f63147\" id=\"u72f63147\">useCallback</span><span data-lake-id=\"ud8917ef0\" id=\"ud8917ef0\"> 主要是为了解决函数的”</span><strong><span data-lake-id=\"u9ac59785\" id=\"u9ac59785\">引用相等</span></strong><span data-lake-id=\"uc2bb965d\" id=\"uc2bb965d\">“问题，而 </span><span data-lake-id=\"ucab65314\" id=\"ucab65314\">useMemo</span><span data-lake-id=\"uca41d18d\" id=\"uca41d18d\"> 则是一个”</span><strong><span data-lake-id=\"uaa99ffdd\" id=\"uaa99ffdd\">全能型选手</span></strong><span data-lake-id=\"u97e4353c\" id=\"u97e4353c\">“，能够同时胜任引用相等和节约计算的任务。</span></p><p data-lake-id=\"uef6dda87\" id=\"uef6dda87\"><span data-lake-id=\"u18eac8bf\" id=\"u18eac8bf\">​</span><br></p><p data-lake-id=\"u3612edf2\" id=\"u3612edf2\" style=\"text-indent: 2em\"><span data-lake-id=\"u6dc78dbc\" id=\"u6dc78dbc\">实际上，useMemo 的功能是 useCallback 的</span><strong><span data-lake-id=\"u3f907102\" id=\"u3f907102\">超集</span></strong><span data-lake-id=\"u50d47b4a\" id=\"u50d47b4a\">。与 useCallback 只能缓存函数相比，useMemo 可以缓存任何类型的值（当然也包括函数）。useMemo 的使用方法如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20memoizedValue%20%3D%20useMemo(()%20%3D%3E%20computeExpensiveValue(a%2C%20b)%2C%20%5Ba%2C%20b%5D)%3B%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22vXYfr%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u09da1c2e\" id=\"u09da1c2e\" style=\"text-indent: 2em\"><span data-lake-id=\"u7234fa86\" id=\"u7234fa86\">其中第一个参数是一个函数，这个函数返回值的返回值（也就是上面 computeExpensiveValue 的结果）将返回给 memoizedValue 。因此以下两个钩子的使用是完全等价的：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22useCallback(fn%2C%20deps)%3B%5CnuseMemo(()%20%3D%3E%20fn%2C%20deps)%3B%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22lET1M%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h3 data-lake-id=\"qWaYi\" id=\"qWaYi\"><span data-lake-id=\"u86794563\" id=\"u86794563\">useEffect 和 useLayoutEffect 的区别</span></h3><ul list=\"u616adb48\"><li fid=\"ub91513da\" data-lake-id=\"u14e556d6\" id=\"u14e556d6\"><span data-lake-id=\"u6ba67338\" id=\"u6ba67338\">useEffect 是异步执行，保证了不会阻塞浏览器进程</span></li><li fid=\"ub91513da\" data-lake-id=\"u0c9e7a1b\" id=\"u0c9e7a1b\"><span data-lake-id=\"u5a65f63f\" id=\"u5a65f63f\">useLayoutEffect 是同步执行，会阻塞浏览器进程</span></li></ul><h3 data-lake-id=\"NkvL0\" id=\"NkvL0\"><span data-lake-id=\"u1c66dc96\" id=\"u1c66dc96\">useEffect dep = [] 与 componentDidMount 的区别</span></h3><p data-lake-id=\"ue758805e\" id=\"ue758805e\" style=\"text-indent: 2em\"><span data-lake-id=\"u5f243a3e\" id=\"u5f243a3e\">在 render 执行之后，componentDidMount 会执行，如果在这个生命周期中再一次 setState ，会导致再次 render ，返回了新的值，浏览器只会渲染第二次 render 返回的值，这样可以避免闪屏。</span></p><p data-lake-id=\"u9f4824cc\" id=\"u9f4824cc\" style=\"text-indent: 2em\"><span data-lake-id=\"uab627c24\" id=\"uab627c24\">但是 </span><span data-lake-id=\"u86df5e96\" id=\"u86df5e96\">useEffect</span><span data-lake-id=\"u6077740b\" id=\"u6077740b\"> 是在真实的 DOM 渲染之后才会去执行，这会造成两次 </span><span data-lake-id=\"u7945c27f\" id=\"u7945c27f\">render</span><span data-lake-id=\"u7500b835\" id=\"u7500b835\"> ，有可能会闪屏。</span></p><p data-lake-id=\"udd9d0e77\" id=\"udd9d0e77\" style=\"text-indent: 2em\"><span data-lake-id=\"udac98254\" id=\"udac98254\">实际上 useLayoutEffect 会更接近 componentDidMount 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。</span></p><h3 data-lake-id=\"gcqKN\" id=\"gcqKN\"><span data-lake-id=\"u8de7fd72\" id=\"u8de7fd72\">React.memo 和 React.useMemo 的区别</span></h3><ul list=\"u9ee5882e\"><li fid=\"u3c2780d9\" data-lake-id=\"u2352a32a\" id=\"u2352a32a\"><span data-lake-id=\"ub118c3e3\" id=\"ub118c3e3\">memo 是一个高阶组件，默认情况下会对 props 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。</span></li><li fid=\"u3c2780d9\" data-lake-id=\"u217dcca9\" id=\"u217dcca9\"><span data-lake-id=\"uf6ce0be6\" id=\"uf6ce0be6\">useMemo 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，useMemo 是在 render 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴。</span></li></ul><h3 data-lake-id=\"wb0db\" id=\"wb0db\"><span data-lake-id=\"uc3fc517a\" id=\"uc3fc517a\">React.useCallback 和 React.useMemo 的区别</span></h3><ul list=\"u5ca60eb4\"><li fid=\"u1d618594\" data-lake-id=\"u0a8828d8\" id=\"u0a8828d8\"><span data-lake-id=\"u9b9ea627\" id=\"u9b9ea627\">useCallback 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。</span></li><li fid=\"u1d618594\" data-lake-id=\"u3a4c4af0\" id=\"u3a4c4af0\"><span data-lake-id=\"ud26911c9\" id=\"ud26911c9\">useMemo</span><span data-lake-id=\"ud5b5ce4c\" id=\"ud5b5ce4c\"> 可缓存值。</span></li></ul><p data-lake-id=\"u29497330\" id=\"u29497330\" style=\"text-indent: 2em\"><span data-lake-id=\"u708e4bc6\" id=\"u708e4bc6\">有很多时候，我们在 useEffect 中使用某个定义的外部函数，是要添加到 deps 数组中的，如果不用 useCallback 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 useEffect 总会无意义的执行。</span></p><h3 data-lake-id=\"JzucX\" id=\"JzucX\"><span data-lake-id=\"u4ff54423\" id=\"u4ff54423\">React.forwardRef</span></h3><p data-lake-id=\"u570fd193\" id=\"u570fd193\" style=\"text-indent: 2em\"><span data-lake-id=\"u9a2ba997\" id=\"u9a2ba997\">React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：</span></p><ul list=\"u001e8e9b\"><li fid=\"u1def6caf\" data-lake-id=\"u91357c2d\" id=\"u91357c2d\"><span data-lake-id=\"uaee53497\" id=\"uaee53497\">转发 refs 到 DOM 组件</span></li></ul><p data-lake-id=\"u9b6229e4\" id=\"u9b6229e4\"><span data-lake-id=\"u5e4fbad5\" id=\"u5e4fbad5\">在高阶组件中转发 refs</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-05-29T20:47:37.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:46.000Z",
  "updated_at": "2022-05-29T20:47:37.000Z",
  "published_at": "2022-05-29T20:47:37.000Z",
  "first_published_at": "2022-04-04T11:32:46.025Z",
  "word_count": 2212,
  "cover": null,
  "description": "react 解决代码复用的主要方式高阶组件render propsreact hooks对 react hooks 的理解没有提出 hooks 前存在的问题在组件之间复用状态逻辑很难hook 使你在无需修改组件结构的情况下复用状态逻辑复杂组件变得难以理解hook 将组件中相互关联的部分拆分成更...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}