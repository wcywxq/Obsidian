{
  "id": 72212042,
  "slug": "ggyg1d",
  "title": "nextTick 相关问题",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"R2aOu\"></a>\n### $nextTick 原理及作用\n:::info\n**简述：**\n\n- Vue 是异步执行 dom 更新的，一旦观察到数据的变化，就会把同一个 event loop 中的观察数据变化的 watcher 推送进这个队列\n- 在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用：Promise -> MutationObserver -> setImmediate -> setTimeout\n:::\nVue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。\n\nnextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。\n\nnextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理\n\nnextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶\n\n- 如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染\n- 同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要\n\nVue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。\n\n由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。\n```javascript\nthis.$nextTick(() => {    // 获取数据的操作...})\n```\n所以，在以下情况下，会用到nextTick：\n\n- 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。\n- 在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。\n\n因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。\n<a name=\"TIO9r\"></a>\n## 什么时候用到 nextTick\n在数据变化后执行某个操作，而这个操作依赖因你数据变化而变化的 dom, 这个操作就应该放到 Vue.nextTick 回调中\n",
  "body_draft": "",
  "body_html": "<!doctype html><h3 id=\"R2aOu\"><span>$nextTick 原理及作用</span></h3><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"ufd2b19ba\"><strong><span>简述：</span></strong></p><ul><li><span>Vue 是异步执行 dom 更新的，一旦观察到数据的变化，就会把同一个 event loop 中的观察数据变化的 watcher 推送进这个队列</span></li><li><span>在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用：Promise -&gt; MutationObserver -&gt; setImmediate -&gt; setTimeout</span></li></ul></blockquote><p data-lake-id=\"u4235cfec\"><span>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</span></p><p data-lake-id=\"u87da5246\"><span>​</span><br /></p><p data-lake-id=\"u7d6c32a4\"><span>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</span></p><p data-lake-id=\"uceadea68\"><span>​</span><br /></p><p data-lake-id=\"udeb4c6a8\"><span>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</span></p><p data-lake-id=\"ub0f41ea1\"><span>​</span><br /></p><p data-lake-id=\"u4469ab98\"><span>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</span></p><ul><li><span>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</span></li><li><span>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</span></li></ul><p data-lake-id=\"uf5b083c5\"><span>​</span><br /></p><p data-lake-id=\"u52204306\"><span>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。</span></p><p data-lake-id=\"u3d39298a\"><span>​</span><br /></p><p data-lake-id=\"uac01dc39\"><span>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。</span></p><pre data-lang=\"javascript\"><code>this.$nextTick(() =&gt; {    // 获取数据的操作...})</code></pre><p data-lake-id=\"u15c3ed05\"><span>所以，在以下情况下，会用到nextTick：</span></p><ul><li><span>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在</span><span>nextTick()</span><span>的回调函数中。</span></li><li><span>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在</span><span>nextTick()</span><span>的回调函数中。</span></li></ul><p data-lake-id=\"u509b639c\"><span>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。</span></p><h2 id=\"TIO9r\"><span>什么时候用到 nextTick</span></h2><p data-lake-id=\"u793bb964\"><span>在数据变化后执行某个操作，而这个操作依赖因你数据变化而变化的 dom, 这个操作就应该放到 Vue.nextTick 回调中</span></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h3 data-lake-id=\"R2aOu\" id=\"R2aOu\"><span data-lake-id=\"u238cfb87\" id=\"u238cfb87\">$nextTick 原理及作用</span></h3><blockquote data-lake-id=\"u599a2708\" id=\"u599a2708\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"ufd2b19ba\" id=\"ufd2b19ba\"><strong><span data-lake-id=\"u8f65bb81\" id=\"u8f65bb81\">简述：</span></strong></p><ul list=\"ub78b5218\"><li fid=\"uf58708f0\" data-lake-id=\"ue26a1f97\" id=\"ue26a1f97\"><span data-lake-id=\"u29daa0f2\" id=\"u29daa0f2\">Vue 是异步执行 dom 更新的，一旦观察到数据的变化，就会把同一个 event loop 中的观察数据变化的 watcher 推送进这个队列</span></li><li fid=\"uf58708f0\" data-lake-id=\"u33c85eea\" id=\"u33c85eea\"><span data-lake-id=\"ub3971158\" id=\"ub3971158\">在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用：Promise -&gt; MutationObserver -&gt; setImmediate -&gt; setTimeout</span></li></ul></blockquote><p data-lake-id=\"u4235cfec\" id=\"u4235cfec\"><span data-lake-id=\"u237ed86c\" id=\"u237ed86c\">Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</span></p><p data-lake-id=\"u87da5246\" id=\"u87da5246\"><span data-lake-id=\"u10aa3ca4\" id=\"u10aa3ca4\">​</span><br></p><p data-lake-id=\"u7d6c32a4\" id=\"u7d6c32a4\"><span data-lake-id=\"u7696e797\" id=\"u7696e797\">nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</span></p><p data-lake-id=\"uceadea68\" id=\"uceadea68\"><span data-lake-id=\"u2c7863e5\" id=\"u2c7863e5\">​</span><br></p><p data-lake-id=\"udeb4c6a8\" id=\"udeb4c6a8\"><span data-lake-id=\"u3cedd074\" id=\"u3cedd074\">nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</span></p><p data-lake-id=\"ub0f41ea1\" id=\"ub0f41ea1\"><span data-lake-id=\"u94d5fcf9\" id=\"u94d5fcf9\">​</span><br></p><p data-lake-id=\"u4469ab98\" id=\"u4469ab98\"><span data-lake-id=\"ud3281740\" id=\"ud3281740\">nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</span></p><ul list=\"u8b45acf4\"><li fid=\"uc35e4c20\" data-lake-id=\"u0aa5483b\" id=\"u0aa5483b\"><span data-lake-id=\"u5bd16752\" id=\"u5bd16752\">如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</span></li><li fid=\"uc35e4c20\" data-lake-id=\"ua39fb285\" id=\"ua39fb285\"><span data-lake-id=\"ue68fdb0a\" id=\"ue68fdb0a\">同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</span></li></ul><p data-lake-id=\"uf5b083c5\" id=\"uf5b083c5\"><span data-lake-id=\"u0a228316\" id=\"u0a228316\">​</span><br></p><p data-lake-id=\"u52204306\" id=\"u52204306\"><span data-lake-id=\"u19b39ef9\" id=\"u19b39ef9\">Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。</span></p><p data-lake-id=\"u3d39298a\" id=\"u3d39298a\"><span data-lake-id=\"ua2859c3c\" id=\"ua2859c3c\">​</span><br></p><p data-lake-id=\"uac01dc39\" id=\"uac01dc39\"><span data-lake-id=\"uca95ffb5\" id=\"uca95ffb5\">由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22this.%24nextTick(()%20%3D%3E%20%7B%20%20%20%20%2F%2F%20%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%93%8D%E4%BD%9C...%7D)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22CdqMD%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u15c3ed05\" id=\"u15c3ed05\"><span data-lake-id=\"ubd408e79\" id=\"ubd408e79\">所以，在以下情况下，会用到nextTick：</span></p><ul list=\"u02f3d00d\"><li fid=\"u430255a7\" data-lake-id=\"u1e173b3a\" id=\"u1e173b3a\"><span data-lake-id=\"u397d4a00\" id=\"u397d4a00\">在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在</span><span data-lake-id=\"u99a419de\" id=\"u99a419de\">nextTick()</span><span data-lake-id=\"ud428c1b8\" id=\"ud428c1b8\">的回调函数中。</span></li><li fid=\"u430255a7\" data-lake-id=\"u7bf18e76\" id=\"u7bf18e76\"><span data-lake-id=\"u215b8fbc\" id=\"u215b8fbc\">在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在</span><span data-lake-id=\"uba766c16\" id=\"uba766c16\">nextTick()</span><span data-lake-id=\"u29407fb5\" id=\"u29407fb5\">的回调函数中。</span></li></ul><p data-lake-id=\"u509b639c\" id=\"u509b639c\"><span data-lake-id=\"u6b2f957a\" id=\"u6b2f957a\">因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。</span></p><h2 data-lake-id=\"TIO9r\" id=\"TIO9r\"><span data-lake-id=\"uf015aa3d\" id=\"uf015aa3d\">什么时候用到 nextTick</span></h2><p data-lake-id=\"u793bb964\" id=\"u793bb964\"><span data-lake-id=\"u47b24a3e\" id=\"u47b24a3e\">在数据变化后执行某个操作，而这个操作依赖因你数据变化而变化的 dom, 这个操作就应该放到 Vue.nextTick 回调中</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:32:41.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:41.000Z",
  "updated_at": "2022-05-10T15:12:43.000Z",
  "published_at": "2022-04-04T11:32:41.000Z",
  "first_published_at": "2022-04-04T11:32:41.018Z",
  "word_count": 828,
  "cover": null,
  "description": "$nextTick 原理及作用简述：Vue 是异步执行 dom 更新的，一旦观察到数据的变化，就会把同一个 event loop 中的观察数据变化的 watcher 推送进这个队列在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}