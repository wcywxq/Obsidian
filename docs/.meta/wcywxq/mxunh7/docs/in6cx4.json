{
  "id": 72212102,
  "slug": "in6cx4",
  "title": "proxy 和 reflect",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"FbJdB\"></a>\n## proxy\nProxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义(如属性查找、赋值、枚举、函数调用等)\n<a name=\"MYAFu\"></a>\n### 语法\n```javascript\nconst p = new Proxy(target, handler)\n```\n<a name=\"MVVPv\"></a>\n### 参数\n\n- target：要使用 Proxy 包装的**目标对象**(可以是任何类型的对象，包括**原生数组**、**函数**，甚至**另一个代理**)\n- handler：一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为\n<a name=\"CDOhV\"></a>\n### 示例\n```javascript\nconst handler = {\n\tget(obj, prop) {\n  \treturn prop in obj ? obj[prop] : 37\n  }\n}\nconst p = new Proxy({}, handler)\np.a = 1\np.b = undefined\nconsole.log(p.a, p.b) // 1，undefined\nconsole.log('c' in p, p.c) // false，37\n```\n<a name=\"moaMA\"></a>\n## reflect\nReflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers(en-US) 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的\n<a name=\"xbzLS\"></a>\n### 描述\n与大多数全局对象不同 Reflect 并非一个构造函数，所以不能通过 new运算符对其进行调用。或者将 Reflect 对象作为一个函数来调用。Reflect 的所有属性和方法都是静态的\n\nReflect 对象提供了与 proxy handler methods 的命名相同。其中的一些方法与 Object 对象相同，可以说它继承了大部分 Object 的方法，也在许多方法做了相应的优化\n\n- return 不返回 obj，而是返回 true 或者 false\n\n这样可以避免 Object.defineProperty 抛出错误\n\n- 更方便的函数操作\n\n如：Reflect.has(obj, name)、Reflect.deleteProperty(obj, name)\n\n- 更加稳定可靠的函数调用\n\n在 es5 中，如果需要调用一个函数 f，执行上下文指向 obj 对象，还有 args 参数列表，通常是这么写：\n```javascript\nf.apply(obj, args)\n```\n然而，函数 f 可能会无意中去定义自己的 apply 方法，所以为了避嫌，可以这么写：\n```javascript\nFunction.prototype.apply.call(f, obj, args)\n```\n而在 es6 中，可以讲代码缩短：\n```javascript\nReflect.apply(f, obj, args)\n```\n\n- 调用构造函数时可接受不确定长度的参数列表\n\n在 es6 中可以使用扩展运算符\n```javascript\nvar obj = new F(...args)\n```\n但是在 es5，这样根本行不通，如果有了 Reflect，就可以这么写：\n```javascript\nvar obj = Reflect.constructor(F, args)\n```\n\n- 控制访问器或者读取器的 this\n\n在 es5 中，访问或者定义对象属性可以这样写\n```javascript\nvar name = ... // get property name as a string\nobj[name] // generic property lookup\nobj[name] = value // generic property update\n```\nReflect 也能有相应的方法，此外，还增加了一个 receiver 参数，用于绑定 getter 和 setter 的执行上下文(一般指 Proxy 或者继承 Proxy 的对象)\n```javascript\nvar name = ... // get property name as a string\nReflect.get(obj, name, wrapper) // if obj[name] is an accessor, it gets run with `this === wrapper`\nReflect.set(obj, name, value, wrapper)\n```\n\n- 避免直接访问 proto\n\nes5 提供了 Object.getPrototypeOf(obj)，去访问对象的原型；而 es6 也提供了 Reflect.getPrototypeOf(obj) 和 Reflect.setPrototypeOf(obj, newProto)，这个是新的方法去访问和设置对象的原型\n<a name=\"FzdAv\"></a>\n### 示例\n\n- 检测一个对象是否存在特定属性\n```javascript\nconst duck = {\n\tname: 'Maurice',\n  color: 'white',\n  greeting() {\n  \tconsole.log(`Quaaack! My name is ${this.name}`)\n  }\n}\nReflect.has(duck, 'color') // true\nReflect.has(duck, 'haircut') // false\n```\n\n- 返回这个对象自身的属性\n```javascript\nReflect.ownKeys(duck) // ['name', 'color', 'greeting']\n```\n\n- 为这个对象添加一个新的属性\n```javascript\nReflect.set(duck, 'eyes', 'black')\n// returns 'ture' if successful\n// 'duck' now contains the property 'eyes: \"black\"'\n```\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"FbJdB\"><span>proxy</span></h2><p data-lake-id=\"ubd71462d\"><span>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义(如属性查找、赋值、枚举、函数调用等)</span></p><h3 id=\"MYAFu\"><span>语法</span></h3><pre data-lang=\"javascript\"><code>const p = new Proxy(target, handler)</code></pre><h3 id=\"MVVPv\"><span>参数</span></h3><ul><li><span>target：要使用 Proxy 包装的</span><strong><span>目标对象</span></strong><span>(可以是任何类型的对象，包括</span><strong><span>原生数组</span></strong><span>、</span><strong><span>函数</span></strong><span>，甚至</span><strong><span>另一个代理</span></strong><span>)</span></li><li><span>handler：一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为</span></li></ul><h3 id=\"CDOhV\"><span>示例</span></h3><pre data-lang=\"javascript\"><code>const handler = {\n\tget(obj, prop) {\n  \treturn prop in obj ? obj[prop] : 37\n  }\n}\nconst p = new Proxy({}, handler)\np.a = 1\np.b = undefined\nconsole.log(p.a, p.b) // 1，undefined\nconsole.log('c' in p, p.c) // false，37</code></pre><h2 id=\"moaMA\"><span>reflect</span></h2><p data-lake-id=\"uea40b53b\"><span>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers(en-US) 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的</span></p><h3 id=\"xbzLS\"><span>描述</span></h3><p data-lake-id=\"u74b0e944\"><span>与大多数全局对象不同 Reflect 并非一个构造函数，所以不能通过 new运算符对其进行调用。或者将 Reflect 对象作为一个函数来调用。Reflect 的所有属性和方法都是静态的</span></p><p data-lake-id=\"ufc37a313\"><span>​</span><br /></p><p data-lake-id=\"udf9f169a\"><span>Reflect 对象提供了与 proxy handler methods 的命名相同。其中的一些方法与 Object 对象相同，可以说它继承了大部分 Object 的方法，也在许多方法做了相应的优化</span></p><ul><li><span>return 不返回 obj，而是返回 true 或者 false</span></li></ul><p data-lake-id=\"u44d7a181\"><span>这样可以避免 Object.defineProperty 抛出错误</span></p><ul><li><span>更方便的函数操作</span></li></ul><p data-lake-id=\"ubc0086ca\"><span>如：Reflect.has(obj, name)、Reflect.deleteProperty(obj, name)</span></p><ul><li><span>更加稳定可靠的函数调用</span></li></ul><p data-lake-id=\"u2c4c85e3\"><span>在 es5 中，如果需要调用一个函数 f，执行上下文指向 obj 对象，还有 args 参数列表，通常是这么写：</span></p><pre data-lang=\"javascript\"><code>f.apply(obj, args)</code></pre><p data-lake-id=\"ue8f59b15\"><span>然而，函数 f 可能会无意中去定义自己的 apply 方法，所以为了避嫌，可以这么写：</span></p><pre data-lang=\"javascript\"><code>Function.prototype.apply.call(f, obj, args)</code></pre><p data-lake-id=\"ude0bce69\"><span>而在 es6 中，可以讲代码缩短：</span></p><pre data-lang=\"javascript\"><code>Reflect.apply(f, obj, args)</code></pre><ul><li><span>调用构造函数时可接受不确定长度的参数列表</span></li></ul><p data-lake-id=\"udd4a856e\"><span>在 es6 中可以使用扩展运算符</span></p><pre data-lang=\"javascript\"><code>var obj = new F(...args)</code></pre><p data-lake-id=\"ucd0966bf\"><span>但是在 es5，这样根本行不通，如果有了 Reflect，就可以这么写：</span></p><pre data-lang=\"javascript\"><code>var obj = Reflect.constructor(F, args)</code></pre><ul><li><span>控制访问器或者读取器的 this</span></li></ul><p data-lake-id=\"u26ce6359\"><span>在 es5 中，访问或者定义对象属性可以这样写</span></p><pre data-lang=\"javascript\"><code>var name = ... // get property name as a string\nobj[name] // generic property lookup\nobj[name] = value // generic property update</code></pre><p data-lake-id=\"u5790b867\"><span>Reflect 也能有相应的方法，此外，还增加了一个 receiver 参数，用于绑定 getter 和 setter 的执行上下文(一般指 Proxy 或者继承 Proxy 的对象)</span></p><pre data-lang=\"javascript\"><code>var name = ... // get property name as a string\nReflect.get(obj, name, wrapper) // if obj[name] is an accessor, it gets run with `this === wrapper`\nReflect.set(obj, name, value, wrapper)</code></pre><ul><li><span>避免直接访问 proto</span></li></ul><p data-lake-id=\"u39e67b43\"><span>es5 提供了 Object.getPrototypeOf(obj)，去访问对象的原型；而 es6 也提供了 Reflect.getPrototypeOf(obj) 和 Reflect.setPrototypeOf(obj, newProto)，这个是新的方法去访问和设置对象的原型</span></p><h3 id=\"FzdAv\"><span>示例</span></h3><ul><li><span>检测一个对象是否存在特定属性</span></li></ul><pre data-lang=\"javascript\"><code>const duck = {\n\tname: 'Maurice',\n  color: 'white',\n  greeting() {\n  \tconsole.log(`Quaaack! My name is ${this.name}`)\n  }\n}\nReflect.has(duck, 'color') // true\nReflect.has(duck, 'haircut') // false</code></pre><ul><li><span>返回这个对象自身的属性</span></li></ul><pre data-lang=\"javascript\"><code>Reflect.ownKeys(duck) // ['name', 'color', 'greeting']</code></pre><ul><li><span>为这个对象添加一个新的属性</span></li></ul><pre data-lang=\"javascript\"><code>Reflect.set(duck, 'eyes', 'black')\n// returns 'ture' if successful\n// 'duck' now contains the property 'eyes: &quot;black&quot;'</code></pre>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"FbJdB\" id=\"FbJdB\"><span data-lake-id=\"u0b57f33e\" id=\"u0b57f33e\">proxy</span></h2><p data-lake-id=\"ubd71462d\" id=\"ubd71462d\"><span data-lake-id=\"ua5ba350e\" id=\"ua5ba350e\">Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义(如属性查找、赋值、枚举、函数调用等)</span></p><h3 data-lake-id=\"MYAFu\" id=\"MYAFu\"><span data-lake-id=\"u36ab6121\" id=\"u36ab6121\">语法</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20p%20%3D%20new%20Proxy(target%2C%20handler)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22Zn9W4%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h3 data-lake-id=\"MVVPv\" id=\"MVVPv\"><span data-lake-id=\"u47895836\" id=\"u47895836\">参数</span></h3><ul list=\"ub40cebc1\"><li fid=\"u836883d2\" data-lake-id=\"u08da01b8\" id=\"u08da01b8\"><span data-lake-id=\"u84b55ac2\" id=\"u84b55ac2\">target：要使用 Proxy 包装的</span><strong><span data-lake-id=\"u2c07c0c8\" id=\"u2c07c0c8\">目标对象</span></strong><span data-lake-id=\"u4d23732e\" id=\"u4d23732e\">(可以是任何类型的对象，包括</span><strong><span data-lake-id=\"uc086829f\" id=\"uc086829f\">原生数组</span></strong><span data-lake-id=\"udf6083b9\" id=\"udf6083b9\">、</span><strong><span data-lake-id=\"u23b5f79e\" id=\"u23b5f79e\">函数</span></strong><span data-lake-id=\"u690ff976\" id=\"u690ff976\">，甚至</span><strong><span data-lake-id=\"u63eac610\" id=\"u63eac610\">另一个代理</span></strong><span data-lake-id=\"u42cfb254\" id=\"u42cfb254\">)</span></li><li fid=\"u836883d2\" data-lake-id=\"ubc3bb7d0\" id=\"ubc3bb7d0\"><span data-lake-id=\"ueb0226bc\" id=\"ueb0226bc\">handler：一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为</span></li></ul><h3 data-lake-id=\"CDOhV\" id=\"CDOhV\"><span data-lake-id=\"u881cacbb\" id=\"u881cacbb\">示例</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20handler%20%3D%20%7B%5Cn%5Ctget(obj%2C%20prop)%20%7B%5Cn%20%20%5Ctreturn%20prop%20in%20obj%20%3F%20obj%5Bprop%5D%20%3A%2037%5Cn%20%20%7D%5Cn%7D%5Cnconst%20p%20%3D%20new%20Proxy(%7B%7D%2C%20handler)%5Cnp.a%20%3D%201%5Cnp.b%20%3D%20undefined%5Cnconsole.log(p.a%2C%20p.b)%20%2F%2F%201%EF%BC%8Cundefined%5Cnconsole.log('c'%20in%20p%2C%20p.c)%20%2F%2F%20false%EF%BC%8C37%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22qlJTU%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"moaMA\" id=\"moaMA\"><span data-lake-id=\"u3d65f041\" id=\"u3d65f041\">reflect</span></h2><p data-lake-id=\"uea40b53b\" id=\"uea40b53b\"><span data-lake-id=\"ude20feab\" id=\"ude20feab\">Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers(en-US) 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的</span></p><h3 data-lake-id=\"xbzLS\" id=\"xbzLS\"><span data-lake-id=\"uaec7bbab\" id=\"uaec7bbab\">描述</span></h3><p data-lake-id=\"u74b0e944\" id=\"u74b0e944\"><span data-lake-id=\"u582e259a\" id=\"u582e259a\">与大多数全局对象不同 Reflect 并非一个构造函数，所以不能通过 new运算符对其进行调用。或者将 Reflect 对象作为一个函数来调用。Reflect 的所有属性和方法都是静态的</span></p><p data-lake-id=\"ufc37a313\" id=\"ufc37a313\"><span data-lake-id=\"ubfe70dbb\" id=\"ubfe70dbb\">​</span><br></p><p data-lake-id=\"udf9f169a\" id=\"udf9f169a\"><span data-lake-id=\"ub6eabe8b\" id=\"ub6eabe8b\">Reflect 对象提供了与 proxy handler methods 的命名相同。其中的一些方法与 Object 对象相同，可以说它继承了大部分 Object 的方法，也在许多方法做了相应的优化</span></p><ul list=\"uaea980a6\"><li fid=\"u1efc10e5\" data-lake-id=\"udee664c9\" id=\"udee664c9\"><span data-lake-id=\"u1414c141\" id=\"u1414c141\">return 不返回 obj，而是返回 true 或者 false</span></li></ul><p data-lake-id=\"u44d7a181\" id=\"u44d7a181\"><span data-lake-id=\"uafb40185\" id=\"uafb40185\">这样可以避免 Object.defineProperty 抛出错误</span></p><ul list=\"uaea980a6\" start=\"2\"><li fid=\"u1efc10e5\" data-lake-id=\"u1d317707\" id=\"u1d317707\"><span data-lake-id=\"u3070f340\" id=\"u3070f340\">更方便的函数操作</span></li></ul><p data-lake-id=\"ubc0086ca\" id=\"ubc0086ca\"><span data-lake-id=\"ucb298d4d\" id=\"ucb298d4d\">如：Reflect.has(obj, name)、Reflect.deleteProperty(obj, name)</span></p><ul list=\"uaea980a6\" start=\"3\"><li fid=\"u1efc10e5\" data-lake-id=\"uc65c257d\" id=\"uc65c257d\"><span data-lake-id=\"ucb1c8180\" id=\"ucb1c8180\">更加稳定可靠的函数调用</span></li></ul><p data-lake-id=\"u2c4c85e3\" id=\"u2c4c85e3\"><span data-lake-id=\"uef52d04e\" id=\"uef52d04e\">在 es5 中，如果需要调用一个函数 f，执行上下文指向 obj 对象，还有 args 参数列表，通常是这么写：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22f.apply(obj%2C%20args)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22XhCv9%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ue8f59b15\" id=\"ue8f59b15\"><span data-lake-id=\"u2ab7e8a6\" id=\"u2ab7e8a6\">然而，函数 f 可能会无意中去定义自己的 apply 方法，所以为了避嫌，可以这么写：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22Function.prototype.apply.call(f%2C%20obj%2C%20args)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22DgZjr%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ude0bce69\" id=\"ude0bce69\"><span data-lake-id=\"ucb876ea1\" id=\"ucb876ea1\">而在 es6 中，可以讲代码缩短：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22Reflect.apply(f%2C%20obj%2C%20args)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22DNqAE%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ul list=\"uaea980a6\" start=\"4\"><li fid=\"u1efc10e5\" data-lake-id=\"u7fe2930a\" id=\"u7fe2930a\"><span data-lake-id=\"u232334ad\" id=\"u232334ad\">调用构造函数时可接受不确定长度的参数列表</span></li></ul><p data-lake-id=\"udd4a856e\" id=\"udd4a856e\"><span data-lake-id=\"u52681fb4\" id=\"u52681fb4\">在 es6 中可以使用扩展运算符</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20obj%20%3D%20new%20F(...args)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22o9PgL%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ucd0966bf\" id=\"ucd0966bf\"><span data-lake-id=\"u0fb52331\" id=\"u0fb52331\">但是在 es5，这样根本行不通，如果有了 Reflect，就可以这么写：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20obj%20%3D%20Reflect.constructor(F%2C%20args)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22a85jV%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ul list=\"uaea980a6\" start=\"5\"><li fid=\"u1efc10e5\" data-lake-id=\"u77484784\" id=\"u77484784\"><span data-lake-id=\"ub753df25\" id=\"ub753df25\">控制访问器或者读取器的 this</span></li></ul><p data-lake-id=\"u26ce6359\" id=\"u26ce6359\"><span data-lake-id=\"uf8665287\" id=\"uf8665287\">在 es5 中，访问或者定义对象属性可以这样写</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20name%20%3D%20...%20%2F%2F%20get%20property%20name%20as%20a%20string%5Cnobj%5Bname%5D%20%2F%2F%20generic%20property%20lookup%5Cnobj%5Bname%5D%20%3D%20value%20%2F%2F%20generic%20property%20update%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22YGX7p%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u5790b867\" id=\"u5790b867\"><span data-lake-id=\"ufa2a5e90\" id=\"ufa2a5e90\">Reflect 也能有相应的方法，此外，还增加了一个 receiver 参数，用于绑定 getter 和 setter 的执行上下文(一般指 Proxy 或者继承 Proxy 的对象)</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20name%20%3D%20...%20%2F%2F%20get%20property%20name%20as%20a%20string%5CnReflect.get(obj%2C%20name%2C%20wrapper)%20%2F%2F%20if%20obj%5Bname%5D%20is%20an%20accessor%2C%20it%20gets%20run%20with%20%60this%20%3D%3D%3D%20wrapper%60%5CnReflect.set(obj%2C%20name%2C%20value%2C%20wrapper)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22pxjz3%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ul list=\"uaea980a6\" start=\"6\"><li fid=\"u1efc10e5\" data-lake-id=\"u70663ce8\" id=\"u70663ce8\"><span data-lake-id=\"ue1f016cf\" id=\"ue1f016cf\">避免直接访问 proto</span></li></ul><p data-lake-id=\"u39e67b43\" id=\"u39e67b43\"><span data-lake-id=\"ufac1a53c\" id=\"ufac1a53c\">es5 提供了 Object.getPrototypeOf(obj)，去访问对象的原型；而 es6 也提供了 Reflect.getPrototypeOf(obj) 和 Reflect.setPrototypeOf(obj, newProto)，这个是新的方法去访问和设置对象的原型</span></p><h3 data-lake-id=\"FzdAv\" id=\"FzdAv\"><span data-lake-id=\"uae0afd56\" id=\"uae0afd56\">示例</span></h3><ul list=\"ue8b7bc70\"><li fid=\"u26026f65\" data-lake-id=\"u9911e21c\" id=\"u9911e21c\"><span data-lake-id=\"ud47a0303\" id=\"ud47a0303\">检测一个对象是否存在特定属性</span></li></ul><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20duck%20%3D%20%7B%5Cn%5Ctname%3A%20'Maurice'%2C%5Cn%20%20color%3A%20'white'%2C%5Cn%20%20greeting()%20%7B%5Cn%20%20%5Ctconsole.log(%60Quaaack!%20My%20name%20is%20%24%7Bthis.name%7D%60)%5Cn%20%20%7D%5Cn%7D%5CnReflect.has(duck%2C%20'color')%20%2F%2F%20true%5CnReflect.has(duck%2C%20'haircut')%20%2F%2F%20false%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22u92We%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ul list=\"u5af60a3b\"><li fid=\"ue728a1bf\" data-lake-id=\"u1cecdbcc\" id=\"u1cecdbcc\"><span data-lake-id=\"u9105665e\" id=\"u9105665e\">返回这个对象自身的属性</span></li></ul><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22Reflect.ownKeys(duck)%20%2F%2F%20%5B'name'%2C%20'color'%2C%20'greeting'%5D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22GaYmA%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ul list=\"u4133b6a5\"><li fid=\"uf6bf6822\" data-lake-id=\"u3c67cca8\" id=\"u3c67cca8\"><span data-lake-id=\"u4f6c3971\" id=\"u4f6c3971\">为这个对象添加一个新的属性</span></li></ul><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22Reflect.set(duck%2C%20'eyes'%2C%20'black')%5Cn%2F%2F%20returns%20'ture'%20if%20successful%5Cn%2F%2F%20'duck'%20now%20contains%20the%20property%20'eyes%3A%20%5C%22black%5C%22'%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22N8Z8P%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:02.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:02.000Z",
  "updated_at": "2022-05-10T15:12:40.000Z",
  "published_at": "2022-04-04T11:33:02.000Z",
  "first_published_at": "2022-04-04T11:33:01.706Z",
  "word_count": 862,
  "cover": null,
  "description": "proxyProxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义(如属性查找、赋值、枚举、函数调用等)语法const p = new Proxy(target, handler)参数target：要使用 Proxy 包装的目标对象(可以是任何类型的对象，包括原生数组、函数，甚至...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}