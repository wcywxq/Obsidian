{
  "id": 72212308,
  "slug": "sagma3",
  "title": "ts 关键字间的区别",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"no2WV\"></a>\n## const 和 readonly 的区别\n1. `const` 用于变量，`readonly` 用于属性\n2. `const` 在运行时检查，`readonly` 在编译时检查\n3. 使用 `const` 变量保存的数组，可以使用 `push`、`pop` 等方法。但是如果使用 `ReadonlyArray<number>` 声明的数组不能使用 `push`、`pop` 等方法\n<a name=\"d1ION\"></a>\n## type 和 interface 的区别\n\n1. 类型别名 `type` 可以为任何类型引入名称。例如基本类型，联合类型等\n2. 类型别名 `type` 不支持继承\n3. 类型别名 `type` 不会创建一个真正的名字\n4. 类型别名 `type` 无法被实现(`implements`)，而接口 `interface` 可以被派生类实现\n5. 类型别名 `type` 重名时编译器会抛出错误，接口 `interface` 重名时会产生合并\n6. 类型别名 `type` 无法在函数上挂载属性，接口 `interface` 可以\n```typescript\ninterface FuncWithAttachment {\n  (params: string): boolean\n  someProperty: number\n}\nconst testFunc: FuncWithAttachment = {}\nconst result = testFunc('mike') // 无类型提醒\ntestFunc.someProperty = 3 // 有类型提醒\n```\n<a name=\"eEY0e\"></a>\n## implements 和 extends 的区别\n\n- `extends`, 子类会继承父类的所有属性和方法。\n- `implements`，使用 `implements` 关键字的类将需要实现需要实现的类的所有属性和方法。\n<a name=\"Q4E2a\"></a>\n## 枚举 和 object 的区别\n\n- 枚举可以通过枚举的名称，获取枚举的值。也可以通过枚举的值获取枚举的名称。\n- `object` 只能通过 `key` 获取 `value`\n- 数字枚举在不指定初始值的情况下，枚举值会从 `0` 开始递增。\n- 虽然在运行时，枚举是一个真实存在的对象。但是使用 `keyof` 时的行为却和普通对象不一致。必须使用 `keyof typeof` 才可以获取枚举所有属性名。\n<a name=\"dfnPF\"></a>\n## never 和 void 的区别\n\n- `never`、`never` 表示永远不存在的类型。比如一个函数总是抛出错误，而没有返回值。或者一个函数内部有死循环，永远不会有返回值。函数的返回值就是 `never` 类型。\n- `void`，没有显示的返回值的函数返回值为 `void` 类型。如果一个变量为 `void` 类型，只能赋予 `undefined` 或者 `null`。\n<a name=\"Hl0D8\"></a>\n## any、never、unknown、null&undefined、void 的区别\n\n- `any`：动态的变量类型(失去了类型检查的作用)\n- `never`：永不存在的值的类型。例如：`never`类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。\n- `unknown`：任何类型的值都可以赋给 `unknown`类型，但是`unknown`类型的值只能赋给`unknown`本身和`any`类型。与`any`类型不同的是，`unknown`类型可以接受任意类型赋值，但是`unknown`类型赋值给其他类型前，必须被断言。\n- `null & undefined`：默认情况下 `null`和`undefined`是所有类型的子类型。就是说你可以把`null`和`undefined`赋值给`number`类型的变量。当你指定了`--strictNullChecks`标记，`null`和`undefined`只能赋值给`void`和它们自己\n- `void`：没有任何类型。\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"no2WV\"><span class=\"ne-text\">const 和 readonly 的区别</span></h2><ol class=\"ne-ol\"><li id=\"ua7eccbdf\"><code class=\"ne-code\"><span class=\"ne-text\">const</span></code><span class=\"ne-text\"> 用于变量，</span><code class=\"ne-code\"><span class=\"ne-text\">readonly</span></code><span class=\"ne-text\"> 用于属性</span></li><li id=\"u4c741e12\"><code class=\"ne-code\"><span class=\"ne-text\">const</span></code><span class=\"ne-text\"> 在运行时检查，</span><code class=\"ne-code\"><span class=\"ne-text\">readonly</span></code><span class=\"ne-text\"> 在编译时检查</span></li><li id=\"u21ffcb46\"><span class=\"ne-text\">使用 </span><code class=\"ne-code\"><span class=\"ne-text\">const</span></code><span class=\"ne-text\"> 变量保存的数组，可以使用 </span><code class=\"ne-code\"><span class=\"ne-text\">push</span></code><span class=\"ne-text\">、</span><code class=\"ne-code\"><span class=\"ne-text\">pop</span></code><span class=\"ne-text\"> 等方法。但是如果使用 </span><code class=\"ne-code\"><span class=\"ne-text\">ReadonlyArray&lt;number&gt;</span></code><span class=\"ne-text\"> 声明的数组不能使用 </span><code class=\"ne-code\"><span class=\"ne-text\">push</span></code><span class=\"ne-text\">、</span><code class=\"ne-code\"><span class=\"ne-text\">pop</span></code><span class=\"ne-text\"> 等方法</span></li></ol><h2 id=\"d1ION\"><span class=\"ne-text\">type 和 interface 的区别</span></h2><p id=\"u48f11e4b\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u584a0786\"><span class=\"ne-text\">类型别名 </span><code class=\"ne-code\"><span class=\"ne-text\">type</span></code><span class=\"ne-text\"> 可以为任何类型引入名称。例如基本类型，联合类型等</span></li><li id=\"u7e751204\"><span class=\"ne-text\">类型别名 </span><code class=\"ne-code\"><span class=\"ne-text\">type</span></code><span class=\"ne-text\"> 不支持继承</span></li><li id=\"uf76d7f26\"><span class=\"ne-text\">类型别名 </span><code class=\"ne-code\"><span class=\"ne-text\">type</span></code><span class=\"ne-text\"> 不会创建一个真正的名字</span></li><li id=\"u09dbbc75\"><span class=\"ne-text\">类型别名 </span><code class=\"ne-code\"><span class=\"ne-text\">type</span></code><span class=\"ne-text\"> 无法被实现(</span><code class=\"ne-code\"><span class=\"ne-text\">implements</span></code><span class=\"ne-text\">)，而接口 </span><code class=\"ne-code\"><span class=\"ne-text\">interface</span></code><span class=\"ne-text\"> 可以被派生类实现</span></li><li id=\"u4bd10463\"><span class=\"ne-text\">类型别名 </span><code class=\"ne-code\"><span class=\"ne-text\">type</span></code><span class=\"ne-text\"> 重名时编译器会抛出错误，接口 </span><code class=\"ne-code\"><span class=\"ne-text\">interface</span></code><span class=\"ne-text\"> 重名时会产生合并</span></li><li id=\"u04c5716c\"><span class=\"ne-text\">类型别名 </span><code class=\"ne-code\"><span class=\"ne-text\">type</span></code><span class=\"ne-text\"> 无法在函数上挂载属性，接口 </span><code class=\"ne-code\"><span class=\"ne-text\">interface</span></code><span class=\"ne-text\"> 可以</span></li></ol><pre data-language=\"typescript\" id=\"pnmyz\" class=\"ne-codeblock language-typescript\">interface FuncWithAttachment {\n  (params: string): boolean\n  someProperty: number\n}\nconst testFunc: FuncWithAttachment = {}\nconst result = testFunc('mike') // 无类型提醒\ntestFunc.someProperty = 3 // 有类型提醒</pre><h2 id=\"eEY0e\"><span class=\"ne-text\">implements 和 extends 的区别</span></h2><ul class=\"ne-ul\"><li id=\"uef697ac9\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">extends</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">, 子类会继承父类的所有属性和方法。</span></li><li id=\"u8b49abba\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">implements</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">，使用 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">implements</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\"> 关键字的类将需要实现需要实现的类的所有属性和方法。</span></li></ul><h2 id=\"Q4E2a\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">枚举 和 object 的区别</span></h2><ul class=\"ne-ul\"><li id=\"ua1811bab\"><span class=\"ne-text\">枚举可以通过枚举的名称，获取枚举的值。也可以通过枚举的值获取枚举的名称。</span></li><li id=\"uf437fc90\"><code class=\"ne-code\"><span class=\"ne-text\">object</span></code><span class=\"ne-text\"> 只能通过 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 获取 </span><code class=\"ne-code\"><span class=\"ne-text\">value</span></code></li><li id=\"u8fe04b6e\"><span class=\"ne-text\">数字枚举在不指定初始值的情况下，枚举值会从 </span><code class=\"ne-code\"><span class=\"ne-text\">0</span></code><span class=\"ne-text\"> 开始递增。</span></li><li id=\"ub87cb450\"><span class=\"ne-text\">虽然在运行时，枚举是一个真实存在的对象。但是使用 </span><code class=\"ne-code\"><span class=\"ne-text\">keyof</span></code><span class=\"ne-text\"> 时的行为却和普通对象不一致。必须使用 </span><code class=\"ne-code\"><span class=\"ne-text\">keyof typeof</span></code><span class=\"ne-text\"> 才可以获取枚举所有属性名。</span></li></ul><h2 id=\"dfnPF\"><span class=\"ne-text\">never 和 void 的区别</span></h2><ul class=\"ne-ul\"><li id=\"u7727e35f\"><code class=\"ne-code\"><span class=\"ne-text\">never</span></code><span class=\"ne-text\">、</span><code class=\"ne-code\"><span class=\"ne-text\">never</span></code><span class=\"ne-text\"> 表示永远不存在的类型。比如一个函数总是抛出错误，而没有返回值。或者一个函数内部有死循环，永远不会有返回值。函数的返回值就是 </span><code class=\"ne-code\"><span class=\"ne-text\">never</span></code><span class=\"ne-text\"> 类型。</span></li><li id=\"u3d40e934\"><code class=\"ne-code\"><span class=\"ne-text\">void</span></code><span class=\"ne-text\">，没有显示的返回值的函数返回值为 </span><code class=\"ne-code\"><span class=\"ne-text\">void</span></code><span class=\"ne-text\"> 类型。如果一个变量为 </span><code class=\"ne-code\"><span class=\"ne-text\">void</span></code><span class=\"ne-text\"> 类型，只能赋予 </span><code class=\"ne-code\"><span class=\"ne-text\">undefined</span></code><span class=\"ne-text\"> 或者 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">。</span></li></ul><h2 id=\"Hl0D8\"><span class=\"ne-text\">any、never、unknown、null&amp;undefined、void 的区别</span></h2><ul class=\"ne-ul\"><li id=\"u7742d35e\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">any</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">：动态的变量类型(失去了类型检查的作用)</span></li><li id=\"ud03b8c54\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">never</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">：永不存在的值的类型。例如：</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">never</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</span></li><li id=\"u1f3af0e1\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">unknown</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">：任何类型的值都可以赋给 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">unknown</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">类型，但是</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">unknown</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">类型的值只能赋给</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">unknown</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">本身和</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">any</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">类型。与</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">any</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">类型不同的是，</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">unknown</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">类型可以接受任意类型赋值，但是</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">unknown</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">类型赋值给其他类型前，必须被断言。</span></li><li id=\"uf37e8c03\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">null &amp; undefined</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">：默认情况下 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">null</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">和</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">undefined</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">是所有类型的子类型。就是说你可以把</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">null</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">和</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">undefined</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">赋值给</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">number</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">类型的变量。当你指定了</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">--strictNullChecks</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">标记，</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">null</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">和</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">undefined</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">只能赋值给</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">void</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">和它们自己</span></li><li id=\"uff19b9b6\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">void</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 16px\">：没有任何类型。</span></li></ul><p id=\"u64bc8213\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\"></span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"no2WV\" id=\"no2WV\"><span data-lake-id=\"ufde384ed\" id=\"ufde384ed\">const 和 readonly 的区别</span></h2><ol list=\"u9c4dec8b\"><li fid=\"u9e644f28\" data-lake-id=\"ua7eccbdf\" id=\"ua7eccbdf\"><code data-lake-id=\"u3091647e\" id=\"u3091647e\"><span data-lake-id=\"u641fe39a\" id=\"u641fe39a\">const</span></code><span data-lake-id=\"uf94dbe56\" id=\"uf94dbe56\"> 用于变量，</span><code data-lake-id=\"u5089eed1\" id=\"u5089eed1\"><span data-lake-id=\"u200717c5\" id=\"u200717c5\">readonly</span></code><span data-lake-id=\"u77685efc\" id=\"u77685efc\"> 用于属性</span></li><li fid=\"u9e644f28\" data-lake-id=\"u4c741e12\" id=\"u4c741e12\"><code data-lake-id=\"uddb218fe\" id=\"uddb218fe\"><span data-lake-id=\"u2f39aaf0\" id=\"u2f39aaf0\">const</span></code><span data-lake-id=\"ub7e8a207\" id=\"ub7e8a207\"> 在运行时检查，</span><code data-lake-id=\"u6e81151a\" id=\"u6e81151a\"><span data-lake-id=\"ucc765829\" id=\"ucc765829\">readonly</span></code><span data-lake-id=\"u4eb4484f\" id=\"u4eb4484f\"> 在编译时检查</span></li><li fid=\"u9e644f28\" data-lake-id=\"u21ffcb46\" id=\"u21ffcb46\"><span data-lake-id=\"u9a8af6d4\" id=\"u9a8af6d4\">使用 </span><code data-lake-id=\"uf475ec6b\" id=\"uf475ec6b\"><span data-lake-id=\"u3701a243\" id=\"u3701a243\">const</span></code><span data-lake-id=\"u3e54426e\" id=\"u3e54426e\"> 变量保存的数组，可以使用 </span><code data-lake-id=\"uada98439\" id=\"uada98439\"><span data-lake-id=\"u0ed20c9b\" id=\"u0ed20c9b\">push</span></code><span data-lake-id=\"ub0e4158f\" id=\"ub0e4158f\">、</span><code data-lake-id=\"u61b9d036\" id=\"u61b9d036\"><span data-lake-id=\"u212ede7b\" id=\"u212ede7b\">pop</span></code><span data-lake-id=\"u551f94d8\" id=\"u551f94d8\"> 等方法。但是如果使用 </span><code data-lake-id=\"ub29b5bd4\" id=\"ub29b5bd4\"><span data-lake-id=\"u2e78c9ba\" id=\"u2e78c9ba\">ReadonlyArray&lt;number&gt;</span></code><span data-lake-id=\"ua69b2268\" id=\"ua69b2268\"> 声明的数组不能使用 </span><code data-lake-id=\"u6d00dacd\" id=\"u6d00dacd\"><span data-lake-id=\"ued34b507\" id=\"ued34b507\">push</span></code><span data-lake-id=\"u16dd4e33\" id=\"u16dd4e33\">、</span><code data-lake-id=\"u4daf658f\" id=\"u4daf658f\"><span data-lake-id=\"u3525b94b\" id=\"u3525b94b\">pop</span></code><span data-lake-id=\"u4ff128e3\" id=\"u4ff128e3\"> 等方法</span></li></ol><h2 data-lake-id=\"d1ION\" id=\"d1ION\"><span data-lake-id=\"u23b6de6c\" id=\"u23b6de6c\">type 和 interface 的区别</span></h2><p data-lake-id=\"u48f11e4b\" id=\"u48f11e4b\"><br></p><ol list=\"uf4cf0d6d\"><li fid=\"u54faeafa\" data-lake-id=\"u584a0786\" id=\"u584a0786\"><span data-lake-id=\"u93b2c829\" id=\"u93b2c829\">类型别名 </span><code data-lake-id=\"ufaee0c4c\" id=\"ufaee0c4c\"><span data-lake-id=\"u8b363ef3\" id=\"u8b363ef3\">type</span></code><span data-lake-id=\"u2954ec7e\" id=\"u2954ec7e\"> 可以为任何类型引入名称。例如基本类型，联合类型等</span></li><li fid=\"u54faeafa\" data-lake-id=\"u7e751204\" id=\"u7e751204\"><span data-lake-id=\"u6f1e6fc8\" id=\"u6f1e6fc8\">类型别名 </span><code data-lake-id=\"ub6094da0\" id=\"ub6094da0\"><span data-lake-id=\"ud153e39c\" id=\"ud153e39c\">type</span></code><span data-lake-id=\"ud8a1bdc9\" id=\"ud8a1bdc9\"> 不支持继承</span></li><li fid=\"u54faeafa\" data-lake-id=\"uf76d7f26\" id=\"uf76d7f26\"><span data-lake-id=\"u1ffc68c1\" id=\"u1ffc68c1\">类型别名 </span><code data-lake-id=\"ud2162fb8\" id=\"ud2162fb8\"><span data-lake-id=\"u593c7e6d\" id=\"u593c7e6d\">type</span></code><span data-lake-id=\"u7a59a55c\" id=\"u7a59a55c\"> 不会创建一个真正的名字</span></li><li fid=\"u54faeafa\" data-lake-id=\"u09dbbc75\" id=\"u09dbbc75\"><span data-lake-id=\"u0b894068\" id=\"u0b894068\">类型别名 </span><code data-lake-id=\"ue6f02f43\" id=\"ue6f02f43\"><span data-lake-id=\"udd17b4bf\" id=\"udd17b4bf\">type</span></code><span data-lake-id=\"ud723358d\" id=\"ud723358d\"> 无法被实现(</span><code data-lake-id=\"u81e27acd\" id=\"u81e27acd\"><span data-lake-id=\"u6097ade9\" id=\"u6097ade9\">implements</span></code><span data-lake-id=\"ub750b1de\" id=\"ub750b1de\">)，而接口 </span><code data-lake-id=\"u129c0f28\" id=\"u129c0f28\"><span data-lake-id=\"uf0e0539a\" id=\"uf0e0539a\">interface</span></code><span data-lake-id=\"ufb7b0d17\" id=\"ufb7b0d17\"> 可以被派生类实现</span></li><li fid=\"u54faeafa\" data-lake-id=\"u4bd10463\" id=\"u4bd10463\"><span data-lake-id=\"u39f70ea2\" id=\"u39f70ea2\">类型别名 </span><code data-lake-id=\"u71a7f95b\" id=\"u71a7f95b\"><span data-lake-id=\"u11bbdd06\" id=\"u11bbdd06\">type</span></code><span data-lake-id=\"u6030b60e\" id=\"u6030b60e\"> 重名时编译器会抛出错误，接口 </span><code data-lake-id=\"ud1d2516f\" id=\"ud1d2516f\"><span data-lake-id=\"ud7b93eb3\" id=\"ud7b93eb3\">interface</span></code><span data-lake-id=\"uc54b3315\" id=\"uc54b3315\"> 重名时会产生合并</span></li><li fid=\"u54faeafa\" data-lake-id=\"u04c5716c\" id=\"u04c5716c\"><span data-lake-id=\"u3bba59f2\" id=\"u3bba59f2\">类型别名 </span><code data-lake-id=\"u14e5922f\" id=\"u14e5922f\"><span data-lake-id=\"ue601f96a\" id=\"ue601f96a\">type</span></code><span data-lake-id=\"uc994fbb4\" id=\"uc994fbb4\"> 无法在函数上挂载属性，接口 </span><code data-lake-id=\"u45e20ac0\" id=\"u45e20ac0\"><span data-lake-id=\"ufc170e12\" id=\"ufc170e12\">interface</span></code><span data-lake-id=\"u5afb4016\" id=\"u5afb4016\"> 可以</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22interface%20FuncWithAttachment%20%7B%5Cn%20%20(params%3A%20string)%3A%20boolean%5Cn%20%20someProperty%3A%20number%5Cn%7D%5Cnconst%20testFunc%3A%20FuncWithAttachment%20%3D%20%7B%7D%5Cnconst%20result%20%3D%20testFunc('mike')%20%2F%2F%20%E6%97%A0%E7%B1%BB%E5%9E%8B%E6%8F%90%E9%86%92%5CntestFunc.someProperty%20%3D%203%20%2F%2F%20%E6%9C%89%E7%B1%BB%E5%9E%8B%E6%8F%90%E9%86%92%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22One%20Dark%20Pro%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22pnmyz%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"eEY0e\" id=\"eEY0e\"><span data-lake-id=\"u2484e21f\" id=\"u2484e21f\">implements 和 extends 的区别</span></h2><ul list=\"u339ff958\"><li fid=\"ufc137d50\" data-lake-id=\"uef697ac9\" id=\"uef697ac9\"><code data-lake-id=\"u79a156c8\" id=\"u79a156c8\"><span data-lake-id=\"u49d85304\" id=\"u49d85304\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">extends</span></code><span data-lake-id=\"ue959db7a\" id=\"ue959db7a\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">, 子类会继承父类的所有属性和方法。</span></li><li fid=\"ufc137d50\" data-lake-id=\"u8b49abba\" id=\"u8b49abba\"><code data-lake-id=\"ucbfdaf49\" id=\"ucbfdaf49\"><span data-lake-id=\"ub207a500\" id=\"ub207a500\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">implements</span></code><span data-lake-id=\"u5dda8e77\" id=\"u5dda8e77\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">，使用 </span><code data-lake-id=\"u85d43d62\" id=\"u85d43d62\"><span data-lake-id=\"ua01ec086\" id=\"ua01ec086\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">implements</span></code><span data-lake-id=\"u3abe8007\" id=\"u3abe8007\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\"> 关键字的类将需要实现需要实现的类的所有属性和方法。</span></li></ul><h2 data-lake-id=\"Q4E2a\" id=\"Q4E2a\"><span data-lake-id=\"u81d85bc0\" id=\"u81d85bc0\" style=\"color: rgb(51, 51, 51)\">枚举 和 object 的区别</span></h2><ul list=\"ub572e4eb\"><li fid=\"ue2bc30c6\" data-lake-id=\"ua1811bab\" id=\"ua1811bab\"><span data-lake-id=\"uf592ba72\" id=\"uf592ba72\">枚举可以通过枚举的名称，获取枚举的值。也可以通过枚举的值获取枚举的名称。</span></li><li fid=\"ue2bc30c6\" data-lake-id=\"uf437fc90\" id=\"uf437fc90\"><code data-lake-id=\"u0abeb0f4\" id=\"u0abeb0f4\"><span data-lake-id=\"u1e19b5a7\" id=\"u1e19b5a7\">object</span></code><span data-lake-id=\"u1a139988\" id=\"u1a139988\"> 只能通过 </span><code data-lake-id=\"u5e0cb77d\" id=\"u5e0cb77d\"><span data-lake-id=\"ud7da1bd3\" id=\"ud7da1bd3\">key</span></code><span data-lake-id=\"uf51e5bbb\" id=\"uf51e5bbb\"> 获取 </span><code data-lake-id=\"u2574b2a7\" id=\"u2574b2a7\"><span data-lake-id=\"ue588b478\" id=\"ue588b478\">value</span></code></li><li fid=\"ue2bc30c6\" data-lake-id=\"u8fe04b6e\" id=\"u8fe04b6e\"><span data-lake-id=\"ubec36b5a\" id=\"ubec36b5a\">数字枚举在不指定初始值的情况下，枚举值会从 </span><code data-lake-id=\"uaf08c4ed\" id=\"uaf08c4ed\"><span data-lake-id=\"u9731374c\" id=\"u9731374c\">0</span></code><span data-lake-id=\"ubdb3fa2f\" id=\"ubdb3fa2f\"> 开始递增。</span></li><li fid=\"ue2bc30c6\" data-lake-id=\"ub87cb450\" id=\"ub87cb450\"><span data-lake-id=\"uc3af5ef2\" id=\"uc3af5ef2\">虽然在运行时，枚举是一个真实存在的对象。但是使用 </span><code data-lake-id=\"u2f79eb5c\" id=\"u2f79eb5c\"><span data-lake-id=\"u1c0be4a1\" id=\"u1c0be4a1\">keyof</span></code><span data-lake-id=\"ufc28f6a8\" id=\"ufc28f6a8\"> 时的行为却和普通对象不一致。必须使用 </span><code data-lake-id=\"u828f3a32\" id=\"u828f3a32\"><span data-lake-id=\"ud37e710e\" id=\"ud37e710e\">keyof typeof</span></code><span data-lake-id=\"u8e358e27\" id=\"u8e358e27\"> 才可以获取枚举所有属性名。</span></li></ul><h2 data-lake-id=\"dfnPF\" id=\"dfnPF\"><span data-lake-id=\"ub309fdcf\" id=\"ub309fdcf\">never 和 void 的区别</span></h2><ul list=\"u45b4bdb2\"><li fid=\"u427d423c\" data-lake-id=\"u7727e35f\" id=\"u7727e35f\"><code data-lake-id=\"u0acd5a05\" id=\"u0acd5a05\"><span data-lake-id=\"u694103cc\" id=\"u694103cc\">never</span></code><span data-lake-id=\"u29ba9eb8\" id=\"u29ba9eb8\">、</span><code data-lake-id=\"u4de8f901\" id=\"u4de8f901\"><span data-lake-id=\"u01e3bb7d\" id=\"u01e3bb7d\">never</span></code><span data-lake-id=\"u4232d40b\" id=\"u4232d40b\"> 表示永远不存在的类型。比如一个函数总是抛出错误，而没有返回值。或者一个函数内部有死循环，永远不会有返回值。函数的返回值就是 </span><code data-lake-id=\"u9fa3b28e\" id=\"u9fa3b28e\"><span data-lake-id=\"u088c25a2\" id=\"u088c25a2\">never</span></code><span data-lake-id=\"uaf7617ce\" id=\"uaf7617ce\"> 类型。</span></li><li fid=\"u427d423c\" data-lake-id=\"u3d40e934\" id=\"u3d40e934\"><code data-lake-id=\"u55643ad4\" id=\"u55643ad4\"><span data-lake-id=\"uc5d20f3f\" id=\"uc5d20f3f\">void</span></code><span data-lake-id=\"ud6ff82cf\" id=\"ud6ff82cf\">，没有显示的返回值的函数返回值为 </span><code data-lake-id=\"u07324ab5\" id=\"u07324ab5\"><span data-lake-id=\"u00bb6d63\" id=\"u00bb6d63\">void</span></code><span data-lake-id=\"u56ac4411\" id=\"u56ac4411\"> 类型。如果一个变量为 </span><code data-lake-id=\"u86d4f23e\" id=\"u86d4f23e\"><span data-lake-id=\"u00d50d46\" id=\"u00d50d46\">void</span></code><span data-lake-id=\"uf8d0a8f7\" id=\"uf8d0a8f7\"> 类型，只能赋予 </span><code data-lake-id=\"u415354b2\" id=\"u415354b2\"><span data-lake-id=\"uecdddd36\" id=\"uecdddd36\">undefined</span></code><span data-lake-id=\"u09e00e12\" id=\"u09e00e12\"> 或者 </span><code data-lake-id=\"u4a6b6ee0\" id=\"u4a6b6ee0\"><span data-lake-id=\"u17001535\" id=\"u17001535\">null</span></code><span data-lake-id=\"u78fd0484\" id=\"u78fd0484\">。</span></li></ul><h2 data-lake-id=\"Hl0D8\" id=\"Hl0D8\"><span data-lake-id=\"uc0e87a8d\" id=\"uc0e87a8d\">any、never、unknown、null&amp;undefined、void 的区别</span></h2><ul list=\"u6dea9b24\"><li fid=\"ud536cac2\" data-lake-id=\"u7742d35e\" id=\"u7742d35e\"><code data-lake-id=\"ue626cc18\" id=\"ue626cc18\"><span data-lake-id=\"u7235ee4d\" id=\"u7235ee4d\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">any</span></code><span data-lake-id=\"ub3eab6f4\" id=\"ub3eab6f4\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">：动态的变量类型(失去了类型检查的作用)</span></li><li fid=\"ud536cac2\" data-lake-id=\"ud03b8c54\" id=\"ud03b8c54\"><code data-lake-id=\"u440cb5e6\" id=\"u440cb5e6\"><span data-lake-id=\"ud9ea1d48\" id=\"ud9ea1d48\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">never</span></code><span data-lake-id=\"u73b9490a\" id=\"u73b9490a\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">：永不存在的值的类型。例如：</span><code data-lake-id=\"u42a176f9\" id=\"u42a176f9\"><span data-lake-id=\"ua6d166e9\" id=\"ua6d166e9\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">never</span></code><span data-lake-id=\"u3c366d0b\" id=\"u3c366d0b\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</span></li><li fid=\"ud536cac2\" data-lake-id=\"u1f3af0e1\" id=\"u1f3af0e1\"><code data-lake-id=\"u4934d58f\" id=\"u4934d58f\"><span data-lake-id=\"uf913e9b0\" id=\"uf913e9b0\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">unknown</span></code><span data-lake-id=\"uf63d4e0a\" id=\"uf63d4e0a\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">：任何类型的值都可以赋给 </span><code data-lake-id=\"u86ebc082\" id=\"u86ebc082\"><span data-lake-id=\"u803f635b\" id=\"u803f635b\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">unknown</span></code><span data-lake-id=\"u461571fc\" id=\"u461571fc\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">类型，但是</span><code data-lake-id=\"ub683647b\" id=\"ub683647b\"><span data-lake-id=\"u4d9f046f\" id=\"u4d9f046f\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">unknown</span></code><span data-lake-id=\"ud709db7b\" id=\"ud709db7b\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">类型的值只能赋给</span><code data-lake-id=\"udcd60210\" id=\"udcd60210\"><span data-lake-id=\"ua178c385\" id=\"ua178c385\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">unknown</span></code><span data-lake-id=\"u30a5ebd6\" id=\"u30a5ebd6\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">本身和</span><code data-lake-id=\"u55143c84\" id=\"u55143c84\"><span data-lake-id=\"ub2773006\" id=\"ub2773006\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">any</span></code><span data-lake-id=\"u78971e79\" id=\"u78971e79\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">类型。与</span><code data-lake-id=\"ucb44bb63\" id=\"ucb44bb63\"><span data-lake-id=\"uf9767826\" id=\"uf9767826\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">any</span></code><span data-lake-id=\"u8e14e6d7\" id=\"u8e14e6d7\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">类型不同的是，</span><code data-lake-id=\"ubf68ee1d\" id=\"ubf68ee1d\"><span data-lake-id=\"ue454b6d6\" id=\"ue454b6d6\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">unknown</span></code><span data-lake-id=\"uf608015b\" id=\"uf608015b\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">类型可以接受任意类型赋值，但是</span><code data-lake-id=\"u57f6839e\" id=\"u57f6839e\"><span data-lake-id=\"u52ff12e1\" id=\"u52ff12e1\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">unknown</span></code><span data-lake-id=\"uad401885\" id=\"uad401885\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">类型赋值给其他类型前，必须被断言。</span></li><li fid=\"ud536cac2\" data-lake-id=\"uf37e8c03\" id=\"uf37e8c03\"><code data-lake-id=\"ue0911e0d\" id=\"ue0911e0d\"><span data-lake-id=\"u2d939479\" id=\"u2d939479\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">null &amp; undefined</span></code><span data-lake-id=\"u98ec4b5f\" id=\"u98ec4b5f\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">：默认情况下 </span><code data-lake-id=\"u78a9a1ca\" id=\"u78a9a1ca\"><span data-lake-id=\"uad267002\" id=\"uad267002\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">null</span></code><span data-lake-id=\"u09c3a001\" id=\"u09c3a001\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">和</span><code data-lake-id=\"udf4d47e7\" id=\"udf4d47e7\"><span data-lake-id=\"u8f425f1d\" id=\"u8f425f1d\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">undefined</span></code><span data-lake-id=\"ue717ab54\" id=\"ue717ab54\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">是所有类型的子类型。就是说你可以把</span><code data-lake-id=\"u941f3fce\" id=\"u941f3fce\"><span data-lake-id=\"u51cc6b0a\" id=\"u51cc6b0a\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">null</span></code><span data-lake-id=\"u70da9eb6\" id=\"u70da9eb6\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">和</span><code data-lake-id=\"u33bec169\" id=\"u33bec169\"><span data-lake-id=\"u2379841c\" id=\"u2379841c\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">undefined</span></code><span data-lake-id=\"u5e14253f\" id=\"u5e14253f\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">赋值给</span><code data-lake-id=\"u632b4432\" id=\"u632b4432\"><span data-lake-id=\"u402e13a7\" id=\"u402e13a7\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">number</span></code><span data-lake-id=\"ue1c36673\" id=\"ue1c36673\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">类型的变量。当你指定了</span><code data-lake-id=\"u251b5327\" id=\"u251b5327\"><span data-lake-id=\"u9f2d7a85\" id=\"u9f2d7a85\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">--strictNullChecks</span></code><span data-lake-id=\"u7a1a73c7\" id=\"u7a1a73c7\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">标记，</span><code data-lake-id=\"uffc0265a\" id=\"uffc0265a\"><span data-lake-id=\"u203cff24\" id=\"u203cff24\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">null</span></code><span data-lake-id=\"ue57a0491\" id=\"ue57a0491\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">和</span><code data-lake-id=\"ubc8b7008\" id=\"ubc8b7008\"><span data-lake-id=\"u9f42fb07\" id=\"u9f42fb07\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">undefined</span></code><span data-lake-id=\"uabfe2306\" id=\"uabfe2306\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">只能赋值给</span><code data-lake-id=\"ucf3674c0\" id=\"ucf3674c0\"><span data-lake-id=\"udfe17787\" id=\"udfe17787\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">void</span></code><span data-lake-id=\"u6b052db5\" id=\"u6b052db5\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">和它们自己</span></li><li fid=\"ud536cac2\" data-lake-id=\"uff19b9b6\" id=\"uff19b9b6\"><code data-lake-id=\"u7e846666\" id=\"u7e846666\"><span data-lake-id=\"uc267f32a\" id=\"uc267f32a\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">void</span></code><span data-lake-id=\"u07394386\" id=\"u07394386\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">：没有任何类型。</span></li></ul><p data-lake-id=\"u64bc8213\" id=\"u64bc8213\"><span data-lake-id=\"u97c1d660\" id=\"u97c1d660\" class=\"lake-fontsize-12\">​</span><br></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-06-11T14:53:24.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:34:09.000Z",
  "updated_at": "2022-06-11T14:53:24.000Z",
  "published_at": "2022-06-11T14:53:24.000Z",
  "first_published_at": "2022-04-04T11:34:08.573Z",
  "word_count": 797,
  "cover": null,
  "description": "const 和 readonly 的区别const 用于变量，readonly 用于属性const 在运行时检查，readonly 在编译时检查使用 const 变量保存的数组，可以使用 push、pop 等方法。但是如果使用 ReadonlyArray<number> 声明的数组不能使用 p...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}