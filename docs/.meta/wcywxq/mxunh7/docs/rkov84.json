{
  "id": 72212123,
  "slug": "rkov84",
  "title": "vue2 性能优化",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"dmLRM\"></a>\n## 编码阶段\n1. 尽量减少 data 中的数据 `=>` data 中的数据都会增加 getter 和 setter，会收集对应的 watcher\n2. 对象的层级不要过深 `=>` 嵌套过深会造成性能问题\n3. 不需要响应式的数据不应该放到 data 中 `=>` 可以使用 Object.freeze 冻结\n4. v-if/v-show, computed/watch 区分使用场景\n5. v-for 避免同时使用 v-if，其中 key 应该为唯一\n6. v-for 中若给每项元素绑定事件，最好使用事件代理\n7. 对大数据列表和表格做性能优化(如：虚拟列表/虚拟表格) `=>` 动态加载可视区域\n8. 避免内存泄漏，应该在组件销毁后销毁全局事件\n9. 图片懒加载\n10. 异步加载路由\n11. 适当食用 keep-alive 缓存组件\n12. 第三方模块按需引入\n13. 高频场景使用防抖和节流\n<a name=\"AZyxE\"></a>\n## SEO 搜索引擎优化\n\n- 服务端 SSR / 服务端预渲染\n\n服务端渲染优先渲染出某一部分重要的内容，让其他内容懒加载，这样在到达浏览器客户端时一部分的 html 已经存在，页面上就会呈现出一定的内容。其中服务端渲染出的 html 最好不要超过 14kb，主要是因为 tcp 慢开始的规则让第一个 tcp 包的大小是 14kb，这是与网站交互会接收到的第一个包\n\n<a name=\"ADDdQ\"></a>\n## 用户体验\n\n- 骨架屏\n- PWA\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"dmLRM\"><span>编码阶段</span></h2><ol><li><span>尽量减少 data 中的数据 </span><code><span>=&gt;</span></code><span> data 中的数据都会增加 getter 和 setter，会收集对应的 watcher</span></li><li><span>对象的层级不要过深 </span><code><span>=&gt;</span></code><span> 嵌套过深会造成性能问题</span></li><li><span>不需要响应式的数据不应该放到 data 中 </span><code><span>=&gt;</span></code><span> 可以使用 Object.freeze 冻结</span></li><li><span>v-if/v-show, computed/watch 区分使用场景</span></li><li><span>v-for 避免同时使用 v-if，其中 key 应该为唯一</span></li><li><span>v-for 中若给每项元素绑定事件，最好使用事件代理</span></li><li><span>对大数据列表和表格做性能优化(如：虚拟列表/虚拟表格) </span><code><span>=&gt;</span></code><span> 动态加载可视区域</span></li><li><span>避免内存泄漏，应该在组件销毁后销毁全局事件</span></li><li><span>图片懒加载</span></li><li><span>异步加载路由</span></li><li><span>适当食用 keep-alive 缓存组件</span></li><li><span>第三方模块按需引入</span></li><li><span>高频场景使用防抖和节流</span></li></ol><h2 id=\"AZyxE\"><span>SEO 搜索引擎优化</span></h2><ul><li><span>服务端 SSR / 服务端预渲染</span></li></ul><p data-lake-id=\"u7f39c0fd\"><span>服务端渲染优先渲染出某一部分重要的内容，让其他内容懒加载，这样在到达浏览器客户端时一部分的 html 已经存在，页面上就会呈现出一定的内容。其中服务端渲染出的 html 最好不要超过 14kb，主要是因为 tcp 慢开始的规则让第一个 tcp 包的大小是 14kb，这是与网站交互会接收到的第一个包</span></p><p data-lake-id=\"ucc2fa0a7\"><span>​</span><br /></p><h2 id=\"ADDdQ\"><span>用户体验</span></h2><ul><li><span>骨架屏</span></li><li><span>PWA</span></li></ul>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"dmLRM\" id=\"dmLRM\"><span data-lake-id=\"u115f76e6\" id=\"u115f76e6\">编码阶段</span></h2><ol list=\"u8db4ca5e\"><li fid=\"u6b40a96c\" data-lake-id=\"ud1041db5\" id=\"ud1041db5\"><span data-lake-id=\"u01b0f2d7\" id=\"u01b0f2d7\">尽量减少 data 中的数据 </span><code data-lake-id=\"ufe89fe49\" id=\"ufe89fe49\"><span data-lake-id=\"u268ec875\" id=\"u268ec875\">=&gt;</span></code><span data-lake-id=\"ue100db1f\" id=\"ue100db1f\"> data 中的数据都会增加 getter 和 setter，会收集对应的 watcher</span></li><li fid=\"u6b40a96c\" data-lake-id=\"uf707e1f1\" id=\"uf707e1f1\"><span data-lake-id=\"u4000c73c\" id=\"u4000c73c\">对象的层级不要过深 </span><code data-lake-id=\"u8212a049\" id=\"u8212a049\"><span data-lake-id=\"u6feb7a2a\" id=\"u6feb7a2a\">=&gt;</span></code><span data-lake-id=\"u9bedc669\" id=\"u9bedc669\"> 嵌套过深会造成性能问题</span></li><li fid=\"u6b40a96c\" data-lake-id=\"u11170462\" id=\"u11170462\"><span data-lake-id=\"u5bffec46\" id=\"u5bffec46\">不需要响应式的数据不应该放到 data 中 </span><code data-lake-id=\"u479779f0\" id=\"u479779f0\"><span data-lake-id=\"u94789a23\" id=\"u94789a23\">=&gt;</span></code><span data-lake-id=\"uea1f3ae9\" id=\"uea1f3ae9\"> 可以使用 Object.freeze 冻结</span></li><li fid=\"u6b40a96c\" data-lake-id=\"ua3936f0c\" id=\"ua3936f0c\"><span data-lake-id=\"uf5bdfab2\" id=\"uf5bdfab2\">v-if/v-show, computed/watch 区分使用场景</span></li><li fid=\"u6b40a96c\" data-lake-id=\"ua91ee5f4\" id=\"ua91ee5f4\"><span data-lake-id=\"u1b002ff2\" id=\"u1b002ff2\">v-for 避免同时使用 v-if，其中 key 应该为唯一</span></li><li fid=\"u6b40a96c\" data-lake-id=\"ub4beb746\" id=\"ub4beb746\"><span data-lake-id=\"u40d479e5\" id=\"u40d479e5\">v-for 中若给每项元素绑定事件，最好使用事件代理</span></li><li fid=\"u6b40a96c\" data-lake-id=\"u65bb9e82\" id=\"u65bb9e82\"><span data-lake-id=\"u08b5e960\" id=\"u08b5e960\">对大数据列表和表格做性能优化(如：虚拟列表/虚拟表格) </span><code data-lake-id=\"u25cf5d51\" id=\"u25cf5d51\"><span data-lake-id=\"uebcedf90\" id=\"uebcedf90\">=&gt;</span></code><span data-lake-id=\"ud24d5c17\" id=\"ud24d5c17\"> 动态加载可视区域</span></li><li fid=\"u6b40a96c\" data-lake-id=\"ue966809d\" id=\"ue966809d\"><span data-lake-id=\"u2bfae048\" id=\"u2bfae048\">避免内存泄漏，应该在组件销毁后销毁全局事件</span></li><li fid=\"u6b40a96c\" data-lake-id=\"u89f514d4\" id=\"u89f514d4\"><span data-lake-id=\"u84df907c\" id=\"u84df907c\">图片懒加载</span></li><li fid=\"u6b40a96c\" data-lake-id=\"u183fd992\" id=\"u183fd992\"><span data-lake-id=\"u5c062117\" id=\"u5c062117\">异步加载路由</span></li><li fid=\"u6b40a96c\" data-lake-id=\"u4933b6a8\" id=\"u4933b6a8\"><span data-lake-id=\"u96e25485\" id=\"u96e25485\">适当食用 keep-alive 缓存组件</span></li><li fid=\"u6b40a96c\" data-lake-id=\"u2c3e0c0a\" id=\"u2c3e0c0a\"><span data-lake-id=\"u80970687\" id=\"u80970687\">第三方模块按需引入</span></li><li fid=\"u6b40a96c\" data-lake-id=\"u561e2d76\" id=\"u561e2d76\"><span data-lake-id=\"u094f65b3\" id=\"u094f65b3\">高频场景使用防抖和节流</span></li></ol><h2 data-lake-id=\"AZyxE\" id=\"AZyxE\"><span data-lake-id=\"u69bb1f88\" id=\"u69bb1f88\">SEO 搜索引擎优化</span></h2><ul list=\"u8106efb7\"><li fid=\"ud98fea3b\" data-lake-id=\"uf1671c10\" id=\"uf1671c10\"><span data-lake-id=\"uee4edc8d\" id=\"uee4edc8d\">服务端 SSR / 服务端预渲染</span></li></ul><p data-lake-id=\"u7f39c0fd\" id=\"u7f39c0fd\"><span data-lake-id=\"u682432d4\" id=\"u682432d4\">服务端渲染优先渲染出某一部分重要的内容，让其他内容懒加载，这样在到达浏览器客户端时一部分的 html 已经存在，页面上就会呈现出一定的内容。其中服务端渲染出的 html 最好不要超过 14kb，主要是因为 tcp 慢开始的规则让第一个 tcp 包的大小是 14kb，这是与网站交互会接收到的第一个包</span></p><p data-lake-id=\"ucc2fa0a7\" id=\"ucc2fa0a7\"><span data-lake-id=\"uca9bcc97\" id=\"uca9bcc97\">​</span><br></p><h2 data-lake-id=\"ADDdQ\" id=\"ADDdQ\"><span data-lake-id=\"uc6a80b43\" id=\"uc6a80b43\">用户体验</span></h2><ul list=\"u2f8beabd\"><li fid=\"ua9ddaeac\" data-lake-id=\"u0d344133\" id=\"u0d344133\"><span data-lake-id=\"u0e730afe\" id=\"u0e730afe\">骨架屏</span></li><li fid=\"ua9ddaeac\" data-lake-id=\"ua8bb4886\" id=\"ua8bb4886\"><span data-lake-id=\"ufe428e31\" id=\"ufe428e31\">PWA</span></li></ul>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:08.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:08.000Z",
  "updated_at": "2022-05-10T15:12:39.000Z",
  "published_at": "2022-04-04T11:33:08.000Z",
  "first_published_at": "2022-04-04T11:33:08.269Z",
  "word_count": 371,
  "cover": null,
  "description": "编码阶段尽量减少 data 中的数据 => data 中的数据都会增加 getter 和 setter，会收集对应的 watcher对象的层级不要过深 => 嵌套过深会造成性能问题不需要响应式的数据不应该放到 data 中 => 可以使用 Object.freeze 冻结v-if/v-show...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}