{
  "id": 72212222,
  "slug": "nm61qs",
  "title": "vue 和 react 的对比",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "相似之处：\n\n- 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库\n- 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。\n- 都使用了 `Virtual DOM`（虚拟 `DOM`）提高重绘性能\n- 都有 `props` 的概念，允许组件间的数据传递\n- 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性\n\n不同之处：\n\n- 数据流\n\n`Vue` 默认支持数据双向绑定，而 `React` 一直提倡单向数据流\n\n- 虚拟DOM\n\n`Vue2.x` 开始引入`\"Virtual DOM\"`，消除了和 `React` 在这方面的差异，但是在具体的细节还是有各自的特点。\n\n   - `Vue` 宣称可以更快地计算出 `Virtual DOM` 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n   - 对于 `React` 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 `PureComponent`/`shouldComponentUpdate` 这个生命周期方法来进行控制，但 `Vue` 将此视为默认的优化。\n- 组件化\n\n`React` 与 `Vue` 最大的不同是模板的编写。\n\n   - `Vue` 鼓励写近似常规 `HTML` 的模板。写起来很接近标准 `HTML`元素，只是多了一些属性。\n   - `React` 推荐你所有的模板通用 `JavaScript` 的语法扩展——`JSX` 书写。\n\n具体来讲：`React` 中 `render` 函数是支持闭包特性的，所以我们 `import` 的组件在 `render` 中可以直接调用。但是在 `Vue` 中，由于模板中使用的数据都必须挂在 `this` 上进行一次中转，所以 `import` 完组件之后，还需要在 `components` 中再声明下。\n\n- 监听数据变化的实现原理不同\n   - `Vue` 通过 `getter`/`setter` 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\n   - `React` 默认是**通过比较引用**的方式进行的，如果不优化（`PureComponent`/`shouldComponentUpdate`）可能导致大量不必要的 `vDOM` 的重新渲染。这是因为 `Vue` 使用的是**可变数据**，而 `React` 更**强调数据的不可变**\n- 高阶组件\n\n`react` 可以通过高阶组件（`Higher Order Components-- HOC`）来扩展，而 `vue` 需要通过 `mixins` 来扩展。<br />原因高阶组件就是高阶函数，而 `React` 的组件本身就是纯粹的函数，所以高阶函数对 `React` 来说易如反掌。相反 `Vue.js` 使用 `HTML` 模板创建视图组件，这时模板无法有效的编译，因此 `Vue` 不采用 `HOC` 来实现。\n\n- 构建工具\n\n两者都有自己的构建工具\n\n   - `React ==> Create React APP`\n   - `Vue ==> vue-cli`\n- 跨平台\n   - `React ==> React Native`\n   - `Vue ==> Weex`\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u614c0807\" class=\"ne-p\"><span class=\"ne-text\">相似之处：</span></p><ul class=\"ne-ul\"><li id=\"uabfe47bf\"><span class=\"ne-text\">都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</span></li><li id=\"u61dbc6dc\"><span class=\"ne-text\">都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。</span></li><li id=\"u6d32a624\"><span class=\"ne-text\">都使用了 </span><code class=\"ne-code\"><span class=\"ne-text\">Virtual DOM</span></code><span class=\"ne-text\">（虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\">）提高重绘性能</span></li><li id=\"u7e09bd6e\"><span class=\"ne-text\">都有 </span><code class=\"ne-code\"><span class=\"ne-text\">props</span></code><span class=\"ne-text\"> 的概念，允许组件间的数据传递</span></li><li id=\"ub6fa01e9\"><span class=\"ne-text\">都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性</span></li></ul><p id=\"u5a6680e5\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ub07cde89\" class=\"ne-p\"><span class=\"ne-text\">不同之处：</span></p><ul class=\"ne-ul\"><li id=\"uae756e19\"><span class=\"ne-text\">数据流</span></li></ul><p id=\"uf7f07998\" class=\"ne-p\" style=\"text-indent: 2em\"><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 默认支持数据双向绑定，而 </span><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 一直提倡单向数据流</span></p><ul class=\"ne-ul\"><li id=\"ue1302c43\"><span class=\"ne-text\">虚拟DOM</span></li></ul><p id=\"u257e87bf\" class=\"ne-p\" style=\"margin-left: 2em\"><code class=\"ne-code\"><span class=\"ne-text\">Vue2.x</span></code><span class=\"ne-text\"> 开始引入</span><code class=\"ne-code\"><span class=\"ne-text\">&quot;Virtual DOM&quot;</span></code><span class=\"ne-text\">，消除了和 </span><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 在这方面的差异，但是在具体的细节还是有各自的特点。</span></p><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u0907ee2f\"><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 宣称可以更快地计算出 </span><code class=\"ne-code\"><span class=\"ne-text\">Virtual DOM</span></code><span class=\"ne-text\"> 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</span></li><li id=\"u170e2008\"><span class=\"ne-text\">对于 </span><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 </span><code class=\"ne-code\"><span class=\"ne-text\">PureComponent</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">shouldComponentUpdate</span></code><span class=\"ne-text\"> 这个生命周期方法来进行控制，但 </span><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 将此视为默认的优化。</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"uc4219596\"><span class=\"ne-text\">组件化</span></li></ul><p id=\"u9488f34a\" class=\"ne-p\" style=\"margin-left: 2em\"><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 与 </span><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 最大的不同是模板的编写。</span></p><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ubcf0e90a\"><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 鼓励写近似常规 </span><code class=\"ne-code\"><span class=\"ne-text\">HTML</span></code><span class=\"ne-text\"> 的模板。写起来很接近标准 </span><code class=\"ne-code\"><span class=\"ne-text\">HTML</span></code><span class=\"ne-text\">元素，只是多了一些属性。</span></li><li id=\"u2c6da8ea\"><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 推荐你所有的模板通用 </span><code class=\"ne-code\"><span class=\"ne-text\">JavaScript</span></code><span class=\"ne-text\"> 的语法扩展——</span><code class=\"ne-code\"><span class=\"ne-text\">JSX</span></code><span class=\"ne-text\"> 书写。</span></li></ul></ul><p id=\"ue81e0e42\" class=\"ne-p\" style=\"margin-left: 2em\"><span class=\"ne-text\">具体来讲：</span><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 中 </span><code class=\"ne-code\"><span class=\"ne-text\">render</span></code><span class=\"ne-text\"> 函数是支持闭包特性的，所以我们 </span><code class=\"ne-code\"><span class=\"ne-text\">import</span></code><span class=\"ne-text\"> 的组件在 </span><code class=\"ne-code\"><span class=\"ne-text\">render</span></code><span class=\"ne-text\"> 中可以直接调用。但是在 </span><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 中，由于模板中使用的数据都必须挂在 </span><code class=\"ne-code\"><span class=\"ne-text\">this</span></code><span class=\"ne-text\"> 上进行一次中转，所以 </span><code class=\"ne-code\"><span class=\"ne-text\">import</span></code><span class=\"ne-text\"> 完组件之后，还需要在 </span><code class=\"ne-code\"><span class=\"ne-text\">components</span></code><span class=\"ne-text\"> 中再声明下。</span></p><ul class=\"ne-ul\"><li id=\"u817ed42c\"><span class=\"ne-text\">监听数据变化的实现原理不同</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uf1865ec9\"><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 通过 </span><code class=\"ne-code\"><span class=\"ne-text\">getter</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">setter</span></code><span class=\"ne-text\"> 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</span></li><li id=\"u68fd2914\"><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 默认是</span><strong><span class=\"ne-text\">通过比较引用</span></strong><span class=\"ne-text\">的方式进行的，如果不优化（</span><code class=\"ne-code\"><span class=\"ne-text\">PureComponent</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">shouldComponentUpdate</span></code><span class=\"ne-text\">）可能导致大量不必要的 </span><code class=\"ne-code\"><span class=\"ne-text\">vDOM</span></code><span class=\"ne-text\"> 的重新渲染。这是因为 </span><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 使用的是</span><strong><span class=\"ne-text\">可变数据</span></strong><span class=\"ne-text\">，而 </span><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 更</span><strong><span class=\"ne-text\">强调数据的不可变</span></strong></li></ul></ul><ul class=\"ne-ul\"><li id=\"u5297a2b0\"><span class=\"ne-text\">高阶组件</span></li></ul><p id=\"u09e7b0b5\" class=\"ne-p\" style=\"margin-left: 2em\"><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 可以通过高阶组件（</span><code class=\"ne-code\"><span class=\"ne-text\">Higher Order Components-- HOC</span></code><span class=\"ne-text\">）来扩展，而 </span><code class=\"ne-code\"><span class=\"ne-text\">vue</span></code><span class=\"ne-text\"> 需要通过 </span><code class=\"ne-code\"><span class=\"ne-text\">mixins</span></code><span class=\"ne-text\"> 来扩展。</span></p><p id=\"u3e91f198\" class=\"ne-p\" style=\"margin-left: 2em\"><span class=\"ne-text\">原因高阶组件就是高阶函数，而 </span><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 的组件本身就是纯粹的函数，所以高阶函数对 </span><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 来说易如反掌。相反 </span><code class=\"ne-code\"><span class=\"ne-text\">Vue.js</span></code><span class=\"ne-text\"> 使用 </span><code class=\"ne-code\"><span class=\"ne-text\">HTML</span></code><span class=\"ne-text\"> 模板创建视图组件，这时模板无法有效的编译，因此 </span><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 不采用 </span><code class=\"ne-code\"><span class=\"ne-text\">HOC</span></code><span class=\"ne-text\"> 来实现。</span></p><ul class=\"ne-ul\"><li id=\"u04f1df3e\"><span class=\"ne-text\">构建工具</span></li></ul><p id=\"ub496b06e\" class=\"ne-p\" style=\"margin-left: 2em\"><span class=\"ne-text\">两者都有自己的构建工具</span></p><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uf1993c72\"><code class=\"ne-code\"><span class=\"ne-text\">React ==&gt; Create React APP</span></code></li><li id=\"ubef594c3\"><code class=\"ne-code\"><span class=\"ne-text\">Vue ==&gt; vue-cli</span></code></li></ul></ul><ul class=\"ne-ul\"><li id=\"ue2266ed3\"><span class=\"ne-text\">跨平台</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u8637fba6\"><code class=\"ne-code\"><span class=\"ne-text\">React ==&gt; React Native</span></code></li><li id=\"udf411fa6\"><code class=\"ne-code\"><span class=\"ne-text\">Vue ==&gt; Weex</span></code></li></ul></ul></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u614c0807\" id=\"u614c0807\"><span data-lake-id=\"u2dfb6ba0\" id=\"u2dfb6ba0\">相似之处：</span></p><ul list=\"uc077b42e\"><li fid=\"u2a2739db\" data-lake-id=\"uabfe47bf\" id=\"uabfe47bf\"><span data-lake-id=\"ua8fb9bb9\" id=\"ua8fb9bb9\">都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</span></li><li fid=\"u2a2739db\" data-lake-id=\"u61dbc6dc\" id=\"u61dbc6dc\"><span data-lake-id=\"u9523eab3\" id=\"u9523eab3\">都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。</span></li><li fid=\"u2a2739db\" data-lake-id=\"u6d32a624\" id=\"u6d32a624\"><span data-lake-id=\"ue168d472\" id=\"ue168d472\">都使用了 </span><code data-lake-id=\"ucb41dac4\" id=\"ucb41dac4\"><span data-lake-id=\"uab1440c3\" id=\"uab1440c3\">Virtual DOM</span></code><span data-lake-id=\"u6e3bbded\" id=\"u6e3bbded\">（虚拟 </span><code data-lake-id=\"uc2891926\" id=\"uc2891926\"><span data-lake-id=\"u28fee6c9\" id=\"u28fee6c9\">DOM</span></code><span data-lake-id=\"uf20ccd9b\" id=\"uf20ccd9b\">）提高重绘性能</span></li><li fid=\"u2a2739db\" data-lake-id=\"u7e09bd6e\" id=\"u7e09bd6e\"><span data-lake-id=\"ue664fb1d\" id=\"ue664fb1d\">都有 </span><code data-lake-id=\"ub0799f5d\" id=\"ub0799f5d\"><span data-lake-id=\"u4342abdf\" id=\"u4342abdf\">props</span></code><span data-lake-id=\"u3990bd4e\" id=\"u3990bd4e\"> 的概念，允许组件间的数据传递</span></li><li fid=\"u2a2739db\" data-lake-id=\"ub6fa01e9\" id=\"ub6fa01e9\"><span data-lake-id=\"u204aba6c\" id=\"u204aba6c\">都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性</span></li></ul><p data-lake-id=\"u5a6680e5\" id=\"u5a6680e5\"><span data-lake-id=\"u633fa184\" id=\"u633fa184\">​</span><br></p><p data-lake-id=\"ub07cde89\" id=\"ub07cde89\"><span data-lake-id=\"uea90f382\" id=\"uea90f382\">不同之处：</span></p><ul list=\"u1b3fcec2\"><li fid=\"u28b4e883\" data-lake-id=\"uae756e19\" id=\"uae756e19\"><span data-lake-id=\"u05d044c3\" id=\"u05d044c3\">数据流</span></li></ul><p data-lake-id=\"uf7f07998\" id=\"uf7f07998\" style=\"text-indent: 2em\"><code data-lake-id=\"u594846bb\" id=\"u594846bb\"><span data-lake-id=\"u8de8daa5\" id=\"u8de8daa5\">Vue</span></code><span data-lake-id=\"ue6fb2b78\" id=\"ue6fb2b78\"> 默认支持数据双向绑定，而 </span><code data-lake-id=\"ud2602a9b\" id=\"ud2602a9b\"><span data-lake-id=\"uca942a25\" id=\"uca942a25\">React</span></code><span data-lake-id=\"u8c43bd1f\" id=\"u8c43bd1f\"> 一直提倡单向数据流</span></p><ul list=\"ua55741df\"><li fid=\"u8b8d0af1\" data-lake-id=\"ue1302c43\" id=\"ue1302c43\"><span data-lake-id=\"u4437339d\" id=\"u4437339d\">虚拟DOM</span></li></ul><p data-lake-id=\"u257e87bf\" id=\"u257e87bf\" style=\"padding-left: 2em\"><code data-lake-id=\"u5cbac178\" id=\"u5cbac178\"><span data-lake-id=\"u1e22f6bb\" id=\"u1e22f6bb\">Vue2.x</span></code><span data-lake-id=\"u734373e3\" id=\"u734373e3\"> 开始引入</span><code data-lake-id=\"u01458514\" id=\"u01458514\"><span data-lake-id=\"u920668af\" id=\"u920668af\">&quot;Virtual DOM&quot;</span></code><span data-lake-id=\"ud0b604d8\" id=\"ud0b604d8\">，消除了和 </span><code data-lake-id=\"udc3380cd\" id=\"udc3380cd\"><span data-lake-id=\"u5c5eef6f\" id=\"u5c5eef6f\">React</span></code><span data-lake-id=\"u41cb2fa3\" id=\"u41cb2fa3\"> 在这方面的差异，但是在具体的细节还是有各自的特点。</span></p><ul list=\"uc0581374\" data-lake-indent=\"1\"><li fid=\"u785a9a80\" data-lake-id=\"u0907ee2f\" id=\"u0907ee2f\"><code data-lake-id=\"ubb860f7c\" id=\"ubb860f7c\"><span data-lake-id=\"u039aceeb\" id=\"u039aceeb\">Vue</span></code><span data-lake-id=\"u00a51c9e\" id=\"u00a51c9e\"> 宣称可以更快地计算出 </span><code data-lake-id=\"ufbb489b4\" id=\"ufbb489b4\"><span data-lake-id=\"ucb07788a\" id=\"ucb07788a\">Virtual DOM</span></code><span data-lake-id=\"uf7f27254\" id=\"uf7f27254\"> 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</span></li><li fid=\"u785a9a80\" data-lake-id=\"u170e2008\" id=\"u170e2008\"><span data-lake-id=\"u614cfe41\" id=\"u614cfe41\">对于 </span><code data-lake-id=\"ub2f2c96b\" id=\"ub2f2c96b\"><span data-lake-id=\"u19541162\" id=\"u19541162\">React</span></code><span data-lake-id=\"ucea6b77f\" id=\"ucea6b77f\"> 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 </span><code data-lake-id=\"u5fcf33e2\" id=\"u5fcf33e2\"><span data-lake-id=\"u53c170f5\" id=\"u53c170f5\">PureComponent</span></code><span data-lake-id=\"u316cca8d\" id=\"u316cca8d\">/</span><code data-lake-id=\"u0dfff469\" id=\"u0dfff469\"><span data-lake-id=\"uf8b30043\" id=\"uf8b30043\">shouldComponentUpdate</span></code><span data-lake-id=\"u04cb279e\" id=\"u04cb279e\"> 这个生命周期方法来进行控制，但 </span><code data-lake-id=\"u22808498\" id=\"u22808498\"><span data-lake-id=\"u1082389c\" id=\"u1082389c\">Vue</span></code><span data-lake-id=\"u95f742d2\" id=\"u95f742d2\"> 将此视为默认的优化。</span></li></ul><ul list=\"uc0581374\"><li fid=\"u8728bd2f\" data-lake-id=\"uc4219596\" id=\"uc4219596\"><span data-lake-id=\"u7e99bb92\" id=\"u7e99bb92\">组件化</span></li></ul><p data-lake-id=\"u9488f34a\" id=\"u9488f34a\" style=\"padding-left: 2em\"><code data-lake-id=\"uadc17a00\" id=\"uadc17a00\"><span data-lake-id=\"u085cf268\" id=\"u085cf268\">React</span></code><span data-lake-id=\"u88898503\" id=\"u88898503\"> 与 </span><code data-lake-id=\"u7e608952\" id=\"u7e608952\"><span data-lake-id=\"u304c87e7\" id=\"u304c87e7\">Vue</span></code><span data-lake-id=\"u89ed45f2\" id=\"u89ed45f2\"> 最大的不同是模板的编写。</span></p><ul list=\"uecf39a56\" data-lake-indent=\"1\"><li fid=\"uf6c8cc58\" data-lake-id=\"ubcf0e90a\" id=\"ubcf0e90a\"><code data-lake-id=\"ue19ca764\" id=\"ue19ca764\"><span data-lake-id=\"ue19d2eaf\" id=\"ue19d2eaf\">Vue</span></code><span data-lake-id=\"u32b7b31d\" id=\"u32b7b31d\"> 鼓励写近似常规 </span><code data-lake-id=\"u51c71448\" id=\"u51c71448\"><span data-lake-id=\"ua20a60fc\" id=\"ua20a60fc\">HTML</span></code><span data-lake-id=\"u60c338d0\" id=\"u60c338d0\"> 的模板。写起来很接近标准 </span><code data-lake-id=\"u11188868\" id=\"u11188868\"><span data-lake-id=\"uc6dcf17c\" id=\"uc6dcf17c\">HTML</span></code><span data-lake-id=\"ue9195f26\" id=\"ue9195f26\">元素，只是多了一些属性。</span></li><li fid=\"uf6c8cc58\" data-lake-id=\"u2c6da8ea\" id=\"u2c6da8ea\"><code data-lake-id=\"u2fd15eb2\" id=\"u2fd15eb2\"><span data-lake-id=\"u8781a26f\" id=\"u8781a26f\">React</span></code><span data-lake-id=\"u32cde30b\" id=\"u32cde30b\"> 推荐你所有的模板通用 </span><code data-lake-id=\"ud0a88555\" id=\"ud0a88555\"><span data-lake-id=\"u82069dfe\" id=\"u82069dfe\">JavaScript</span></code><span data-lake-id=\"ud8720383\" id=\"ud8720383\"> 的语法扩展——</span><code data-lake-id=\"u45c58edb\" id=\"u45c58edb\"><span data-lake-id=\"u27cc046e\" id=\"u27cc046e\">JSX</span></code><span data-lake-id=\"u3337e37c\" id=\"u3337e37c\"> 书写。</span></li></ul><p data-lake-id=\"ue81e0e42\" id=\"ue81e0e42\" style=\"padding-left: 2em\"><span data-lake-id=\"u2f559ab6\" id=\"u2f559ab6\">具体来讲：</span><code data-lake-id=\"u8924f867\" id=\"u8924f867\"><span data-lake-id=\"ud9f2beef\" id=\"ud9f2beef\">React</span></code><span data-lake-id=\"uc9486211\" id=\"uc9486211\"> 中 </span><code data-lake-id=\"ua54d8784\" id=\"ua54d8784\"><span data-lake-id=\"u7d7f5324\" id=\"u7d7f5324\">render</span></code><span data-lake-id=\"uc656c96e\" id=\"uc656c96e\"> 函数是支持闭包特性的，所以我们 </span><code data-lake-id=\"ub070f82a\" id=\"ub070f82a\"><span data-lake-id=\"uaea03aff\" id=\"uaea03aff\">import</span></code><span data-lake-id=\"ud08b9de2\" id=\"ud08b9de2\"> 的组件在 </span><code data-lake-id=\"u9e342ee9\" id=\"u9e342ee9\"><span data-lake-id=\"u155cc721\" id=\"u155cc721\">render</span></code><span data-lake-id=\"u1cfcdea0\" id=\"u1cfcdea0\"> 中可以直接调用。但是在 </span><code data-lake-id=\"uf87a8278\" id=\"uf87a8278\"><span data-lake-id=\"u4b7e2955\" id=\"u4b7e2955\">Vue</span></code><span data-lake-id=\"u3de7d1b1\" id=\"u3de7d1b1\"> 中，由于模板中使用的数据都必须挂在 </span><code data-lake-id=\"u8556529c\" id=\"u8556529c\"><span data-lake-id=\"u30e9294a\" id=\"u30e9294a\">this</span></code><span data-lake-id=\"ue115e4d6\" id=\"ue115e4d6\"> 上进行一次中转，所以 </span><code data-lake-id=\"ucad80c44\" id=\"ucad80c44\"><span data-lake-id=\"uf9ddc62d\" id=\"uf9ddc62d\">import</span></code><span data-lake-id=\"u402dae50\" id=\"u402dae50\"> 完组件之后，还需要在 </span><code data-lake-id=\"u708ed3dd\" id=\"u708ed3dd\"><span data-lake-id=\"u887cae20\" id=\"u887cae20\">components</span></code><span data-lake-id=\"u1303adaa\" id=\"u1303adaa\"> 中再声明下。</span></p><ul list=\"u4dd2511a\"><li fid=\"ucbdab31d\" data-lake-id=\"u817ed42c\" id=\"u817ed42c\"><span data-lake-id=\"uf478a787\" id=\"uf478a787\">监听数据变化的实现原理不同</span></li></ul><ul list=\"u98a45c69\" data-lake-indent=\"1\"><li fid=\"uc71be162\" data-lake-id=\"uf1865ec9\" id=\"uf1865ec9\"><code data-lake-id=\"u25d36624\" id=\"u25d36624\"><span data-lake-id=\"u0bf15824\" id=\"u0bf15824\">Vue</span></code><span data-lake-id=\"ud02b6250\" id=\"ud02b6250\"> 通过 </span><code data-lake-id=\"u47ce9aa9\" id=\"u47ce9aa9\"><span data-lake-id=\"uca9035fc\" id=\"uca9035fc\">getter</span></code><span data-lake-id=\"uca1c1dec\" id=\"uca1c1dec\">/</span><code data-lake-id=\"u0db44791\" id=\"u0db44791\"><span data-lake-id=\"u587a934d\" id=\"u587a934d\">setter</span></code><span data-lake-id=\"uedd04930\" id=\"uedd04930\"> 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</span></li><li fid=\"uc71be162\" data-lake-id=\"u68fd2914\" id=\"u68fd2914\"><code data-lake-id=\"u88636923\" id=\"u88636923\"><span data-lake-id=\"ue4431ebb\" id=\"ue4431ebb\">React</span></code><span data-lake-id=\"u5347030f\" id=\"u5347030f\"> 默认是</span><strong><span data-lake-id=\"u19e963e6\" id=\"u19e963e6\">通过比较引用</span></strong><span data-lake-id=\"u516c0bb5\" id=\"u516c0bb5\">的方式进行的，如果不优化（</span><code data-lake-id=\"u91ef8705\" id=\"u91ef8705\"><span data-lake-id=\"u1d795e08\" id=\"u1d795e08\">PureComponent</span></code><span data-lake-id=\"ud3c9877b\" id=\"ud3c9877b\">/</span><code data-lake-id=\"ubaed0e8c\" id=\"ubaed0e8c\"><span data-lake-id=\"u93efd51c\" id=\"u93efd51c\">shouldComponentUpdate</span></code><span data-lake-id=\"ue5022292\" id=\"ue5022292\">）可能导致大量不必要的 </span><code data-lake-id=\"u4ffec924\" id=\"u4ffec924\"><span data-lake-id=\"uca84cd0b\" id=\"uca84cd0b\">vDOM</span></code><span data-lake-id=\"u1cafa818\" id=\"u1cafa818\"> 的重新渲染。这是因为 </span><code data-lake-id=\"u0b6ec097\" id=\"u0b6ec097\"><span data-lake-id=\"ue80c6fa3\" id=\"ue80c6fa3\">Vue</span></code><span data-lake-id=\"u3745a36a\" id=\"u3745a36a\"> 使用的是</span><strong><span data-lake-id=\"u4700afad\" id=\"u4700afad\">可变数据</span></strong><span data-lake-id=\"u63c07b54\" id=\"u63c07b54\">，而 </span><code data-lake-id=\"uf310c52f\" id=\"uf310c52f\"><span data-lake-id=\"u1366dd8c\" id=\"u1366dd8c\">React</span></code><span data-lake-id=\"u5db9eb1d\" id=\"u5db9eb1d\"> 更</span><strong><span data-lake-id=\"ucf118155\" id=\"ucf118155\">强调数据的不可变</span></strong></li></ul><ul list=\"u98a45c69\"><li fid=\"u32919836\" data-lake-id=\"u5297a2b0\" id=\"u5297a2b0\"><span data-lake-id=\"ubba608fd\" id=\"ubba608fd\">高阶组件</span></li></ul><p data-lake-id=\"u09e7b0b5\" id=\"u09e7b0b5\" style=\"padding-left: 2em\"><code data-lake-id=\"uf350689c\" id=\"uf350689c\"><span data-lake-id=\"u23c3db76\" id=\"u23c3db76\">react</span></code><span data-lake-id=\"u51bf6ddf\" id=\"u51bf6ddf\"> 可以通过高阶组件（</span><code data-lake-id=\"ua8525f2b\" id=\"ua8525f2b\"><span data-lake-id=\"u2ae92bdc\" id=\"u2ae92bdc\">Higher Order Components-- HOC</span></code><span data-lake-id=\"u4a2a6c6c\" id=\"u4a2a6c6c\">）来扩展，而 </span><code data-lake-id=\"u8c46ed24\" id=\"u8c46ed24\"><span data-lake-id=\"u79ca719f\" id=\"u79ca719f\">vue</span></code><span data-lake-id=\"u9b0f1525\" id=\"u9b0f1525\"> 需要通过 </span><code data-lake-id=\"uf006b5b7\" id=\"uf006b5b7\"><span data-lake-id=\"ud38cc169\" id=\"ud38cc169\">mixins</span></code><span data-lake-id=\"uef0072ce\" id=\"uef0072ce\"> 来扩展。</span></p><p data-lake-id=\"u3e91f198\" id=\"u3e91f198\" style=\"padding-left: 2em\"><span data-lake-id=\"u1c12e48b\" id=\"u1c12e48b\">原因高阶组件就是高阶函数，而 </span><code data-lake-id=\"u180974e0\" id=\"u180974e0\"><span data-lake-id=\"u7f8231ff\" id=\"u7f8231ff\">React</span></code><span data-lake-id=\"u948c53c0\" id=\"u948c53c0\"> 的组件本身就是纯粹的函数，所以高阶函数对 </span><code data-lake-id=\"u80fd14fe\" id=\"u80fd14fe\"><span data-lake-id=\"u2741b458\" id=\"u2741b458\">React</span></code><span data-lake-id=\"u7239552b\" id=\"u7239552b\"> 来说易如反掌。相反 </span><code data-lake-id=\"ueb9a47be\" id=\"ueb9a47be\"><span data-lake-id=\"ud267447a\" id=\"ud267447a\">Vue.js</span></code><span data-lake-id=\"udeb863f0\" id=\"udeb863f0\"> 使用 </span><code data-lake-id=\"u4aafde23\" id=\"u4aafde23\"><span data-lake-id=\"ue7492217\" id=\"ue7492217\">HTML</span></code><span data-lake-id=\"u0f6ea278\" id=\"u0f6ea278\"> 模板创建视图组件，这时模板无法有效的编译，因此 </span><code data-lake-id=\"u75265c5e\" id=\"u75265c5e\"><span data-lake-id=\"ud1a4206a\" id=\"ud1a4206a\">Vue</span></code><span data-lake-id=\"ub26335d2\" id=\"ub26335d2\"> 不采用 </span><code data-lake-id=\"u70d96b4f\" id=\"u70d96b4f\"><span data-lake-id=\"u1a584575\" id=\"u1a584575\">HOC</span></code><span data-lake-id=\"u324515ea\" id=\"u324515ea\"> 来实现。</span></p><ul list=\"ue8bb3e7f\"><li fid=\"u02718e07\" data-lake-id=\"u04f1df3e\" id=\"u04f1df3e\"><span data-lake-id=\"ue79eec9d\" id=\"ue79eec9d\">构建工具</span></li></ul><p data-lake-id=\"ub496b06e\" id=\"ub496b06e\" style=\"padding-left: 2em\"><span data-lake-id=\"u1769af28\" id=\"u1769af28\">两者都有自己的构建工具</span></p><ul list=\"u746eb4fe\" data-lake-indent=\"1\"><li fid=\"uf7e5bff0\" data-lake-id=\"uf1993c72\" id=\"uf1993c72\"><code data-lake-id=\"ue9d23205\" id=\"ue9d23205\"><span data-lake-id=\"u1233c7d3\" id=\"u1233c7d3\">React ==&gt; Create React APP</span></code></li><li fid=\"uf7e5bff0\" data-lake-id=\"ubef594c3\" id=\"ubef594c3\"><code data-lake-id=\"ubea5173a\" id=\"ubea5173a\"><span data-lake-id=\"ua4879833\" id=\"ua4879833\">Vue ==&gt; vue-cli</span></code></li></ul><ul list=\"u746eb4fe\"><li fid=\"ucac36345\" data-lake-id=\"ue2266ed3\" id=\"ue2266ed3\"><span data-lake-id=\"uc38e1775\" id=\"uc38e1775\">跨平台</span></li></ul><ul list=\"u60f4224e\" data-lake-indent=\"1\"><li fid=\"u5f066d07\" data-lake-id=\"u8637fba6\" id=\"u8637fba6\"><code data-lake-id=\"u8b68ea71\" id=\"u8b68ea71\"><span data-lake-id=\"uc2a43b27\" id=\"uc2a43b27\">React ==&gt; React Native</span></code></li><li fid=\"u5f066d07\" data-lake-id=\"udf411fa6\" id=\"udf411fa6\"><code data-lake-id=\"u3346bf11\" id=\"u3346bf11\"><span data-lake-id=\"u34fbc704\" id=\"u34fbc704\">Vue ==&gt; Weex</span></code></li></ul>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-28T16:50:32.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:42.000Z",
  "updated_at": "2022-04-28T16:50:32.000Z",
  "published_at": "2022-04-28T16:50:32.000Z",
  "first_published_at": "2022-04-04T11:33:41.914Z",
  "word_count": 767,
  "cover": null,
  "description": "相似之处：都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。都使用了 Virtual DOM（虚拟 DOM）提高重绘性能都有 props 的概念，允许组件间的数据传递都鼓励组件化应用，将应用分拆成一个个功能明确...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}