{
  "id": 72212116,
  "slug": "zq4s02",
  "title": "computed 相关问题",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"H7SKA\"></a>\n## computed 实现原理\ncomputed watcher, 计算属性的监听器<br />computed watcher 持有一个 dep 实例，通过 drity 属性标记计算属性是否需要重新求值\n\n当 computed 的依赖值改变后，就会通知订阅的 watcher 进行更新，对于 computed watcher 会将 drity 属性设置为 true，并且进行计算属性方法的调用\n<a name=\"wNthY\"></a>\n## computed 所谓的缓存是什么\n计算属性是基于它的响应式依赖进行缓存的，只有依赖发生改变的时候才会重新求值\n<a name=\"Z32HB\"></a>\n## 何时会用到 computed 缓存\n比如计算属性方法内部操作非常耗时，遍历一个极大的数组，计算一次可能要耗时 1s\n\n<a name=\"bMLvz\"></a>\n## computed 和 watch 的差异\n\n- computed: 计算一个新属性，挂载到实例上(当依赖发生变化后才会重新计算)。\n- watch: 监听已经被挂载到实例上的数据，数据发生变化了就会调用。\n<a name=\"WtGk1\"></a>\n## <br /><br />\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"H7SKA\"><span>computed 实现原理</span></h2><p data-lake-id=\"u4ea2f23a\"><span>computed watcher, 计算属性的监听器</span></p><p data-lake-id=\"uf15a3d75\"><span>computed watcher 持有一个 dep 实例，通过 drity 属性标记计算属性是否需要重新求值</span></p><p data-lake-id=\"u76d49730\"><span>​</span><br /></p><p data-lake-id=\"u298d4951\"><span>当 computed 的依赖值改变后，就会通知订阅的 watcher 进行更新，对于 computed watcher 会将 drity 属性设置为 true，并且进行计算属性方法的调用</span></p><h2 id=\"wNthY\"><span>computed 所谓的缓存是什么</span></h2><p data-lake-id=\"u5fe05145\"><span>计算属性是基于它的响应式依赖进行缓存的，只有依赖发生改变的时候才会重新求值</span></p><h2 id=\"Z32HB\"><span>何时会用到 computed 缓存</span></h2><p data-lake-id=\"u161252aa\"><span>比如计算属性方法内部操作非常耗时，遍历一个极大的数组，计算一次可能要耗时 1s</span></p><p data-lake-id=\"ua1821a14\"><span>​</span><br /></p><h2 id=\"bMLvz\"><span>computed 和 watch 的差异</span></h2><ul><li><span>computed: 计算一个新属性，挂载到实例上(当依赖发生变化后才会重新计算)。</span></li><li><span>watch: 监听已经被挂载到实例上的数据，数据发生变化了就会调用。</span></li></ul><h2 id=\"WtGk1\"><span><br /><br /></span></h2>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"H7SKA\" id=\"H7SKA\"><span data-lake-id=\"u4aec7b03\" id=\"u4aec7b03\">computed 实现原理</span></h2><p data-lake-id=\"u4ea2f23a\" id=\"u4ea2f23a\"><span data-lake-id=\"u7d64d694\" id=\"u7d64d694\">computed watcher, 计算属性的监听器</span></p><p data-lake-id=\"uf15a3d75\" id=\"uf15a3d75\"><span data-lake-id=\"u65cb1920\" id=\"u65cb1920\">computed watcher 持有一个 dep 实例，通过 drity 属性标记计算属性是否需要重新求值</span></p><p data-lake-id=\"u76d49730\" id=\"u76d49730\"><span data-lake-id=\"u9794108e\" id=\"u9794108e\">​</span><br></p><p data-lake-id=\"u298d4951\" id=\"u298d4951\"><span data-lake-id=\"u7cc93416\" id=\"u7cc93416\">当 computed 的依赖值改变后，就会通知订阅的 watcher 进行更新，对于 computed watcher 会将 drity 属性设置为 true，并且进行计算属性方法的调用</span></p><h2 data-lake-id=\"wNthY\" id=\"wNthY\"><span data-lake-id=\"ucf135ff1\" id=\"ucf135ff1\">computed 所谓的缓存是什么</span></h2><p data-lake-id=\"u5fe05145\" id=\"u5fe05145\"><span data-lake-id=\"uc3bdfea6\" id=\"uc3bdfea6\">计算属性是基于它的响应式依赖进行缓存的，只有依赖发生改变的时候才会重新求值</span></p><h2 data-lake-id=\"Z32HB\" id=\"Z32HB\"><span data-lake-id=\"u5eda20b2\" id=\"u5eda20b2\">何时会用到 computed 缓存</span></h2><p data-lake-id=\"u161252aa\" id=\"u161252aa\"><span data-lake-id=\"u4bf4fa90\" id=\"u4bf4fa90\">比如计算属性方法内部操作非常耗时，遍历一个极大的数组，计算一次可能要耗时 1s</span></p><p data-lake-id=\"ua1821a14\" id=\"ua1821a14\"><span data-lake-id=\"uf37ae6b8\" id=\"uf37ae6b8\">​</span><br></p><h2 data-lake-id=\"bMLvz\" id=\"bMLvz\"><span data-lake-id=\"uf840acef\" id=\"uf840acef\">computed 和 watch 的差异</span></h2><ul list=\"ub09dac31\"><li fid=\"u9f8a8fd0\" data-lake-id=\"u7306f120\" id=\"u7306f120\"><span data-lake-id=\"u4df8313f\" id=\"u4df8313f\">computed: 计算一个新属性，挂载到实例上(当依赖发生变化后才会重新计算)。</span></li><li fid=\"u9f8a8fd0\" data-lake-id=\"u429d498a\" id=\"u429d498a\"><span data-lake-id=\"ued91130f\" id=\"ued91130f\">watch: 监听已经被挂载到实例上的数据，数据发生变化了就会调用。</span></li></ul><h2 data-lake-id=\"WtGk1\" id=\"WtGk1\"><span data-lake-id=\"ue795f091\" id=\"ue795f091\"><br /><br /></span></h2>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:07.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:07.000Z",
  "updated_at": "2022-05-10T15:12:39.000Z",
  "published_at": "2022-04-04T11:33:07.000Z",
  "first_published_at": "2022-04-04T11:33:06.842Z",
  "word_count": 251,
  "cover": null,
  "description": "computed 实现原理computed watcher, 计算属性的监听器computed watcher 持有一个 dep 实例，通过 drity 属性标记计算属性是否需要重新求值当 computed 的依赖值改变后，就会通知订阅的 watcher 进行更新，对于 computed wa...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}