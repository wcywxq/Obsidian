{
  "id": 72212089,
  "slug": "ppt4fu",
  "title": "内存和垃圾回收",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"GstLU\"></a>\n## 内存\n<a name=\"BTwKV\"></a>\n### 生命周期\n\n- 内存分配\n\n声明变量、函数、对象的时候，javaScript 会自动分配内存\n\n- 内存使用\n\n调用的时候，使用的时候\n\n- 内存回收\n\njavaScript 的垃圾回收机制\n<a name=\"dh5lP\"></a>\n### 存储方式\n\n- 栈内存 stack\n\n自动分配内存空间，大小固定，会自动释放 \n\n- 堆内存 heap\n\n动态分配内存，大小不固定，不会自动释放\n<a name=\"EUJQP\"></a>\n## javaScript 的垃圾回收机制\n<a name=\"gXogo\"></a>\n### 什么是 GC\nGC(Garbadge Collection 垃圾回收)，在程序运行过程中会产生很多垃圾，这些垃圾可能是 **程序不用的内存** 或 **不再需要使用的内存空间**，而 GC 就是负责回收垃圾的，也就是我们常说的 **垃圾回收机制**\n<a name=\"OUB8p\"></a>\n### 垃圾的产生\n在编写代码的过程中，声明的变量、对象往往都需要占用内存，而不同类型的数据是保存在不同的内存中的\n\n- 基本数据类型(number、string、boolean、undefined、null、symbol、bigInt)\n:::tips\n存储在栈内存中，其特点是：大小固定、占据空间小，通过值来访问，属于被频繁使用的数据\n:::\n\n- 引用数据类型(object、array、function)\n:::tips\n存储在堆内存中，其特点是：大小不固定、占据空间大，通过指针来访问\n:::\n<a name=\"Fa01v\"></a>\n### 垃圾回收方法\n在 javaScript 内存管理中有一个该概念叫做 **可达性**，表示的是以某种方式可访问或可用的值，它们被包转存储在内存中，反之不可访问则需要回收(即：定期找出不用的内存，然后释放)。\n<a name=\"fdb9h\"></a>\n#### 引用计数法缺陷很多\n它的核心策略是跟踪记录每个变量值被使用的次数\n\n- 当声明了一个变量并将一个引用类型赋值给变量时，这个值的引用次数 +1\n- 如果用一个值被赋给另一个变量，那么引用次数 +1\n- 如果该变量的值被其它值覆盖了，那么引用次数 +1\n- 当这个值的引用次数变为 0 时，说明没有变量在使用，这时会回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值所占用的内存\n<a name=\"VbeS2\"></a>\n##### 优点\n当引用次数变为 0 时，会被回收，因此可以立即回收垃圾\n<a name=\"HPfOJ\"></a>\n##### 缺点\n\n1. 需要新增一个计数器，但计数器需要占用很大的位置\n2. 我们不清楚被引用数量的上限\n3. 无法解决循环引用所导致的无法回收的问题，这种情况会造成内存泄漏\n<a name=\"D7KCY\"></a>\n#### 标记清除法最常用\n到目前为止，大多数浏览器的 javaScript 引擎都在采用标记清除法来回收内存\n\n- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记。假设内存中的所有对象都是垃圾，全部标记为 0\n- 接着从各个根对象开始进行遍历，把不是垃圾的节点标记为 1\n- 清理所有标记为 0 的垃圾节点，销毁并回收它们所占用的内存空间\n- 最后，把所有内存中对象的标记修改为 0，等待下一轮垃圾回收\n<a name=\"FVuwh\"></a>\n##### 优点\n实现比较简单，标记的方式通过二进制位 0 和 1 就可以解决\n<a name=\"f8T90\"></a>\n##### 缺点\n\n1. 由于会从根对象(全局对象)开始查找，因此一些无法从根对象查询到的对象都将被清除。\n2. 内存碎片化。空闲的内存块不是连续的，容易出现很多空间内存块，还可能出现分配所需内存过大的对象时无法找到连续的内存空间\n3. 分配速度慢。因为即使使用 first-fit(找到>=size 的块后立即返回)的策略，其操作仍旧是一个 O(n) 的操作，最坏的情况是：每次都需要遍历到最后，同时因为碎片化，大的对象的分配效率就会变得更慢。\n<a name=\"d8A3r\"></a>\n## 内存泄漏\n\n1. 意外的全局变量\n2. 未被清除的定时器、订阅内容或者回调函数\n3. 不合理地使用闭包\n4. 脱离 dom 的引用\n```javascript\nconst elements = {\n\timage: document.querySelector('#image')\n}\n// 会造成内存泄漏\ndocument.body.removeChild(document.querySelector('#image'))\n// 正确的使用方式\nelements.image = null \n```\n<a name=\"CFXFP\"></a>\n## Nodejs v8回收机制\nv8 的回收机制基于 **分代回收机制**，将内存分为：新生代(young generation) 和 老生代(tenured generation)。\n\n- 新生代：存活时间较短的对象\n- 老生代：存活时间较长或者常驻内存的变量\n<a name=\"tJRjz\"></a>\n### v8 堆的构成\nv8 将堆分成了几个不同的区域<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647015547785-64a07e0f-2f3f-4759-9b81-5ed68b2dbe34.png#clientId=u65b7515d-866f-4&from=paste&height=407&id=u7c79c968&originHeight=407&originWidth=732&originalType=binary&ratio=1&size=97682&status=done&style=none&taskId=u7bee5ef3-cef1-4680-ad0f-e9f3f63c0da&width=732)\n\n- 新生代(New Space/Young Generation)：大多数新生对象被分配到这，分为两块空间，整体占据小块空间，垃圾回收的频率较高，采用的回收算法为 **Scavenge 算法**\n- 老生代(Old Space/Old Generation)：大多数在新生区存活一段时间后的对象会转移至此，采用的回收算法为 **标记清除 & 整理算法(Mark-Sweep & Mark-compact，Major GC)**，内部再细分为两个空间\n   - 指针空间(Old pointer space)：存储的对象含有指向其他对象的指针\n   - 数据空间：存储的对象仅包含数据，无指向其他对象的指针\n- 大对象空间(Large Object Space)：存储超过其他空间(Space)限制的大对象，垃圾回收器从不移动此空间中的对象\n- 代码空间(Code Space)：代码对象，用于存放代码段，是**唯一拥有执行权限的内存空间**，需要注意的是：如果代码对象太大而被移入大对象空间，这个代码对象在大对象空间内也是拥有执行权限的，但不能因此说大对象空间也有执行权限\n- Cell 空间、属性空间、Map 空间(Cell，Property，Map Space)：这些区域存放 Cell、属性 Cell 和 Map，每个空间因为都是存放大小相同的元素，因此内存结构很简单\n<a name=\"nRhSZ\"></a>\n### Scavenge 算法\nScavenge 算法是新生代空间中的主要算法，该算法由 C.J. Cheney 在 1970 年在论文 [A nonrecursive list compacting algorithm](https://link.segmentfault.com/?enc=2MXpNEEIQ6lZda4j1X55yA%3D%3D.cQM0pgzjhMjEsvKJZuTkoYWz3TuFArSmJclq4DkPUooVgJZmvfxML2GEC8d1tr06) 提出<br />Scavenge 主要采用了 Cheney 算法，Cheney 算法新生代空间的堆内存分为 2 块同样大小的空间，称为 Semi space，处于使用状态的称为 From 空间，闲置的称为 To 空间。垃圾回收过程如下：\n\n- 检查 From 空间，如果 From 空间被分配满了，则执行 Scavenge 算法进行垃圾回收\n- 如果未分配满，则检查 From 空间是否有存活对象，如果如存活对象，则直接释放未存活对象的空间\n- 如果存活，将检查对象是否符合晋升条件，如果符合晋升条件，则被移入老生代空间，否则将对象直接复制进 To 空间\n- 完成复制后将 From 和 To 空间角色互换，然后再从第一步开始执行\n<a name=\"LBFQx\"></a>\n#### 晋升条件\n\n1. 经历过一次 Scavenge 算法\n2. To 空间内存使用超过 25%\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647062175852-1ecf81c7-c8dc-4b8e-8523-da8c75535353.png#clientId=u35b2ec58-59dc-4&from=paste&height=478&id=u773b7ab8&originHeight=478&originWidth=682&originalType=binary&ratio=1&size=42571&status=done&style=none&taskId=u578938ec-257f-4865-9a09-469d46f9173&width=682)\n<a name=\"cWPJf\"></a>\n### 标记清除 & 整理算法(Mark-Sweep & Mark-Compact，Major GC)算法\n之前说过，标记清除策略会产生内存碎片，从而影响内存的使用，这里 标记整理算法(Mark-Compact)的出现就能很好的解决这个问题。标记整理算法是在 标记清除(Mark-Sweep)的基础上演变而来的，整理算法会将活跃的对象往边界移动，完成移动后，再清除不活跃的对象。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647062229721-d6577e13-84aa-468d-84ab-117dc0bd7f54.png#clientId=u35b2ec58-59dc-4&from=paste&height=343&id=ua8d089de&originHeight=343&originWidth=621&originalType=binary&ratio=1&size=44372&status=done&style=none&taskId=ubbded5e8-a90c-4e6e-bf67-09b57349642&width=621)<br />由于需要移动移动对象，所以在处理速度上，会慢于 Mark-Sweep\n<a name=\"ShUgB\"></a>\n### 全停顿(Stop The World)\n为了避免应用逻辑与垃圾回收器看到的逻辑不一样，垃圾回收器在执行回收时会停止应用逻辑，执行完回收任务后，再继续执行应用逻辑，这种行为就是 **全停顿**。停顿的时间取决于不同引擎执行一次垃圾回收的时间。这种停顿对新生代空间的影响较小，但对老生代空间可能会造成停顿的现象\n<a name=\"q8Idc\"></a>\n### 增量标记(Incremental Marking)\n为了解决全停顿的现象，2011 年 v8 推出了增量标记。v8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 js 应用逻辑交替进行，直至标记完成<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647062475529-09dd3980-657f-4eaa-ac95-bed7a6a0702a.png#clientId=u35b2ec58-59dc-4&from=paste&height=205&id=ucc387e50&originHeight=205&originWidth=732&originalType=binary&ratio=1&size=31980&status=done&style=none&taskId=ue1c8b542-1157-4fa0-97bf-744ba239cc5&width=732)\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"GstLU\"><span>内存</span></h2><h3 id=\"BTwKV\"><span>生命周期</span></h3><ul><li><span>内存分配</span></li></ul><p data-lake-id=\"ua784638e\"><span>声明变量、函数、对象的时候，javaScript 会自动分配内存</span></p><ul><li><span>内存使用</span></li></ul><p data-lake-id=\"u768785f3\"><span>调用的时候，使用的时候</span></p><ul><li><span>内存回收</span></li></ul><p data-lake-id=\"ue6c525dc\"><span>javaScript 的垃圾回收机制</span></p><h3 id=\"dh5lP\"><span>存储方式</span></h3><ul><li><span>栈内存 stack</span></li></ul><p data-lake-id=\"ucbb04ecc\"><span>自动分配内存空间，大小固定，会自动释放 </span></p><ul><li><span>堆内存 heap</span></li></ul><p data-lake-id=\"u95f7b2d5\"><span>动态分配内存，大小不固定，不会自动释放</span></p><h2 id=\"EUJQP\"><span>javaScript 的垃圾回收机制</span></h2><h3 id=\"gXogo\"><span>什么是 GC</span></h3><p data-lake-id=\"uc13fc0a2\"><span>GC(Garbadge Collection 垃圾回收)，在程序运行过程中会产生很多垃圾，这些垃圾可能是 </span><strong><span>程序不用的内存</span></strong><span> 或 </span><strong><span>不再需要使用的内存空间</span></strong><span>，而 GC 就是负责回收垃圾的，也就是我们常说的 </span><strong><span>垃圾回收机制</span></strong></p><h3 id=\"OUB8p\"><span>垃圾的产生</span></h3><p data-lake-id=\"u6c4e40bb\"><span>在编写代码的过程中，声明的变量、对象往往都需要占用内存，而不同类型的数据是保存在不同的内存中的</span></p><ul><li><span>基本数据类型(number、string、boolean、undefined、null、symbol、bigInt)</span></li></ul><blockquote class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"udf533d6a\"><span>存储在栈内存中，其特点是：大小固定、占据空间小，通过值来访问，属于被频繁使用的数据</span></p></blockquote><ul><li><span>引用数据类型(object、array、function)</span></li></ul><blockquote class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"ufdef30d4\"><span>存储在堆内存中，其特点是：大小不固定、占据空间大，通过指针来访问</span></p></blockquote><h3 id=\"Fa01v\"><span>垃圾回收方法</span></h3><p data-lake-id=\"ud7ddc5e2\"><span>在 javaScript 内存管理中有一个该概念叫做 </span><strong><span>可达性</span></strong><span>，表示的是以某种方式可访问或可用的值，它们被包转存储在内存中，反之不可访问则需要回收(即：定期找出不用的内存，然后释放)。</span></p><h4 id=\"fdb9h\"><span>引用计数法</span><span class=\"lake-card-label\" style=\"background-color: #FFE8E6; color: #820014;\">缺陷很多</span></h4><p data-lake-id=\"u4b550119\"><span>它的核心策略是跟踪记录每个变量值被使用的次数</span></p><ul><li><span>当声明了一个变量并将一个引用类型赋值给变量时，这个值的引用次数 +1</span></li><li><span>如果用一个值被赋给另一个变量，那么引用次数 +1</span></li><li><span>如果该变量的值被其它值覆盖了，那么引用次数 +1</span></li><li><span>当这个值的引用次数变为 0 时，说明没有变量在使用，这时会回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值所占用的内存</span></li></ul><h5 id=\"VbeS2\"><span>优点</span></h5><p data-lake-id=\"ub5a0deff\"><span>当引用次数变为 0 时，会被回收，因此可以立即回收垃圾</span></p><h5 id=\"HPfOJ\"><span>缺点</span></h5><ol><li><span>需要新增一个计数器，但计数器需要占用很大的位置</span></li><li><span>我们不清楚被引用数量的上限</span></li><li><span>无法解决循环引用所导致的无法回收的问题，这种情况会造成内存泄漏</span></li></ol><h4 id=\"D7KCY\"><span>标记清除法</span><span class=\"lake-card-label\" style=\"background-color: #E4F7D2; color: #135200;\">最常用</span></h4><p data-lake-id=\"ud6d18147\"><span>到目前为止，大多数浏览器的 javaScript 引擎都在采用标记清除法来回收内存</span></p><ul><li><span>垃圾收集器在运行时会给内存中的所有变量都加上一个标记。假设内存中的所有对象都是垃圾，全部标记为 0</span></li><li><span>接着从各个根对象开始进行遍历，把不是垃圾的节点标记为 1</span></li><li><span>清理所有标记为 0 的垃圾节点，销毁并回收它们所占用的内存空间</span></li><li><span>最后，把所有内存中对象的标记修改为 0，等待下一轮垃圾回收</span></li></ul><h5 id=\"FVuwh\"><span>优点</span></h5><p data-lake-id=\"u3dae347c\"><span>实现比较简单，标记的方式通过二进制位 0 和 1 就可以解决</span></p><h5 id=\"f8T90\"><span>缺点</span></h5><ol><li><span>由于会从根对象(全局对象)开始查找，因此一些无法从根对象查询到的对象都将被清除。</span></li><li><span>内存碎片化。空闲的内存块不是连续的，容易出现很多空间内存块，还可能出现分配所需内存过大的对象时无法找到连续的内存空间</span></li><li><span>分配速度慢。因为即使使用 first-fit(找到&gt;=size 的块后立即返回)的策略，其操作仍旧是一个 O(n) 的操作，最坏的情况是：每次都需要遍历到最后，同时因为碎片化，大的对象的分配效率就会变得更慢。</span></li></ol><h2 id=\"d8A3r\"><span>内存泄漏</span></h2><ol><li><span>意外的全局变量</span></li><li><span>未被清除的定时器、订阅内容或者回调函数</span></li><li><span>不合理地使用闭包</span></li><li><span>脱离 dom 的引用</span></li></ol><pre data-lang=\"javascript\"><code>const elements = {\n\timage: document.querySelector('#image')\n}\n// 会造成内存泄漏\ndocument.body.removeChild(document.querySelector('#image'))\n// 正确的使用方式\nelements.image = null </code></pre><h2 id=\"CFXFP\"><span>Nodejs v8回收机制</span></h2><p data-lake-id=\"ubc874628\"><span>v8 的回收机制基于 </span><strong><span>分代回收机制</span></strong><span>，将内存分为：新生代(young generation) 和 老生代(tenured generation)。</span></p><ul><li><span>新生代：存活时间较短的对象</span></li><li><span>老生代：存活时间较长或者常驻内存的变量</span></li></ul><h3 id=\"tJRjz\"><span>v8 堆的构成</span></h3><p data-lake-id=\"uaafd6868\"><span>v8 将堆分成了几个不同的区域</span></p><p data-lake-id=\"u01180c9a\"><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647015547785-64a07e0f-2f3f-4759-9b81-5ed68b2dbe34.png#clientId=u65b7515d-866f-4&amp;from=paste&amp;height=407&amp;id=u7c79c968&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=407&amp;originWidth=732&amp;originalType=binary&amp;ratio=1&amp;size=97682&amp;status=done&amp;style=none&amp;taskId=u7bee5ef3-cef1-4680-ad0f-e9f3f63c0da&amp;width=732\" style=\"max-width: 600px; width: 732px;\" /></p><ul><li><span>新生代(New Space/Young Generation)：大多数新生对象被分配到这，分为两块空间，整体占据小块空间，垃圾回收的频率较高，采用的回收算法为 </span><strong><span>Scavenge 算法</span></strong></li><li><span>老生代(Old Space/Old Generation)：大多数在新生区存活一段时间后的对象会转移至此，采用的回收算法为 </span><strong><span>标记清除 &amp; 整理算法(Mark-Sweep &amp; Mark-compact，Major GC)</span></strong><span>，内部再细分为两个空间</span></li></ul><ul data-lake-indent=\"1\"><li><span>指针空间(Old pointer space)：存储的对象含有指向其他对象的指针</span></li><li><span>数据空间：存储的对象仅包含数据，无指向其他对象的指针</span></li></ul><ul><li><span>大对象空间(Large Object Space)：存储超过其他空间(Space)限制的大对象，垃圾回收器从不移动此空间中的对象</span></li><li><span>代码空间(Code Space)：代码对象，用于存放代码段，是</span><strong><span>唯一拥有执行权限的内存空间</span></strong><span>，需要注意的是：如果代码对象太大而被移入大对象空间，这个代码对象在大对象空间内也是拥有执行权限的，但不能因此说大对象空间也有执行权限</span></li><li><span>Cell 空间、属性空间、Map 空间(Cell，Property，Map Space)：这些区域存放 Cell、属性 Cell 和 Map，每个空间因为都是存放大小相同的元素，因此内存结构很简单</span></li></ul><h3 id=\"nRhSZ\"><span>Scavenge 算法</span></h3><p data-lake-id=\"u415a7165\"><span>Scavenge 算法是新生代空间中的主要算法，该算法由 C.J. Cheney 在 1970 年在论文 </span><a href=\"https://link.segmentfault.com/?enc=2MXpNEEIQ6lZda4j1X55yA%3D%3D.cQM0pgzjhMjEsvKJZuTkoYWz3TuFArSmJclq4DkPUooVgJZmvfxML2GEC8d1tr06\" target=\"_blank\"><span>A nonrecursive list compacting algorithm</span></a><span> 提出</span></p><p data-lake-id=\"uf13e08b9\"><span>Scavenge 主要采用了 Cheney 算法，Cheney 算法新生代空间的堆内存分为 2 块同样大小的空间，称为 Semi space，处于使用状态的称为 From 空间，闲置的称为 To 空间。垃圾回收过程如下：</span></p><ul><li><span>检查 From 空间，如果 From 空间被分配满了，则执行 Scavenge 算法进行垃圾回收</span></li><li><span>如果未分配满，则检查 From 空间是否有存活对象，如果如存活对象，则直接释放未存活对象的空间</span></li><li><span>如果存活，将检查对象是否符合晋升条件，如果符合晋升条件，则被移入老生代空间，否则将对象直接复制进 To 空间</span></li><li><span>完成复制后将 From 和 To 空间角色互换，然后再从第一步开始执行</span></li></ul><h4 id=\"LBFQx\"><span>晋升条件</span></h4><ol><li><span>经历过一次 Scavenge 算法</span></li><li><span>To 空间内存使用超过 25%</span></li></ol><p data-lake-id=\"u484a3935\"><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647062175852-1ecf81c7-c8dc-4b8e-8523-da8c75535353.png#clientId=u35b2ec58-59dc-4&amp;from=paste&amp;height=478&amp;id=u773b7ab8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=478&amp;originWidth=682&amp;originalType=binary&amp;ratio=1&amp;size=42571&amp;status=done&amp;style=none&amp;taskId=u578938ec-257f-4865-9a09-469d46f9173&amp;width=682\" style=\"max-width: 600px; width: 682px;\" /></p><h3 id=\"cWPJf\"><span>标记清除 &amp; 整理算法(</span><span style=\"color: #212529;\">Mark-Sweep &amp; Mark-Compact，Major GC)算法</span></h3><p data-lake-id=\"u6bf77c8a\"><span>之前说过，标记清除策略会产生内存碎片，从而影响内存的使用，这里 标记整理算法(Mark-Compact)的出现就能很好的解决这个问题。标记整理算法是在 标记清除(Mark-Sweep)的基础上演变而来的，整理算法会将活跃的对象往边界移动，完成移动后，再清除不活跃的对象。</span></p><p data-lake-id=\"ua5e304b5\"><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647062229721-d6577e13-84aa-468d-84ab-117dc0bd7f54.png#clientId=u35b2ec58-59dc-4&amp;from=paste&amp;height=343&amp;id=ua8d089de&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=343&amp;originWidth=621&amp;originalType=binary&amp;ratio=1&amp;size=44372&amp;status=done&amp;style=none&amp;taskId=ubbded5e8-a90c-4e6e-bf67-09b57349642&amp;width=621\" style=\"max-width: 600px; width: 621px;\" /></p><p data-lake-id=\"u6f062ec0\"><span>由于需要移动移动对象，所以在处理速度上，会慢于 Mark-Sweep</span></p><h3 id=\"ShUgB\"><span>全停顿(Stop The World)</span></h3><p data-lake-id=\"u068c24fa\"><span>为了避免应用逻辑与垃圾回收器看到的逻辑不一样，垃圾回收器在执行回收时会停止应用逻辑，执行完回收任务后，再继续执行应用逻辑，这种行为就是 </span><strong><span>全停顿</span></strong><span>。停顿的时间取决于不同引擎执行一次垃圾回收的时间。这种停顿对新生代空间的影响较小，但对老生代空间可能会造成停顿的现象</span></p><h3 id=\"q8Idc\"><span>增量标记(</span><span style=\"color: #212529;\">Incremental Marking</span><span>)</span></h3><p data-lake-id=\"u5622c545\"><span>为了解决全停顿的现象，2011 年 v8 推出了增量标记。v8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 js 应用逻辑交替进行，直至标记完成</span></p><p data-lake-id=\"u4ffdf691\"><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647062475529-09dd3980-657f-4eaa-ac95-bed7a6a0702a.png#clientId=u35b2ec58-59dc-4&amp;from=paste&amp;height=205&amp;id=ucc387e50&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=205&amp;originWidth=732&amp;originalType=binary&amp;ratio=1&amp;size=31980&amp;status=done&amp;style=none&amp;taskId=ue1c8b542-1157-4fa0-97bf-744ba239cc5&amp;width=732\" style=\"max-width: 600px; width: 732px;\" /></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"GstLU\" id=\"GstLU\"><span data-lake-id=\"u0e2b7bd7\" id=\"u0e2b7bd7\">内存</span></h2><h3 data-lake-id=\"BTwKV\" id=\"BTwKV\"><span data-lake-id=\"u44a9403b\" id=\"u44a9403b\">生命周期</span></h3><ul list=\"ub1783fe7\"><li fid=\"uf15678cd\" data-lake-id=\"u69f2adb8\" id=\"u69f2adb8\"><span data-lake-id=\"ubef319d9\" id=\"ubef319d9\">内存分配</span></li></ul><p data-lake-id=\"ua784638e\" id=\"ua784638e\"><span data-lake-id=\"u93666796\" id=\"u93666796\">声明变量、函数、对象的时候，javaScript 会自动分配内存</span></p><ul list=\"uf44cb4f9\"><li fid=\"u5cd9effd\" data-lake-id=\"u949b0bfc\" id=\"u949b0bfc\"><span data-lake-id=\"ufb563bfb\" id=\"ufb563bfb\">内存使用</span></li></ul><p data-lake-id=\"u768785f3\" id=\"u768785f3\"><span data-lake-id=\"uab56ab64\" id=\"uab56ab64\">调用的时候，使用的时候</span></p><ul list=\"u0ce1d5e5\"><li fid=\"u07058ab4\" data-lake-id=\"ufb242189\" id=\"ufb242189\"><span data-lake-id=\"uf6152ed0\" id=\"uf6152ed0\">内存回收</span></li></ul><p data-lake-id=\"ue6c525dc\" id=\"ue6c525dc\"><span data-lake-id=\"u8516e27c\" id=\"u8516e27c\">javaScript 的垃圾回收机制</span></p><h3 data-lake-id=\"dh5lP\" id=\"dh5lP\"><span data-lake-id=\"u6b3f1996\" id=\"u6b3f1996\">存储方式</span></h3><ul list=\"ub071f01c\"><li fid=\"ue83a8793\" data-lake-id=\"u8d1fa21e\" id=\"u8d1fa21e\"><span data-lake-id=\"ub8bbe10b\" id=\"ub8bbe10b\">栈内存 stack</span></li></ul><p data-lake-id=\"ucbb04ecc\" id=\"ucbb04ecc\"><span data-lake-id=\"u2676c506\" id=\"u2676c506\">自动分配内存空间，大小固定，会自动释放 </span></p><ul list=\"ub071f01c\" start=\"2\"><li fid=\"ue83a8793\" data-lake-id=\"u255ab4f0\" id=\"u255ab4f0\"><span data-lake-id=\"u9e20a8e3\" id=\"u9e20a8e3\">堆内存 heap</span></li></ul><p data-lake-id=\"u95f7b2d5\" id=\"u95f7b2d5\"><span data-lake-id=\"u358176b8\" id=\"u358176b8\">动态分配内存，大小不固定，不会自动释放</span></p><h2 data-lake-id=\"EUJQP\" id=\"EUJQP\"><span data-lake-id=\"ua73480f3\" id=\"ua73480f3\">javaScript 的垃圾回收机制</span></h2><h3 data-lake-id=\"gXogo\" id=\"gXogo\"><span data-lake-id=\"u23f6c11c\" id=\"u23f6c11c\">什么是 GC</span></h3><p data-lake-id=\"uc13fc0a2\" id=\"uc13fc0a2\"><span data-lake-id=\"ud8f57240\" id=\"ud8f57240\">GC(Garbadge Collection 垃圾回收)，在程序运行过程中会产生很多垃圾，这些垃圾可能是 </span><strong><span data-lake-id=\"u6240928e\" id=\"u6240928e\">程序不用的内存</span></strong><span data-lake-id=\"u959fe3d7\" id=\"u959fe3d7\"> 或 </span><strong><span data-lake-id=\"u44f44d5d\" id=\"u44f44d5d\">不再需要使用的内存空间</span></strong><span data-lake-id=\"ub8b9e331\" id=\"ub8b9e331\">，而 GC 就是负责回收垃圾的，也就是我们常说的 </span><strong><span data-lake-id=\"u38d4d877\" id=\"u38d4d877\">垃圾回收机制</span></strong></p><h3 data-lake-id=\"OUB8p\" id=\"OUB8p\"><span data-lake-id=\"u7476df49\" id=\"u7476df49\">垃圾的产生</span></h3><p data-lake-id=\"u6c4e40bb\" id=\"u6c4e40bb\"><span data-lake-id=\"u7909312b\" id=\"u7909312b\">在编写代码的过程中，声明的变量、对象往往都需要占用内存，而不同类型的数据是保存在不同的内存中的</span></p><ul list=\"uc0544275\"><li fid=\"u8def7cda\" data-lake-id=\"u48d40efb\" id=\"u48d40efb\"><span data-lake-id=\"u0e3524b2\" id=\"u0e3524b2\">基本数据类型(number、string、boolean、undefined、null、symbol、bigInt)</span></li></ul><blockquote data-lake-id=\"u6e6e4f98\" id=\"u6e6e4f98\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"udf533d6a\" id=\"udf533d6a\"><span data-lake-id=\"ub8db88db\" id=\"ub8db88db\">存储在栈内存中，其特点是：大小固定、占据空间小，通过值来访问，属于被频繁使用的数据</span></p></blockquote><ul list=\"uc0544275\" start=\"2\"><li fid=\"u8def7cda\" data-lake-id=\"u0714d148\" id=\"u0714d148\"><span data-lake-id=\"u8693dab4\" id=\"u8693dab4\">引用数据类型(object、array、function)</span></li></ul><blockquote data-lake-id=\"u2c2a2bb9\" id=\"u2c2a2bb9\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"ufdef30d4\" id=\"ufdef30d4\"><span data-lake-id=\"u1b3bd591\" id=\"u1b3bd591\">存储在堆内存中，其特点是：大小不固定、占据空间大，通过指针来访问</span></p></blockquote><h3 data-lake-id=\"Fa01v\" id=\"Fa01v\"><span data-lake-id=\"u6d77af9e\" id=\"u6d77af9e\">垃圾回收方法</span></h3><p data-lake-id=\"ud7ddc5e2\" id=\"ud7ddc5e2\"><span data-lake-id=\"u0524affc\" id=\"u0524affc\">在 javaScript 内存管理中有一个该概念叫做 </span><strong><span data-lake-id=\"u3f5d6dac\" id=\"u3f5d6dac\">可达性</span></strong><span data-lake-id=\"u618367e3\" id=\"u618367e3\">，表示的是以某种方式可访问或可用的值，它们被包转存储在内存中，反之不可访问则需要回收(即：定期找出不用的内存，然后释放)。</span></p><h4 data-lake-id=\"fdb9h\" id=\"fdb9h\"><span data-lake-id=\"u0b916f7f\" id=\"u0b916f7f\">引用计数法</span><card type=\"inline\" name=\"label\" value=\"data:%7B%22label%22%3A%22%E7%BC%BA%E9%99%B7%E5%BE%88%E5%A4%9A%22%2C%22colorIndex%22%3A0%2C%22id%22%3A%22i0Rae%22%7D\"></card></h4><p data-lake-id=\"u4b550119\" id=\"u4b550119\"><span data-lake-id=\"uacb99a2d\" id=\"uacb99a2d\">它的核心策略是跟踪记录每个变量值被使用的次数</span></p><ul list=\"uf3a06893\"><li fid=\"u6696886a\" data-lake-id=\"u5b436029\" id=\"u5b436029\"><span data-lake-id=\"u1c3aadf8\" id=\"u1c3aadf8\">当声明了一个变量并将一个引用类型赋值给变量时，这个值的引用次数 +1</span></li><li fid=\"u6696886a\" data-lake-id=\"uf15f1a28\" id=\"uf15f1a28\"><span data-lake-id=\"ub12e6677\" id=\"ub12e6677\">如果用一个值被赋给另一个变量，那么引用次数 +1</span></li><li fid=\"u6696886a\" data-lake-id=\"ua47b4f2e\" id=\"ua47b4f2e\"><span data-lake-id=\"ue4c4c452\" id=\"ue4c4c452\">如果该变量的值被其它值覆盖了，那么引用次数 +1</span></li><li fid=\"u6696886a\" data-lake-id=\"u884946d7\" id=\"u884946d7\"><span data-lake-id=\"u8f48ce3a\" id=\"u8f48ce3a\">当这个值的引用次数变为 0 时，说明没有变量在使用，这时会回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值所占用的内存</span></li></ul><h5 data-lake-id=\"VbeS2\" id=\"VbeS2\"><span data-lake-id=\"uaf510a85\" id=\"uaf510a85\">优点</span></h5><p data-lake-id=\"ub5a0deff\" id=\"ub5a0deff\"><span data-lake-id=\"u5289f84e\" id=\"u5289f84e\">当引用次数变为 0 时，会被回收，因此可以立即回收垃圾</span></p><h5 data-lake-id=\"HPfOJ\" id=\"HPfOJ\"><span data-lake-id=\"u4c1ef124\" id=\"u4c1ef124\">缺点</span></h5><ol list=\"u8126e019\"><li fid=\"u966856fa\" data-lake-id=\"u53dc2e8d\" id=\"u53dc2e8d\"><span data-lake-id=\"u5fe2d88e\" id=\"u5fe2d88e\">需要新增一个计数器，但计数器需要占用很大的位置</span></li><li fid=\"u966856fa\" data-lake-id=\"uca47733b\" id=\"uca47733b\"><span data-lake-id=\"u0b8bf5be\" id=\"u0b8bf5be\">我们不清楚被引用数量的上限</span></li><li fid=\"u966856fa\" data-lake-id=\"uf654d128\" id=\"uf654d128\"><span data-lake-id=\"uf53a6f1e\" id=\"uf53a6f1e\">无法解决循环引用所导致的无法回收的问题，这种情况会造成内存泄漏</span></li></ol><h4 data-lake-id=\"D7KCY\" id=\"D7KCY\"><span data-lake-id=\"u9b5c80b5\" id=\"u9b5c80b5\">标记清除法</span><card type=\"inline\" name=\"label\" value=\"data:%7B%22label%22%3A%22%E6%9C%80%E5%B8%B8%E7%94%A8%22%2C%22colorIndex%22%3A2%2C%22id%22%3A%22QUw59%22%7D\"></card></h4><p data-lake-id=\"ud6d18147\" id=\"ud6d18147\"><span data-lake-id=\"ud417ae97\" id=\"ud417ae97\">到目前为止，大多数浏览器的 javaScript 引擎都在采用标记清除法来回收内存</span></p><ul list=\"u9254a008\"><li fid=\"ub64fea6d\" data-lake-id=\"uf2c2b216\" id=\"uf2c2b216\"><span data-lake-id=\"u05be0119\" id=\"u05be0119\">垃圾收集器在运行时会给内存中的所有变量都加上一个标记。假设内存中的所有对象都是垃圾，全部标记为 0</span></li><li fid=\"ub64fea6d\" data-lake-id=\"u84c855ba\" id=\"u84c855ba\"><span data-lake-id=\"u4964a970\" id=\"u4964a970\">接着从各个根对象开始进行遍历，把不是垃圾的节点标记为 1</span></li><li fid=\"ub64fea6d\" data-lake-id=\"u37da0d4f\" id=\"u37da0d4f\"><span data-lake-id=\"u9d0837d4\" id=\"u9d0837d4\">清理所有标记为 0 的垃圾节点，销毁并回收它们所占用的内存空间</span></li><li fid=\"ub64fea6d\" data-lake-id=\"u527d30e5\" id=\"u527d30e5\"><span data-lake-id=\"ud90e44b7\" id=\"ud90e44b7\">最后，把所有内存中对象的标记修改为 0，等待下一轮垃圾回收</span></li></ul><h5 data-lake-id=\"FVuwh\" id=\"FVuwh\"><span data-lake-id=\"ud4f2a067\" id=\"ud4f2a067\">优点</span></h5><p data-lake-id=\"u3dae347c\" id=\"u3dae347c\"><span data-lake-id=\"ubd155a9e\" id=\"ubd155a9e\">实现比较简单，标记的方式通过二进制位 0 和 1 就可以解决</span></p><h5 data-lake-id=\"f8T90\" id=\"f8T90\"><span data-lake-id=\"u068be71e\" id=\"u068be71e\">缺点</span></h5><ol list=\"u802bd3b2\"><li fid=\"u1450b707\" data-lake-id=\"u6cd297e5\" id=\"u6cd297e5\"><span data-lake-id=\"u7ca5b072\" id=\"u7ca5b072\">由于会从根对象(全局对象)开始查找，因此一些无法从根对象查询到的对象都将被清除。</span></li><li fid=\"u1450b707\" data-lake-id=\"ueebf6d59\" id=\"ueebf6d59\"><span data-lake-id=\"ucc498cde\" id=\"ucc498cde\">内存碎片化。空闲的内存块不是连续的，容易出现很多空间内存块，还可能出现分配所需内存过大的对象时无法找到连续的内存空间</span></li><li fid=\"u1450b707\" data-lake-id=\"u461f2ede\" id=\"u461f2ede\"><span data-lake-id=\"u1aaa23fb\" id=\"u1aaa23fb\">分配速度慢。因为即使使用 first-fit(找到&gt;=size 的块后立即返回)的策略，其操作仍旧是一个 O(n) 的操作，最坏的情况是：每次都需要遍历到最后，同时因为碎片化，大的对象的分配效率就会变得更慢。</span></li></ol><h2 data-lake-id=\"d8A3r\" id=\"d8A3r\"><span data-lake-id=\"ub41b42e2\" id=\"ub41b42e2\">内存泄漏</span></h2><ol list=\"u3a249973\"><li fid=\"u63ea953b\" data-lake-id=\"u0d82f740\" id=\"u0d82f740\"><span data-lake-id=\"u0922bf47\" id=\"u0922bf47\">意外的全局变量</span></li><li fid=\"u63ea953b\" data-lake-id=\"u655dc879\" id=\"u655dc879\"><span data-lake-id=\"u3794d816\" id=\"u3794d816\">未被清除的定时器、订阅内容或者回调函数</span></li><li fid=\"u63ea953b\" data-lake-id=\"uecdeb66b\" id=\"uecdeb66b\"><span data-lake-id=\"ufbb1c014\" id=\"ufbb1c014\">不合理地使用闭包</span></li><li fid=\"u63ea953b\" data-lake-id=\"u39cb3413\" id=\"u39cb3413\"><span data-lake-id=\"u37f0f985\" id=\"u37f0f985\">脱离 dom 的引用</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20elements%20%3D%20%7B%5Cn%5Ctimage%3A%20document.querySelector('%23image')%5Cn%7D%5Cn%2F%2F%20%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%5Cndocument.body.removeChild(document.querySelector('%23image'))%5Cn%2F%2F%20%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%5Cnelements.image%20%3D%20null%20%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22sfoA5%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"CFXFP\" id=\"CFXFP\"><span data-lake-id=\"ub4714882\" id=\"ub4714882\">Nodejs v8回收机制</span></h2><p data-lake-id=\"ubc874628\" id=\"ubc874628\"><span data-lake-id=\"ue2465b9d\" id=\"ue2465b9d\">v8 的回收机制基于 </span><strong><span data-lake-id=\"u55e804ca\" id=\"u55e804ca\">分代回收机制</span></strong><span data-lake-id=\"u4bab61ba\" id=\"u4bab61ba\">，将内存分为：新生代(young generation) 和 老生代(tenured generation)。</span></p><ul list=\"uc4bb207b\"><li fid=\"ub192e4f5\" data-lake-id=\"u75b8c2b8\" id=\"u75b8c2b8\"><span data-lake-id=\"u0ef867e9\" id=\"u0ef867e9\">新生代：存活时间较短的对象</span></li><li fid=\"ub192e4f5\" data-lake-id=\"ue7d55f6d\" id=\"ue7d55f6d\"><span data-lake-id=\"u02540187\" id=\"u02540187\">老生代：存活时间较长或者常驻内存的变量</span></li></ul><h3 data-lake-id=\"tJRjz\" id=\"tJRjz\"><span data-lake-id=\"u65a31ca9\" id=\"u65a31ca9\">v8 堆的构成</span></h3><p data-lake-id=\"uaafd6868\" id=\"uaafd6868\"><span data-lake-id=\"u6cfe966f\" id=\"u6cfe966f\">v8 将堆分成了几个不同的区域</span></p><p data-lake-id=\"u01180c9a\" id=\"u01180c9a\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647015547785-64a07e0f-2f3f-4759-9b81-5ed68b2dbe34.png%22%2C%22taskId%22%3A%22u7bee5ef3-cef1-4680-ad0f-e9f3f63c0da%22%2C%22clientId%22%3A%22u65b7515d-866f-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A732%2C%22height%22%3A407%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A97682%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A732%2C%22originHeight%22%3A407%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22RESIDENT%20SET%20OLD%20POINTER%20SPACE%20OLD%20DATA%20SPACE%20SEMI%20SPACE%20SEMI%20SPACE%20NEW%20SPACE(YOUNG%20GENERATION)%20OLD%20SPACE(OLD%20GENERATION)%20CELL%20SPACE%20LARGE%20OBJECT%20SPACE%20CODE%20SPACE%20PROPERTY%20CELL%20SPACE%20MAP%20SPACE%20HEAP%20MEMORY%20STACK%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A322.4192%2C%22y%22%3A6.175405%2C%22width%22%3A89.87288000000001%2C%22height%22%3A14.020632%2C%22text%22%3A%22RESIDENT%20SET%22%7D%2C%7B%22x%22%3A401.38354%2C%22y%22%3A104.6196%2C%22width%22%3A98.68066000000005%2C%22height%22%3A14.034809999999993%2C%22text%22%3A%22OLD%20POINTER%20SPACE%22%7D%2C%7B%22x%22%3A561.1324%2C%22y%22%3A105.348045%2C%22width%22%3A83.99340000000007%2C%22height%22%3A12.929884999999999%2C%22text%22%3A%22OLD%20DATA%20SPACE%22%7D%2C%7B%22x%22%3A93.52741%2C%22y%22%3A105.829926%2C%22width%22%3A65.65365%2C%22height%22%3A12.111574000000005%2C%22text%22%3A%22SEMI%20SPACE%22%7D%2C%7B%22x%22%3A237.44798%2C%22y%22%3A105.90277%2C%22width%22%3A65.78132000000002%2C%22height%22%3A12.268106000000003%2C%22text%22%3A%22SEMI%20SPACE%22%7D%2C%7B%22x%22%3A95.14265%2C%22y%22%3A165.77971%2C%22width%22%3A210.86158999999998%2C%22height%22%3A19.462890000000016%2C%22text%22%3A%22NEW%20SPACE(YOUNG%20GENERATION)%22%7D%2C%7B%22x%22%3A434.10275%2C%22y%22%3A167.16414%2C%22width%22%3A183.74374999999998%2C%22height%22%3A17.497680000000003%2C%22text%22%3A%22OLD%20SPACE(OLD%20GENERATION)%22%7D%2C%7B%22x%22%3A570.13257%2C%22y%22%3A212.17964%2C%22width%22%3A58.963070000000016%2C%22height%22%3A13.833859999999987%2C%22text%22%3A%22CELL%20SPACE%22%7D%2C%7B%22x%22%3A93.98172%2C%22y%22%3A234.87941%2C%22width%22%3A105.68308000000002%2C%22height%22%3A12.432789999999983%2C%22text%22%3A%22LARGE%20OBJECT%20SPACE%22%7D%2C%7B%22x%22%3A345.962%2C%22y%22%3A235.78162%2C%22width%22%3A65.50576999999998%2C%22height%22%3A10.724609999999984%2C%22text%22%3A%22CODE%20SPACE%22%7D%2C%7B%22x%22%3A545.0808%2C%22y%22%3A256.35712%2C%22width%22%3A107.5032500000001%2C%22height%22%3A13.474080000000015%2C%22text%22%3A%22PROPERTY%20CELL%20SPACE%22%7D%2C%7B%22x%22%3A568.84784%2C%22y%22%3A300.43863%2C%22width%22%3A61.11536000000001%2C%22height%22%3A12.35759999999999%2C%22text%22%3A%22MAP%20SPACE%22%7D%2C%7B%22x%22%3A318.72552%2C%22y%22%3A314.26813%2C%22width%22%3A98.75315%2C%22height%22%3A15.414770000000033%2C%22text%22%3A%22HEAP%20MEMORY%22%7D%2C%7B%22x%22%3A348.68347%2C%22y%22%3A366.54114%2C%22width%22%3A39.46492999999998%2C%22height%22%3A13.455660000000023%2C%22text%22%3A%22STACK%22%7D%5D%2C%22id%22%3A%22u7c79c968%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><ul list=\"uc913a8be\"><li fid=\"ua2b5d768\" data-lake-id=\"u95fe2af3\" id=\"u95fe2af3\"><span data-lake-id=\"uf7f3713a\" id=\"uf7f3713a\">新生代(New Space/Young Generation)：大多数新生对象被分配到这，分为两块空间，整体占据小块空间，垃圾回收的频率较高，采用的回收算法为 </span><strong><span data-lake-id=\"ue39f2889\" id=\"ue39f2889\">Scavenge 算法</span></strong></li><li fid=\"ua2b5d768\" data-lake-id=\"u144f8145\" id=\"u144f8145\"><span data-lake-id=\"u39589853\" id=\"u39589853\">老生代(Old Space/Old Generation)：大多数在新生区存活一段时间后的对象会转移至此，采用的回收算法为 </span><strong><span data-lake-id=\"u26483e37\" id=\"u26483e37\">标记清除 &amp; 整理算法(Mark-Sweep &amp; Mark-compact，Major GC)</span></strong><span data-lake-id=\"u284f2963\" id=\"u284f2963\">，内部再细分为两个空间</span></li></ul><ul list=\"uc913a8be\" data-lake-indent=\"1\"><li fid=\"ua2b5d768\" data-lake-id=\"u19da43ac\" id=\"u19da43ac\"><span data-lake-id=\"ua744a2ae\" id=\"ua744a2ae\">指针空间(Old pointer space)：存储的对象含有指向其他对象的指针</span></li><li fid=\"ua2b5d768\" data-lake-id=\"u37d6d4cd\" id=\"u37d6d4cd\"><span data-lake-id=\"u73d688b5\" id=\"u73d688b5\">数据空间：存储的对象仅包含数据，无指向其他对象的指针</span></li></ul><ul list=\"uc913a8be\" start=\"3\"><li fid=\"ua2b5d768\" data-lake-id=\"u59f2cbf9\" id=\"u59f2cbf9\"><span data-lake-id=\"u31251062\" id=\"u31251062\">大对象空间(Large Object Space)：存储超过其他空间(Space)限制的大对象，垃圾回收器从不移动此空间中的对象</span></li><li fid=\"ua2b5d768\" data-lake-id=\"uf9a14612\" id=\"uf9a14612\"><span data-lake-id=\"u293c2b02\" id=\"u293c2b02\">代码空间(Code Space)：代码对象，用于存放代码段，是</span><strong><span data-lake-id=\"u38e797f1\" id=\"u38e797f1\">唯一拥有执行权限的内存空间</span></strong><span data-lake-id=\"u76c88fe6\" id=\"u76c88fe6\">，需要注意的是：如果代码对象太大而被移入大对象空间，这个代码对象在大对象空间内也是拥有执行权限的，但不能因此说大对象空间也有执行权限</span></li><li fid=\"ua2b5d768\" data-lake-id=\"u031e3b75\" id=\"u031e3b75\"><span data-lake-id=\"ua1347c11\" id=\"ua1347c11\">Cell 空间、属性空间、Map 空间(Cell，Property，Map Space)：这些区域存放 Cell、属性 Cell 和 Map，每个空间因为都是存放大小相同的元素，因此内存结构很简单</span></li></ul><h3 data-lake-id=\"nRhSZ\" id=\"nRhSZ\"><span data-lake-id=\"ua9f3cb6a\" id=\"ua9f3cb6a\">Scavenge 算法</span></h3><p data-lake-id=\"u415a7165\" id=\"u415a7165\"><span data-lake-id=\"u923a24ec\" id=\"u923a24ec\">Scavenge 算法是新生代空间中的主要算法，该算法由 C.J. Cheney 在 1970 年在论文 </span><a href=\"https://link.segmentfault.com/?enc=2MXpNEEIQ6lZda4j1X55yA%3D%3D.cQM0pgzjhMjEsvKJZuTkoYWz3TuFArSmJclq4DkPUooVgJZmvfxML2GEC8d1tr06\" target=\"_blank\" data-lake-id=\"u0c8d1a63\" id=\"u0c8d1a63\"><span data-lake-id=\"u0a13d8d5\" id=\"u0a13d8d5\">A nonrecursive list compacting algorithm</span></a><span data-lake-id=\"ub205ec6c\" id=\"ub205ec6c\"> 提出</span></p><p data-lake-id=\"uf13e08b9\" id=\"uf13e08b9\"><span data-lake-id=\"ue81e5b70\" id=\"ue81e5b70\">Scavenge 主要采用了 Cheney 算法，Cheney 算法新生代空间的堆内存分为 2 块同样大小的空间，称为 Semi space，处于使用状态的称为 From 空间，闲置的称为 To 空间。垃圾回收过程如下：</span></p><ul list=\"u2ac66a68\"><li fid=\"u947c43e8\" data-lake-id=\"uee9c24f4\" id=\"uee9c24f4\"><span data-lake-id=\"u1a0cc676\" id=\"u1a0cc676\">检查 From 空间，如果 From 空间被分配满了，则执行 Scavenge 算法进行垃圾回收</span></li><li fid=\"u947c43e8\" data-lake-id=\"u9a03c5ba\" id=\"u9a03c5ba\"><span data-lake-id=\"u31dd8800\" id=\"u31dd8800\">如果未分配满，则检查 From 空间是否有存活对象，如果如存活对象，则直接释放未存活对象的空间</span></li><li fid=\"u947c43e8\" data-lake-id=\"u3cbad116\" id=\"u3cbad116\"><span data-lake-id=\"u5eb3bf72\" id=\"u5eb3bf72\">如果存活，将检查对象是否符合晋升条件，如果符合晋升条件，则被移入老生代空间，否则将对象直接复制进 To 空间</span></li><li fid=\"u947c43e8\" data-lake-id=\"u555c40d6\" id=\"u555c40d6\"><span data-lake-id=\"ue22660e7\" id=\"ue22660e7\">完成复制后将 From 和 To 空间角色互换，然后再从第一步开始执行</span></li></ul><h4 data-lake-id=\"LBFQx\" id=\"LBFQx\"><span data-lake-id=\"u33c9149b\" id=\"u33c9149b\">晋升条件</span></h4><ol list=\"ucd97cff0\"><li fid=\"u4cbc7265\" data-lake-id=\"u3536a517\" id=\"u3536a517\"><span data-lake-id=\"u30109d51\" id=\"u30109d51\">经历过一次 Scavenge 算法</span></li><li fid=\"u4cbc7265\" data-lake-id=\"u905cc3a1\" id=\"u905cc3a1\"><span data-lake-id=\"u0e1b2e47\" id=\"u0e1b2e47\">To 空间内存使用超过 25%</span></li></ol><p data-lake-id=\"u484a3935\" id=\"u484a3935\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647062175852-1ecf81c7-c8dc-4b8e-8523-da8c75535353.png%22%2C%22taskId%22%3A%22u578938ec-257f-4865-9a09-469d46f9173%22%2C%22clientId%22%3A%22u35b2ec58-59dc-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A682%2C%22height%22%3A478%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A42571%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A682%2C%22originHeight%22%3A478%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22SEMISPACE%20(FROM)%20%E7%BB%8F%E5%8E%86%E8%BF%87SCAVENGE%E5%9B%9E%E6%94%B6%20SEMISPACE%20%E6%88%96%20(TO)%20TO%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E8%B6%85%E8%BF%8725%25%20%E8%80%81%E7%94%9F%E4%BB%A3%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A147.76027%2C%22y%22%3A48.529526%2C%22width%22%3A81.41496000000001%2C%22height%22%3A14.342296000000005%2C%22text%22%3A%22SEMISPACE%22%7D%2C%7B%22x%22%3A158.88933%2C%22y%22%3A66.676994%2C%22width%22%3A56.85903999999999%2C%22height%22%3A14.018996000000001%2C%22text%22%3A%22(FROM)%22%7D%2C%7B%22x%22%3A111.94614%2C%22y%22%3A203.46759%2C%22width%22%3A153.54213999999996%2C%22height%22%3A20.25605999999999%2C%22text%22%3A%22%E7%BB%8F%E5%8E%86%E8%BF%87SCAVENGE%E5%9B%9E%E6%94%B6%22%7D%2C%7B%22x%22%3A522.16974%2C%22y%22%3A217.27583%2C%22width%22%3A80.70911000000001%2C%22height%22%3A14.98214999999999%2C%22text%22%3A%22SEMISPACE%22%7D%2C%7B%22x%22%3A177.68791%2C%22y%22%3A227.5721%2C%22width%22%3A21.40010000000001%2C%22height%22%3A14.805049999999994%2C%22text%22%3A%22%E6%88%96%22%7D%2C%7B%22x%22%3A538.60016%2C%22y%22%3A234.11354%2C%22width%22%3A44.020380000000046%2C%22height%22%3A18.30779000000001%2C%22text%22%3A%22(TO)%22%7D%2C%7B%22x%22%3A114.33179%2C%22y%22%3A242.79128%2C%22width%22%3A148.09753%2C%22height%22%3A16.25239000000002%2C%22text%22%3A%22TO%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E8%B6%85%E8%BF%8725%25%22%7D%2C%7B%22x%22%3A165.48355%2C%22y%22%3A414.6543%2C%22width%22%3A47.15178%2C%22height%22%3A17.511230000000012%2C%22text%22%3A%22%E8%80%81%E7%94%9F%E4%BB%A3%22%7D%5D%2C%22id%22%3A%22u773b7ab8%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h3 data-lake-id=\"cWPJf\" id=\"cWPJf\"><span data-lake-id=\"u865ba42d\" id=\"u865ba42d\">标记清除 &amp; 整理算法(</span><span data-lake-id=\"u78ec6702\" id=\"u78ec6702\" style=\"color: rgb(33, 37, 41)\">Mark-Sweep &amp; Mark-Compact，Major GC)算法</span></h3><p data-lake-id=\"u6bf77c8a\" id=\"u6bf77c8a\"><span data-lake-id=\"u8bd50811\" id=\"u8bd50811\">之前说过，标记清除策略会产生内存碎片，从而影响内存的使用，这里 标记整理算法(Mark-Compact)的出现就能很好的解决这个问题。标记整理算法是在 标记清除(Mark-Sweep)的基础上演变而来的，整理算法会将活跃的对象往边界移动，完成移动后，再清除不活跃的对象。</span></p><p data-lake-id=\"ua5e304b5\" id=\"ua5e304b5\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647062229721-d6577e13-84aa-468d-84ab-117dc0bd7f54.png%22%2C%22taskId%22%3A%22ubbded5e8-a90c-4e6e-bf67-09b57349642%22%2C%22clientId%22%3A%22u35b2ec58-59dc-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A621%2C%22height%22%3A343%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A44372%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A621%2C%22originHeight%22%3A343%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E5%8F%AF%E5%9B%9E%E6%94%B6%20%E6%9C%AA%E4%BD%BF%E7%94%A8%20%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A213.26978%2C%22y%22%3A309.52905%2C%22width%22%3A30.282049999999998%2C%22height%22%3A11.648050000000012%2C%22text%22%3A%22%E5%8F%AF%E5%9B%9E%E6%94%B6%22%7D%2C%7B%22x%22%3A301.676%2C%22y%22%3A309.64713%2C%22width%22%3A30.39733000000001%2C%22height%22%3A12.078300000000013%2C%22text%22%3A%22%E6%9C%AA%E4%BD%BF%E7%94%A8%22%7D%2C%7B%22x%22%3A115.999084%2C%22y%22%3A310.01352%2C%22width%22%3A36.73902600000001%2C%22height%22%3A10.361139999999978%2C%22text%22%3A%22%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%22%7D%5D%2C%22id%22%3A%22ua8d089de%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u6f062ec0\" id=\"u6f062ec0\"><span data-lake-id=\"u76ce6974\" id=\"u76ce6974\">由于需要移动移动对象，所以在处理速度上，会慢于 Mark-Sweep</span></p><h3 data-lake-id=\"ShUgB\" id=\"ShUgB\"><span data-lake-id=\"uc33672bf\" id=\"uc33672bf\">全停顿(Stop The World)</span></h3><p data-lake-id=\"u068c24fa\" id=\"u068c24fa\"><span data-lake-id=\"u437d6dbc\" id=\"u437d6dbc\">为了避免应用逻辑与垃圾回收器看到的逻辑不一样，垃圾回收器在执行回收时会停止应用逻辑，执行完回收任务后，再继续执行应用逻辑，这种行为就是 </span><strong><span data-lake-id=\"u2633d8a3\" id=\"u2633d8a3\">全停顿</span></strong><span data-lake-id=\"u4d080354\" id=\"u4d080354\">。停顿的时间取决于不同引擎执行一次垃圾回收的时间。这种停顿对新生代空间的影响较小，但对老生代空间可能会造成停顿的现象</span></p><h3 data-lake-id=\"q8Idc\" id=\"q8Idc\"><span data-lake-id=\"u5d3205e2\" id=\"u5d3205e2\">增量标记(</span><span data-lake-id=\"uf900bc17\" id=\"uf900bc17\" style=\"color: rgb(33, 37, 41)\">Incremental Marking</span><span data-lake-id=\"u2f23884a\" id=\"u2f23884a\">)</span></h3><p data-lake-id=\"u5622c545\" id=\"u5622c545\"><span data-lake-id=\"u2fdd1e6b\" id=\"u2fdd1e6b\">为了解决全停顿的现象，2011 年 v8 推出了增量标记。v8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 js 应用逻辑交替进行，直至标记完成</span></p><p data-lake-id=\"u4ffdf691\" id=\"u4ffdf691\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647062475529-09dd3980-657f-4eaa-ac95-bed7a6a0702a.png%22%2C%22taskId%22%3A%22ue1c8b542-1157-4fa0-97bf-744ba239cc5%22%2C%22clientId%22%3A%22u35b2ec58-59dc-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A732%2C%22height%22%3A205%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A31980%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A732%2C%22originHeight%22%3A205%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22JAVASCRIPT%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%87%E8%AE%B0%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%20-%E6%B8%85%E7%90%86%2F%E6%95%B4%E7%90%86%20(%E5%81%9C%E9%A1%BF)%20%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A32.71419%2C%22y%22%3A47.081264%2C%22width%22%3A87.90725%2C%22height%22%3A21.85746600000001%2C%22text%22%3A%22JAVASCRIPT%22%7D%2C%7B%22x%22%3A190.98132%2C%22y%22%3A101.60064%2C%22width%22%3A104.04781999999997%2C%22height%22%3A23.566019999999995%2C%22text%22%3A%22%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%87%E8%AE%B0%22%7D%2C%7B%22x%22%3A33.529922%2C%22y%22%3A112.3727%2C%22width%22%3A83.283432%2C%22height%22%3A22.178399999999996%2C%22text%22%3A%22%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%22%7D%2C%7B%22x%22%3A515.7261%2C%22y%22%3A113.65208%2C%22width%22%3A100.44900000000007%2C%22height%22%3A21.64112999999999%2C%22text%22%3A%22-%E6%B8%85%E7%90%86%2F%E6%95%B4%E7%90%86%22%7D%2C%7B%22x%22%3A212.68694%2C%22y%22%3A127.45011%2C%22width%22%3A60.08670999999998%2C%22height%22%3A20.881020000000007%2C%22text%22%3A%22(%E5%81%9C%E9%A1%BF)%22%7D%2C%7B%22x%22%3A367.8912%2C%22y%22%3A173.27136%2C%22width%22%3A83.26666999999998%2C%22height%22%3A22.410080000000022%2C%22text%22%3A%22%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0%22%7D%5D%2C%22id%22%3A%22ucc387e50%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:32:59.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:59.000Z",
  "updated_at": "2022-05-10T15:12:41.000Z",
  "published_at": "2022-04-04T11:32:59.000Z",
  "first_published_at": "2022-04-04T11:32:58.563Z",
  "word_count": 2253,
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1647015547785-64a07e0f-2f3f-4759-9b81-5ed68b2dbe34.png",
  "description": "内存生命周期内存分配声明变量、函数、对象的时候，javaScript 会自动分配内存内存使用调用的时候，使用的时候内存回收javaScript 的垃圾回收机制存储方式栈内存 stack自动分配内存空间，大小固定，会自动释放 堆内存 heap动态分配内存，大小不固定，不会自动释放javaScri...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}