{
  "id": 72212045,
  "slug": "wqgptk",
  "title": "组件缓存(keep-alive)",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。\n\n常用的两个属性 include/exclude，允许组件有条件的进行缓存。\n\n两个生命周期 activated(命中缓存时调用)/deactivated(切换时调用)，用来得知当前组件是否处于活跃状态。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。\n\nkeep-alive 的中还运用了 LRU(Least Recently Used)算法。\n<a name=\"BEZtk\"></a>\n## LRU(Least Recently Used)缓存策略\nLRU 缓存策略：<br />从内存中找出最久未使用的数据并置换新的数据。 LRU(Least Recently Used)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 \"如果数据最近被访问过，那么将来被访问的几率也更高\"。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：\n\n- 新数据插入到链表头部\n- 每当缓存命中（即缓存数据被访问），则将数据移到链表头部\n- 链表满的时候，将链表尾部的数据丢弃。\n",
  "body_draft": "",
  "body_html": "<!doctype html><p data-lake-id=\"u6f488bc5\"><span>keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</span></p><p data-lake-id=\"u07144abf\"><span>​</span><br /></p><p data-lake-id=\"u5c620eb7\"><span>常用的两个属性 include/exclude，允许组件有条件的进行缓存。</span></p><p data-lake-id=\"udf6155a6\"><span>​</span><br /></p><p data-lake-id=\"u47c03251\"><span>两个生命周期 activated(命中缓存时调用)/deactivated(切换时调用)，用来得知当前组件是否处于活跃状态。</span><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</span></p><p data-lake-id=\"u251f81f6\"><span>​</span><br /></p><p data-lake-id=\"uf25ff4a6\"><span>keep-alive 的中还运用了 LRU(Least Recently Used)算法。</span></p><h2 id=\"BEZtk\"><span>LRU(Least Recently Used)缓存策略</span></h2><p data-lake-id=\"u1be53309\"><span>LRU 缓存策略：</span></p><p data-lake-id=\"u156bdfde\" style=\"text-indent: 2em;\"><span>从内存中找出最久未使用的数据并置换新的数据。 LRU(Least Recently Used)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 &quot;如果数据最近被访问过，那么将来被访问的几率也更高&quot;。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</span></p><ul><li><span>新数据插入到链表头部</span></li><li><span>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</span></li><li><span>链表满的时候，将链表尾部的数据丢弃。</span></li></ul>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u6f488bc5\" id=\"u6f488bc5\"><span data-lake-id=\"uea9a08d2\" id=\"uea9a08d2\">keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</span></p><p data-lake-id=\"u07144abf\" id=\"u07144abf\"><span data-lake-id=\"uf7b690d3\" id=\"uf7b690d3\">​</span><br></p><p data-lake-id=\"u5c620eb7\" id=\"u5c620eb7\"><span data-lake-id=\"ud7a12827\" id=\"ud7a12827\">常用的两个属性 include/exclude，允许组件有条件的进行缓存。</span></p><p data-lake-id=\"udf6155a6\" id=\"udf6155a6\"><span data-lake-id=\"u84a6854c\" id=\"u84a6854c\">​</span><br></p><p data-lake-id=\"u47c03251\" id=\"u47c03251\"><span data-lake-id=\"u4810fba9\" id=\"u4810fba9\">两个生命周期 activated(命中缓存时调用)/deactivated(切换时调用)，用来得知当前组件是否处于活跃状态。</span><span data-lake-id=\"ud22d32f8\" id=\"ud22d32f8\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</span></p><p data-lake-id=\"u251f81f6\" id=\"u251f81f6\"><span data-lake-id=\"uff6bbfd1\" id=\"uff6bbfd1\">​</span><br></p><p data-lake-id=\"uf25ff4a6\" id=\"uf25ff4a6\"><span data-lake-id=\"u1ba506d4\" id=\"u1ba506d4\">keep-alive 的中还运用了 LRU(Least Recently Used)算法。</span></p><h2 data-lake-id=\"BEZtk\" id=\"BEZtk\"><span data-lake-id=\"u2040313c\" id=\"u2040313c\">LRU(Least Recently Used)缓存策略</span></h2><p data-lake-id=\"u1be53309\" id=\"u1be53309\"><span data-lake-id=\"u456186ee\" id=\"u456186ee\">LRU 缓存策略：</span></p><p data-lake-id=\"u156bdfde\" id=\"u156bdfde\" style=\"text-indent: 2em\"><span data-lake-id=\"uf9a325da\" id=\"uf9a325da\">从内存中找出最久未使用的数据并置换新的数据。 LRU(Least Recently Used)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 &quot;如果数据最近被访问过，那么将来被访问的几率也更高&quot;。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</span></p><ul list=\"uf581ea5a\"><li fid=\"ufe713591\" data-lake-id=\"ub63283b8\" id=\"ub63283b8\"><span data-lake-id=\"u2e182733\" id=\"u2e182733\">新数据插入到链表头部</span></li><li fid=\"ufe713591\" data-lake-id=\"u673b20e7\" id=\"u673b20e7\"><span data-lake-id=\"uce342ebc\" id=\"uce342ebc\">每当缓存命中（即缓存数据被访问），则将数据移到链表头部</span></li><li fid=\"ufe713591\" data-lake-id=\"ubd535e4e\" id=\"ubd535e4e\"><span data-lake-id=\"u86472aba\" id=\"u86472aba\">链表满的时候，将链表尾部的数据丢弃。</span></li></ul>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:32:42.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:42.000Z",
  "updated_at": "2022-05-10T15:12:43.000Z",
  "published_at": "2022-04-04T11:32:42.000Z",
  "first_published_at": "2022-04-04T11:32:41.928Z",
  "word_count": 305,
  "cover": null,
  "description": "keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。常用的两个属性 include/exclude，允许组件有条件的进行缓存。两个生命周期 activated(命中缓存时调用)/deactivated(切换时调用)，用来得知当前组件是否处于活跃状态。同时，beforeD...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}