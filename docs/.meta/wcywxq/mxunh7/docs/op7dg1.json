{
  "id": 72212178,
  "slug": "op7dg1",
  "title": "diff 算法",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"K2rDx\"></a>\n## diff 算法策略\n:::info\n`diff` 算法的三个策略(观察的规律)\n\n1. `dom` 节点的跨层级移动操作特别少，可以忽略不计\n2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构\n3. 对于同一层级的一组子节点，可以通过唯一的 `id(key)` 进行区分\n:::\n<a name=\"pu6qR\"></a>\n### tree diff\n因为以上三个策略中的第一点，`dom` 节点的跨级操作比较少，那么 `diff` 算法只会对相同层级的 `dom` 节点进行比较。<br />如果发现节点不存在，那么会将该节点以及其子节点完全删除，不会再继续比较。<br />如果出现了 `dom` 节点的跨层级移动操作，那么会删除该节点以及其所有的子节点，然后再移动后的为重新创建。\n<a name=\"gVsIr\"></a>\n### component diff\n如果是同一类型的组件，那么会继续对比 `vm` (虚拟 `dom`)数。<br />如果不是同一类型的组件，那么会将其和子节点完全替换，不会再进行比对。<br />同一类型的组件，有可能 `vm` 没有任何的变化，如果可以确定的知道这一点，就可以节省大量的 diff 时间，所以用户可以设置 `shouldComponentUpdate` 判断段是否需要进行 `diff` 算法。\n<a name=\"cuAh5\"></a>\n### element diff\n当节点处于同一层级的时候时，有三种操作：`INSERT_MAKEUP` 插入、`MOVE_EXISTING` 移动、`REMOVE_NODE` 删除，这里 `react` 有一个优化策略，对于同一层级的同组子节点，添加唯一的 `key` 进行区分。<br />这样的话，就可以判断出来是否是移动节点。通过 `key` 发现新旧集合中的节点都会相同的节点，就只需要进行移动操作即可。\n<a name=\"zZkou\"></a>\n## 重新渲染 render 会做些什么\n\n- 会对新旧 `VNode` 进行对比，也就是 `diff` 算法\n- 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\n- 遍历差异对象，根据差异的类型，根据对应规则更新 `VNode`\n<a name=\"wmsRg\"></a>\n## diff 算法的执行过程\n\n1. 同级比较，然后比较子节点\n2. 先判断一方有子节点而另外一方没有子节点的情况(如果新的 `children` 没有子节点，则将旧的子节点移除)\n3. 比较双方都有子节点的情况 (核心 `diff`)\n4. 递归比较子节点\n<a name=\"oFlGt\"></a>\n## react 的 diff 算法\n`diff` 算法是指生成更新补丁的方式，主要应用于虚拟 `DOM` 树变化后，更新真实 `DOM`。所以 `diff` 算法一定存在这样一个过程：**触发更新 → 生成补丁 → 应用补丁**。\n\n`React` 的 `diff` 算法，触发更新的时机主要在 `state` 变化与 `hooks` 调用之后。此时触发虚拟 `DOM` 树变更遍历，采用了**深度优先遍历算法**。但传统的遍历方式，效率较低。为了优化效率，使用了**分治**的方式。将单一节点比对转化为了 `3` 种类型节点的比对，分别是**树、组件及元素**，以此提升效率。\n\n- 树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 `DOM` 树只对同一层次的节点进行比较。\n- 组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。\n- 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 `DOM` 剪裁操作。\n\n以上是经典的 `React diff` 算法内容。自 `React 16` 起，引入了 `Fiber` 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 `FiberNode` 与 `FiberTree` 进行重构。\n\n`fiberNode` 使用了**双链表**的结构，可以直接找到兄弟节点与子节点。整个更新过程由 `current` 与 `workInProgress` 两株树双缓冲完成。`workInProgress` 更新完成后，再通过修改 `current` 相关指针指向新节点。\n<a name=\"h6d6E\"></a>\n## vue 的 diff 算法\n[https://juejin.cn/post/7113734401434845191](https://juejin.cn/post/7113734401434845191)<br />正常 `diff` 两个树的时间复杂度是 `O(n^3)`，但实际情况下我们很少会跨层级去移动 `dom`，所以 `vue` 将 `diff` 进行了优化，将时间复杂度从 `O(n^3)`优化为 `O(n)`，只有当新旧 `children` 都为多个子节点时才需要用核心的 `diff` 算法来进行同层比较\n<a name=\"d90cm\"></a>\n### diff 算法的核心-vue2\n`vue2` 的核心 `diff` 算法采用了 **双端比较** 的算法，即同时从新旧 `children` 的两端开始进行比较(头尾指针)，借助 `key` 值找到可复用的节点，然后进行相关操作。对比于 `react` 的 `diff` 算法而言，在相同情况下可以**减少节点的移动次数**，从而减少不必要的性能损耗，整体而言更加优雅。\n<a name=\"rmTp3\"></a>\n### diff 算法的核心-vue3\n`vue3` 借鉴了 **ivi 算法** 和 **inferno 算法**，在创建 `vnode` 的时候就确定其类型，以及在 `mount`/`patch` 的过程中采用 **位运算 **来判断一个 `vnode` 的类型，在这个基础之上再配合核心的 `diff` 算法(双端比较算法)，使得性能上较 `vue2` 而言得到了显著的提升。另外，该算法中还运用了动态规划的思想求解最长递增子序列\n```javascript\n// 位运算\nTEXT = 1 // --取值是1---表示具有动态textContent的元素\nCLASS = 1 << 1 // --取值是2---表示有动态Class的元素\nSTYLE = 1 << 2 // --取值是4---表示动态样式（静态如style=\"color: pink\"，也会提升至动态）\nPROPS = 1 << 3 // --取值是8--- 表示具有非类/样式动态道具的元素\nFULL_PROPS = 1 << 4 // --取值是16---表示带有动态键的道具的元素，与上面三种相斥\nHYDRATE_EVENTS = 1 << 5 // --取值是32---表示带有事件监听器的元素\nSTABLE_FRAGMENT = 1 << 6 // --取值是64---表示其子顺序不变，不会改变自顺序的片段。\nKEYED_FRAGMENT = 1 << 7 // --取值是128---表示带有键控或部分键控子元素的片段。\nUNKEYED_FRAGMENT = 1 << 8 // --取值是256---子节点无key绑定的片段（fragment）\nNEED_PATCH = 1 << 9 // --取值是512---表示只需要非属性补丁的元素，例如 ref 或 hooks\nDYNAMIC_SLOTS = 1 << 10 // --取值是1024---表示具有动态插槽的元素\n```\n\n---\n\n\n---\n\n<a name=\"ZboGs\"></a>\n## vue2 和 vue3 的 diff 算法对比\n\n- `vue3` 在 `vue2` 的双端比较算法上做了进一步优化，它只会比较动态节点而忽略静态节点，极大的提高了效率，在实现上采取了**双指针**的思想。另外，该算法中还运用了动态规划的思想求解最长递增子序列\n- `vue3` 新增了 **静态标记 (**`**patch flag**`**)**，与上次虚拟节点对比，只会对比带有 `patch flag` 的节点\n<a name=\"EzUzn\"></a>\n## React 与 Vue 的 diff 算法有何不同\n`Vue` 的整体 `diff` 策略与 `React` 对齐，虽然缺乏时间切片能力，但这并不意味着 `Vue` 的性能更差，因为在 `Vue 3` 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 `Vue` 中其他的场景几乎都可以使用防抖和节流去提高响应性能。\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"K2rDx\"><span class=\"ne-text\">diff 算法策略</span></h2><div data-type=\"info\" class=\"ne-alert\"><p id=\"ucd35f88d\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法的三个策略(观察的规律)</span></p><ol class=\"ne-ol\"><li id=\"ue3fbebf7\"><code class=\"ne-code\"><span class=\"ne-text\">dom</span></code><span class=\"ne-text\"> 节点的跨层级移动操作特别少，可以忽略不计</span></li><li id=\"u5b2c0a30\"><span class=\"ne-text\">拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构</span></li><li id=\"u2f40c8bb\"><span class=\"ne-text\">对于同一层级的一组子节点，可以通过唯一的 </span><code class=\"ne-code\"><span class=\"ne-text\">id(key)</span></code><span class=\"ne-text\"> 进行区分</span></li></ol></div><h3 id=\"pu6qR\"><span class=\"ne-text\">tree diff</span></h3><p id=\"u2811c85b\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">因为以上三个策略中的第一点，</span><code class=\"ne-code\"><span class=\"ne-text\">dom</span></code><span class=\"ne-text\"> 节点的跨级操作比较少，那么 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法只会对相同层级的 </span><code class=\"ne-code\"><span class=\"ne-text\">dom</span></code><span class=\"ne-text\"> 节点进行比较。</span></p><p id=\"u03eb9e50\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">如果发现节点不存在，那么会将该节点以及其子节点完全删除，不会再继续比较。</span></p><p id=\"u7930e2a9\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">如果出现了 </span><code class=\"ne-code\"><span class=\"ne-text\">dom</span></code><span class=\"ne-text\"> 节点的跨层级移动操作，那么会删除该节点以及其所有的子节点，然后再移动后的为重新创建。</span></p><h3 id=\"gVsIr\"><span class=\"ne-text\">component diff</span></h3><p id=\"uce9ef1b7\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">如果是同一类型的组件，那么会继续对比 </span><code class=\"ne-code\"><span class=\"ne-text\">vm</span></code><span class=\"ne-text\"> (虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">dom</span></code><span class=\"ne-text\">)数。</span></p><p id=\"ufc26afc3\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">如果不是同一类型的组件，那么会将其和子节点完全替换，不会再进行比对。</span></p><p id=\"u65916c3b\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">同一类型的组件，有可能 </span><code class=\"ne-code\"><span class=\"ne-text\">vm</span></code><span class=\"ne-text\"> 没有任何的变化，如果可以确定的知道这一点，就可以节省大量的 diff 时间，所以用户可以设置 </span><code class=\"ne-code\"><span class=\"ne-text\">shouldComponentUpdate</span></code><span class=\"ne-text\"> 判断段是否需要进行 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法。</span></p><h3 id=\"cuAh5\"><span class=\"ne-text\">element diff</span></h3><p id=\"u025b45bb\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">当节点处于同一层级的时候时，有三种操作：</span><code class=\"ne-code\"><span class=\"ne-text\">INSERT_MAKEUP</span></code><span class=\"ne-text\"> 插入、</span><code class=\"ne-code\"><span class=\"ne-text\">MOVE_EXISTING</span></code><span class=\"ne-text\"> 移动、</span><code class=\"ne-code\"><span class=\"ne-text\">REMOVE_NODE</span></code><span class=\"ne-text\"> 删除，这里 </span><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 有一个优化策略，对于同一层级的同组子节点，添加唯一的 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 进行区分。</span></p><p id=\"u23150ff6\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">这样的话，就可以判断出来是否是移动节点。通过 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 发现新旧集合中的节点都会相同的节点，就只需要进行移动操作即可。</span></p><h2 id=\"zZkou\"><span class=\"ne-text\">重新渲染 render 会做些什么</span></h2><ul class=\"ne-ul\"><li id=\"uc334dd48\"><span class=\"ne-text\">会对新旧 </span><code class=\"ne-code\"><span class=\"ne-text\">VNode</span></code><span class=\"ne-text\"> 进行对比，也就是 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法</span></li><li id=\"u211265ae\"><span class=\"ne-text\">对新旧两棵树进行一个深度优先遍历，这样每一个节点都会标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</span></li><li id=\"u5da687e9\"><span class=\"ne-text\">遍历差异对象，根据差异的类型，根据对应规则更新 </span><code class=\"ne-code\"><span class=\"ne-text\">VNode</span></code></li></ul><h2 id=\"wmsRg\"><span class=\"ne-text\">diff 算法的执行过程</span></h2><ol class=\"ne-ol\"><li id=\"ub98a42f9\"><span class=\"ne-text\">同级比较，然后比较子节点</span></li><li id=\"uf50761fa\"><span class=\"ne-text\">先判断一方有子节点而另外一方没有子节点的情况(如果新的 </span><code class=\"ne-code\"><span class=\"ne-text\">children</span></code><span class=\"ne-text\"> 没有子节点，则将旧的子节点移除)</span></li><li id=\"u3f0d2530\"><span class=\"ne-text\">比较双方都有子节点的情况 (核心 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\">)</span></li><li id=\"u34e0cc67\"><span class=\"ne-text\">递归比较子节点</span></li></ol><h2 id=\"oFlGt\"><span class=\"ne-text\">react 的 diff 算法</span></h2><p id=\"u972af08d\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法是指生成更新补丁的方式，主要应用于虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 树变化后，更新真实 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\">。所以 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法一定存在这样一个过程：</span><strong><span class=\"ne-text\">触发更新 → 生成补丁 → 应用补丁</span></strong><span class=\"ne-text\">。</span></p><p id=\"uae867ce4\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ue822d47d\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法，触发更新的时机主要在 </span><code class=\"ne-code\"><span class=\"ne-text\">state</span></code><span class=\"ne-text\"> 变化与 </span><code class=\"ne-code\"><span class=\"ne-text\">hooks</span></code><span class=\"ne-text\"> 调用之后。此时触发虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 树变更遍历，采用了</span><strong><span class=\"ne-text\">深度优先遍历算法</span></strong><span class=\"ne-text\">。但传统的遍历方式，效率较低。为了优化效率，使用了</span><strong><span class=\"ne-text\">分治</span></strong><span class=\"ne-text\">的方式。将单一节点比对转化为了 </span><code class=\"ne-code\"><span class=\"ne-text\">3</span></code><span class=\"ne-text\"> 种类型节点的比对，分别是</span><strong><span class=\"ne-text\">树、组件及元素</span></strong><span class=\"ne-text\">，以此提升效率。</span></p><ul class=\"ne-ul\"><li id=\"u7b66997c\"><span class=\"ne-text\">树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 树只对同一层次的节点进行比较。</span></li><li id=\"u97a258d6\"><span class=\"ne-text\">组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。</span></li><li id=\"u2a32a2c7\"><span class=\"ne-text\">元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 剪裁操作。</span></li></ul><p id=\"uc792bb2f\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ub965b664\" class=\"ne-p\"><span class=\"ne-text\">以上是经典的 </span><code class=\"ne-code\"><span class=\"ne-text\">React diff</span></code><span class=\"ne-text\"> 算法内容。自 </span><code class=\"ne-code\"><span class=\"ne-text\">React 16</span></code><span class=\"ne-text\"> 起，引入了 </span><code class=\"ne-code\"><span class=\"ne-text\">Fiber</span></code><span class=\"ne-text\"> 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 </span><code class=\"ne-code\"><span class=\"ne-text\">FiberNode</span></code><span class=\"ne-text\"> 与 </span><code class=\"ne-code\"><span class=\"ne-text\">FiberTree</span></code><span class=\"ne-text\"> 进行重构。</span></p><p id=\"u4893f9d3\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u8884ff27\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">fiberNode</span></code><span class=\"ne-text\"> 使用了</span><strong><span class=\"ne-text\">双链表</span></strong><span class=\"ne-text\">的结构，可以直接找到兄弟节点与子节点。整个更新过程由 </span><code class=\"ne-code\"><span class=\"ne-text\">current</span></code><span class=\"ne-text\"> 与 </span><code class=\"ne-code\"><span class=\"ne-text\">workInProgress</span></code><span class=\"ne-text\"> 两株树双缓冲完成。</span><code class=\"ne-code\"><span class=\"ne-text\">workInProgress</span></code><span class=\"ne-text\"> 更新完成后，再通过修改 </span><code class=\"ne-code\"><span class=\"ne-text\">current</span></code><span class=\"ne-text\"> 相关指针指向新节点。</span></p><h2 id=\"h6d6E\"><span class=\"ne-text\">vue 的 diff 算法</span></h2><p id=\"u0d472aaf\" class=\"ne-p\"><a href=\"https://juejin.cn/post/7113734401434845191\" data-href=\"https://juejin.cn/post/7113734401434845191\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://juejin.cn/post/7113734401434845191</span></a></p><p id=\"u1f23837d\" class=\"ne-p\"><span class=\"ne-text\">正常 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 两个树的时间复杂度是 </span><code class=\"ne-code\"><span class=\"ne-text\">O(n^3)</span></code><span class=\"ne-text\">，但实际情况下我们很少会跨层级去移动 </span><code class=\"ne-code\"><span class=\"ne-text\">dom</span></code><span class=\"ne-text\">，所以 </span><code class=\"ne-code\"><span class=\"ne-text\">vue</span></code><span class=\"ne-text\"> 将 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 进行了优化，将时间复杂度从 </span><code class=\"ne-code\"><span class=\"ne-text\">O(n^3)</span></code><span class=\"ne-text\">优化为 </span><code class=\"ne-code\"><span class=\"ne-text\">O(n)</span></code><span class=\"ne-text\">，只有当新旧 </span><code class=\"ne-code\"><span class=\"ne-text\">children</span></code><span class=\"ne-text\"> 都为多个子节点时才需要用核心的 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法来进行同层比较</span></p><h3 id=\"d90cm\"><span class=\"ne-text\">diff 算法的核心-vue2</span></h3><p id=\"u807d4afc\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">vue2</span></code><span class=\"ne-text\"> 的核心 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法采用了 </span><strong><span class=\"ne-text\">双端比较</span></strong><span class=\"ne-text\"> 的算法，即同时从新旧 </span><code class=\"ne-code\"><span class=\"ne-text\">children</span></code><span class=\"ne-text\"> 的两端开始进行比较(头尾指针)，借助 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 值找到可复用的节点，然后进行相关操作。对比于 </span><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法而言，在相同情况下可以</span><strong><span class=\"ne-text\">减少节点的移动次数</span></strong><span class=\"ne-text\">，从而减少不必要的性能损耗，整体而言更加优雅。</span></p><h3 id=\"rmTp3\"><span class=\"ne-text\">diff 算法的核心-vue3</span></h3><p id=\"u7a4885d5\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">vue3</span></code><span class=\"ne-text\"> 借鉴了 </span><strong><span class=\"ne-text\">ivi 算法</span></strong><span class=\"ne-text\"> 和 </span><strong><span class=\"ne-text\">inferno 算法</span></strong><span class=\"ne-text\">，在创建 </span><code class=\"ne-code\"><span class=\"ne-text\">vnode</span></code><span class=\"ne-text\"> 的时候就确定其类型，以及在 </span><code class=\"ne-code\"><span class=\"ne-text\">mount</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">patch</span></code><span class=\"ne-text\"> 的过程中采用 </span><strong><span class=\"ne-text\">位运算 </span></strong><span class=\"ne-text\">来判断一个 </span><code class=\"ne-code\"><span class=\"ne-text\">vnode</span></code><span class=\"ne-text\"> 的类型，在这个基础之上再配合核心的 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法(双端比较算法)，使得性能上较 </span><code class=\"ne-code\"><span class=\"ne-text\">vue2</span></code><span class=\"ne-text\"> 而言得到了显著的提升。另外，该算法中还运用了动态规划的思想求解最长递增子序列</span></p><pre data-language=\"javascript\" id=\"GVtZk\" class=\"ne-codeblock language-javascript\">// 位运算\nTEXT = 1 // --取值是1---表示具有动态textContent的元素\nCLASS = 1 &lt;&lt; 1 // --取值是2---表示有动态Class的元素\nSTYLE = 1 &lt;&lt; 2 // --取值是4---表示动态样式（静态如style=&quot;color: pink&quot;，也会提升至动态）\nPROPS = 1 &lt;&lt; 3 // --取值是8--- 表示具有非类/样式动态道具的元素\nFULL_PROPS = 1 &lt;&lt; 4 // --取值是16---表示带有动态键的道具的元素，与上面三种相斥\nHYDRATE_EVENTS = 1 &lt;&lt; 5 // --取值是32---表示带有事件监听器的元素\nSTABLE_FRAGMENT = 1 &lt;&lt; 6 // --取值是64---表示其子顺序不变，不会改变自顺序的片段。\nKEYED_FRAGMENT = 1 &lt;&lt; 7 // --取值是128---表示带有键控或部分键控子元素的片段。\nUNKEYED_FRAGMENT = 1 &lt;&lt; 8 // --取值是256---子节点无key绑定的片段（fragment）\nNEED_PATCH = 1 &lt;&lt; 9 // --取值是512---表示只需要非属性补丁的元素，例如 ref 或 hooks\nDYNAMIC_SLOTS = 1 &lt;&lt; 10 // --取值是1024---表示具有动态插槽的元素</pre><hr id=\"Ig9Oe\" class=\"ne-hr\"><p id=\"u8ec43649\" class=\"ne-p\"><br></p><hr id=\"cx8NM\" class=\"ne-hr\"><h2 id=\"ZboGs\"><span class=\"ne-text\">vue2 和 vue3 的 diff 算法对比</span></h2><ul class=\"ne-ul\"><li id=\"ue3e5765e\"><code class=\"ne-code\"><span class=\"ne-text\">vue3</span></code><span class=\"ne-text\"> 在 </span><code class=\"ne-code\"><span class=\"ne-text\">vue2</span></code><span class=\"ne-text\"> 的双端比较算法上做了进一步优化，它只会比较动态节点而忽略静态节点，极大的提高了效率，在实现上采取了</span><strong><span class=\"ne-text\">双指针</span></strong><span class=\"ne-text\">的思想。另外，该算法中还运用了动态规划的思想求解最长递增子序列</span></li><li id=\"u07c44539\"><code class=\"ne-code\"><span class=\"ne-text\">vue3</span></code><span class=\"ne-text\"> 新增了 </span><strong><span class=\"ne-text\">静态标记 (</span></strong><code class=\"ne-code\"><strong><span class=\"ne-text\">patch flag</span></strong></code><strong><span class=\"ne-text\">)</span></strong><span class=\"ne-text\">，与上次虚拟节点对比，只会对比带有 </span><code class=\"ne-code\"><span class=\"ne-text\">patch flag</span></code><span class=\"ne-text\"> 的节点</span></li></ul><h2 id=\"EzUzn\"><span class=\"ne-text\">React 与 Vue 的 diff 算法有何不同</span></h2><p id=\"u52c442f0\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 的整体 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 策略与 </span><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 对齐，虽然缺乏时间切片能力，但这并不意味着 </span><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 的性能更差，因为在 </span><code class=\"ne-code\"><span class=\"ne-text\">Vue 3</span></code><span class=\"ne-text\"> 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 </span><code class=\"ne-code\"><span class=\"ne-text\">Vue</span></code><span class=\"ne-text\"> 中其他的场景几乎都可以使用防抖和节流去提高响应性能。</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"K2rDx\" id=\"K2rDx\"><span data-lake-id=\"u6a8d58dc\" id=\"u6a8d58dc\">diff 算法策略</span></h2><blockquote data-lake-id=\"u295a2dc5\" id=\"u295a2dc5\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"ucd35f88d\" id=\"ucd35f88d\"><code data-lake-id=\"ub7284c73\" id=\"ub7284c73\"><span data-lake-id=\"u1772e2a3\" id=\"u1772e2a3\">diff</span></code><span data-lake-id=\"u2f53b1ba\" id=\"u2f53b1ba\"> 算法的三个策略(观察的规律)</span></p><ol list=\"uca5c293b\"><li fid=\"u3dc81a63\" data-lake-id=\"ue3fbebf7\" id=\"ue3fbebf7\"><code data-lake-id=\"u976a1b9d\" id=\"u976a1b9d\"><span data-lake-id=\"u4c85e0a8\" id=\"u4c85e0a8\">dom</span></code><span data-lake-id=\"ufdfa40bb\" id=\"ufdfa40bb\"> 节点的跨层级移动操作特别少，可以忽略不计</span></li><li fid=\"u3dc81a63\" data-lake-id=\"u5b2c0a30\" id=\"u5b2c0a30\"><span data-lake-id=\"u1780014f\" id=\"u1780014f\">拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构</span></li><li fid=\"u3dc81a63\" data-lake-id=\"u2f40c8bb\" id=\"u2f40c8bb\"><span data-lake-id=\"u95dc2a38\" id=\"u95dc2a38\">对于同一层级的一组子节点，可以通过唯一的 </span><code data-lake-id=\"u8eb0d48b\" id=\"u8eb0d48b\"><span data-lake-id=\"u816dba11\" id=\"u816dba11\">id(key)</span></code><span data-lake-id=\"ub9996fe4\" id=\"ub9996fe4\"> 进行区分</span></li></ol></blockquote><h3 data-lake-id=\"pu6qR\" id=\"pu6qR\"><span data-lake-id=\"uac97b894\" id=\"uac97b894\">tree diff</span></h3><p data-lake-id=\"u2811c85b\" id=\"u2811c85b\" style=\"text-indent: 2em\"><span data-lake-id=\"u252d1f86\" id=\"u252d1f86\">因为以上三个策略中的第一点，</span><code data-lake-id=\"u3a79aaba\" id=\"u3a79aaba\"><span data-lake-id=\"u88eeed0e\" id=\"u88eeed0e\">dom</span></code><span data-lake-id=\"u1c26181e\" id=\"u1c26181e\"> 节点的跨级操作比较少，那么 </span><code data-lake-id=\"ude81fe7b\" id=\"ude81fe7b\"><span data-lake-id=\"ud1dc5c76\" id=\"ud1dc5c76\">diff</span></code><span data-lake-id=\"ubcc02881\" id=\"ubcc02881\"> 算法只会对相同层级的 </span><code data-lake-id=\"u4dd27257\" id=\"u4dd27257\"><span data-lake-id=\"ub16777d4\" id=\"ub16777d4\">dom</span></code><span data-lake-id=\"u68f5c125\" id=\"u68f5c125\"> 节点进行比较。</span></p><p data-lake-id=\"u03eb9e50\" id=\"u03eb9e50\" style=\"text-indent: 2em\"><span data-lake-id=\"u591db3f8\" id=\"u591db3f8\">如果发现节点不存在，那么会将该节点以及其子节点完全删除，不会再继续比较。</span></p><p data-lake-id=\"u7930e2a9\" id=\"u7930e2a9\" style=\"text-indent: 2em\"><span data-lake-id=\"uf77be866\" id=\"uf77be866\">如果出现了 </span><code data-lake-id=\"u10629a4d\" id=\"u10629a4d\"><span data-lake-id=\"u32021237\" id=\"u32021237\">dom</span></code><span data-lake-id=\"u75e3c7bc\" id=\"u75e3c7bc\"> 节点的跨层级移动操作，那么会删除该节点以及其所有的子节点，然后再移动后的为重新创建。</span></p><h3 data-lake-id=\"gVsIr\" id=\"gVsIr\"><span data-lake-id=\"u3efeb4a3\" id=\"u3efeb4a3\">component diff</span></h3><p data-lake-id=\"uce9ef1b7\" id=\"uce9ef1b7\" style=\"text-indent: 2em\"><span data-lake-id=\"u5f961075\" id=\"u5f961075\">如果是同一类型的组件，那么会继续对比 </span><code data-lake-id=\"uf08987b5\" id=\"uf08987b5\"><span data-lake-id=\"u72ec4564\" id=\"u72ec4564\">vm</span></code><span data-lake-id=\"ub6574b86\" id=\"ub6574b86\"> (虚拟 </span><code data-lake-id=\"ua37ff202\" id=\"ua37ff202\"><span data-lake-id=\"ubf309627\" id=\"ubf309627\">dom</span></code><span data-lake-id=\"ucb2898ab\" id=\"ucb2898ab\">)数。</span></p><p data-lake-id=\"ufc26afc3\" id=\"ufc26afc3\" style=\"text-indent: 2em\"><span data-lake-id=\"u6924ed9a\" id=\"u6924ed9a\">如果不是同一类型的组件，那么会将其和子节点完全替换，不会再进行比对。</span></p><p data-lake-id=\"u65916c3b\" id=\"u65916c3b\" style=\"text-indent: 2em\"><span data-lake-id=\"u5e751883\" id=\"u5e751883\">同一类型的组件，有可能 </span><code data-lake-id=\"u23250d35\" id=\"u23250d35\"><span data-lake-id=\"u9ca8ea3a\" id=\"u9ca8ea3a\">vm</span></code><span data-lake-id=\"u88c1396c\" id=\"u88c1396c\"> 没有任何的变化，如果可以确定的知道这一点，就可以节省大量的 diff 时间，所以用户可以设置 </span><code data-lake-id=\"ub407f6f1\" id=\"ub407f6f1\"><span data-lake-id=\"udb766ed4\" id=\"udb766ed4\">shouldComponentUpdate</span></code><span data-lake-id=\"u21d43a8b\" id=\"u21d43a8b\"> 判断段是否需要进行 </span><code data-lake-id=\"ufb369ad4\" id=\"ufb369ad4\"><span data-lake-id=\"u812812b6\" id=\"u812812b6\">diff</span></code><span data-lake-id=\"u1f3c41d2\" id=\"u1f3c41d2\"> 算法。</span></p><h3 data-lake-id=\"cuAh5\" id=\"cuAh5\"><span data-lake-id=\"u495d84e2\" id=\"u495d84e2\">element diff</span></h3><p data-lake-id=\"u025b45bb\" id=\"u025b45bb\" style=\"text-indent: 2em\"><span data-lake-id=\"u18250fe5\" id=\"u18250fe5\">当节点处于同一层级的时候时，有三种操作：</span><code data-lake-id=\"ub9450b42\" id=\"ub9450b42\"><span data-lake-id=\"u628269fe\" id=\"u628269fe\">INSERT_MAKEUP</span></code><span data-lake-id=\"ud2923886\" id=\"ud2923886\"> 插入、</span><code data-lake-id=\"u379ddc60\" id=\"u379ddc60\"><span data-lake-id=\"u936b69ee\" id=\"u936b69ee\">MOVE_EXISTING</span></code><span data-lake-id=\"u43c1cb91\" id=\"u43c1cb91\"> 移动、</span><code data-lake-id=\"u9494c611\" id=\"u9494c611\"><span data-lake-id=\"ua703aac3\" id=\"ua703aac3\">REMOVE_NODE</span></code><span data-lake-id=\"u8c47aa96\" id=\"u8c47aa96\"> 删除，这里 </span><code data-lake-id=\"u5ca1dccf\" id=\"u5ca1dccf\"><span data-lake-id=\"u619fc546\" id=\"u619fc546\">react</span></code><span data-lake-id=\"ud60f27cd\" id=\"ud60f27cd\"> 有一个优化策略，对于同一层级的同组子节点，添加唯一的 </span><code data-lake-id=\"u046b4681\" id=\"u046b4681\"><span data-lake-id=\"u5ee7d43b\" id=\"u5ee7d43b\">key</span></code><span data-lake-id=\"uff60d655\" id=\"uff60d655\"> 进行区分。</span></p><p data-lake-id=\"u23150ff6\" id=\"u23150ff6\" style=\"text-indent: 2em\"><span data-lake-id=\"ue06eb5bf\" id=\"ue06eb5bf\">这样的话，就可以判断出来是否是移动节点。通过 </span><code data-lake-id=\"u4d7616c0\" id=\"u4d7616c0\"><span data-lake-id=\"u21488cf1\" id=\"u21488cf1\">key</span></code><span data-lake-id=\"u70d76175\" id=\"u70d76175\"> 发现新旧集合中的节点都会相同的节点，就只需要进行移动操作即可。</span></p><h2 data-lake-id=\"zZkou\" id=\"zZkou\"><span data-lake-id=\"u8ef76eef\" id=\"u8ef76eef\">重新渲染 render 会做些什么</span></h2><ul list=\"ub2fedafa\"><li fid=\"ucb05eeb7\" data-lake-id=\"uc334dd48\" id=\"uc334dd48\"><span data-lake-id=\"u4264507d\" id=\"u4264507d\">会对新旧 </span><code data-lake-id=\"u2ca632d7\" id=\"u2ca632d7\"><span data-lake-id=\"u7e15ec58\" id=\"u7e15ec58\">VNode</span></code><span data-lake-id=\"u7fb13e57\" id=\"u7fb13e57\"> 进行对比，也就是 </span><code data-lake-id=\"u61f8de9f\" id=\"u61f8de9f\"><span data-lake-id=\"ucdbdbe91\" id=\"ucdbdbe91\">diff</span></code><span data-lake-id=\"u01c203d5\" id=\"u01c203d5\"> 算法</span></li><li fid=\"ucb05eeb7\" data-lake-id=\"u211265ae\" id=\"u211265ae\"><span data-lake-id=\"ud46c0c8e\" id=\"ud46c0c8e\">对新旧两棵树进行一个深度优先遍历，这样每一个节点都会标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</span></li><li fid=\"ucb05eeb7\" data-lake-id=\"u5da687e9\" id=\"u5da687e9\"><span data-lake-id=\"u1daf2c30\" id=\"u1daf2c30\">遍历差异对象，根据差异的类型，根据对应规则更新 </span><code data-lake-id=\"ub27c5d68\" id=\"ub27c5d68\"><span data-lake-id=\"u1d8a0b6a\" id=\"u1d8a0b6a\">VNode</span></code></li></ul><h2 data-lake-id=\"wmsRg\" id=\"wmsRg\"><span data-lake-id=\"u46af3f97\" id=\"u46af3f97\">diff 算法的执行过程</span></h2><ol list=\"uade40757\"><li fid=\"u998f0a2c\" data-lake-id=\"ub98a42f9\" id=\"ub98a42f9\"><span data-lake-id=\"u53efb0fe\" id=\"u53efb0fe\">同级比较，然后比较子节点</span></li><li fid=\"u998f0a2c\" data-lake-id=\"uf50761fa\" id=\"uf50761fa\"><span data-lake-id=\"u9a4f3df5\" id=\"u9a4f3df5\">先判断一方有子节点而另外一方没有子节点的情况(如果新的 </span><code data-lake-id=\"u542da121\" id=\"u542da121\"><span data-lake-id=\"u75446f8c\" id=\"u75446f8c\">children</span></code><span data-lake-id=\"u32a87ec0\" id=\"u32a87ec0\"> 没有子节点，则将旧的子节点移除)</span></li><li fid=\"u998f0a2c\" data-lake-id=\"u3f0d2530\" id=\"u3f0d2530\"><span data-lake-id=\"u14dcf7ea\" id=\"u14dcf7ea\">比较双方都有子节点的情况 (核心 </span><code data-lake-id=\"u890d1553\" id=\"u890d1553\"><span data-lake-id=\"udba2be39\" id=\"udba2be39\">diff</span></code><span data-lake-id=\"u247a6173\" id=\"u247a6173\">)</span></li><li fid=\"u998f0a2c\" data-lake-id=\"u34e0cc67\" id=\"u34e0cc67\"><span data-lake-id=\"u53954d9e\" id=\"u53954d9e\">递归比较子节点</span></li></ol><h2 data-lake-id=\"oFlGt\" id=\"oFlGt\"><span data-lake-id=\"u710ef312\" id=\"u710ef312\">react 的 diff 算法</span></h2><p data-lake-id=\"u972af08d\" id=\"u972af08d\"><code data-lake-id=\"u8387c220\" id=\"u8387c220\"><span data-lake-id=\"ua58f1a85\" id=\"ua58f1a85\">diff</span></code><span data-lake-id=\"u1e7e4e43\" id=\"u1e7e4e43\"> 算法是指生成更新补丁的方式，主要应用于虚拟 </span><code data-lake-id=\"u737d67d3\" id=\"u737d67d3\"><span data-lake-id=\"ua196b41c\" id=\"ua196b41c\">DOM</span></code><span data-lake-id=\"u32277c01\" id=\"u32277c01\"> 树变化后，更新真实 </span><code data-lake-id=\"uf95291a4\" id=\"uf95291a4\"><span data-lake-id=\"uff1c2efc\" id=\"uff1c2efc\">DOM</span></code><span data-lake-id=\"uc19f3c31\" id=\"uc19f3c31\">。所以 </span><code data-lake-id=\"u4bd9b084\" id=\"u4bd9b084\"><span data-lake-id=\"ue1b65a56\" id=\"ue1b65a56\">diff</span></code><span data-lake-id=\"u3d579cce\" id=\"u3d579cce\"> 算法一定存在这样一个过程：</span><strong><span data-lake-id=\"ud9d82871\" id=\"ud9d82871\">触发更新 → 生成补丁 → 应用补丁</span></strong><span data-lake-id=\"u17b6755a\" id=\"u17b6755a\">。</span></p><p data-lake-id=\"uae867ce4\" id=\"uae867ce4\"><span data-lake-id=\"u69d18885\" id=\"u69d18885\">​</span><br></p><p data-lake-id=\"ue822d47d\" id=\"ue822d47d\"><code data-lake-id=\"u6a961234\" id=\"u6a961234\"><span data-lake-id=\"u123ea87a\" id=\"u123ea87a\">React</span></code><span data-lake-id=\"ub74efefc\" id=\"ub74efefc\"> 的 </span><code data-lake-id=\"ua5419106\" id=\"ua5419106\"><span data-lake-id=\"ua335cfef\" id=\"ua335cfef\">diff</span></code><span data-lake-id=\"u4c45d89a\" id=\"u4c45d89a\"> 算法，触发更新的时机主要在 </span><code data-lake-id=\"ua4f9a2a2\" id=\"ua4f9a2a2\"><span data-lake-id=\"ucf73ae4d\" id=\"ucf73ae4d\">state</span></code><span data-lake-id=\"u455e7204\" id=\"u455e7204\"> 变化与 </span><code data-lake-id=\"u136d3a32\" id=\"u136d3a32\"><span data-lake-id=\"uab58ec28\" id=\"uab58ec28\">hooks</span></code><span data-lake-id=\"u9109f710\" id=\"u9109f710\"> 调用之后。此时触发虚拟 </span><code data-lake-id=\"u27134d49\" id=\"u27134d49\"><span data-lake-id=\"uc54e2137\" id=\"uc54e2137\">DOM</span></code><span data-lake-id=\"u898cf15e\" id=\"u898cf15e\"> 树变更遍历，采用了</span><strong><span data-lake-id=\"u4ccdf4f0\" id=\"u4ccdf4f0\">深度优先遍历算法</span></strong><span data-lake-id=\"u0c0bca94\" id=\"u0c0bca94\">。但传统的遍历方式，效率较低。为了优化效率，使用了</span><strong><span data-lake-id=\"uc7165da8\" id=\"uc7165da8\">分治</span></strong><span data-lake-id=\"ufd46ae7e\" id=\"ufd46ae7e\">的方式。将单一节点比对转化为了 </span><code data-lake-id=\"u8f1bd645\" id=\"u8f1bd645\"><span data-lake-id=\"uf04fd84f\" id=\"uf04fd84f\">3</span></code><span data-lake-id=\"u16186312\" id=\"u16186312\"> 种类型节点的比对，分别是</span><strong><span data-lake-id=\"u815d2cb6\" id=\"u815d2cb6\">树、组件及元素</span></strong><span data-lake-id=\"u08a96345\" id=\"u08a96345\">，以此提升效率。</span></p><ul list=\"u2e5b77fe\"><li fid=\"u0455c165\" data-lake-id=\"u7b66997c\" id=\"u7b66997c\"><span data-lake-id=\"u619f6a9e\" id=\"u619f6a9e\">树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 </span><code data-lake-id=\"ua1135c67\" id=\"ua1135c67\"><span data-lake-id=\"ude7f08d9\" id=\"ude7f08d9\">DOM</span></code><span data-lake-id=\"u8b6a370e\" id=\"u8b6a370e\"> 树只对同一层次的节点进行比较。</span></li><li fid=\"u0455c165\" data-lake-id=\"u97a258d6\" id=\"u97a258d6\"><span data-lake-id=\"u3a335157\" id=\"u3a335157\">组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。</span></li><li fid=\"u0455c165\" data-lake-id=\"u2a32a2c7\" id=\"u2a32a2c7\"><span data-lake-id=\"u29482476\" id=\"u29482476\">元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 </span><code data-lake-id=\"ua8c8db54\" id=\"ua8c8db54\"><span data-lake-id=\"u0ac7774b\" id=\"u0ac7774b\">DOM</span></code><span data-lake-id=\"u2bc0e1eb\" id=\"u2bc0e1eb\"> 剪裁操作。</span></li></ul><p data-lake-id=\"uc792bb2f\" id=\"uc792bb2f\"><span data-lake-id=\"uf02b49be\" id=\"uf02b49be\">​</span><br></p><p data-lake-id=\"ub965b664\" id=\"ub965b664\"><span data-lake-id=\"u4a8cf18f\" id=\"u4a8cf18f\">以上是经典的 </span><code data-lake-id=\"u4b0871e0\" id=\"u4b0871e0\"><span data-lake-id=\"u9b529f1c\" id=\"u9b529f1c\">React diff</span></code><span data-lake-id=\"uda875c4f\" id=\"uda875c4f\"> 算法内容。自 </span><code data-lake-id=\"u76d3fa6f\" id=\"u76d3fa6f\"><span data-lake-id=\"u5b2af641\" id=\"u5b2af641\">React 16</span></code><span data-lake-id=\"uf7a0f9f2\" id=\"uf7a0f9f2\"> 起，引入了 </span><code data-lake-id=\"ub49becea\" id=\"ub49becea\"><span data-lake-id=\"uabc94687\" id=\"uabc94687\">Fiber</span></code><span data-lake-id=\"u22caba62\" id=\"u22caba62\"> 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 </span><code data-lake-id=\"u884df189\" id=\"u884df189\"><span data-lake-id=\"ua454af6c\" id=\"ua454af6c\">FiberNode</span></code><span data-lake-id=\"u6e209f47\" id=\"u6e209f47\"> 与 </span><code data-lake-id=\"u2ed331b1\" id=\"u2ed331b1\"><span data-lake-id=\"u970d5df9\" id=\"u970d5df9\">FiberTree</span></code><span data-lake-id=\"u9f1c2375\" id=\"u9f1c2375\"> 进行重构。</span></p><p data-lake-id=\"u4893f9d3\" id=\"u4893f9d3\"><span data-lake-id=\"u4dd40682\" id=\"u4dd40682\">​</span><br></p><p data-lake-id=\"u8884ff27\" id=\"u8884ff27\"><code data-lake-id=\"u01d6c49a\" id=\"u01d6c49a\"><span data-lake-id=\"uc376215b\" id=\"uc376215b\">fiberNode</span></code><span data-lake-id=\"u38c214f5\" id=\"u38c214f5\"> 使用了</span><strong><span data-lake-id=\"uf753ce24\" id=\"uf753ce24\">双链表</span></strong><span data-lake-id=\"udb123200\" id=\"udb123200\">的结构，可以直接找到兄弟节点与子节点。整个更新过程由 </span><code data-lake-id=\"u64f8588a\" id=\"u64f8588a\"><span data-lake-id=\"u803d97a7\" id=\"u803d97a7\">current</span></code><span data-lake-id=\"u0dc00b3d\" id=\"u0dc00b3d\"> 与 </span><code data-lake-id=\"u3cc741f8\" id=\"u3cc741f8\"><span data-lake-id=\"u8c615c10\" id=\"u8c615c10\">workInProgress</span></code><span data-lake-id=\"ufbc8c7a0\" id=\"ufbc8c7a0\"> 两株树双缓冲完成。</span><code data-lake-id=\"uc5ee7d10\" id=\"uc5ee7d10\"><span data-lake-id=\"uefb653c7\" id=\"uefb653c7\">workInProgress</span></code><span data-lake-id=\"ud7024f9a\" id=\"ud7024f9a\"> 更新完成后，再通过修改 </span><code data-lake-id=\"u2670fc8b\" id=\"u2670fc8b\"><span data-lake-id=\"ueff872e0\" id=\"ueff872e0\">current</span></code><span data-lake-id=\"u5e805f3e\" id=\"u5e805f3e\"> 相关指针指向新节点。</span></p><h2 data-lake-id=\"h6d6E\" id=\"h6d6E\"><span data-lake-id=\"u74ca8ae1\" id=\"u74ca8ae1\">vue 的 diff 算法</span></h2><p data-lake-id=\"u0d472aaf\" id=\"u0d472aaf\"><a href=\"https://juejin.cn/post/7113734401434845191\" target=\"_blank\" data-lake-id=\"uaf591035\" id=\"uaf591035\"><span data-lake-id=\"u15cd3513\" id=\"u15cd3513\">https://juejin.cn/post/7113734401434845191</span></a></p><p data-lake-id=\"u1f23837d\" id=\"u1f23837d\"><span data-lake-id=\"ua4a8d97a\" id=\"ua4a8d97a\">正常 </span><code data-lake-id=\"u188ef5e1\" id=\"u188ef5e1\"><span data-lake-id=\"u47410950\" id=\"u47410950\">diff</span></code><span data-lake-id=\"uf3b82c57\" id=\"uf3b82c57\"> 两个树的时间复杂度是 </span><code data-lake-id=\"u6262405d\" id=\"u6262405d\"><span data-lake-id=\"u936a235c\" id=\"u936a235c\">O(n^3)</span></code><span data-lake-id=\"uae0569f7\" id=\"uae0569f7\">，但实际情况下我们很少会跨层级去移动 </span><code data-lake-id=\"u9c75dbaa\" id=\"u9c75dbaa\"><span data-lake-id=\"u6c78c350\" id=\"u6c78c350\">dom</span></code><span data-lake-id=\"ua1c753bc\" id=\"ua1c753bc\">，所以 </span><code data-lake-id=\"u8aab066f\" id=\"u8aab066f\"><span data-lake-id=\"ue87b4f69\" id=\"ue87b4f69\">vue</span></code><span data-lake-id=\"ubfe7c72e\" id=\"ubfe7c72e\"> 将 </span><code data-lake-id=\"u2579eeac\" id=\"u2579eeac\"><span data-lake-id=\"u6c146ab9\" id=\"u6c146ab9\">diff</span></code><span data-lake-id=\"u1893c63c\" id=\"u1893c63c\"> 进行了优化，将时间复杂度从 </span><code data-lake-id=\"ue2888b2f\" id=\"ue2888b2f\"><span data-lake-id=\"u1b02fb34\" id=\"u1b02fb34\">O(n^3)</span></code><span data-lake-id=\"u4f916721\" id=\"u4f916721\">优化为 </span><code data-lake-id=\"u1a98d1df\" id=\"u1a98d1df\"><span data-lake-id=\"u5b00a1ca\" id=\"u5b00a1ca\">O(n)</span></code><span data-lake-id=\"u2f854cc2\" id=\"u2f854cc2\">，只有当新旧 </span><code data-lake-id=\"u8c73e0bd\" id=\"u8c73e0bd\"><span data-lake-id=\"uec0dc48f\" id=\"uec0dc48f\">children</span></code><span data-lake-id=\"ud894ee17\" id=\"ud894ee17\"> 都为多个子节点时才需要用核心的 </span><code data-lake-id=\"udc778aa6\" id=\"udc778aa6\"><span data-lake-id=\"uecf2b197\" id=\"uecf2b197\">diff</span></code><span data-lake-id=\"u5edab60a\" id=\"u5edab60a\"> 算法来进行同层比较</span></p><h3 data-lake-id=\"d90cm\" id=\"d90cm\"><span data-lake-id=\"u3657aa05\" id=\"u3657aa05\">diff 算法的核心-vue2</span></h3><p data-lake-id=\"u807d4afc\" id=\"u807d4afc\"><code data-lake-id=\"u120a8dea\" id=\"u120a8dea\"><span data-lake-id=\"u38d85e5c\" id=\"u38d85e5c\">vue2</span></code><span data-lake-id=\"ue3809d43\" id=\"ue3809d43\"> 的核心 </span><code data-lake-id=\"u0645ec75\" id=\"u0645ec75\"><span data-lake-id=\"u1fa77e60\" id=\"u1fa77e60\">diff</span></code><span data-lake-id=\"u8f3c5e81\" id=\"u8f3c5e81\"> 算法采用了 </span><strong><span data-lake-id=\"ue0cc07ae\" id=\"ue0cc07ae\">双端比较</span></strong><span data-lake-id=\"u25b529bf\" id=\"u25b529bf\"> 的算法，即同时从新旧 </span><code data-lake-id=\"u526e1cd8\" id=\"u526e1cd8\"><span data-lake-id=\"u74078a43\" id=\"u74078a43\">children</span></code><span data-lake-id=\"u6ade7ded\" id=\"u6ade7ded\"> 的两端开始进行比较(头尾指针)，借助 </span><code data-lake-id=\"u48bba04a\" id=\"u48bba04a\"><span data-lake-id=\"ued4a2f64\" id=\"ued4a2f64\">key</span></code><span data-lake-id=\"u1a89fa7a\" id=\"u1a89fa7a\"> 值找到可复用的节点，然后进行相关操作。对比于 </span><code data-lake-id=\"u82d7efc4\" id=\"u82d7efc4\"><span data-lake-id=\"ucc20b929\" id=\"ucc20b929\">react</span></code><span data-lake-id=\"ua0e62bb8\" id=\"ua0e62bb8\"> 的 </span><code data-lake-id=\"uc1b3e9d8\" id=\"uc1b3e9d8\"><span data-lake-id=\"u3144e04f\" id=\"u3144e04f\">diff</span></code><span data-lake-id=\"u764d6511\" id=\"u764d6511\"> 算法而言，在相同情况下可以</span><strong><span data-lake-id=\"u7ab78645\" id=\"u7ab78645\">减少节点的移动次数</span></strong><span data-lake-id=\"u5c82500e\" id=\"u5c82500e\">，从而减少不必要的性能损耗，整体而言更加优雅。</span></p><h3 data-lake-id=\"rmTp3\" id=\"rmTp3\"><span data-lake-id=\"u01c62743\" id=\"u01c62743\">diff 算法的核心-vue3</span></h3><p data-lake-id=\"u7a4885d5\" id=\"u7a4885d5\"><code data-lake-id=\"u9582b8eb\" id=\"u9582b8eb\"><span data-lake-id=\"u7fd99f10\" id=\"u7fd99f10\">vue3</span></code><span data-lake-id=\"u15c038a4\" id=\"u15c038a4\"> 借鉴了 </span><strong><span data-lake-id=\"ub2b3a4fc\" id=\"ub2b3a4fc\">ivi 算法</span></strong><span data-lake-id=\"u6d16637b\" id=\"u6d16637b\"> 和 </span><strong><span data-lake-id=\"u2a17ea88\" id=\"u2a17ea88\">inferno 算法</span></strong><span data-lake-id=\"uf593ee41\" id=\"uf593ee41\">，在创建 </span><code data-lake-id=\"ue563093c\" id=\"ue563093c\"><span data-lake-id=\"ua5dca9d0\" id=\"ua5dca9d0\">vnode</span></code><span data-lake-id=\"uc3f18fde\" id=\"uc3f18fde\"> 的时候就确定其类型，以及在 </span><code data-lake-id=\"ud61b8166\" id=\"ud61b8166\"><span data-lake-id=\"u57258625\" id=\"u57258625\">mount</span></code><span data-lake-id=\"u5a40e32d\" id=\"u5a40e32d\">/</span><code data-lake-id=\"u2f599def\" id=\"u2f599def\"><span data-lake-id=\"u179d2d5d\" id=\"u179d2d5d\">patch</span></code><span data-lake-id=\"u568f2966\" id=\"u568f2966\"> 的过程中采用 </span><strong><span data-lake-id=\"u5a19dfce\" id=\"u5a19dfce\">位运算 </span></strong><span data-lake-id=\"u7720ec61\" id=\"u7720ec61\">来判断一个 </span><code data-lake-id=\"u10f32489\" id=\"u10f32489\"><span data-lake-id=\"uc8ae79aa\" id=\"uc8ae79aa\">vnode</span></code><span data-lake-id=\"u330a21cc\" id=\"u330a21cc\"> 的类型，在这个基础之上再配合核心的 </span><code data-lake-id=\"u573ca532\" id=\"u573ca532\"><span data-lake-id=\"uc0353032\" id=\"uc0353032\">diff</span></code><span data-lake-id=\"uc2402acc\" id=\"uc2402acc\"> 算法(双端比较算法)，使得性能上较 </span><code data-lake-id=\"ub7e8e50e\" id=\"ub7e8e50e\"><span data-lake-id=\"ube0d67b6\" id=\"ube0d67b6\">vue2</span></code><span data-lake-id=\"ub5c56d85\" id=\"ub5c56d85\"> 而言得到了显著的提升。另外，该算法中还运用了动态规划的思想求解最长递增子序列</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E4%BD%8D%E8%BF%90%E7%AE%97%5CnTEXT%20%3D%201%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF1---%E8%A1%A8%E7%A4%BA%E5%85%B7%E6%9C%89%E5%8A%A8%E6%80%81textContent%E7%9A%84%E5%85%83%E7%B4%A0%5CnCLASS%20%3D%201%20%3C%3C%201%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF2---%E8%A1%A8%E7%A4%BA%E6%9C%89%E5%8A%A8%E6%80%81Class%E7%9A%84%E5%85%83%E7%B4%A0%5CnSTYLE%20%3D%201%20%3C%3C%202%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF4---%E8%A1%A8%E7%A4%BA%E5%8A%A8%E6%80%81%E6%A0%B7%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%A6%82style%3D%5C%22color%3A%20pink%5C%22%EF%BC%8C%E4%B9%9F%E4%BC%9A%E6%8F%90%E5%8D%87%E8%87%B3%E5%8A%A8%E6%80%81%EF%BC%89%5CnPROPS%20%3D%201%20%3C%3C%203%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF8---%20%E8%A1%A8%E7%A4%BA%E5%85%B7%E6%9C%89%E9%9D%9E%E7%B1%BB%2F%E6%A0%B7%E5%BC%8F%E5%8A%A8%E6%80%81%E9%81%93%E5%85%B7%E7%9A%84%E5%85%83%E7%B4%A0%5CnFULL_PROPS%20%3D%201%20%3C%3C%204%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF16---%E8%A1%A8%E7%A4%BA%E5%B8%A6%E6%9C%89%E5%8A%A8%E6%80%81%E9%94%AE%E7%9A%84%E9%81%93%E5%85%B7%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E4%B8%8E%E4%B8%8A%E9%9D%A2%E4%B8%89%E7%A7%8D%E7%9B%B8%E6%96%A5%5CnHYDRATE_EVENTS%20%3D%201%20%3C%3C%205%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF32---%E8%A1%A8%E7%A4%BA%E5%B8%A6%E6%9C%89%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%85%83%E7%B4%A0%5CnSTABLE_FRAGMENT%20%3D%201%20%3C%3C%206%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF64---%E8%A1%A8%E7%A4%BA%E5%85%B6%E5%AD%90%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%8F%98%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E8%87%AA%E9%A1%BA%E5%BA%8F%E7%9A%84%E7%89%87%E6%AE%B5%E3%80%82%5CnKEYED_FRAGMENT%20%3D%201%20%3C%3C%207%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF128---%E8%A1%A8%E7%A4%BA%E5%B8%A6%E6%9C%89%E9%94%AE%E6%8E%A7%E6%88%96%E9%83%A8%E5%88%86%E9%94%AE%E6%8E%A7%E5%AD%90%E5%85%83%E7%B4%A0%E7%9A%84%E7%89%87%E6%AE%B5%E3%80%82%5CnUNKEYED_FRAGMENT%20%3D%201%20%3C%3C%208%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF256---%E5%AD%90%E8%8A%82%E7%82%B9%E6%97%A0key%E7%BB%91%E5%AE%9A%E7%9A%84%E7%89%87%E6%AE%B5%EF%BC%88fragment%EF%BC%89%5CnNEED_PATCH%20%3D%201%20%3C%3C%209%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF512---%E8%A1%A8%E7%A4%BA%E5%8F%AA%E9%9C%80%E8%A6%81%E9%9D%9E%E5%B1%9E%E6%80%A7%E8%A1%A5%E4%B8%81%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E4%BE%8B%E5%A6%82%20ref%20%E6%88%96%20hooks%5CnDYNAMIC_SLOTS%20%3D%201%20%3C%3C%2010%20%2F%2F%20--%E5%8F%96%E5%80%BC%E6%98%AF1024---%E8%A1%A8%E7%A4%BA%E5%85%B7%E6%9C%89%E5%8A%A8%E6%80%81%E6%8F%92%E6%A7%BD%E7%9A%84%E5%85%83%E7%B4%A0%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Darcula%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22GVtZk%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><card type=\"block\" name=\"hr\"></card><p data-lake-id=\"u8ec43649\" id=\"u8ec43649\"><br></p><card type=\"block\" name=\"hr\"></card><h2 data-lake-id=\"ZboGs\" id=\"ZboGs\"><span data-lake-id=\"ua5610881\" id=\"ua5610881\">vue2 和 vue3 的 diff 算法对比</span></h2><ul list=\"u27328ae5\"><li fid=\"u0026f003\" data-lake-id=\"ue3e5765e\" id=\"ue3e5765e\"><code data-lake-id=\"ua7802dfd\" id=\"ua7802dfd\"><span data-lake-id=\"u89fa9b31\" id=\"u89fa9b31\">vue3</span></code><span data-lake-id=\"ue266dc73\" id=\"ue266dc73\"> 在 </span><code data-lake-id=\"u7f30c336\" id=\"u7f30c336\"><span data-lake-id=\"ua0e73687\" id=\"ua0e73687\">vue2</span></code><span data-lake-id=\"u46a4a1ef\" id=\"u46a4a1ef\"> 的双端比较算法上做了进一步优化，它只会比较动态节点而忽略静态节点，极大的提高了效率，在实现上采取了</span><strong><span data-lake-id=\"ub2342418\" id=\"ub2342418\">双指针</span></strong><span data-lake-id=\"u03258189\" id=\"u03258189\">的思想。另外，该算法中还运用了动态规划的思想求解最长递增子序列</span></li><li fid=\"u0026f003\" data-lake-id=\"u07c44539\" id=\"u07c44539\"><code data-lake-id=\"ue551e710\" id=\"ue551e710\"><span data-lake-id=\"u26badc90\" id=\"u26badc90\">vue3</span></code><span data-lake-id=\"u089ae883\" id=\"u089ae883\"> 新增了 </span><strong><span data-lake-id=\"u9464cf26\" id=\"u9464cf26\">静态标记 (</span></strong><code data-lake-id=\"ua60a1573\" id=\"ua60a1573\"><strong><span data-lake-id=\"ud24e22b8\" id=\"ud24e22b8\">patch flag</span></strong></code><strong><span data-lake-id=\"uc9089b38\" id=\"uc9089b38\">)</span></strong><span data-lake-id=\"u1e5a9afb\" id=\"u1e5a9afb\">，与上次虚拟节点对比，只会对比带有 </span><code data-lake-id=\"u56a01ae3\" id=\"u56a01ae3\"><span data-lake-id=\"uccd18b6e\" id=\"uccd18b6e\">patch flag</span></code><span data-lake-id=\"u44eaa16c\" id=\"u44eaa16c\"> 的节点</span></li></ul><h2 data-lake-id=\"EzUzn\" id=\"EzUzn\"><span data-lake-id=\"ubccc6e22\" id=\"ubccc6e22\">React 与 Vue 的 diff 算法有何不同</span></h2><p data-lake-id=\"u52c442f0\" id=\"u52c442f0\"><code data-lake-id=\"u436a31e0\" id=\"u436a31e0\"><span data-lake-id=\"ub461ea09\" id=\"ub461ea09\">Vue</span></code><span data-lake-id=\"u12d5acc4\" id=\"u12d5acc4\"> 的整体 </span><code data-lake-id=\"u44bbd402\" id=\"u44bbd402\"><span data-lake-id=\"uae3ada49\" id=\"uae3ada49\">diff</span></code><span data-lake-id=\"ueb6f9a53\" id=\"ueb6f9a53\"> 策略与 </span><code data-lake-id=\"ud66f874d\" id=\"ud66f874d\"><span data-lake-id=\"u467f04db\" id=\"u467f04db\">React</span></code><span data-lake-id=\"uc0a1ec5b\" id=\"uc0a1ec5b\"> 对齐，虽然缺乏时间切片能力，但这并不意味着 </span><code data-lake-id=\"uca50b920\" id=\"uca50b920\"><span data-lake-id=\"ub08d72de\" id=\"ub08d72de\">Vue</span></code><span data-lake-id=\"u8a139dff\" id=\"u8a139dff\"> 的性能更差，因为在 </span><code data-lake-id=\"u39df873f\" id=\"u39df873f\"><span data-lake-id=\"ub92ce35c\" id=\"ub92ce35c\">Vue 3</span></code><span data-lake-id=\"u16291158\" id=\"u16291158\"> 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 </span><code data-lake-id=\"u286a7b22\" id=\"u286a7b22\"><span data-lake-id=\"u7ac20c5d\" id=\"u7ac20c5d\">Vue</span></code><span data-lake-id=\"u86f17f2d\" id=\"u86f17f2d\"> 中其他的场景几乎都可以使用防抖和节流去提高响应性能。</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-06-30T07:35:04.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:28.000Z",
  "updated_at": "2022-06-30T07:35:04.000Z",
  "published_at": "2022-06-30T07:35:04.000Z",
  "first_published_at": "2022-04-04T11:33:27.871Z",
  "word_count": 2024,
  "cover": null,
  "description": "diff 算法策略diff 算法的三个策略(观察的规律)dom 节点的跨层级移动操作特别少，可以忽略不计拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构对于同一层级的一组子节点，可以通过唯一的 id(key) 进行区分tree diff因为以上三个策略中的...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}