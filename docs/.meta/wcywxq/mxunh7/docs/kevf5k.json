{
  "id": 72212059,
  "slug": "kevf5k",
  "title": "事件循环机制(EventLoop)",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"GzXwt\"></a>\n## 执行栈\n执行栈是类似函数调用栈的运行容器，执行栈为空时，javaScript 引擎会检查事件队列是否为空，如果不为空，那么将第一个任务压入执行栈中执行\n<a name=\"cRycY\"></a>\n## 事件队列\n事件队列就是一个存储着待执行任务的队列，其中的任务严格按照时间顺序来执行，队首的任务率先执行，队尾的任务最后执行。同时每次仅执行一个任务。\n<a name=\"JbDwc\"></a>\n## javaScript 在浏览器中的事件循环机制\n\n- javaScript 是单线程执行的(两个线程同时操作 DOM，会发生冲突)，在代码执行的过程中，通过将不同函数的**执行上下文**压入**执行栈**中来保证代码的有序执行\n- 最开始将整个 script 脚本作为一个宏任务执行，执行过程中同步代码直接执行\n- 执行同步代码时，如果遇到了异步事件，javaScript 引擎将不会一直等待其返回结果，而是将这个事件暂时挂起，继续执行**执行栈**中的其它任务\n- 当异步事件执行完毕后，再将异步事件对应的回调函数加入到**与当前执行栈不同的任务队列**中等待执行，宏任务进入宏任务队列，微任务进入微任务队列\n- 在主执行栈中的事件执行完毕后，javaScript 引擎会**首先判断微任务队列**中是否有任务可以执行，如果有就将微任务队列的**队首**的事件压入执行栈中执行。直到**微任务队列的所有任务全部执行完毕**\n- 执行浏览器的 UI 线程渲染工作，渲染阶段会收到以下因素的影响\n   - 屏幕分辨率改变，如果页面性能太差，为了不丢帧，浏览器会选择降低帧率\n   - 浏览器判断本次渲染是否会造成视觉上的改变，比如背景色改变\n   - map of animation frame callbacks 为空\n- 检查是否有 web worker 任务，有则执行\n   - 对需要渲染的文档，如果窗口发生了变化，就会调用 resize 事件(resize 自带节流)\n   - 对需要渲染的文档，如果页面发生了滚动，就会调用 scroll 事件(scroll 自带节流)\n   - 对需要渲染的文档，执行 requestAnimationFrame 回调\n   - 调用 IntersectionObserver 回调，重新渲染页面\n   - 最后会检查宏任务队列和微任务队列是否为空，如果为空会调用 idle 空闲周期算法，检测 requestIdleCallback 是否为空，如果不为空就会执行里面的回调\n- 执行完本轮宏任务后，执行下一轮宏任务\n:::success\n**任务队列：**\n\n- **宏任务(macroTasks)队列：**\n   - script 脚本的执行\n   - setTimeout/setInterval/setImmediate\n   -  I/O 操作\n   - UI 渲染\n- **微任务(microTasks)队列：**\n   - promise 回调(必须有 resolve/reject 结果，同一块作用域内多个 resolve 中，其中一个执行完毕后其余的皆不再执行)\n   - node.js 中的 process.nextTick\n   - 对 DOM 变化进行监听的 MutationObserver\n:::\n\n:::success\n**requestAnimationFrame 和 requestIdleCallback**<br />前者是在渲染前执行的，因为动画会更改 dom 结构，后者是用来处理计算量大但不紧急的事件，当队列中没有任务执行时，会清空它内部的回调，也可以传入 timeout 参数，强制 timeout 秒后执行，但是会阻塞其他代码的执行\n:::\n<a name=\"ipMVF\"></a>\n## 为什么 javaScript 引擎将异步任务区分为宏任务和微任务\n\n- 这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。\n- 区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。\n<a name=\"qxOhd\"></a>\n## javaScript 在 node.js 环境下的事件循环机制\n当 node.js 启动后，它会初始化事件循环，处理已提供的输入脚本，它可能会调用一些异步的 API、调度定时器，或者调用 process.nextTick，然后开始处理事件循环\n<a name=\"AavFm\"></a>\n### node.js 中的微任务\n\n- process.nextTick 注册的回调 (nextTick task queue)\n- promise.then 注册的回调 (promise task queue)\n\nnode 在执行微任务时，会优先执行 nextTick task queue 中的任务，执行完后会接着执行 promise task queue 中的任务。因此如果二者同时处于主线程或者事件循环中的相同阶段，process.nextTick 回调优先级 > promise.then 回调优先级\n<a name=\"TZ54M\"></a>\n### 事件循环\n下面为 node 执行的整个过程，如果执行了任何非阻塞的异步代码，则会进入事件循环：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646662274965-6259f561-8bd7-4251-9810-67df3477bbcf.png#clientId=u5d023ea2-a4d9-4&from=paste&height=556&id=u2d752270&originHeight=1112&originWidth=1960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=180079&status=done&style=none&taskId=uc7f19d61-bd9e-44f6-adb0-4e441a2adbd&title=&width=980)\n\n其中事件循环分为六个阶段：\n\n- 定时器 **_timers_**：本阶段执行已经被 setTimeout 和 setInterval 的调度回调函数\n- 待定回调 **_pending callbacks_**：执行延迟到下一个循环迭代的 I/O 回调\n- **_idle，prepare_**：仅系统内部使用\n- 轮询 **_poll_**：检索新的 I/O 事件；执行与 I/O 相关的回调(几乎所有情况下，除了 close callbacks，那些由定时器和 setImmediate 调度的之外)，其余情况 node 将在适当的时候在此阻塞\n- 检测 **_check_**：setImmediate 回调函数在这里执行\n- 关闭的回调函数 **_close callbacks_**：一些关闭的回调函数。如：`socket.on('close', ...)`\n\n:::warning\n注意：\n\n1. 每一个阶段都会有一个 FIFO 回调队列，都会尽可能地执行完当前阶段中所有的回调或者到达了系统相关的限制之后，才会进入下一阶段\n2. poll 阶段执行微任务的时机与 timers & check 阶段的时机不同，前者是在每一个回调执行的时候就会执行相应的微任务；后者会在所有回调执行完毕之后，才统一 执行相应的微任务\n:::\n\n<a name=\"wgSt6\"></a>\n### setImmediate、setTimeout/setInterval 和 process.nextTick 执行时机\n\n- **setImmediate**\n\n触发一个异步回调，在事件循环的 check 阶段立即执行。\n\n- **setTimeout**\n\n触发一个异步回调，当计时器过期后，在事件循环的 timers 阶段执行，只执行一次（可用 clearTimeout 取消）。\n\n- **setInterval**\n\n触发一个异步回调，每次计时器过期后，都会在事件循环的 timers 阶段执行一次回调（可用 clearInterval 取消）。\n\n- **process.nextTick**\n\n触发一个微任务（异步）回调，既可以在主线程（mainline）中执行，可以存在事件循环的某一个阶段中执行。\n<a name=\"Y21SO\"></a>\n### 总结\n\n- 初始化事件循环，处理输入脚本，处理事件循环\n- 执行事件循环的每个阶段\n- 在相应阶段的回调执行时或者执行完，去执行微任务，其中 nextTick task queue >  promise task queue\n:::success\n在 node v10 及以前：\n\n1. 执行完 1-6 阶段的任务\n2. 执行 nextTick 中的任务\n3. 执行完微任务队列中的任务\n\n在 node v11 之后，node 在 setTimeout 执行后会手动清空微任务队列，用来保证结果贴近浏览器\n:::\n\n<a name=\"TJa6Z\"></a>\n### 案例\n```javascript\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n \nasync function async2() {\n    console.log('async2')\n}\n \nconsole.log('script start')\n \nsetTimeout(function () {\n    console.log('setTimeout0')\n}, 0)\n \nsetTimeout(function () {\n    console.log('setTimeout2')\n}, 300)\n \nsetImmediate(() => console.log('setImmediate'));\n \nprocess.nextTick(() => console.log('nextTick1'));\n \nasync1();\n \nprocess.nextTick(() => console.log('nextTick2'));\n \nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve();\n    console.log('promise2')\n}).then(function () {\n    console.log('promise3')\n})\n \nconsole.log('script end')\n```\n\n- 先找到同步任务，输出 script start\n- 遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中\n- 遇到第二个 setTimeout，300ms 后将里面的回调函数放到 timer 队列中\n- 遇到第一个 setImmediate，将里面的回调函数放到 check 队列中\n- 遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行\n- 执行 async1 函数，输出 async1 start\n- 执行 async2 函数，输出 async2，async2 后面的输出 async1 end 进入微任务，等待下一轮的事件循环\n- 遇到第二个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行\n- 遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2\n- then 里面的回调函数进入微任务队列\n- 遇到同步任务，输出 script end\n- 执行下一轮回调函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2\n- 然后执行微任务队列，依次输出 async1 end、promise3\n- 执行 timer 队列，依次输出 setTimeout0\n- 接着执行 check 队列，依次输出 setImmediate\n- 300ms 后，timer 队列存在任务，执行输出 setTimeout2\n\n执行结果如下：\n```shell\nscript start\nasync1 start\nasync2\npromise1\npromise2\nscript end\nnextTick1\nnextTick2\nasync1 end\npromise3\nsetTimeout0\nsetImmediate\nsetTimeout2\n```\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"GzXwt\"><span class=\"ne-text\">执行栈</span></h2><p id=\"u3fd75c27\" class=\"ne-p\"><span class=\"ne-text\">执行栈是类似函数调用栈的运行容器，执行栈为空时，javaScript 引擎会检查事件队列是否为空，如果不为空，那么将第一个任务压入执行栈中执行</span></p><h2 id=\"cRycY\"><span class=\"ne-text\">事件队列</span></h2><p id=\"u3d31171d\" class=\"ne-p\"><span class=\"ne-text\">事件队列就是一个存储着待执行任务的队列，其中的任务严格按照时间顺序来执行，队首的任务率先执行，队尾的任务最后执行。同时每次仅执行一个任务。</span></p><h2 id=\"JbDwc\"><span class=\"ne-text\">javaScript 在浏览器中的事件循环机制</span></h2><ul class=\"ne-ul\"><li id=\"u30246495\"><span class=\"ne-text\" style=\"font-size: 14px\">javaScript 是单线程执行的(两个线程同时操作 DOM，会发生冲突)，在代码执行的过程中，通过将不同函数的</span><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">执行上下文</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">压入</span><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">执行栈</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中来保证代码的有序执行</span></li><li id=\"u379cdf55\"><span class=\"ne-text\" style=\"font-size: 14px\">最开始将整个 script 脚本作为一个宏任务执行，执行过程中同步代码直接执行</span><span class=\"ne-text\"></span></li><li id=\"uef8237db\"><span class=\"ne-text\" style=\"font-size: 14px\">执行同步代码时，如果遇到了异步事件，javaScript 引擎将不会一直等待其返回结果，而是将这个事件暂时挂起，继续执行</span><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">执行栈</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中的其它任务</span></li><li id=\"u72924162\"><span class=\"ne-text\" style=\"font-size: 14px\">当异步事件执行完毕后，再将异步事件对应的回调函数加入到</span><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">与当前执行栈不同的任务队列</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中等待执行，宏任务进入宏任务队列，微任务进入微任务队列</span></li></ul><ul class=\"ne-ul\"><li id=\"uf8f088c0\"><span class=\"ne-text\" style=\"font-size: 14px\">在主执行栈中的事件执行完毕后，javaScript 引擎会</span><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">首先判断微任务队列</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中是否有任务可以执行，如果有就将微任务队列的</span><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">队首</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">的事件压入执行栈中执行。直到</span><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">微任务队列的所有任务全部执行完毕</span></strong></li><li id=\"u7270a7c7\"><span class=\"ne-text\">执行浏览器的 UI 线程渲染工作，渲染阶段会收到以下因素的影响</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u85bb964f\"><span class=\"ne-text\">屏幕分辨率改变，如果页面性能太差，为了不丢帧，浏览器会选择降低帧率</span></li><li id=\"u401c2231\"><span class=\"ne-text\">浏览器判断本次渲染是否会造成视觉上的改变，比如背景色改变</span></li><li id=\"u289961cd\"><span class=\"ne-text\">map of animation frame callbacks 为空</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u4bd31d9b\"><span class=\"ne-text\">检查是否有 web worker 任务，有则执行</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u3d7f99c5\"><span class=\"ne-text\">对需要渲染的文档，如果窗口发生了变化，就会调用 resize 事件(resize 自带节流)</span></li><li id=\"ue5fcdc17\"><span class=\"ne-text\">对需要渲染的文档，如果页面发生了滚动，就会调用 scroll 事件(scroll 自带节流)</span></li><li id=\"ua6211f3d\"><span class=\"ne-text\">对需要渲染的文档，执行 requestAnimationFrame 回调</span></li><li id=\"u055bf1dd\"><span class=\"ne-text\">调用 IntersectionObserver 回调，重新渲染页面</span></li><li id=\"u111214e1\"><span class=\"ne-text\">最后会检查宏任务队列和微任务队列是否为空，如果为空会调用 idle 空闲周期算法，检测 requestIdleCallback 是否为空，如果不为空就会执行里面的回调</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"uf4c399d0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行完本轮宏任务后，执行下一轮宏任务</span></li></ul><div data-type=\"success\" class=\"ne-alert\"><p id=\"udf60241f\" class=\"ne-p\"><strong><span class=\"ne-text\">任务队列：</span></strong></p><ul class=\"ne-ul\"><li id=\"u5ef0c4ee\"><strong><span class=\"ne-text\">宏任务(macroTasks)队列：</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ua1e7bc6e\"><span class=\"ne-text\">script 脚本的执行</span></li><li id=\"udd49d99a\"><span class=\"ne-text\">setTimeout/setInterval/setImmediate</span></li><li id=\"u53b8c2c6\"><span class=\"ne-text\"> I/O 操作</span></li><li id=\"u998f7adc\"><span class=\"ne-text\">UI 渲染</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u7bf9a383\"><strong><span class=\"ne-text\">微任务(microTasks)队列：</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u2960ffe5\"><span class=\"ne-text\">promise 回调(必须有 resolve/reject 结果，同一块作用域内多个 resolve 中，其中一个执行完毕后其余的皆不再执行)</span></li><li id=\"ue354bee4\"><span class=\"ne-text\">node.js 中的 process.nextTick</span></li><li id=\"u19559057\"><span class=\"ne-text\">对 DOM 变化进行监听的 MutationObserver</span></li></ul></ul></div><p id=\"u4b6baffc\" class=\"ne-p\"><br></p><div data-type=\"success\" class=\"ne-alert\"><p id=\"u85ad7f5c\" class=\"ne-p\"><strong><span class=\"ne-text\">requestAnimationFrame 和 requestIdleCallback</span></strong></p><p id=\"udfa755b4\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">前者是在渲染前执行的，因为动画会更改 dom 结构，后者是用来处理计算量大但不紧急的事件，当队列中没有任务执行时，会清空它内部的回调，也可以传入 timeout 参数，强制 timeout 秒后执行，但是会阻塞其他代码的执行</span></p></div><h2 id=\"ipMVF\"><span class=\"ne-text\">为什么 javaScript 引擎将异步任务区分为宏任务和微任务</span></h2><ul class=\"ne-ul\"><li id=\"ub60cf9c3\"><span class=\"ne-text\">这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。</span></li><li id=\"uea6de08e\"><span class=\"ne-text\">区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。</span></li></ul><h2 id=\"qxOhd\"><span class=\"ne-text\">javaScript 在 node.js 环境下的事件循环机制</span></h2><p id=\"u896c8a73\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">当 node.js 启动后，它会初始化事件循环，处理已提供的输入脚本，它可能会调用一些异步的 API、调度定时器，或者调用 process.nextTick，然后开始处理事件循环</span></p><h3 id=\"AavFm\"><span class=\"ne-text\">node.js 中的微任务</span></h3><ul class=\"ne-ul\"><li id=\"uc9e145c5\"><span class=\"ne-text\" style=\"font-size: 14px\">process.nextTick 注册的回调 (nextTick task queue)</span></li><li id=\"u8662d74f\"><span class=\"ne-text\" style=\"font-size: 14px\">promise.then 注册的回调 (promise task queue)</span></li></ul><p id=\"u3e278156\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\"></span></p><p id=\"ufbbdf4fd\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">node 在执行微任务时，会优先执行 nextTick task queue 中的任务，执行完后会接着执行 promise task queue 中的任务。因此如果二者同时处于主线程或者事件循环中的相同阶段，process.nextTick 回调优先级 &gt; promise.then 回调优先级</span></p><h3 id=\"TZ54M\"><span class=\"ne-text\">事件循环</span></h3><p id=\"u1b71a0ab\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">下面为 node 执行的整个过程，如果执行了任何非阻塞的异步代码，则会进入事件循环：</span></p><p id=\"u4f1b1453\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646662274965-6259f561-8bd7-4251-9810-67df3477bbcf.png\" width=\"980\" id=\"u2d752270\" class=\"ne-image\"></p><p id=\"u64610802\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\"></span></p><p id=\"uf5cbc935\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">其中事件循环分为六个阶段：</span></p><ul class=\"ne-ul\"><li id=\"u72cb75d5\"><span class=\"ne-text\" style=\"font-size: 14px\">定时器 </span><em><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">timers</span></strong></em><span class=\"ne-text\" style=\"font-size: 14px\">：本阶段执行已经被 setTimeout 和 setInterval 的调度回调函数</span></li><li id=\"u9a553fb8\"><span class=\"ne-text\" style=\"font-size: 14px\">待定回调 </span><em><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">pending callbacks</span></strong></em><span class=\"ne-text\" style=\"font-size: 14px\">：执行延迟到下一个循环迭代的 I/O 回调</span></li><li id=\"ue8787399\"><em><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">idle，prepare</span></strong></em><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">：</span><span class=\"ne-text\" style=\"font-size: 14px\">仅系统内部使用</span></li><li id=\"u102afb60\"><span class=\"ne-text\" style=\"font-size: 14px\">轮询 </span><em><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">poll</span></strong></em><span class=\"ne-text\" style=\"font-size: 14px\">：检索新的 I/O 事件；执行与 I/O 相关的回调(几乎所有情况下，除了 close callbacks，那些由定时器和 setImmediate 调度的之外)，其余情况 node 将在适当的时候在此阻塞</span></li><li id=\"u3fbd4751\"><span class=\"ne-text\" style=\"font-size: 14px\">检测 </span><em><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">check</span></strong></em><span class=\"ne-text\" style=\"font-size: 14px\">：setImmediate 回调函数在这里执行</span></li><li id=\"u064f2b47\"><span class=\"ne-text\" style=\"font-size: 14px\">关闭的回调函数 </span><em><strong><span class=\"ne-text\" style=\"color: rgba(33,95,255,1); font-size: 14px\">close callbacks</span></strong></em><span class=\"ne-text\" style=\"font-size: 14px\">：一些关闭的回调函数。如：</span><code class=\"ne-code\"><span class=\"ne-text\">socket.on('close', ...)</span></code></li></ul><p id=\"u82a5d221\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\"></span></p><div data-type=\"warning\" class=\"ne-alert\"><p id=\"u95ee311b\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">注意：</span></p><ol class=\"ne-ol\"><li id=\"u17d85251\"><span class=\"ne-text\" style=\"font-size: 14px\">每一个阶段都会有一个 FIFO 回调队列，都会尽可能地执行完当前阶段中所有的回调或者到达了系统相关的限制之后，才会进入下一阶段</span></li><li id=\"ub0d3836a\"><span class=\"ne-text\" style=\"font-size: 14px\">poll 阶段执行微任务的时机与 timers &amp; check 阶段的时机不同，前者是在每一个回调执行的时候就会执行相应的微任务；后者会在所有回调执行完毕之后，才统一 执行相应的微任务</span></li></ol></div><p id=\"u47fc981a\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\"></span></p><h3 id=\"wgSt6\"><span class=\"ne-text\">setImmediate、setTimeout/setInterval 和 process.nextTick 执行时机</span></h3><ul class=\"ne-ul\"><li id=\"ud4df187c\"><strong><span class=\"ne-text\" style=\"font-size: 14px\">setImmediate</span></strong></li></ul><p id=\"u8653f645\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">触发一个异步回调，在事件循环的 check 阶段立即执行。</span></p><ul class=\"ne-ul\"><li id=\"uac6725d6\"><strong><span class=\"ne-text\" style=\"font-size: 14px\">setTimeout</span></strong></li></ul><p id=\"uc0b0fd5b\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">触发一个异步回调，当计时器过期后，在事件循环的 timers 阶段执行，只执行一次（可用 clearTimeout 取消）。</span></p><ul class=\"ne-ul\"><li id=\"ub7a81607\"><strong><span class=\"ne-text\" style=\"font-size: 14px\">setInterval</span></strong></li></ul><p id=\"u4da76ceb\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">触发一个异步回调，每次计时器过期后，都会在事件循环的 timers 阶段执行一次回调（可用 clearInterval 取消）。</span></p><ul class=\"ne-ul\"><li id=\"ufa43990b\"><strong><span class=\"ne-text\" style=\"font-size: 14px\">process.nextTick</span></strong></li></ul><p id=\"ua7606637\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">触发一个微任务（异步）回调，既可以在主线程（mainline）中执行，可以存在事件循环的某一个阶段中执行。</span></p><h3 id=\"Y21SO\"><span class=\"ne-text\">总结</span></h3><ul class=\"ne-ul\"><li id=\"uf6ba8fff\"><span class=\"ne-text\" style=\"font-size: 14px\">初始化事件循环，处理输入脚本，处理事件循环</span></li><li id=\"u291c4f90\"><span class=\"ne-text\" style=\"font-size: 14px\">执行事件循环的每个阶段</span></li><li id=\"ua9a9c41c\"><span class=\"ne-text\" style=\"font-size: 14px\">在相应阶段的回调执行时或者执行完，去执行微任务，其中 nextTick task queue &gt;  promise task queue</span></li></ul><div data-type=\"success\" class=\"ne-alert\"><p id=\"u1dbbd3e5\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">在 node v10 及以前：</span></p><ol class=\"ne-ol\"><li id=\"u560f8408\"><span class=\"ne-text\" style=\"font-size: 14px\">执行完 1-6 阶段的任务</span></li><li id=\"u24af6f94\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 nextTick 中的任务</span></li><li id=\"u6b770fab\"><span class=\"ne-text\" style=\"font-size: 14px\">执行完微任务队列中的任务</span></li></ol><p id=\"u6c7ff5b9\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">在 node v11 之后，node 在 setTimeout 执行后会手动清空微任务队列，用来保证结果贴近浏览器</span></p></div><p id=\"u83858e98\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\"></span></p><h3 id=\"TJa6Z\"><span class=\"ne-text\">案例</span></h3><pre data-language=\"javascript\" id=\"ETy1X\" class=\"ne-codeblock language-javascript\">async function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n \nasync function async2() {\n    console.log('async2')\n}\n \nconsole.log('script start')\n \nsetTimeout(function () {\n    console.log('setTimeout0')\n}, 0)\n \nsetTimeout(function () {\n    console.log('setTimeout2')\n}, 300)\n \nsetImmediate(() =&gt; console.log('setImmediate'));\n \nprocess.nextTick(() =&gt; console.log('nextTick1'));\n \nasync1();\n \nprocess.nextTick(() =&gt; console.log('nextTick2'));\n \nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve();\n    console.log('promise2')\n}).then(function () {\n    console.log('promise3')\n})\n \nconsole.log('script end')</pre><ul class=\"ne-ul\"><li id=\"u7a40a41e\"><span class=\"ne-text\" style=\"font-size: 14px\">先找到同步任务，输出 script start</span></li><li id=\"u20497a45\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</span></li><li id=\"uf7cca6e1\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第二个 setTimeout，300ms 后将里面的回调函数放到 timer 队列中</span></li><li id=\"uce150b27\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第一个 setImmediate，将里面的回调函数放到 check 队列中</span></li><li id=\"udb1c1194\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li id=\"ub4af3f8c\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 async1 函数，输出 async1 start</span></li><li id=\"u415792e2\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 async2 函数，输出 async2，async2 后面的输出 async1 end 进入微任务，等待下一轮的事件循环</span></li><li id=\"u5422cd44\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第二个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li id=\"u84245938\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</span></li><li id=\"uaa34cf68\"><span class=\"ne-text\" style=\"font-size: 14px\">then 里面的回调函数进入微任务队列</span></li><li id=\"u89bb1c55\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到同步任务，输出 script end</span></li><li id=\"u480356b6\"><span class=\"ne-text\" style=\"font-size: 14px\">执行下一轮回调函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</span></li><li id=\"u1f2d483f\"><span class=\"ne-text\" style=\"font-size: 14px\">然后执行微任务队列，依次输出 async1 end、promise3</span></li><li id=\"uab245ab6\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 timer 队列，依次输出 setTimeout0</span></li><li id=\"u87013448\"><span class=\"ne-text\" style=\"font-size: 14px\">接着执行 check 队列，依次输出 setImmediate</span></li><li id=\"u44172c50\"><span class=\"ne-text\" style=\"font-size: 14px\">300ms 后，timer 队列存在任务，执行输出 setTimeout2</span></li></ul><p id=\"u34cd94b0\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">执行结果如下：</span></p><pre data-language=\"shell\" id=\"gF2iX\" class=\"ne-codeblock language-shell\">script start\nasync1 start\nasync2\npromise1\npromise2\nscript end\nnextTick1\nnextTick2\nasync1 end\npromise3\nsetTimeout0\nsetImmediate\nsetTimeout2</pre></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"GzXwt\" id=\"GzXwt\"><span data-lake-id=\"ubf8b6200\" id=\"ubf8b6200\">执行栈</span></h2><p data-lake-id=\"u3fd75c27\" id=\"u3fd75c27\"><span data-lake-id=\"u41ff6199\" id=\"u41ff6199\">执行栈是类似函数调用栈的运行容器，执行栈为空时，javaScript 引擎会检查事件队列是否为空，如果不为空，那么将第一个任务压入执行栈中执行</span></p><h2 data-lake-id=\"cRycY\" id=\"cRycY\"><span data-lake-id=\"u6ba91760\" id=\"u6ba91760\">事件队列</span></h2><p data-lake-id=\"u3d31171d\" id=\"u3d31171d\"><span data-lake-id=\"ubc835cf6\" id=\"ubc835cf6\">事件队列就是一个存储着待执行任务的队列，其中的任务严格按照时间顺序来执行，队首的任务率先执行，队尾的任务最后执行。同时每次仅执行一个任务。</span></p><h2 data-lake-id=\"JbDwc\" id=\"JbDwc\"><span data-lake-id=\"u4724d818\" id=\"u4724d818\">javaScript 在浏览器中的事件循环机制</span></h2><ul list=\"uf5a9bec6\"><li fid=\"u8fa50d31\" data-lake-id=\"u30246495\" id=\"u30246495\"><span data-lake-id=\"uddb0fe16\" id=\"uddb0fe16\" class=\"lake-fontsize-11\">javaScript 是单线程执行的(两个线程同时操作 DOM，会发生冲突)，在代码执行的过程中，通过将不同函数的</span><strong><span data-lake-id=\"uc1bd6f07\" id=\"uc1bd6f07\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">执行上下文</span></strong><span data-lake-id=\"u461ec753\" id=\"u461ec753\" class=\"lake-fontsize-11\">压入</span><strong><span data-lake-id=\"u483f29d6\" id=\"u483f29d6\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">执行栈</span></strong><span data-lake-id=\"u19060c21\" id=\"u19060c21\" class=\"lake-fontsize-11\">中来保证代码的有序执行</span></li><li fid=\"u8fa50d31\" data-lake-id=\"u379cdf55\" id=\"u379cdf55\"><span data-lake-id=\"u6d139230\" id=\"u6d139230\" class=\"lake-fontsize-11\">最开始将整个 script 脚本作为一个宏任务执行，执行过程中同步代码直接执行</span><span data-lake-id=\"u9849fdcb\" id=\"u9849fdcb\">​</span></li><li fid=\"u8fa50d31\" data-lake-id=\"uef8237db\" id=\"uef8237db\"><span data-lake-id=\"u86aa8ef5\" id=\"u86aa8ef5\" class=\"lake-fontsize-11\">执行同步代码时，如果遇到了异步事件，javaScript 引擎将不会一直等待其返回结果，而是将这个事件暂时挂起，继续执行</span><strong><span data-lake-id=\"ued17d326\" id=\"ued17d326\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">执行栈</span></strong><span data-lake-id=\"ucefb9e92\" id=\"ucefb9e92\" class=\"lake-fontsize-11\">中的其它任务</span></li><li fid=\"u8fa50d31\" data-lake-id=\"u72924162\" id=\"u72924162\"><span data-lake-id=\"u8bd8d64f\" id=\"u8bd8d64f\" class=\"lake-fontsize-11\">当异步事件执行完毕后，再将异步事件对应的回调函数加入到</span><strong><span data-lake-id=\"uc66cd9e5\" id=\"uc66cd9e5\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">与当前执行栈不同的任务队列</span></strong><span data-lake-id=\"uc7e068d1\" id=\"uc7e068d1\" class=\"lake-fontsize-11\">中等待执行，宏任务进入宏任务队列，微任务进入微任务队列</span></li></ul><ul list=\"u48d431c8\"><li fid=\"u4ec89819\" data-lake-id=\"uf8f088c0\" id=\"uf8f088c0\"><span data-lake-id=\"u2739a59c\" id=\"u2739a59c\" class=\"lake-fontsize-11\">在主执行栈中的事件执行完毕后，javaScript 引擎会</span><strong><span data-lake-id=\"u65bea290\" id=\"u65bea290\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">首先判断微任务队列</span></strong><span data-lake-id=\"u1d3ba263\" id=\"u1d3ba263\" class=\"lake-fontsize-11\">中是否有任务可以执行，如果有就将微任务队列的</span><strong><span data-lake-id=\"u9260419d\" id=\"u9260419d\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">队首</span></strong><span data-lake-id=\"ue7dab18f\" id=\"ue7dab18f\" class=\"lake-fontsize-11\">的事件压入执行栈中执行。直到</span><strong><span data-lake-id=\"uce593be1\" id=\"uce593be1\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">微任务队列的所有任务全部执行完毕</span></strong></li><li fid=\"u4ec89819\" data-lake-id=\"u7270a7c7\" id=\"u7270a7c7\"><span data-lake-id=\"ub37e51eb\" id=\"ub37e51eb\">执行浏览器的 UI 线程渲染工作，渲染阶段会收到以下因素的影响</span></li></ul><ul list=\"u48d431c8\" data-lake-indent=\"1\"><li fid=\"u4ec89819\" data-lake-id=\"u85bb964f\" id=\"u85bb964f\"><span data-lake-id=\"ua624fc4b\" id=\"ua624fc4b\">屏幕分辨率改变，如果页面性能太差，为了不丢帧，浏览器会选择降低帧率</span></li><li fid=\"u4ec89819\" data-lake-id=\"u401c2231\" id=\"u401c2231\"><span data-lake-id=\"u1e6a149b\" id=\"u1e6a149b\">浏览器判断本次渲染是否会造成视觉上的改变，比如背景色改变</span></li><li fid=\"u4ec89819\" data-lake-id=\"u289961cd\" id=\"u289961cd\"><span data-lake-id=\"u8ac8dbe4\" id=\"u8ac8dbe4\">map of animation frame callbacks 为空</span></li></ul><ul list=\"u48d431c8\" start=\"3\"><li fid=\"u4ec89819\" data-lake-id=\"u4bd31d9b\" id=\"u4bd31d9b\"><span data-lake-id=\"u54828a05\" id=\"u54828a05\">检查是否有 web worker 任务，有则执行</span></li></ul><ul list=\"u48d431c8\" data-lake-indent=\"1\"><li fid=\"u4ec89819\" data-lake-id=\"u3d7f99c5\" id=\"u3d7f99c5\"><span data-lake-id=\"ub2633614\" id=\"ub2633614\">对需要渲染的文档，如果窗口发生了变化，就会调用 resize 事件(resize 自带节流)</span></li><li fid=\"u4ec89819\" data-lake-id=\"ue5fcdc17\" id=\"ue5fcdc17\"><span data-lake-id=\"u49aa7e99\" id=\"u49aa7e99\">对需要渲染的文档，如果页面发生了滚动，就会调用 scroll 事件(scroll 自带节流)</span></li><li fid=\"u4ec89819\" data-lake-id=\"ua6211f3d\" id=\"ua6211f3d\"><span data-lake-id=\"u8666306c\" id=\"u8666306c\">对需要渲染的文档，执行 requestAnimationFrame 回调</span></li><li fid=\"u4ec89819\" data-lake-id=\"u055bf1dd\" id=\"u055bf1dd\"><span data-lake-id=\"u18dad986\" id=\"u18dad986\">调用 IntersectionObserver 回调，重新渲染页面</span></li><li fid=\"u4ec89819\" data-lake-id=\"u111214e1\" id=\"u111214e1\"><span data-lake-id=\"u2479df00\" id=\"u2479df00\">最后会检查宏任务队列和微任务队列是否为空，如果为空会调用 idle 空闲周期算法，检测 requestIdleCallback 是否为空，如果不为空就会执行里面的回调</span></li></ul><ul list=\"u48d431c8\" start=\"4\"><li fid=\"u4ec89819\" data-lake-id=\"uf4c399d0\" id=\"uf4c399d0\"><span data-lake-id=\"u09aa814c\" id=\"u09aa814c\" class=\"lake-fontsize-11\">执行完本轮宏任务后，执行下一轮宏任务</span></li></ul><blockquote data-lake-id=\"ucb3016fe\" id=\"ucb3016fe\" class=\"lake-alert lake-alert-success\"><p data-lake-id=\"udf60241f\" id=\"udf60241f\"><strong><span data-lake-id=\"u294249ec\" id=\"u294249ec\">任务队列：</span></strong></p><ul list=\"u7789bbff\"><li fid=\"u08db6753\" data-lake-id=\"u5ef0c4ee\" id=\"u5ef0c4ee\"><strong><span data-lake-id=\"u63f3c760\" id=\"u63f3c760\">宏任务(macroTasks)队列：</span></strong></li></ul><ul list=\"u7789bbff\" data-lake-indent=\"1\"><li fid=\"u08db6753\" data-lake-id=\"ua1e7bc6e\" id=\"ua1e7bc6e\"><span data-lake-id=\"u85758ddb\" id=\"u85758ddb\">script 脚本的执行</span></li><li fid=\"u08db6753\" data-lake-id=\"udd49d99a\" id=\"udd49d99a\"><span data-lake-id=\"u6d3ebe7f\" id=\"u6d3ebe7f\">setTimeout/setInterval/setImmediate</span></li><li fid=\"u08db6753\" data-lake-id=\"u53b8c2c6\" id=\"u53b8c2c6\"><span data-lake-id=\"u352792cc\" id=\"u352792cc\"> I/O 操作</span></li><li fid=\"u08db6753\" data-lake-id=\"u998f7adc\" id=\"u998f7adc\"><span data-lake-id=\"u9e448f79\" id=\"u9e448f79\">UI 渲染</span></li></ul><ul list=\"u7789bbff\" start=\"2\"><li fid=\"u08db6753\" data-lake-id=\"u7bf9a383\" id=\"u7bf9a383\"><strong><span data-lake-id=\"ub73e04c8\" id=\"ub73e04c8\">微任务(microTasks)队列：</span></strong></li></ul><ul list=\"ue59036a4\" data-lake-indent=\"1\"><li fid=\"ude5f3d86\" data-lake-id=\"u2960ffe5\" id=\"u2960ffe5\"><span data-lake-id=\"u5144096a\" id=\"u5144096a\">promise 回调(必须有 resolve/reject 结果，同一块作用域内多个 resolve 中，其中一个执行完毕后其余的皆不再执行)</span></li><li fid=\"ude5f3d86\" data-lake-id=\"ue354bee4\" id=\"ue354bee4\"><span data-lake-id=\"u82083a5a\" id=\"u82083a5a\">node.js 中的 process.nextTick</span></li><li fid=\"ude5f3d86\" data-lake-id=\"u19559057\" id=\"u19559057\"><span data-lake-id=\"ua0b933a2\" id=\"ua0b933a2\">对 DOM 变化进行监听的 MutationObserver</span></li></ul></blockquote><p data-lake-id=\"u4b6baffc\" id=\"u4b6baffc\"><br></p><blockquote data-lake-id=\"uc78d2199\" id=\"uc78d2199\" class=\"lake-alert lake-alert-success\"><p data-lake-id=\"u85ad7f5c\" id=\"u85ad7f5c\"><strong><span data-lake-id=\"ud3649cf5\" id=\"ud3649cf5\">requestAnimationFrame 和 requestIdleCallback</span></strong></p><p data-lake-id=\"udfa755b4\" id=\"udfa755b4\" style=\"text-indent: 2em\"><span data-lake-id=\"ufabdbea9\" id=\"ufabdbea9\">前者是在渲染前执行的，因为动画会更改 dom 结构，后者是用来处理计算量大但不紧急的事件，当队列中没有任务执行时，会清空它内部的回调，也可以传入 timeout 参数，强制 timeout 秒后执行，但是会阻塞其他代码的执行</span></p></blockquote><h2 data-lake-id=\"ipMVF\" id=\"ipMVF\"><span data-lake-id=\"u07ae341d\" id=\"u07ae341d\">为什么 javaScript 引擎将异步任务区分为宏任务和微任务</span></h2><ul list=\"u6e6998e3\"><li fid=\"ub96dd4d3\" data-lake-id=\"ub60cf9c3\" id=\"ub60cf9c3\"><span data-lake-id=\"u2f6ca79d\" id=\"u2f6ca79d\">这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。</span></li><li fid=\"ub96dd4d3\" data-lake-id=\"uea6de08e\" id=\"uea6de08e\"><span data-lake-id=\"uf524d1ae\" id=\"uf524d1ae\">区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。</span></li></ul><h2 data-lake-id=\"qxOhd\" id=\"qxOhd\"><span data-lake-id=\"uf4e4e649\" id=\"uf4e4e649\">javaScript 在 node.js 环境下的事件循环机制</span></h2><p data-lake-id=\"u896c8a73\" id=\"u896c8a73\"><span data-lake-id=\"u549bb889\" id=\"u549bb889\" class=\"lake-fontsize-11\">当 node.js 启动后，它会初始化事件循环，处理已提供的输入脚本，它可能会调用一些异步的 API、调度定时器，或者调用 process.nextTick，然后开始处理事件循环</span></p><h3 data-lake-id=\"AavFm\" id=\"AavFm\"><span data-lake-id=\"ud759d967\" id=\"ud759d967\">node.js 中的微任务</span></h3><ul list=\"u66b1a600\"><li fid=\"ubb7495b7\" data-lake-id=\"uc9e145c5\" id=\"uc9e145c5\"><span data-lake-id=\"ud496e17f\" id=\"ud496e17f\" class=\"lake-fontsize-11\">process.nextTick 注册的回调 (nextTick task queue)</span></li><li fid=\"ubb7495b7\" data-lake-id=\"u8662d74f\" id=\"u8662d74f\"><span data-lake-id=\"u92feed7e\" id=\"u92feed7e\" class=\"lake-fontsize-11\">promise.then 注册的回调 (promise task queue)</span></li></ul><p data-lake-id=\"u3e278156\" id=\"u3e278156\"><span data-lake-id=\"u592b3a70\" id=\"u592b3a70\" class=\"lake-fontsize-11\">​</span><br></p><p data-lake-id=\"ufbbdf4fd\" id=\"ufbbdf4fd\"><span data-lake-id=\"u2905eec5\" id=\"u2905eec5\" class=\"lake-fontsize-11\">node 在执行微任务时，会优先执行 nextTick task queue 中的任务，执行完后会接着执行 promise task queue 中的任务。因此如果二者同时处于主线程或者事件循环中的相同阶段，process.nextTick 回调优先级 &gt; promise.then 回调优先级</span></p><h3 data-lake-id=\"TZ54M\" id=\"TZ54M\"><span data-lake-id=\"u4c8f0135\" id=\"u4c8f0135\">事件循环</span></h3><p data-lake-id=\"u1b71a0ab\" id=\"u1b71a0ab\"><span data-lake-id=\"u2d86c4a2\" id=\"u2d86c4a2\" class=\"lake-fontsize-11\">下面为 node 执行的整个过程，如果执行了任何非阻塞的异步代码，则会进入事件循环：</span></p><p data-lake-id=\"u4f1b1453\" id=\"u4f1b1453\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646662274965-6259f561-8bd7-4251-9810-67df3477bbcf.png%22%2C%22taskId%22%3A%22uc7f19d61-bd9e-44f6-adb0-4e441a2adbd%22%2C%22clientId%22%3A%22u5d023ea2-a4d9-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A980%2C%22height%22%3A556%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A180079%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A1960%2C%22originHeight%22%3A1112%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22NODE%20PENDING%20START%20TIMERS%20CALLBACKS%20MICROTASKS%20YES%20IDLE%2FPREPARE%20ACTIVE%20HANDLERS%20MAINLINE%20OR%20EVENT%20LOOP%20REQUESTS%20MICROTASKS%20MICROTASKS%20POLL%20NO%20NOTE%3ATHE%20TIMING%20OF%20THE%20CLOSE%20EXECUTION%20OF%20MICROTASKS%20CHECK%20HERE%20IS%20DIFFERENT%20FROM%20OTHERS%20CALLBACKS%20NODE%20END%20MICROTASKS%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A100.13535%2C%22y%22%3A61.772163%2C%22width%22%3A95.04871999999999%2C%22height%22%3A31.632431000000004%2C%22text%22%3A%22NODE%22%7D%2C%7B%22x%22%3A1265.4126%2C%22y%22%3A101.629585%2C%22width%22%3A140.7425999999998%2C%22height%22%3A36.936284999999984%2C%22text%22%3A%22PENDING%22%7D%2C%7B%22x%22%3A107.49211%2C%22y%22%3A115.21987%2C%22width%22%3A81.09487999999999%2C%22height%22%3A29.338710000000006%2C%22text%22%3A%22START%22%7D%2C%7B%22x%22%3A853.31934%2C%22y%22%3A125.65624%2C%22width%22%3A115.54509999999993%2C%22height%22%3A34.73559%2C%22text%22%3A%22TIMERS%22%7D%2C%7B%22x%22%3A1260.17%2C%22y%22%3A150.97543%2C%22width%22%3A150.37599999999998%2C%22height%22%3A34.23116000000002%2C%22text%22%3A%22CALLBACKS%22%7D%2C%7B%22x%22%3A831.6851%2C%22y%22%3A224.3897%2C%22width%22%3A158.6988%2C%22height%22%3A25.090100000000007%2C%22text%22%3A%22MICROTASKS%22%7D%2C%7B%22x%22%3A637.6718%2C%22y%22%3A277.9678%2C%22width%22%3A61.72140000000002%2C%22height%22%3A37.16805999999997%2C%22text%22%3A%22YES%22%7D%2C%7B%22x%22%3A1632.9617%2C%22y%22%3A352.89813%2C%22width%22%3A213.07219999999984%2C%22height%22%3A41.30717000000004%2C%22text%22%3A%22IDLE%2FPREPARE%22%7D%2C%7B%22x%22%3A558.51324%2C%22y%22%3A441.79303%2C%22width%22%3A74.36446000000001%2C%22height%22%3A23.752319999999997%2C%22text%22%3A%22ACTIVE%22%7D%2C%7B%22x%22%3A544.23553%2C%22y%22%3A475.55356%2C%22width%22%3A98.57426999999996%2C%22height%22%3A22.552489999999977%2C%22text%22%3A%22HANDLERS%22%7D%2C%7B%22x%22%3A73.71015%2C%22y%22%3A483.3756%2C%22width%22%3A147.39239%2C%22height%22%3A31.36599999999993%2C%22text%22%3A%22MAINLINE%22%7D%2C%7B%22x%22%3A577.933%2C%22y%22%3A512.9687%2C%22width%22%3A37.18443000000002%2C%22height%22%3A18.375%2C%22text%22%3A%22OR%22%7D%2C%7B%22x%22%3A1013.4062%2C%22y%22%3A540.8466%2C%22width%22%3A289.93230000000005%2C%22height%22%3A50.00570000000005%2C%22text%22%3A%22EVENT%20LOOP%22%7D%2C%7B%22x%22%3A542.0549%2C%22y%22%3A540.9865%2C%22width%22%3A103.53200000000004%2C%22height%22%3A23.8836%2C%22text%22%3A%22REQUESTS%22%7D%2C%7B%22x%22%3A68.47498%2C%22y%22%3A578.38257%2C%22width%22%3A158.34172%2C%22height%22%3A24.02773000000002%2C%22text%22%3A%22MICROTASKS%22%7D%2C%7B%22x%22%3A1850.2899%2C%22y%22%3A653.4574%2C%22width%22%3A27.527700000000095%2C%22height%22%3A145.64549999999997%2C%22text%22%3A%22MICROTASKS%22%7D%2C%7B%22x%22%3A1689.692%2C%22y%22%3A706.7841%2C%22width%22%3A64.93229999999994%2C%22height%22%3A32.97163999999998%2C%22text%22%3A%22POLL%22%7D%2C%7B%22x%22%3A426.15613%2C%22y%22%3A766.3127%2C%22width%22%3A55.61901999999998%2C%22height%22%3A31.51445000000001%2C%22text%22%3A%22NO%22%7D%2C%7B%22x%22%3A1613.3322%2C%22y%22%3A869.2507%2C%22width%22%3A264.3088%2C%22height%22%3A27.213300000000004%2C%22text%22%3A%22NOTE%3ATHE%20TIMING%20OF%20THE%22%7D%2C%7B%22x%22%3A861.90375%2C%22y%22%3A894.37787%2C%22width%22%3A94.73169000000007%2C%22height%22%3A39.62373000000002%2C%22text%22%3A%22CLOSE%22%7D%2C%7B%22x%22%3A1615.8507%2C%22y%22%3A903.93304%2C%22width%22%3A270.2772%2C%22height%22%3A21.895819999999958%2C%22text%22%3A%22EXECUTION%20OF%20MICROTASKS%22%7D%2C%7B%22x%22%3A1301.0377%2C%22y%22%3A924.56396%2C%22width%22%3A102.21769999999992%2C%22height%22%3A38.22203999999999%2C%22text%22%3A%22CHECK%22%7D%2C%7B%22x%22%3A1614.6619%2C%22y%22%3A934.76807%2C%22width%22%3A317.7111%2C%22height%22%3A25.66763000000003%2C%22text%22%3A%22HERE%20IS%20DIFFERENT%20FROM%20OTHERS%22%7D%2C%7B%22x%22%3A831.71906%2C%22y%22%3A943.4289%2C%22width%22%3A154.62634000000003%2C%22height%22%3A39.81920000000002%2C%22text%22%3A%22CALLBACKS%22%7D%2C%7B%22x%22%3A106.12054%2C%22y%22%3A949.29193%2C%22width%22%3A89.75146000000001%2C%22height%22%3A32.225040000000035%2C%22text%22%3A%22NODE%22%7D%2C%7B%22x%22%3A118.86394%2C%22y%22%3A1004.1138%2C%22width%22%3A64.96486%2C%22height%22%3A26.802500000000123%2C%22text%22%3A%22END%22%7D%2C%7B%22x%22%3A1272.4097%2C%22y%22%3A1025.9928%2C%22width%22%3A158.5748000000001%2C%22height%22%3A25.942000000000007%2C%22text%22%3A%22MICROTASKS%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22u2d752270%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u64610802\" id=\"u64610802\"><span data-lake-id=\"uf4fb4149\" id=\"uf4fb4149\" class=\"lake-fontsize-11\">​</span><br></p><p data-lake-id=\"uf5cbc935\" id=\"uf5cbc935\"><span data-lake-id=\"u1303e809\" id=\"u1303e809\" class=\"lake-fontsize-11\">其中事件循环分为六个阶段：</span></p><ul list=\"ud05978d1\"><li fid=\"u9f8fc63f\" data-lake-id=\"u72cb75d5\" id=\"u72cb75d5\"><span data-lake-id=\"u5bab2eff\" id=\"u5bab2eff\" class=\"lake-fontsize-11\">定时器 </span><strong><em><span data-lake-id=\"ufe10b776\" id=\"ufe10b776\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">timers</span></em></strong><span data-lake-id=\"u6c048cf6\" id=\"u6c048cf6\" class=\"lake-fontsize-11\">：本阶段执行已经被 setTimeout 和 setInterval 的调度回调函数</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"u9a553fb8\" id=\"u9a553fb8\"><span data-lake-id=\"u28b286b4\" id=\"u28b286b4\" class=\"lake-fontsize-11\">待定回调 </span><strong><em><span data-lake-id=\"u0b4a8c49\" id=\"u0b4a8c49\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">pending callbacks</span></em></strong><span data-lake-id=\"ub33ef0fb\" id=\"ub33ef0fb\" class=\"lake-fontsize-11\">：执行延迟到下一个循环迭代的 I/O 回调</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"ue8787399\" id=\"ue8787399\"><strong><em><span data-lake-id=\"ud3e585e0\" id=\"ud3e585e0\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">idle，prepare</span></em></strong><span data-lake-id=\"u2182cd44\" id=\"u2182cd44\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">：</span><span data-lake-id=\"u127d768c\" id=\"u127d768c\" class=\"lake-fontsize-11\">仅系统内部使用</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"u102afb60\" id=\"u102afb60\"><span data-lake-id=\"ub83fe0c7\" id=\"ub83fe0c7\" class=\"lake-fontsize-11\">轮询 </span><strong><em><span data-lake-id=\"ua43fc3ce\" id=\"ua43fc3ce\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">poll</span></em></strong><span data-lake-id=\"u03a2d54b\" id=\"u03a2d54b\" class=\"lake-fontsize-11\">：检索新的 I/O 事件；执行与 I/O 相关的回调(几乎所有情况下，除了 close callbacks，那些由定时器和 setImmediate 调度的之外)，其余情况 node 将在适当的时候在此阻塞</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"u3fbd4751\" id=\"u3fbd4751\"><span data-lake-id=\"u06f9f322\" id=\"u06f9f322\" class=\"lake-fontsize-11\">检测 </span><strong><em><span data-lake-id=\"u5abd6b5c\" id=\"u5abd6b5c\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">check</span></em></strong><span data-lake-id=\"u45f4fb09\" id=\"u45f4fb09\" class=\"lake-fontsize-11\">：setImmediate 回调函数在这里执行</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"u064f2b47\" id=\"u064f2b47\"><span data-lake-id=\"u5315ec27\" id=\"u5315ec27\" class=\"lake-fontsize-11\">关闭的回调函数 </span><strong><em><span data-lake-id=\"ud98678be\" id=\"ud98678be\" class=\"lake-fontsize-11\" style=\"color: rgba(33,95,255,1)\">close callbacks</span></em></strong><span data-lake-id=\"u9442c512\" id=\"u9442c512\" class=\"lake-fontsize-11\">：一些关闭的回调函数。如：</span><code data-lake-id=\"u1c572aae\" id=\"u1c572aae\"><span data-lake-id=\"u5e5155fd\" id=\"u5e5155fd\">socket.on('close', ...)</span></code></li></ul><p data-lake-id=\"u82a5d221\" id=\"u82a5d221\"><span data-lake-id=\"uc790bb8a\" id=\"uc790bb8a\" class=\"lake-fontsize-11\">​</span><br></p><blockquote data-lake-id=\"u83023bf7\" id=\"u83023bf7\" class=\"lake-alert lake-alert-warning\"><p data-lake-id=\"u95ee311b\" id=\"u95ee311b\"><span data-lake-id=\"u25919106\" id=\"u25919106\" class=\"lake-fontsize-11\">注意：</span></p><ol list=\"u1f4fd07f\"><li fid=\"u3ac4af13\" data-lake-id=\"u17d85251\" id=\"u17d85251\"><span data-lake-id=\"u62e66d7d\" id=\"u62e66d7d\" class=\"lake-fontsize-11\">每一个阶段都会有一个 FIFO 回调队列，都会尽可能地执行完当前阶段中所有的回调或者到达了系统相关的限制之后，才会进入下一阶段</span></li><li fid=\"u3ac4af13\" data-lake-id=\"ub0d3836a\" id=\"ub0d3836a\"><span data-lake-id=\"u0f7614e9\" id=\"u0f7614e9\" class=\"lake-fontsize-11\">poll 阶段执行微任务的时机与 timers &amp; check 阶段的时机不同，前者是在每一个回调执行的时候就会执行相应的微任务；后者会在所有回调执行完毕之后，才统一 执行相应的微任务</span></li></ol></blockquote><p data-lake-id=\"u47fc981a\" id=\"u47fc981a\"><span data-lake-id=\"u57230e26\" id=\"u57230e26\" class=\"lake-fontsize-11\">​</span><br></p><h3 data-lake-id=\"wgSt6\" id=\"wgSt6\"><span data-lake-id=\"u5bb33a31\" id=\"u5bb33a31\">setImmediate、setTimeout/setInterval 和 process.nextTick 执行时机</span></h3><ul list=\"ucd33fef1\"><li fid=\"u90ab7435\" data-lake-id=\"ud4df187c\" id=\"ud4df187c\"><strong><span data-lake-id=\"u0b16c1b5\" id=\"u0b16c1b5\" class=\"lake-fontsize-11\">setImmediate</span></strong></li></ul><p data-lake-id=\"u8653f645\" id=\"u8653f645\"><span data-lake-id=\"u0943021c\" id=\"u0943021c\" class=\"lake-fontsize-11\">触发一个异步回调，在事件循环的 check 阶段立即执行。</span></p><ul list=\"ucd33fef1\" start=\"2\"><li fid=\"u90ab7435\" data-lake-id=\"uac6725d6\" id=\"uac6725d6\"><strong><span data-lake-id=\"ua85c6c5a\" id=\"ua85c6c5a\" class=\"lake-fontsize-11\">setTimeout</span></strong></li></ul><p data-lake-id=\"uc0b0fd5b\" id=\"uc0b0fd5b\"><span data-lake-id=\"u49dce901\" id=\"u49dce901\" class=\"lake-fontsize-11\">触发一个异步回调，当计时器过期后，在事件循环的 timers 阶段执行，只执行一次（可用 clearTimeout 取消）。</span></p><ul list=\"ucd33fef1\" start=\"3\"><li fid=\"u90ab7435\" data-lake-id=\"ub7a81607\" id=\"ub7a81607\"><strong><span data-lake-id=\"ub453e9d3\" id=\"ub453e9d3\" class=\"lake-fontsize-11\">setInterval</span></strong></li></ul><p data-lake-id=\"u4da76ceb\" id=\"u4da76ceb\"><span data-lake-id=\"u2acc0829\" id=\"u2acc0829\" class=\"lake-fontsize-11\">触发一个异步回调，每次计时器过期后，都会在事件循环的 timers 阶段执行一次回调（可用 clearInterval 取消）。</span></p><ul list=\"ucd33fef1\" start=\"4\"><li fid=\"u90ab7435\" data-lake-id=\"ufa43990b\" id=\"ufa43990b\"><strong><span data-lake-id=\"u010ea97b\" id=\"u010ea97b\" class=\"lake-fontsize-11\">process.nextTick</span></strong></li></ul><p data-lake-id=\"ua7606637\" id=\"ua7606637\"><span data-lake-id=\"ucf1fe0ae\" id=\"ucf1fe0ae\" class=\"lake-fontsize-11\">触发一个微任务（异步）回调，既可以在主线程（mainline）中执行，可以存在事件循环的某一个阶段中执行。</span></p><h3 data-lake-id=\"Y21SO\" id=\"Y21SO\"><span data-lake-id=\"ud844282b\" id=\"ud844282b\">总结</span></h3><ul list=\"u61a2c784\"><li fid=\"u7ce3a8de\" data-lake-id=\"uf6ba8fff\" id=\"uf6ba8fff\"><span data-lake-id=\"u42ff2a62\" id=\"u42ff2a62\" class=\"lake-fontsize-11\">初始化事件循环，处理输入脚本，处理事件循环</span></li><li fid=\"u7ce3a8de\" data-lake-id=\"u291c4f90\" id=\"u291c4f90\"><span data-lake-id=\"ubc21edbb\" id=\"ubc21edbb\" class=\"lake-fontsize-11\">执行事件循环的每个阶段</span></li><li fid=\"u7ce3a8de\" data-lake-id=\"ua9a9c41c\" id=\"ua9a9c41c\"><span data-lake-id=\"ucd6ed6d6\" id=\"ucd6ed6d6\" class=\"lake-fontsize-11\">在相应阶段的回调执行时或者执行完，去执行微任务，其中 nextTick task queue &gt;  promise task queue</span></li></ul><blockquote data-lake-id=\"u3e7e49da\" id=\"u3e7e49da\" class=\"lake-alert lake-alert-success\"><p data-lake-id=\"u1dbbd3e5\" id=\"u1dbbd3e5\"><span data-lake-id=\"ud407ab1b\" id=\"ud407ab1b\" class=\"lake-fontsize-11\">在 node v10 及以前：</span></p><ol list=\"ufa107847\"><li fid=\"u58298666\" data-lake-id=\"u560f8408\" id=\"u560f8408\"><span data-lake-id=\"uab9ea1bc\" id=\"uab9ea1bc\" class=\"lake-fontsize-11\">执行完 1-6 阶段的任务</span></li><li fid=\"u58298666\" data-lake-id=\"u24af6f94\" id=\"u24af6f94\"><span data-lake-id=\"u04a630f2\" id=\"u04a630f2\" class=\"lake-fontsize-11\">执行 nextTick 中的任务</span></li><li fid=\"u58298666\" data-lake-id=\"u6b770fab\" id=\"u6b770fab\"><span data-lake-id=\"u6769791e\" id=\"u6769791e\" class=\"lake-fontsize-11\">执行完微任务队列中的任务</span></li></ol><p data-lake-id=\"u6c7ff5b9\" id=\"u6c7ff5b9\"><span data-lake-id=\"u4cccd4b3\" id=\"u4cccd4b3\" class=\"lake-fontsize-11\">在 node v11 之后，node 在 setTimeout 执行后会手动清空微任务队列，用来保证结果贴近浏览器</span></p></blockquote><p data-lake-id=\"u83858e98\" id=\"u83858e98\"><span data-lake-id=\"u9e969de1\" id=\"u9e969de1\" class=\"lake-fontsize-11\">​</span><br></p><h3 data-lake-id=\"TJa6Z\" id=\"TJa6Z\"><span data-lake-id=\"u1671ee9c\" id=\"u1671ee9c\">案例</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22async%C2%A0function%C2%A0async1()%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0console.log('async1%C2%A0start')%5Cn%C2%A0%C2%A0%C2%A0%C2%A0await%C2%A0async2()%5Cn%C2%A0%C2%A0%C2%A0%C2%A0console.log('async1%C2%A0end')%5Cn%7D%5Cn%20%5Cnasync%C2%A0function%C2%A0async2()%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0console.log('async2')%5Cn%7D%5Cn%20%5Cnconsole.log('script%C2%A0start')%5Cn%20%5CnsetTimeout(function%C2%A0()%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0console.log('setTimeout0')%5Cn%7D%2C%C2%A00)%5Cn%20%5CnsetTimeout(function%C2%A0()%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0console.log('setTimeout2')%5Cn%7D%2C%C2%A0300)%5Cn%20%5CnsetImmediate(()%C2%A0%3D%3E%C2%A0console.log('setImmediate'))%3B%5Cn%20%5Cnprocess.nextTick(()%C2%A0%3D%3E%C2%A0console.log('nextTick1'))%3B%5Cn%20%5Cnasync1()%3B%5Cn%20%5Cnprocess.nextTick(()%C2%A0%3D%3E%C2%A0console.log('nextTick2'))%3B%5Cn%20%5Cnnew%C2%A0Promise(function%C2%A0(resolve)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0console.log('promise1')%5Cn%C2%A0%C2%A0%C2%A0%C2%A0resolve()%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0console.log('promise2')%5Cn%7D).then(function%C2%A0()%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0console.log('promise3')%5Cn%7D)%5Cn%20%5Cnconsole.log('script%C2%A0end')%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22ETy1X%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ul list=\"uf5358931\"><li fid=\"u5ab13f46\" data-lake-id=\"u7a40a41e\" id=\"u7a40a41e\"><span data-lake-id=\"uf838717f\" id=\"uf838717f\" class=\"lake-fontsize-11\">先找到同步任务，输出 script start</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u20497a45\" id=\"u20497a45\"><span data-lake-id=\"uc630e9c4\" id=\"uc630e9c4\" class=\"lake-fontsize-11\">遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</span></li><li fid=\"u5ab13f46\" data-lake-id=\"uf7cca6e1\" id=\"uf7cca6e1\"><span data-lake-id=\"u0f80a9fa\" id=\"u0f80a9fa\" class=\"lake-fontsize-11\">遇到第二个 setTimeout，300ms 后将里面的回调函数放到 timer 队列中</span></li><li fid=\"u5ab13f46\" data-lake-id=\"uce150b27\" id=\"uce150b27\"><span data-lake-id=\"u1f264b3d\" id=\"u1f264b3d\" class=\"lake-fontsize-11\">遇到第一个 setImmediate，将里面的回调函数放到 check 队列中</span></li><li fid=\"u5ab13f46\" data-lake-id=\"udb1c1194\" id=\"udb1c1194\"><span data-lake-id=\"u1d66bb3f\" id=\"u1d66bb3f\" class=\"lake-fontsize-11\">遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li fid=\"u5ab13f46\" data-lake-id=\"ub4af3f8c\" id=\"ub4af3f8c\"><span data-lake-id=\"u024840ae\" id=\"u024840ae\" class=\"lake-fontsize-11\">执行 async1 函数，输出 async1 start</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u415792e2\" id=\"u415792e2\"><span data-lake-id=\"u25097e68\" id=\"u25097e68\" class=\"lake-fontsize-11\">执行 async2 函数，输出 async2，async2 后面的输出 async1 end 进入微任务，等待下一轮的事件循环</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u5422cd44\" id=\"u5422cd44\"><span data-lake-id=\"u9d8a4e58\" id=\"u9d8a4e58\" class=\"lake-fontsize-11\">遇到第二个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u84245938\" id=\"u84245938\"><span data-lake-id=\"u7dde9685\" id=\"u7dde9685\" class=\"lake-fontsize-11\">遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</span></li><li fid=\"u5ab13f46\" data-lake-id=\"uaa34cf68\" id=\"uaa34cf68\"><span data-lake-id=\"u6d590bae\" id=\"u6d590bae\" class=\"lake-fontsize-11\">then 里面的回调函数进入微任务队列</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u89bb1c55\" id=\"u89bb1c55\"><span data-lake-id=\"ufb51ea4f\" id=\"ufb51ea4f\" class=\"lake-fontsize-11\">遇到同步任务，输出 script end</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u480356b6\" id=\"u480356b6\"><span data-lake-id=\"u9dd69001\" id=\"u9dd69001\" class=\"lake-fontsize-11\">执行下一轮回调函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u1f2d483f\" id=\"u1f2d483f\"><span data-lake-id=\"u8900207e\" id=\"u8900207e\" class=\"lake-fontsize-11\">然后执行微任务队列，依次输出 async1 end、promise3</span></li><li fid=\"u5ab13f46\" data-lake-id=\"uab245ab6\" id=\"uab245ab6\"><span data-lake-id=\"u90429afa\" id=\"u90429afa\" class=\"lake-fontsize-11\">执行 timer 队列，依次输出 setTimeout0</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u87013448\" id=\"u87013448\"><span data-lake-id=\"uc4b6d73f\" id=\"uc4b6d73f\" class=\"lake-fontsize-11\">接着执行 check 队列，依次输出 setImmediate</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u44172c50\" id=\"u44172c50\"><span data-lake-id=\"uc952fe3e\" id=\"uc952fe3e\" class=\"lake-fontsize-11\">300ms 后，timer 队列存在任务，执行输出 setTimeout2</span></li></ul><p data-lake-id=\"u34cd94b0\" id=\"u34cd94b0\"><span data-lake-id=\"ufa7631be\" id=\"ufa7631be\" class=\"lake-fontsize-11\">执行结果如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22shell%22%2C%22code%22%3A%22script%C2%A0start%5Cnasync1%C2%A0start%5Cnasync2%5Cnpromise1%5Cnpromise2%5Cnscript%C2%A0end%5CnnextTick1%5CnnextTick2%5Cnasync1%C2%A0end%5Cnpromise3%5CnsetTimeout0%5CnsetImmediate%5CnsetTimeout2%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22gF2iX%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-06-30T07:08:23.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:47.000Z",
  "updated_at": "2022-06-30T07:08:24.000Z",
  "published_at": "2022-06-30T07:08:23.000Z",
  "first_published_at": "2022-04-04T11:32:47.122Z",
  "word_count": 2256,
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1646662274965-6259f561-8bd7-4251-9810-67df3477bbcf.png",
  "description": "执行栈执行栈是类似函数调用栈的运行容器，执行栈为空时，javaScript 引擎会检查事件队列是否为空，如果不为空，那么将第一个任务压入执行栈中执行事件队列事件队列就是一个存储着待执行任务的队列，其中的任务严格按照时间顺序来执行，队首的任务率先执行，队尾的任务最后执行。同时每次仅执行一个任务。...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}