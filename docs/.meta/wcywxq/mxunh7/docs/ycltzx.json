{
  "id": 72212037,
  "slug": "ycltzx",
  "title": "vue 和 react 中的 key",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"LrRWN\"></a>\n## key 的作用\n- 在开发过程中，我们需要保证某个元素的 `key` 在其统计元素中具有唯一性\n- 在 `vue` 中\n   - 如果不使用 `key`，`vue` 默认会使用一种最大限度减少动态元素并且尽可能的尝试就地修改或者复用相同类型元素的做法\n   - `key` 是 `vnode` 的唯一标记，用来使 `diff` 节点的操纵更准确、更便捷\n      - 更准确：如果元素提供了 `key`，将不会走默认的就地复用逻辑，因此会更加准确\n      - 更快捷：如果元素提供了 `key`，将可以利用 `key` 的唯一性生成 `map` 对象来获取对应节点，整体而言比遍历查找的方式更迅速\n- 在 `react`中\n   - `react` 的 `diff` 算法会借助元素的 `key` 值来判断元素是最新创建的还是被移动而来的元素，从而减少不必要的元素重渲染\n   - 此外，`react` 还需要借助 `key` 值来判断元素与本地状态的关联关系\n<a name=\"GifFx\"></a>\n## 为什么不建议用 index 作为 key\n使用 `index` 作为 `key` 和没写基本上没区别，因为无论数组的顺序如何变换，`index` 的顺序是不会改变的，导致 `vue` 会复用错误的旧节点，耗费很多时间去做额外的工作。\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"LrRWN\"><span class=\"ne-text\">key 的作用</span></h2><ul class=\"ne-ul\"><li id=\"u0359e190\"><span class=\"ne-text\">在开发过程中，我们需要保证某个元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 在其统计元素中具有唯一性</span></li><li id=\"u534d62a2\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">vue</span></code><span class=\"ne-text\"> 中</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u3e1dd47a\"><span class=\"ne-text\">如果不使用 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\">，</span><code class=\"ne-code\"><span class=\"ne-text\">vue</span></code><span class=\"ne-text\"> 默认会使用一种最大限度减少动态元素并且尽可能的尝试就地修改或者复用相同类型元素的做法</span></li><li id=\"u7623c17a\"><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 是 </span><code class=\"ne-code\"><span class=\"ne-text\">vnode</span></code><span class=\"ne-text\"> 的唯一标记，用来使 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 节点的操纵更准确、更便捷</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u0e0dcf77\"><span class=\"ne-text\">更准确：如果元素提供了 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\">，将不会走默认的就地复用逻辑，因此会更加准确</span></li><li id=\"u95673f10\"><span class=\"ne-text\">更快捷：如果元素提供了 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\">，将可以利用 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 的唯一性生成 </span><code class=\"ne-code\"><span class=\"ne-text\">map</span></code><span class=\"ne-text\"> 对象来获取对应节点，整体而言比遍历查找的方式更迅速</span></li></ul></ul></ul><ul class=\"ne-ul\"><li id=\"u489044b3\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\">中</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ub4cc2d8f\"><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">diff</span></code><span class=\"ne-text\"> 算法会借助元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 值来判断元素是最新创建的还是被移动而来的元素，从而减少不必要的元素重渲染</span></li><li id=\"uf31ce899\"><span class=\"ne-text\">此外，</span><code class=\"ne-code\"><span class=\"ne-text\">react</span></code><span class=\"ne-text\"> 还需要借助 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 值来判断元素与本地状态的关联关系</span></li></ul></ul><h2 id=\"GifFx\"><span class=\"ne-text\">为什么不建议用 index 作为 key</span></h2><p id=\"u88409ade\" class=\"ne-p\"><span class=\"ne-text\">使用 </span><code class=\"ne-code\"><span class=\"ne-text\">index</span></code><span class=\"ne-text\"> 作为 </span><code class=\"ne-code\"><span class=\"ne-text\">key</span></code><span class=\"ne-text\"> 和没写基本上没区别，因为无论数组的顺序如何变换，</span><code class=\"ne-code\"><span class=\"ne-text\">index</span></code><span class=\"ne-text\"> 的顺序是不会改变的，导致 </span><code class=\"ne-code\"><span class=\"ne-text\">vue</span></code><span class=\"ne-text\"> 会复用错误的旧节点，耗费很多时间去做额外的工作。</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"LrRWN\" id=\"LrRWN\"><span data-lake-id=\"ub016bf35\" id=\"ub016bf35\">key 的作用</span></h2><ul list=\"u83184595\"><li fid=\"u46c4c114\" data-lake-id=\"u0359e190\" id=\"u0359e190\"><span data-lake-id=\"u2990c790\" id=\"u2990c790\">在开发过程中，我们需要保证某个元素的 </span><code data-lake-id=\"uefdf5093\" id=\"uefdf5093\"><span data-lake-id=\"u81d83634\" id=\"u81d83634\">key</span></code><span data-lake-id=\"u726bc748\" id=\"u726bc748\"> 在其统计元素中具有唯一性</span></li><li fid=\"u46c4c114\" data-lake-id=\"u534d62a2\" id=\"u534d62a2\"><span data-lake-id=\"uc3129784\" id=\"uc3129784\">在 </span><code data-lake-id=\"ubb29a09a\" id=\"ubb29a09a\"><span data-lake-id=\"ub405a5e1\" id=\"ub405a5e1\">vue</span></code><span data-lake-id=\"ud110da08\" id=\"ud110da08\"> 中</span></li></ul><ul list=\"u83184595\" data-lake-indent=\"1\"><li fid=\"u46c4c114\" data-lake-id=\"u3e1dd47a\" id=\"u3e1dd47a\"><span data-lake-id=\"ucac42071\" id=\"ucac42071\">如果不使用 </span><code data-lake-id=\"u8d21d003\" id=\"u8d21d003\"><span data-lake-id=\"uda3bd8d8\" id=\"uda3bd8d8\">key</span></code><span data-lake-id=\"u5aff4380\" id=\"u5aff4380\">，</span><code data-lake-id=\"udc44b82c\" id=\"udc44b82c\"><span data-lake-id=\"u9a97995c\" id=\"u9a97995c\">vue</span></code><span data-lake-id=\"u8933d7df\" id=\"u8933d7df\"> 默认会使用一种最大限度减少动态元素并且尽可能的尝试就地修改或者复用相同类型元素的做法</span></li><li fid=\"u46c4c114\" data-lake-id=\"u7623c17a\" id=\"u7623c17a\"><code data-lake-id=\"uae4c1938\" id=\"uae4c1938\"><span data-lake-id=\"u0713e777\" id=\"u0713e777\">key</span></code><span data-lake-id=\"u95614848\" id=\"u95614848\"> 是 </span><code data-lake-id=\"u5668aab1\" id=\"u5668aab1\"><span data-lake-id=\"u836da425\" id=\"u836da425\">vnode</span></code><span data-lake-id=\"u8f13fd0d\" id=\"u8f13fd0d\"> 的唯一标记，用来使 </span><code data-lake-id=\"u4a7e46eb\" id=\"u4a7e46eb\"><span data-lake-id=\"u575d3df3\" id=\"u575d3df3\">diff</span></code><span data-lake-id=\"u5ed37214\" id=\"u5ed37214\"> 节点的操纵更准确、更便捷</span></li></ul><ul list=\"u83184595\" data-lake-indent=\"2\"><li fid=\"u46c4c114\" data-lake-id=\"u0e0dcf77\" id=\"u0e0dcf77\"><span data-lake-id=\"u731fb3a9\" id=\"u731fb3a9\">更准确：如果元素提供了 </span><code data-lake-id=\"u55f4cb2c\" id=\"u55f4cb2c\"><span data-lake-id=\"u84b750ea\" id=\"u84b750ea\">key</span></code><span data-lake-id=\"u6d337ca5\" id=\"u6d337ca5\">，将不会走默认的就地复用逻辑，因此会更加准确</span></li><li fid=\"u46c4c114\" data-lake-id=\"u95673f10\" id=\"u95673f10\"><span data-lake-id=\"ufefce2f9\" id=\"ufefce2f9\">更快捷：如果元素提供了 </span><code data-lake-id=\"ufdef8eb5\" id=\"ufdef8eb5\"><span data-lake-id=\"u5447fd5c\" id=\"u5447fd5c\">key</span></code><span data-lake-id=\"u94e6dee7\" id=\"u94e6dee7\">，将可以利用 </span><code data-lake-id=\"u3864f92e\" id=\"u3864f92e\"><span data-lake-id=\"u98975742\" id=\"u98975742\">key</span></code><span data-lake-id=\"u200bf0c6\" id=\"u200bf0c6\"> 的唯一性生成 </span><code data-lake-id=\"u527f3bb9\" id=\"u527f3bb9\"><span data-lake-id=\"ub787a000\" id=\"ub787a000\">map</span></code><span data-lake-id=\"u3b5394a1\" id=\"u3b5394a1\"> 对象来获取对应节点，整体而言比遍历查找的方式更迅速</span></li></ul><ul list=\"u83184595\" start=\"3\"><li fid=\"u46c4c114\" data-lake-id=\"u489044b3\" id=\"u489044b3\"><span data-lake-id=\"uad28ac6f\" id=\"uad28ac6f\">在 </span><code data-lake-id=\"u3507cc07\" id=\"u3507cc07\"><span data-lake-id=\"ub31f65a6\" id=\"ub31f65a6\">react</span></code><span data-lake-id=\"u07a442ab\" id=\"u07a442ab\">中</span></li></ul><ul list=\"u83184595\" data-lake-indent=\"1\"><li fid=\"u46c4c114\" data-lake-id=\"ub4cc2d8f\" id=\"ub4cc2d8f\"><code data-lake-id=\"ua9d9bf3a\" id=\"ua9d9bf3a\"><span data-lake-id=\"uca0321d0\" id=\"uca0321d0\">react</span></code><span data-lake-id=\"u076a4265\" id=\"u076a4265\"> 的 </span><code data-lake-id=\"u7aba09af\" id=\"u7aba09af\"><span data-lake-id=\"u2cace1a9\" id=\"u2cace1a9\">diff</span></code><span data-lake-id=\"u30637498\" id=\"u30637498\"> 算法会借助元素的 </span><code data-lake-id=\"ufec622b8\" id=\"ufec622b8\"><span data-lake-id=\"u7048d45f\" id=\"u7048d45f\">key</span></code><span data-lake-id=\"u41fc17f3\" id=\"u41fc17f3\"> 值来判断元素是最新创建的还是被移动而来的元素，从而减少不必要的元素重渲染</span></li><li fid=\"u46c4c114\" data-lake-id=\"uf31ce899\" id=\"uf31ce899\"><span data-lake-id=\"u99502ed9\" id=\"u99502ed9\">此外，</span><code data-lake-id=\"u18b0781d\" id=\"u18b0781d\"><span data-lake-id=\"ubbd97b2b\" id=\"ubbd97b2b\">react</span></code><span data-lake-id=\"ufe15d763\" id=\"ufe15d763\"> 还需要借助 </span><code data-lake-id=\"u284c2a17\" id=\"u284c2a17\"><span data-lake-id=\"ucd2cc336\" id=\"ucd2cc336\">key</span></code><span data-lake-id=\"u530c8ecf\" id=\"u530c8ecf\"> 值来判断元素与本地状态的关联关系</span></li></ul><h2 data-lake-id=\"GifFx\" id=\"GifFx\"><span data-lake-id=\"u26002e0e\" id=\"u26002e0e\">为什么不建议用 index 作为 key</span></h2><p data-lake-id=\"u88409ade\" id=\"u88409ade\"><span data-lake-id=\"u0f53bc57\" id=\"u0f53bc57\">使用 </span><code data-lake-id=\"uc4d3da1b\" id=\"uc4d3da1b\"><span data-lake-id=\"u4819c39d\" id=\"u4819c39d\">index</span></code><span data-lake-id=\"u2847d902\" id=\"u2847d902\"> 作为 </span><code data-lake-id=\"u9b085cc2\" id=\"u9b085cc2\"><span data-lake-id=\"u6fd89d16\" id=\"u6fd89d16\">key</span></code><span data-lake-id=\"ua8413858\" id=\"ua8413858\"> 和没写基本上没区别，因为无论数组的顺序如何变换，</span><code data-lake-id=\"u37887a33\" id=\"u37887a33\"><span data-lake-id=\"u717f37b6\" id=\"u717f37b6\">index</span></code><span data-lake-id=\"uf11f0f7b\" id=\"uf11f0f7b\"> 的顺序是不会改变的，导致 </span><code data-lake-id=\"u379634c5\" id=\"u379634c5\"><span data-lake-id=\"ua04c7f41\" id=\"ua04c7f41\">vue</span></code><span data-lake-id=\"u54337939\" id=\"u54337939\"> 会复用错误的旧节点，耗费很多时间去做额外的工作。</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-28T16:59:59.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:40.000Z",
  "updated_at": "2022-04-28T17:00:00.000Z",
  "published_at": "2022-04-28T16:59:59.000Z",
  "first_published_at": "2022-04-04T11:32:39.496Z",
  "word_count": 354,
  "cover": null,
  "description": "key 的作用在开发过程中，我们需要保证某个元素的 key 在其统计元素中具有唯一性在 vue 中如果不使用 key，vue 默认会使用一种最大限度减少动态元素并且尽可能的尝试就地修改或者复用相同类型元素的做法key 是 vnode 的唯一标记，用来使 diff 节点的操纵更准确、更便捷更准确...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}