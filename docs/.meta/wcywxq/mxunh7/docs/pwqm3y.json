{
  "id": 72212205,
  "slug": "pwqm3y",
  "title": "setState 相关问题",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"oBA5a\"></a>\n## setState 之后发生了什么\n<a name=\"HXVkQ\"></a>\n### 简单版本\nreact 利用状态队列机制实现了 setState 的\"异步\"更新，避免频繁的重复更新 state。首先将新的 state 合并到状态更新队列中，然后根据更新队列和 shouldComponentUpdate 的状态来判断是否需要更新组件。\n<a name=\"yJh1d\"></a>\n### 复杂版本\n\n1. enqueueSetState 将 state 放入队列中，并调用 enqueueUpdate 处理需要更新的 Component\n2. 如果组件当前正处于 update 事务中，则先将 Component 存入 dirtyComponent 中，否则调用 batchedUpdates 处理\n3. batchedUpdates 发起一次 transaction.perform() 事务\n4. 开始执行事务初始化、运行、结束三个阶段\n   1. 初始化：事务初始化阶段没有注册方法，因此无方法要执行\n   2. 运行：执行 setState 时传入的 callback 方法\n   3. 结束：更新 isBatchingUpdates 为 false，并执行 FLUSH_BATCHED_UPDATES 这个 wrapper 中的 close 方法，FLUSH_BATCHED_UPDATES 在 close 阶段，会循环遍历所有的 dirtyComponents，调用 updateComponent 刷新组件，并执行它的 pendingCallbacks，也就是 setState 中设置的 callback\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647436689950-e2481d82-ba34-4444-999d-6394d138a83c.png#clientId=u14a0d2a2-59e0-4&from=paste&height=826&id=u06226bd9&originHeight=826&originWidth=1263&originalType=binary&ratio=1&size=151915&status=done&style=none&taskId=u2705d769-6a18-4441-afa6-d597ec634a5&width=1263)\n\n---\n\n<a name=\"LYSey\"></a>\n## setState 是同步还是异步\n\nsetState 有时表现为异步，有时表现为同步\n\nsetState 只在 **合成事件 **和 **钩子函数 **中是\"异步\"的，在 **原生事件 **和 **setTimeout** 中都是同步的\n\nsetState 的\"异步\"并不是说内部由异步代码实现，其本身执行的过程和代码都是同步的，只是 **合成事件** 和 **钩子函数** 的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成所谓的 \"异步\"，当然可以通过**第二个参数** setState(partialState, callback) 中的 callback 拿到更新后的结果\n\nsetState 的批量更新优化也是建立在 \"异步\"(合成事件、钩子函数)之上的，在 **原生事件** 和 **setTimeout **中不会批量更新。在\"异步\"中如果对同一个值进行 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新\n<a name=\"kocyt\"></a>\n### 为什么 setState 不设计为同步的\n\n- 保持内部的一致性和状态的安全性\n\nstate、props、refs 一致性\n\n- 性能优化\n\nreact 会对依据不同的调用源，给不同的 setState 调用分配不同的优先级。调用源包括：事件处理、网络请求、动画\n\n- 更多的可能性\n\n异步获取数据后，统一渲染页面，保持一致性\n\n---\n\n<a name=\"LCTa8\"></a>\n## setState 批量更新的过程是什么\n调用 setState 时，组件的 state 并不会立即改变，setState 只是把要修改的 state 放入一个队列，react 会优化真正的执行实际，并处于性能原因，会将 react 事件处理程序中的多次 setState 的状态修改并合并成一次状态修改。最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要\n\n---\n\n<a name=\"v3o1p\"></a>\n## setState 的第二个参数作用是什么\nsetState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议用 componentDidUpdate 来代替此方式。在这个回调函数中可以拿到更新后的 state 的值。\n\n---\n\n<a name=\"bJtnG\"></a>\n## 在 shouldComponentUpdate 中使用 setState 会发生什么\n当调用 setState 的时候，实际上会将新的 state 合并到状态更新队列中，并对 partialState 以及 _pendingStateQueue 更新队列进行合并操作。最终通过 enqueueUpdate 执行 state 更新。<br />如果在 shouldComponent 中使用 setState，会使得 state 队列(_pendingStateQueue)不为 null，从而调用 updateComponent 方法，updateComponent 中会继续调用 shouldComponentUpdate，因此会造成死循环。\n\n---\n\n<a name=\"x4MVA\"></a>\n## setState 和 replaceState 的区别\n:::info\n**总结：** <br />setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而 replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。\n:::\n<a name=\"IHDSq\"></a>\n### setState\nsetState 用于设置状态对象，用法如下：\n```javascript\nsetState(object nextState[, function callback])\n```\n\n- nextState，将要设置的新状态，该状态会和当前的state合并\n- callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。\n\n合并 nextState 和当前 state，并重新渲染组件。setState 是 React 事件处理函数中和请求回调函数中触发UI更新的主要方法。\n<a name=\"rZ2U7\"></a>\n### replaceState\nreplaceState 方法与 setState 类似，但是方法只会保留 nextState 中的状态，原 state 不在 nextState 中的状态都会被删除，用法如下：\n```javascript\nreplaceState(object nextState[, function callback])\n```\n\n- nextState，将要设置的新状态，该状态会替换当前的state。\n- callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。\n\n---\n\n<a name=\"X5G1r\"></a>\n## 为什么不能直接使用 this.state 改变数据\nsetState 通过一个队列机制来实现 state 更新。当执行 setState 的时候，会将需要更新的 state 合并后放入状态队列，而不会立刻更新 this.state。队列机制可以高效的批量更新 state，如果不通过 setState 而直接修改 this.state，那么该 state 将不会被放入状态队列中，当下次调用 setState 并对状态队列进行合并时，将会忽略之前被直接修改的 state，而造成无法预知的错误。\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"oBA5a\"><span>setState 之后发生了什么</span></h2><h3 id=\"HXVkQ\"><span>简单版本</span></h3><p data-lake-id=\"ue1c36905\" style=\"text-indent: 2em;\"><span>react 利用状态队列机制实现了 setState 的&quot;异步&quot;更新，避免频繁的重复更新 state。首先将新的 state 合并到状态更新队列中，然后根据更新队列和 shouldComponentUpdate 的状态来判断是否需要更新组件。</span></p><h3 id=\"yJh1d\"><span>复杂版本</span></h3><ol><li><span>enqueueSetState 将 state 放入队列中，并调用 enqueueUpdate 处理需要更新的 Component</span></li><li><span>如果组件当前正处于 update 事务中，则先将 Component 存入 dirtyComponent 中，否则调用 batchedUpdates 处理</span></li><li><span>batchedUpdates 发起一次 transaction.perform() 事务</span></li><li><span>开始执行事务初始化、运行、结束三个阶段</span></li></ol><ol data-lake-indent=\"1\"><li><span>初始化：事务初始化阶段没有注册方法，因此无方法要执行</span></li><li><span>运行：执行 setState 时传入的 callback 方法</span></li><li><span>结束：更新 isBatchingUpdates 为 false，并执行 FLUSH_BATCHED_UPDATES 这个 wrapper 中的 close 方法，FLUSH_BATCHED_UPDATES 在 close 阶段，会循环遍历所有的 dirtyComponents，调用 updateComponent 刷新组件，并执行它的 pendingCallbacks，也就是 setState 中设置的 callback</span></li></ol><p data-lake-id=\"u434af8d1\"><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647436689950-e2481d82-ba34-4444-999d-6394d138a83c.png#clientId=u14a0d2a2-59e0-4&amp;from=paste&amp;height=826&amp;id=u06226bd9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=826&amp;originWidth=1263&amp;originalType=binary&amp;ratio=1&amp;size=151915&amp;status=done&amp;style=none&amp;taskId=u2705d769-6a18-4441-afa6-d597ec634a5&amp;width=1263\" style=\"max-width: 600px; width: 1263px;\" /></p><hr /><h2 id=\"LYSey\"><span>setState 是同步还是异步</span></h2><p data-lake-id=\"u59277ee0\"><br /></p><p data-lake-id=\"uec0a6840\"><span>setState 有时表现为异步，有时表现为同步</span></p><p data-lake-id=\"ufe492a79\"><span>​</span><br /></p><p data-lake-id=\"u4ada018a\"><span>setState 只在 </span><strong><span>合成事件 </span></strong><span>和 </span><strong><span>钩子函数 </span></strong><span>中是&quot;异步&quot;的，在 </span><strong><span>原生事件 </span></strong><span>和 </span><strong><span>setTimeout</span></strong><span> 中都是同步的</span></p><p data-lake-id=\"u77af545b\"><span>​</span><br /></p><p data-lake-id=\"ud4bc1616\"><span>setState 的&quot;异步&quot;并不是说内部由异步代码实现，其本身执行的过程和代码都是同步的，只是 </span><strong><span>合成事件</span></strong><span> 和 </span><strong><span>钩子函数</span></strong><span> 的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成所谓的 &quot;异步&quot;，当然可以通过</span><strong><span>第二个参数</span></strong><span> setState(partialState, callback) 中的 callback 拿到更新后的结果</span></p><p data-lake-id=\"u5e9c5d13\"><span>​</span><br /></p><p data-lake-id=\"u7d51ac49\"><span>setState 的批量更新优化也是建立在 &quot;异步&quot;(合成事件、钩子函数)之上的，在 </span><strong><span>原生事件</span></strong><span> 和 </span><strong><span>setTimeout </span></strong><span>中不会批量更新。在&quot;异步&quot;中如果对同一个值进行 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新</span></p><h3 id=\"kocyt\"><span>为什么 setState 不设计为同步的</span></h3><ul><li><span>保持内部的一致性和状态的安全性</span></li></ul><p data-lake-id=\"u89ceceec\"><span>state、props、refs 一致性</span></p><ul><li><span>性能优化</span></li></ul><p data-lake-id=\"u635e1dfa\"><span>react 会对依据不同的调用源，给不同的 setState 调用分配不同的优先级。调用源包括：事件处理、网络请求、动画</span></p><ul><li><span>更多的可能性</span></li></ul><p data-lake-id=\"u435c05e0\"><span>异步获取数据后，统一渲染页面，保持一致性</span></p><hr /><h2 id=\"LCTa8\"><span>setState 批量更新的过程是什么</span></h2><p data-lake-id=\"ua351350c\" style=\"text-indent: 2em;\"><span>调用 setState 时，组件的 state 并不会立即改变，setState 只是把要修改的 state 放入一个队列，react 会优化真正的执行实际，并处于性能原因，会将 react 事件处理程序中的多次 setState 的状态修改并合并成一次状态修改。最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要</span></p><hr /><h2 id=\"v3o1p\"><span>setState 的第二个参数作用是什么</span></h2><p data-lake-id=\"ueb216df9\" style=\"text-indent: 2em;\"><span>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议用 componentDidUpdate 来代替此方式。在这个回调函数中可以拿到更新后的 state 的值。</span></p><hr /><h2 id=\"bJtnG\"><span>在 shouldComponentUpdate 中使用 setState 会发生什么</span></h2><p data-lake-id=\"uca744d33\" style=\"text-indent: 2em;\"><span>当调用 setState 的时候，实际上会将新的 state 合并到状态更新队列中，并对 partialState 以及 _pendingStateQueue 更新队列进行合并操作。最终通过 enqueueUpdate 执行 state 更新。</span></p><p data-lake-id=\"ued838a58\" style=\"text-indent: 2em;\"><span>如果在 shouldComponent 中使用 setState，会使得 state 队列(_pendingStateQueue)不为 null，从而调用 updateComponent 方法，updateComponent 中会继续调用 shouldComponentUpdate，因此会造成死循环。</span></p><hr /><h2 id=\"x4MVA\"><span>setState 和 replaceState 的区别</span></h2><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"uc4d9ad19\"><strong><span>总结：</span></strong><span> </span></p><p data-lake-id=\"u0980a2dc\" style=\"text-indent: 2em;\"><span>setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而 replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</span></p></blockquote><h3 id=\"IHDSq\"><span>setState</span></h3><p data-lake-id=\"ub34c910b\"><span>setState 用于设置状态对象，用法如下：</span></p><pre data-lang=\"javascript\"><code>setState(object nextState[, function callback])</code></pre><ul><li><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">nextState，将要设置的新状态，该状态会和当前的state合并</span></li><li><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</span></li></ul><p data-lake-id=\"u6a2ce896\" style=\"text-indent: 2em;\"><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">合并 nextState 和当前 state，并重新渲染组件。setState 是 React 事件处理函数中和请求回调函数中触发UI更新的主要方法。</span></p><h3 id=\"rZ2U7\"><span>replaceState</span></h3><p data-lake-id=\"ueb779255\"><span>replaceState 方法与 setState 类似，但是方法只会保留 nextState 中的状态，原 state 不在 nextState 中的状态都会被删除，用法如下：</span></p><pre data-lang=\"javascript\"><code>replaceState(object nextState[, function callback])</code></pre><ul><li><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">nextState，将要设置的新状态，该状态会替换当前的state。</span></li><li><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</span></li></ul><hr /><h2 id=\"X5G1r\"><span>为什么不能直接使用 this.state 改变数据</span></h2><p data-lake-id=\"u864fb434\" style=\"text-indent: 2em;\"><span>setState 通过一个队列机制来实现 state 更新。当执行 setState 的时候，会将需要更新的 state 合并后放入状态队列，而不会立刻更新 this.state。队列机制可以高效的批量更新 state，如果不通过 setState 而直接修改 this.state，那么该 state 将不会被放入状态队列中，当下次调用 setState 并对状态队列进行合并时，将会忽略之前被直接修改的 state，而造成无法预知的错误。</span></p><p data-lake-id=\"u641d1ef9\"><br /></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"oBA5a\" id=\"oBA5a\"><span data-lake-id=\"uf42c73fd\" id=\"uf42c73fd\">setState 之后发生了什么</span></h2><h3 data-lake-id=\"HXVkQ\" id=\"HXVkQ\"><span data-lake-id=\"u51a58324\" id=\"u51a58324\">简单版本</span></h3><p data-lake-id=\"ue1c36905\" id=\"ue1c36905\" style=\"text-indent: 2em\"><span data-lake-id=\"u2edafbe4\" id=\"u2edafbe4\">react 利用状态队列机制实现了 setState 的&quot;异步&quot;更新，避免频繁的重复更新 state。首先将新的 state 合并到状态更新队列中，然后根据更新队列和 shouldComponentUpdate 的状态来判断是否需要更新组件。</span></p><h3 data-lake-id=\"yJh1d\" id=\"yJh1d\"><span data-lake-id=\"ud996cdec\" id=\"ud996cdec\">复杂版本</span></h3><ol list=\"u17ce83b5\"><li fid=\"u1a25c4af\" data-lake-id=\"u2eaedc46\" id=\"u2eaedc46\"><span data-lake-id=\"ue9737511\" id=\"ue9737511\">enqueueSetState 将 state 放入队列中，并调用 enqueueUpdate 处理需要更新的 Component</span></li><li fid=\"u1a25c4af\" data-lake-id=\"u598f0a82\" id=\"u598f0a82\"><span data-lake-id=\"u69e41c06\" id=\"u69e41c06\">如果组件当前正处于 update 事务中，则先将 Component 存入 dirtyComponent 中，否则调用 batchedUpdates 处理</span></li><li fid=\"u1a25c4af\" data-lake-id=\"u4baac270\" id=\"u4baac270\"><span data-lake-id=\"u73b0b5fa\" id=\"u73b0b5fa\">batchedUpdates 发起一次 transaction.perform() 事务</span></li><li fid=\"u1a25c4af\" data-lake-id=\"u51e12632\" id=\"u51e12632\"><span data-lake-id=\"u2d3628ce\" id=\"u2d3628ce\">开始执行事务初始化、运行、结束三个阶段</span></li></ol><ol list=\"u17ce83b5\" data-lake-indent=\"1\"><li fid=\"u1a25c4af\" data-lake-id=\"u1378f22f\" id=\"u1378f22f\"><span data-lake-id=\"uec4cba56\" id=\"uec4cba56\">初始化：事务初始化阶段没有注册方法，因此无方法要执行</span></li><li fid=\"u1a25c4af\" data-lake-id=\"u6624ce36\" id=\"u6624ce36\"><span data-lake-id=\"u4cea2438\" id=\"u4cea2438\">运行：执行 setState 时传入的 callback 方法</span></li><li fid=\"u1a25c4af\" data-lake-id=\"uf7851cef\" id=\"uf7851cef\"><span data-lake-id=\"ueff73172\" id=\"ueff73172\">结束：更新 isBatchingUpdates 为 false，并执行 FLUSH_BATCHED_UPDATES 这个 wrapper 中的 close 方法，FLUSH_BATCHED_UPDATES 在 close 阶段，会循环遍历所有的 dirtyComponents，调用 updateComponent 刷新组件，并执行它的 pendingCallbacks，也就是 setState 中设置的 callback</span></li></ol><p data-lake-id=\"u434af8d1\" id=\"u434af8d1\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647436689950-e2481d82-ba34-4444-999d-6394d138a83c.png%22%2C%22taskId%22%3A%22u2705d769-6a18-4441-afa6-d597ec634a5%22%2C%22clientId%22%3A%22u14a0d2a2-59e0-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A1263%2C%22height%22%3A826%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A151915%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A1263%2C%22originHeight%22%3A826%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22THIS.SETSTATE(NEWSTATE)%20NEWSTATE%20%E5%AD%98%E5%85%A5PENDING%20%E9%98%9F%E5%88%97%20%E8%B0%83%E7%94%A8%20ENQUEUEUPDATE%20%E6%98%AF%E5%90%A6%E5%A4%84%E4%BA%8E%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%BC%8F%20N%20%E9%81%8D%E5%8E%86DIRTYCOMPONENTS%20%E5%B0%86%E7%BB%84%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%88%B0%20DIRTYCOMPONENTS%20%E8%B0%83%E7%94%A8UPDATECOMPONENT%20%E6%9B%B4%E6%96%B0PENDING%20STATE%20OR%20PROPS%20%40%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A469.0168%2C%22y%22%3A78.53943%2C%22width%22%3A278.96477000000004%2C%22height%22%3A24.07793000000001%2C%22text%22%3A%22THIS.SETSTATE(NEWSTATE)%22%7D%2C%7B%22x%22%3A464.30634%2C%22y%22%3A228.07095%2C%22width%22%3A294.03056000000004%2C%22height%22%3A24.35056%2C%22text%22%3A%22NEWSTATE%20%E5%AD%98%E5%85%A5PENDING%20%E9%98%9F%E5%88%97%22%7D%2C%7B%22x%22%3A510.5823%2C%22y%22%3A378.036%2C%22width%22%3A57.29469999999998%2C%22height%22%3A23.353700000000003%2C%22text%22%3A%22%E8%B0%83%E7%94%A8%22%7D%2C%7B%22x%22%3A550.79785%2C%22y%22%3A379.00067%2C%22width%22%3A176.11974999999995%2C%22height%22%3A23.469449999999995%2C%22text%22%3A%22ENQUEUEUPDATE%22%7D%2C%7B%22x%22%3A492.93954%2C%22y%22%3A529.13947%2C%22width%22%3A244.73836%2C%22height%22%3A25.317330000000084%2C%22text%22%3A%22%E6%98%AF%E5%90%A6%E5%A4%84%E4%BA%8E%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%BC%8F%22%7D%2C%7B%22x%22%3A825.78955%2C%22y%22%3A601.9716%2C%22width%22%3A23.30609000000004%2C%22height%22%3A23.015300000000025%2C%22text%22%3A%22N%22%7D%2C%7B%22x%22%3A766.5617%2C%22y%22%3A689.6574%2C%22width%22%3A239.95010000000002%2C%22height%22%3A23.795099999999934%2C%22text%22%3A%22%E9%81%8D%E5%8E%86DIRTYCOMPONENTS%22%7D%2C%7B%22x%22%3A176.98239%2C%22y%22%3A724.01843%2C%22width%22%3A337.05980999999997%2C%22height%22%3A25.076070000000072%2C%22text%22%3A%22%E5%B0%86%E7%BB%84%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%88%B0%20DIRTYCOMPONENTS%22%7D%2C%7B%22x%22%3A761.27124%2C%22y%22%3A724.4149%2C%22width%22%3A241.48632999999995%2C%22height%22%3A27.07027000000005%2C%22text%22%3A%22%E8%B0%83%E7%94%A8UPDATECOMPONENT%22%7D%2C%7B%22x%22%3A742.84546%2C%22y%22%3A762.66223%2C%22width%22%3A274.41193999999996%2C%22height%22%3A28.212040000000002%2C%22text%22%3A%22%E6%9B%B4%E6%96%B0PENDING%20STATE%20OR%20PROPS%22%7D%2C%7B%22x%22%3A1118.7957%2C%22y%22%3A782.6625%2C%22width%22%3A123.10860000000002%2C%22height%22%3A20.730099999999993%2C%22text%22%3A%22%40%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%7D%5D%2C%22id%22%3A%22u06226bd9%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22fFfMh%22%7D\"></card><h2 data-lake-id=\"LYSey\" id=\"LYSey\"><span data-lake-id=\"ub04a6e48\" id=\"ub04a6e48\">setState 是同步还是异步</span></h2><p data-lake-id=\"u59277ee0\" id=\"u59277ee0\"><br></p><p data-lake-id=\"uec0a6840\" id=\"uec0a6840\"><span data-lake-id=\"u466a4238\" id=\"u466a4238\">setState 有时表现为异步，有时表现为同步</span></p><p data-lake-id=\"ufe492a79\" id=\"ufe492a79\"><span data-lake-id=\"u0e3fbe8a\" id=\"u0e3fbe8a\">​</span><br></p><p data-lake-id=\"u4ada018a\" id=\"u4ada018a\"><span data-lake-id=\"ue322df54\" id=\"ue322df54\">setState 只在 </span><strong><span data-lake-id=\"ue2e16da5\" id=\"ue2e16da5\">合成事件 </span></strong><span data-lake-id=\"u322d4474\" id=\"u322d4474\">和 </span><strong><span data-lake-id=\"u155b7c4b\" id=\"u155b7c4b\">钩子函数 </span></strong><span data-lake-id=\"ued57989f\" id=\"ued57989f\">中是&quot;异步&quot;的，在 </span><strong><span data-lake-id=\"u8dbaa9e4\" id=\"u8dbaa9e4\">原生事件 </span></strong><span data-lake-id=\"u308689a8\" id=\"u308689a8\">和 </span><strong><span data-lake-id=\"u68f8ced7\" id=\"u68f8ced7\">setTimeout</span></strong><span data-lake-id=\"u5b817bce\" id=\"u5b817bce\"> 中都是同步的</span></p><p data-lake-id=\"u77af545b\" id=\"u77af545b\"><span data-lake-id=\"ua77cceee\" id=\"ua77cceee\">​</span><br></p><p data-lake-id=\"ud4bc1616\" id=\"ud4bc1616\"><span data-lake-id=\"ubb7c1f44\" id=\"ubb7c1f44\">setState 的&quot;异步&quot;并不是说内部由异步代码实现，其本身执行的过程和代码都是同步的，只是 </span><strong><span data-lake-id=\"u577fe4e3\" id=\"u577fe4e3\">合成事件</span></strong><span data-lake-id=\"uc03ba2e4\" id=\"uc03ba2e4\"> 和 </span><strong><span data-lake-id=\"ub54f5bfa\" id=\"ub54f5bfa\">钩子函数</span></strong><span data-lake-id=\"ue17b9a09\" id=\"ue17b9a09\"> 的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成所谓的 &quot;异步&quot;，当然可以通过</span><strong><span data-lake-id=\"ue017b7df\" id=\"ue017b7df\">第二个参数</span></strong><span data-lake-id=\"u7498c92e\" id=\"u7498c92e\"> setState(partialState, callback) 中的 callback 拿到更新后的结果</span></p><p data-lake-id=\"u5e9c5d13\" id=\"u5e9c5d13\"><span data-lake-id=\"ud59aa6b6\" id=\"ud59aa6b6\">​</span><br></p><p data-lake-id=\"u7d51ac49\" id=\"u7d51ac49\"><span data-lake-id=\"u4ac11e35\" id=\"u4ac11e35\">setState 的批量更新优化也是建立在 &quot;异步&quot;(合成事件、钩子函数)之上的，在 </span><strong><span data-lake-id=\"uc5e62250\" id=\"uc5e62250\">原生事件</span></strong><span data-lake-id=\"ubc9a8bcc\" id=\"ubc9a8bcc\"> 和 </span><strong><span data-lake-id=\"udc337f40\" id=\"udc337f40\">setTimeout </span></strong><span data-lake-id=\"uc5021c8b\" id=\"uc5021c8b\">中不会批量更新。在&quot;异步&quot;中如果对同一个值进行 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新</span></p><h3 data-lake-id=\"kocyt\" id=\"kocyt\"><span data-lake-id=\"ub60725fd\" id=\"ub60725fd\">为什么 setState 不设计为同步的</span></h3><ul list=\"u908e90bf\"><li fid=\"u6354653b\" data-lake-id=\"ud30aa8b5\" id=\"ud30aa8b5\"><span data-lake-id=\"u6e8810e9\" id=\"u6e8810e9\">保持内部的一致性和状态的安全性</span></li></ul><p data-lake-id=\"u89ceceec\" id=\"u89ceceec\"><span data-lake-id=\"u59ffcf90\" id=\"u59ffcf90\">state、props、refs 一致性</span></p><ul list=\"u908e90bf\" start=\"2\"><li fid=\"u6354653b\" data-lake-id=\"u208a44ee\" id=\"u208a44ee\"><span data-lake-id=\"uad65c1c2\" id=\"uad65c1c2\">性能优化</span></li></ul><p data-lake-id=\"u635e1dfa\" id=\"u635e1dfa\"><span data-lake-id=\"u16866e31\" id=\"u16866e31\">react 会对依据不同的调用源，给不同的 setState 调用分配不同的优先级。调用源包括：事件处理、网络请求、动画</span></p><ul list=\"u908e90bf\" start=\"3\"><li fid=\"u6354653b\" data-lake-id=\"u9891d1fa\" id=\"u9891d1fa\"><span data-lake-id=\"u2af6eee5\" id=\"u2af6eee5\">更多的可能性</span></li></ul><p data-lake-id=\"u435c05e0\" id=\"u435c05e0\"><span data-lake-id=\"ua24808e0\" id=\"ua24808e0\">异步获取数据后，统一渲染页面，保持一致性</span></p><card type=\"block\" name=\"hr\"></card><h2 data-lake-id=\"LCTa8\" id=\"LCTa8\"><span data-lake-id=\"ub205918f\" id=\"ub205918f\">setState 批量更新的过程是什么</span></h2><p data-lake-id=\"ua351350c\" id=\"ua351350c\" style=\"text-indent: 2em\"><span data-lake-id=\"u96b65021\" id=\"u96b65021\">调用 setState 时，组件的 state 并不会立即改变，setState 只是把要修改的 state 放入一个队列，react 会优化真正的执行实际，并处于性能原因，会将 react 事件处理程序中的多次 setState 的状态修改并合并成一次状态修改。最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22Kj10A%22%7D\"></card><h2 data-lake-id=\"v3o1p\" id=\"v3o1p\"><span data-lake-id=\"u08cfbf2f\" id=\"u08cfbf2f\">setState 的第二个参数作用是什么</span></h2><p data-lake-id=\"ueb216df9\" id=\"ueb216df9\" style=\"text-indent: 2em\"><span data-lake-id=\"u445b4a41\" id=\"u445b4a41\">setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议用 componentDidUpdate 来代替此方式。在这个回调函数中可以拿到更新后的 state 的值。</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22zZDnW%22%7D\"></card><h2 data-lake-id=\"bJtnG\" id=\"bJtnG\"><span data-lake-id=\"u48825c82\" id=\"u48825c82\">在 shouldComponentUpdate 中使用 setState 会发生什么</span></h2><p data-lake-id=\"uca744d33\" id=\"uca744d33\" style=\"text-indent: 2em\"><span data-lake-id=\"u4287a9d2\" id=\"u4287a9d2\">当调用 setState 的时候，实际上会将新的 state 合并到状态更新队列中，并对 partialState 以及 _pendingStateQueue 更新队列进行合并操作。最终通过 enqueueUpdate 执行 state 更新。</span></p><p data-lake-id=\"ued838a58\" id=\"ued838a58\" style=\"text-indent: 2em\"><span data-lake-id=\"u0c8df4b1\" id=\"u0c8df4b1\">如果在 shouldComponent 中使用 setState，会使得 state 队列(_pendingStateQueue)不为 null，从而调用 updateComponent 方法，updateComponent 中会继续调用 shouldComponentUpdate，因此会造成死循环。</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22oFxnx%22%7D\"></card><h2 data-lake-id=\"x4MVA\" id=\"x4MVA\"><span data-lake-id=\"uca6b0625\" id=\"uca6b0625\">setState 和 replaceState 的区别</span></h2><blockquote data-lake-id=\"u100fdbde\" id=\"u100fdbde\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"uc4d9ad19\" id=\"uc4d9ad19\"><strong><span data-lake-id=\"u1fac7ce5\" id=\"u1fac7ce5\">总结：</span></strong><span data-lake-id=\"u9ec9e109\" id=\"u9ec9e109\"> </span></p><p data-lake-id=\"u0980a2dc\" id=\"u0980a2dc\" style=\"text-indent: 2em\"><span data-lake-id=\"ufedc7a05\" id=\"ufedc7a05\">setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而 replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</span></p></blockquote><h3 data-lake-id=\"IHDSq\" id=\"IHDSq\"><span data-lake-id=\"u594d1201\" id=\"u594d1201\">setState</span></h3><p data-lake-id=\"ub34c910b\" id=\"ub34c910b\"><span data-lake-id=\"u54f3aaa8\" id=\"u54f3aaa8\">setState 用于设置状态对象，用法如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22setState(object%20nextState%5B%2C%20function%20callback%5D)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22FJcVO%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ul list=\"ud4d257bf\"><li fid=\"u3b76ccdb\" data-lake-id=\"u52ca247d\" id=\"u52ca247d\"><span data-lake-id=\"uac1b9183\" id=\"uac1b9183\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">nextState，将要设置的新状态，该状态会和当前的state合并</span></li><li fid=\"u3b76ccdb\" data-lake-id=\"u789a30ce\" id=\"u789a30ce\"><span data-lake-id=\"u781c2199\" id=\"u781c2199\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</span></li></ul><p data-lake-id=\"u6a2ce896\" id=\"u6a2ce896\" style=\"text-indent: 2em\"><span data-lake-id=\"u5e75008c\" id=\"u5e75008c\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">合并 nextState 和当前 state，并重新渲染组件。setState 是 React 事件处理函数中和请求回调函数中触发UI更新的主要方法。</span></p><h3 data-lake-id=\"rZ2U7\" id=\"rZ2U7\"><span data-lake-id=\"u026720f7\" id=\"u026720f7\">replaceState</span></h3><p data-lake-id=\"ueb779255\" id=\"ueb779255\"><span data-lake-id=\"u123e165c\" id=\"u123e165c\">replaceState 方法与 setState 类似，但是方法只会保留 nextState 中的状态，原 state 不在 nextState 中的状态都会被删除，用法如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22replaceState(object%20nextState%5B%2C%20function%20callback%5D)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22elrNe%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ul list=\"u2755e15d\"><li fid=\"ub699d649\" data-lake-id=\"uc21df9cc\" id=\"uc21df9cc\"><span data-lake-id=\"u72d3f656\" id=\"u72d3f656\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">nextState，将要设置的新状态，该状态会替换当前的state。</span></li><li fid=\"ub699d649\" data-lake-id=\"u13bbeb4a\" id=\"u13bbeb4a\"><span data-lake-id=\"u63616d29\" id=\"u63616d29\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</span></li></ul><card type=\"block\" name=\"hr\"></card><h2 data-lake-id=\"X5G1r\" id=\"X5G1r\"><span data-lake-id=\"u7391cbed\" id=\"u7391cbed\">为什么不能直接使用 this.state 改变数据</span></h2><p data-lake-id=\"u864fb434\" id=\"u864fb434\" style=\"text-indent: 2em\"><span data-lake-id=\"u685026d9\" id=\"u685026d9\">setState 通过一个队列机制来实现 state 更新。当执行 setState 的时候，会将需要更新的 state 合并后放入状态队列，而不会立刻更新 this.state。队列机制可以高效的批量更新 state，如果不通过 setState 而直接修改 this.state，那么该 state 将不会被放入状态队列中，当下次调用 setState 并对状态队列进行合并时，将会忽略之前被直接修改的 state，而造成无法预知的错误。</span></p><p data-lake-id=\"u641d1ef9\" id=\"u641d1ef9\"><br></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:37.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:37.000Z",
  "updated_at": "2022-05-10T15:12:35.000Z",
  "published_at": "2022-04-04T11:33:37.000Z",
  "first_published_at": "2022-04-04T11:33:36.610Z",
  "word_count": 1484,
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1647436689950-e2481d82-ba34-4444-999d-6394d138a83c.png",
  "description": "setState 之后发生了什么简单版本react 利用状态队列机制实现了 setState 的\"异步\"更新，避免频繁的重复更新 state。首先将新的 state 合并到状态更新队列中，然后根据更新队列和 shouldComponentUpdate 的状态来判断是否需要更新组件。复杂版本en...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}