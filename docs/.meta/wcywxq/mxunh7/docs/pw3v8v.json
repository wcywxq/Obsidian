{
  "id": 72212043,
  "slug": "pw3v8v",
  "title": "服务端渲染 ssr",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。\n\nSSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。还有就是服务器会有更大的负载需求。\n<a name=\"NMYh7\"></a>\n## 如何等待异步请求的数据返回后，再渲染页面；客户端中的 store 如何同步服务端的数据\n\n1. 组件中添加 serverPrefetch 选项，返回 promise\n2. 服务端入口 server-entry.js 添加 context.rendered 回调，渲染完成后执行，自动序列化注入 window.__INITIAL_STATE__ 变量\n3. 设置 context.state = store.state\n4. 客户端入口获取 window.__INITIAL_STATE__，设置 store 初始状态\n<a name=\"gUUQF\"></a>\n## meta、title 等标签如何注入\n\n1. 使用 vue-meta 插件\n2. 根组件 app.vue 使用 metaInfo 添加 meta 和 title\n3. 子组件中可使用 metaInfo 函数，覆盖默认的 metaInfo\n4. server-entry 中拿到 meta，并将其传入到 context 中，渲染 server.html 中的 meta 信息\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    {{{ meta.inject().title.text() }}} \n    {{{ meta.inject().meta.text() }}}\n  </head>\n  <body>\n    <!--vue-ssr-outlet-->\n  </body>\n</html>\n```\n<a name=\"xwW4j\"></a>\n## 服务端渲染会执行的生命周期\n只会执行 beforeCreate 和 created，不要在这两个生命周期里添加定时器或者使用 window 等\n<a name=\"hwYQF\"></a>\n## 服务端本地开发热更新\nwebpack 配置读取在内存中\n",
  "body_draft": "",
  "body_html": "<!doctype html><p data-lake-id=\"u8d69df97\" style=\"text-align: justify;\"><span class=\"lake-fontsize-12\" style=\"color: #444444;\">SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</span></p><p data-lake-id=\"u93ccbdde\" style=\"text-align: justify;\"><span class=\"lake-fontsize-12\" style=\"color: #444444;\">​</span><br /></p><p data-lake-id=\"u5cdfb678\" style=\"text-align: justify;\"><span class=\"lake-fontsize-12\" style=\"color: #444444;\">SSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。还有就是服务器会有更大的负载需求。</span></p><h2 id=\"NMYh7\"><span>如何等待异步请求的数据返回后，再渲染页面；客户端中的 store 如何同步服务端的数据</span></h2><ol><li><span>组件中添加 serverPrefetch 选项，返回 promise</span></li><li><span>服务端入口 server-entry.js 添加 context.rendered 回调，渲染完成后执行，自动序列化注入 window.__INITIAL_STATE__ 变量</span></li><li><span>设置 context.state = store.state</span></li><li><span>客户端入口获取 window.__INITIAL_STATE__，设置 store 初始状态</span></li></ol><h2 id=\"gUUQF\"><span>meta、title 等标签如何注入</span></h2><ol><li><span>使用 vue-meta 插件</span></li><li><span>根组件 app.vue 使用 metaInfo 添加 meta 和 title</span></li><li><span>子组件中可使用 metaInfo 函数，覆盖默认的 metaInfo</span></li><li><span>server-entry 中拿到 meta，并将其传入到 context 中，渲染 server.html 中的 meta 信息</span></li></ol><pre data-lang=\"html\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;\n    {{{ meta.inject().title.text() }}} \n    {{{ meta.inject().meta.text() }}}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!--vue-ssr-outlet--&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre><h2 id=\"xwW4j\"><span>服务端渲染会执行的生命周期</span></h2><p data-lake-id=\"ud5a1477f\"><span>只会执行 beforeCreate 和 created，不要在这两个生命周期里添加定时器或者使用 window 等</span></p><h2 id=\"hwYQF\"><span>服务端本地开发热更新</span></h2><p data-lake-id=\"ue431c1b7\"><span>webpack 配置读取在内存中</span></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u8d69df97\" id=\"u8d69df97\" style=\"text-align: justify\"><span data-lake-id=\"u1542b3ea\" id=\"u1542b3ea\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</span></p><p data-lake-id=\"u93ccbdde\" id=\"u93ccbdde\" style=\"text-align: justify\"><span data-lake-id=\"u388a5ffd\" id=\"u388a5ffd\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">​</span><br></p><p data-lake-id=\"u5cdfb678\" id=\"u5cdfb678\" style=\"text-align: justify\"><span data-lake-id=\"uad597e0c\" id=\"uad597e0c\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">SSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。还有就是服务器会有更大的负载需求。</span></p><h2 data-lake-id=\"NMYh7\" id=\"NMYh7\"><span data-lake-id=\"u45412db9\" id=\"u45412db9\">如何等待异步请求的数据返回后，再渲染页面；客户端中的 store 如何同步服务端的数据</span></h2><ol list=\"ua528cd0f\"><li fid=\"u9be40da4\" data-lake-id=\"u208da6b6\" id=\"u208da6b6\"><span data-lake-id=\"u8d7d666c\" id=\"u8d7d666c\">组件中添加 serverPrefetch 选项，返回 promise</span></li><li fid=\"u9be40da4\" data-lake-id=\"ud5b646d6\" id=\"ud5b646d6\"><span data-lake-id=\"u0a2e2c2f\" id=\"u0a2e2c2f\">服务端入口 server-entry.js 添加 context.rendered 回调，渲染完成后执行，自动序列化注入 window.__INITIAL_STATE__ 变量</span></li><li fid=\"u9be40da4\" data-lake-id=\"ufc1237ac\" id=\"ufc1237ac\"><span data-lake-id=\"u5c03d493\" id=\"u5c03d493\">设置 context.state = store.state</span></li><li fid=\"u9be40da4\" data-lake-id=\"ue483871c\" id=\"ue483871c\"><span data-lake-id=\"uf15d150a\" id=\"uf15d150a\">客户端入口获取 window.__INITIAL_STATE__，设置 store 初始状态</span></li></ol><h2 data-lake-id=\"gUUQF\" id=\"gUUQF\"><span data-lake-id=\"u2d5cd0ce\" id=\"u2d5cd0ce\">meta、title 等标签如何注入</span></h2><ol list=\"u02e28f62\"><li fid=\"u2191e47e\" data-lake-id=\"uf9fa6f1e\" id=\"uf9fa6f1e\"><span data-lake-id=\"uf6dbf5d8\" id=\"uf6dbf5d8\">使用 vue-meta 插件</span></li><li fid=\"u2191e47e\" data-lake-id=\"u40dfaa10\" id=\"u40dfaa10\"><span data-lake-id=\"uc2f25ce1\" id=\"uc2f25ce1\">根组件 app.vue 使用 metaInfo 添加 meta 和 title</span></li><li fid=\"u2191e47e\" data-lake-id=\"u32342a17\" id=\"u32342a17\"><span data-lake-id=\"uf9b1b156\" id=\"uf9b1b156\">子组件中可使用 metaInfo 函数，覆盖默认的 metaInfo</span></li><li fid=\"u2191e47e\" data-lake-id=\"uc9ef5918\" id=\"uc9ef5918\"><span data-lake-id=\"u95746dd8\" id=\"u95746dd8\">server-entry 中拿到 meta，并将其传入到 context 中，渲染 server.html 中的 meta 信息</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3C!DOCTYPE%20html%3E%5Cn%3Chtml%20lang%3D%5C%22en%5C%22%3E%5Cn%20%20%3Chead%3E%5Cn%20%20%20%20%3Cmeta%20charset%3D%5C%22utf-8%5C%22%3E%5Cn%20%20%20%20%3Cmeta%20http-equiv%3D%5C%22X-UA-Compatible%5C%22%20content%3D%5C%22IE%3Dedge%5C%22%3E%5Cn%20%20%20%20%3Cmeta%20name%3D%5C%22viewport%5C%22%20content%3D%5C%22width%3Ddevice-width%2Cinitial-scale%3D1.0%5C%22%3E%5Cn%20%20%20%20%7B%7B%7B%20meta.inject().title.text()%20%7D%7D%7D%20%5Cn%20%20%20%20%7B%7B%7B%20meta.inject().meta.text()%20%7D%7D%7D%5Cn%20%20%3C%2Fhead%3E%5Cn%20%20%3Cbody%3E%5Cn%20%20%20%20%3C!--vue-ssr-outlet--%3E%5Cn%20%20%3C%2Fbody%3E%5Cn%3C%2Fhtml%3E%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22bX2Fa%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"xwW4j\" id=\"xwW4j\"><span data-lake-id=\"u22f0d90a\" id=\"u22f0d90a\">服务端渲染会执行的生命周期</span></h2><p data-lake-id=\"ud5a1477f\" id=\"ud5a1477f\"><span data-lake-id=\"u3284d570\" id=\"u3284d570\">只会执行 beforeCreate 和 created，不要在这两个生命周期里添加定时器或者使用 window 等</span></p><h2 data-lake-id=\"hwYQF\" id=\"hwYQF\"><span data-lake-id=\"ud79a68e0\" id=\"ud79a68e0\">服务端本地开发热更新</span></h2><p data-lake-id=\"ue431c1b7\" id=\"ue431c1b7\"><span data-lake-id=\"u0468d318\" id=\"u0468d318\">webpack 配置读取在内存中</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:32:41.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:41.000Z",
  "updated_at": "2022-05-10T15:12:43.000Z",
  "published_at": "2022-04-04T11:32:41.000Z",
  "first_published_at": "2022-04-04T11:32:41.482Z",
  "word_count": 428,
  "cover": null,
  "description": "SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。SSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 c...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}