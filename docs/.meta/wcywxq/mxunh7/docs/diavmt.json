{
  "id": 81946293,
  "slug": "diavmt",
  "title": "vue diff 算法",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"4ec332ef\"></a>\n## diff 算法解决的问题\n\nvnode 更新，diff 算法寻求最佳性能同步更新真实 dom。必须明确 old vnode 和 old 真实 dom 是过去时，new vnode 对应的 new 真实 dom 是我们最终想要的。基于 old，得到 new，如果让性能最好？最简单粗暴就是把 old 干掉，直接生成 new。但是性能消耗最大。最佳方法是，尽可能复用真实 dom。对真实 dom 的操作消耗关系：更新属性不移动 < 更新属性后移动到对应位置 < 创建新节点插入到对应位置。所以，diff 算法最终是要尽可能找到可被复用的真实 dom，如果不要移动最好，否则移动到对应位置，最后创建没有可复用的新节点，删除多余的未被复用的老真实 dom 节点。<br />vue3 的 diff 算法比 vue2 的快，主要原因是在于复用 dom 元素相同的情况，移动 dom 的次数减少，因为 vue3 用到了最长递增子序列方案。更细节的讨论放在后面分析。\n\n所以算法目标是：\n\n- 尽可能块的找到可复用真实 dom 节点\n- 复用真实 dom 节点的时候，尽可能也复用其相对顺序，少做移动。\n\n<a name=\"4ccd0554\"></a>\n## vue2 的 diff 算法\n\nvue2 的 diff 算法采用了双端 diff 算法。\n\n同时使用四个指针分别放到 old 子节点和 new 子节点的头和尾。<br />对比头头，尾尾，头尾，尾头，如果其一满足 sameVnode，则进行真实 dom 复用且不需要移动真实 dom，指针向内移动。否则，通过 keyToOldIdxMap 尝试快速找到 old 子节点中 key 相同 sameVnode，如果找到，则复用真实 dom，并移动到当前位置，然后将 old 子节点[i]设置为 undefined，后续查找忽略此节点。如果没有找到则创建新的真实 dom 并插入。<br />最后满足 old 子节点的头尾交叉，或 new 子节点的头尾交叉。说明对比完了。此时如果 old 交叉，new 未交叉，说明 new 子节点剩下的都是要新创建并插入。反之，old 未交叉，new 交叉，说明 old 子节点剩下的是多余的，需要从 dom 中移除。\n\n<a name=\"3815629f\"></a>\n### vue2 算法优劣分析\n\n算法通过相互比较头尾，如果复用，不需要移动，直接复用。这个是优点也是缺点，缺点就在于只要复用的节点不在头尾，则一定得移动复用的真实 dom。并且受头尾影响，假如头尾是两个新节点，就一直不能头尾复用，剩下的所有节点复用，只可能走 keyToOldIdxMap 的方法，在头尾直接寻找复用元素，并移动它。试想一下，如果头尾直接的元素都是可被复用的，并且更新前后的相对顺序未发生变化，则所有的移动几乎都是额外的性能开销。是否可以有其他方案，尽可能在复用 old 子节点的同时，也复用其相对顺序，把移动真实 dom 的次数降到最低，较少性能消耗。后面 vue3 的 diff 算法提供了一个解决此问题的更好思路。\n\n<a name=\"c449f9f6\"></a>\n## vue3 的 diff 算法\n\nvue3 的 diff 算法借鉴了字符串 diff 的一些思路。\n\n首先进行预处理，将前置和后置可复用的节点找出，且是不需要移动的。<br />判断是否存在剩余节点。如果 old 子节点存在剩余节点，new 子节点不存在，比对完成，移除多余的 old 子节点对应的真实 dom。如果 old 子节点不存在剩余节点，new 子节点存在，比对完成，新建多余的 new 子节点对应的真实 dom 并插入。如果 old 和 new 子节点都存在剩余子节点，则将剩余部分进行比对复用。<br />剩余部分比对非 vue2 的比对方式，用到了最长递增子序列，复用与最长递增子序列内的节点对应的 old 真实 dom 时，无需移动。进一步减少移动次数，提高了性能。\n\n<a name=\"55c5b1df\"></a>\n### vue3 算法优劣分析\n\n该算法引入最长递增子序列，尽可能复用了原来的顺序，减少移动次数，提升了性能。发散一下，该算法是移动次数最少的方法吗？还有没有其他更好的算法思路，有待进一步研究。\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"4ec332ef\"><span class=\"ne-text\">diff 算法解决的问题</span></h2><p id=\"u948cc434\" class=\"ne-p\"><br></p><p id=\"u22f040fd\" class=\"ne-p\"><span class=\"ne-text\">vnode 更新，diff 算法寻求最佳性能同步更新真实 dom。必须明确 old vnode 和 old 真实 dom 是过去时，new vnode 对应的 new 真实 dom 是我们最终想要的。基于 old，得到 new，如果让性能最好？最简单粗暴就是把 old 干掉，直接生成 new。但是性能消耗最大。最佳方法是，尽可能复用真实 dom。对真实 dom 的操作消耗关系：更新属性不移动 &lt; 更新属性后移动到对应位置 &lt; 创建新节点插入到对应位置。所以，diff 算法最终是要尽可能找到可被复用的真实 dom，如果不要移动最好，否则移动到对应位置，最后创建没有可复用的新节点，删除多余的未被复用的老真实 dom 节点。<br /></span><span class=\"ne-text\">vue3 的 diff 算法比 vue2 的快，主要原因是在于复用 dom 元素相同的情况，移动 dom 的次数减少，因为 vue3 用到了最长递增子序列方案。更细节的讨论放在后面分析。</span></p><p id=\"u92cc1697\" class=\"ne-p\"><br></p><p id=\"ud5ac0f1c\" class=\"ne-p\"><span class=\"ne-text\">所以算法目标是：</span></p><p id=\"u835590ba\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u861b500f\"><span class=\"ne-text\">尽可能块的找到可复用真实 dom 节点</span></li><li id=\"u55d4ea4e\"><span class=\"ne-text\">复用真实 dom 节点的时候，尽可能也复用其相对顺序，少做移动。</span></li></ul><p id=\"u97b91c25\" class=\"ne-p\"><br></p><h2 id=\"4ccd0554\"><span class=\"ne-text\">vue2 的 diff 算法</span></h2><p id=\"u9fc30304\" class=\"ne-p\"><br></p><p id=\"u9f7be2eb\" class=\"ne-p\"><span class=\"ne-text\">vue2 的 diff 算法采用了双端 diff 算法。</span></p><p id=\"u476c4ec9\" class=\"ne-p\"><br></p><p id=\"u2e22ca64\" class=\"ne-p\"><span class=\"ne-text\">同时使用四个指针分别放到 old 子节点和 new 子节点的头和尾。<br /></span><span class=\"ne-text\">对比头头，尾尾，头尾，尾头，如果其一满足 sameVnode，则进行真实 dom 复用且不需要移动真实 dom，指针向内移动。否则，通过 keyToOldIdxMap 尝试快速找到 old 子节点中 key 相同 sameVnode，如果找到，则复用真实 dom，并移动到当前位置，然后将 old 子节点[i]设置为 undefined，后续查找忽略此节点。如果没有找到则创建新的真实 dom 并插入。<br /></span><span class=\"ne-text\">最后满足 old 子节点的头尾交叉，或 new 子节点的头尾交叉。说明对比完了。此时如果 old 交叉，new 未交叉，说明 new 子节点剩下的都是要新创建并插入。反之，old 未交叉，new 交叉，说明 old 子节点剩下的是多余的，需要从 dom 中移除。</span></p><p id=\"ue19902b7\" class=\"ne-p\"><br></p><h3 id=\"3815629f\"><span class=\"ne-text\">vue2 算法优劣分析</span></h3><p id=\"u18fc4589\" class=\"ne-p\"><br></p><p id=\"u975bb861\" class=\"ne-p\"><span class=\"ne-text\">算法通过相互比较头尾，如果复用，不需要移动，直接复用。这个是优点也是缺点，缺点就在于只要复用的节点不在头尾，则一定得移动复用的真实 dom。并且受头尾影响，假如头尾是两个新节点，就一直不能头尾复用，剩下的所有节点复用，只可能走 keyToOldIdxMap 的方法，在头尾直接寻找复用元素，并移动它。试想一下，如果头尾直接的元素都是可被复用的，并且更新前后的相对顺序未发生变化，则所有的移动几乎都是额外的性能开销。是否可以有其他方案，尽可能在复用 old 子节点的同时，也复用其相对顺序，把移动真实 dom 的次数降到最低，较少性能消耗。后面 vue3 的 diff 算法提供了一个解决此问题的更好思路。</span></p><p id=\"ubedad33c\" class=\"ne-p\"><br></p><h2 id=\"c449f9f6\"><span class=\"ne-text\">vue3 的 diff 算法</span></h2><p id=\"uc6a01608\" class=\"ne-p\"><br></p><p id=\"ufda1878c\" class=\"ne-p\"><span class=\"ne-text\">vue3 的 diff 算法借鉴了字符串 diff 的一些思路。</span></p><p id=\"u6b1d6dab\" class=\"ne-p\"><br></p><p id=\"uf4f0766f\" class=\"ne-p\"><span class=\"ne-text\">首先进行预处理，将前置和后置可复用的节点找出，且是不需要移动的。<br /></span><span class=\"ne-text\">判断是否存在剩余节点。如果 old 子节点存在剩余节点，new 子节点不存在，比对完成，移除多余的 old 子节点对应的真实 dom。如果 old 子节点不存在剩余节点，new 子节点存在，比对完成，新建多余的 new 子节点对应的真实 dom 并插入。如果 old 和 new 子节点都存在剩余子节点，则将剩余部分进行比对复用。<br /></span><span class=\"ne-text\">剩余部分比对非 vue2 的比对方式，用到了最长递增子序列，复用与最长递增子序列内的节点对应的 old 真实 dom 时，无需移动。进一步减少移动次数，提高了性能。</span></p><p id=\"ub505142b\" class=\"ne-p\"><br></p><h3 id=\"55c5b1df\"><span class=\"ne-text\">vue3 算法优劣分析</span></h3><p id=\"u080c7c5c\" class=\"ne-p\"><br></p><p id=\"u1b4cf768\" class=\"ne-p\"><span class=\"ne-text\">该算法引入最长递增子序列，尽可能复用了原来的顺序，减少移动次数，提升了性能。发散一下，该算法是移动次数最少的方法吗？还有没有其他更好的算法思路，有待进一步研究。</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><meta name=\"paragraphSpacing\" content=\"relax\" /><h2 data-lake-id=\"4ec332ef\" id=\"4ec332ef\"><span data-lake-id=\"ud580b738\" id=\"ud580b738\">diff 算法解决的问题</span></h2><p data-lake-id=\"u948cc434\" id=\"u948cc434\"><br></p><p data-lake-id=\"u22f040fd\" id=\"u22f040fd\"><span data-lake-id=\"u9b60612d\" id=\"u9b60612d\">vnode 更新，diff 算法寻求最佳性能同步更新真实 dom。必须明确 old vnode 和 old 真实 dom 是过去时，new vnode 对应的 new 真实 dom 是我们最终想要的。基于 old，得到 new，如果让性能最好？最简单粗暴就是把 old 干掉，直接生成 new。但是性能消耗最大。最佳方法是，尽可能复用真实 dom。对真实 dom 的操作消耗关系：更新属性不移动 &lt; 更新属性后移动到对应位置 &lt; 创建新节点插入到对应位置。所以，diff 算法最终是要尽可能找到可被复用的真实 dom，如果不要移动最好，否则移动到对应位置，最后创建没有可复用的新节点，删除多余的未被复用的老真实 dom 节点。<br /></span><span data-lake-id=\"ucb81ed20\" id=\"ucb81ed20\">vue3 的 diff 算法比 vue2 的快，主要原因是在于复用 dom 元素相同的情况，移动 dom 的次数减少，因为 vue3 用到了最长递增子序列方案。更细节的讨论放在后面分析。</span></p><p data-lake-id=\"u92cc1697\" id=\"u92cc1697\"><br></p><p data-lake-id=\"ud5ac0f1c\" id=\"ud5ac0f1c\"><span data-lake-id=\"uc6a6e7e1\" id=\"uc6a6e7e1\">所以算法目标是：</span></p><p data-lake-id=\"u835590ba\" id=\"u835590ba\"><br></p><ul list=\"ucd10589a\"><li fid=\"ufa529d47\" data-lake-id=\"u861b500f\" id=\"u861b500f\"><span data-lake-id=\"u7b0974c6\" id=\"u7b0974c6\">尽可能块的找到可复用真实 dom 节点</span></li><li fid=\"ufa529d47\" data-lake-id=\"u55d4ea4e\" id=\"u55d4ea4e\"><span data-lake-id=\"u691d2dd2\" id=\"u691d2dd2\">复用真实 dom 节点的时候，尽可能也复用其相对顺序，少做移动。</span></li></ul><p data-lake-id=\"u97b91c25\" id=\"u97b91c25\"><br></p><h2 data-lake-id=\"4ccd0554\" id=\"4ccd0554\"><span data-lake-id=\"u87405c59\" id=\"u87405c59\">vue2 的 diff 算法</span></h2><p data-lake-id=\"u9fc30304\" id=\"u9fc30304\"><br></p><p data-lake-id=\"u9f7be2eb\" id=\"u9f7be2eb\"><span data-lake-id=\"u72cc9c34\" id=\"u72cc9c34\">vue2 的 diff 算法采用了双端 diff 算法。</span></p><p data-lake-id=\"u476c4ec9\" id=\"u476c4ec9\"><br></p><p data-lake-id=\"u2e22ca64\" id=\"u2e22ca64\"><span data-lake-id=\"u8651de44\" id=\"u8651de44\">同时使用四个指针分别放到 old 子节点和 new 子节点的头和尾。<br /></span><span data-lake-id=\"u6c55b9a9\" id=\"u6c55b9a9\">对比头头，尾尾，头尾，尾头，如果其一满足 sameVnode，则进行真实 dom 复用且不需要移动真实 dom，指针向内移动。否则，通过 keyToOldIdxMap 尝试快速找到 old 子节点中 key 相同 sameVnode，如果找到，则复用真实 dom，并移动到当前位置，然后将 old 子节点[i]设置为 undefined，后续查找忽略此节点。如果没有找到则创建新的真实 dom 并插入。<br /></span><span data-lake-id=\"u04303dee\" id=\"u04303dee\">最后满足 old 子节点的头尾交叉，或 new 子节点的头尾交叉。说明对比完了。此时如果 old 交叉，new 未交叉，说明 new 子节点剩下的都是要新创建并插入。反之，old 未交叉，new 交叉，说明 old 子节点剩下的是多余的，需要从 dom 中移除。</span></p><p data-lake-id=\"ue19902b7\" id=\"ue19902b7\"><br></p><h3 data-lake-id=\"3815629f\" id=\"3815629f\"><span data-lake-id=\"u62896c21\" id=\"u62896c21\">vue2 算法优劣分析</span></h3><p data-lake-id=\"u18fc4589\" id=\"u18fc4589\"><br></p><p data-lake-id=\"u975bb861\" id=\"u975bb861\"><span data-lake-id=\"u77618b38\" id=\"u77618b38\">算法通过相互比较头尾，如果复用，不需要移动，直接复用。这个是优点也是缺点，缺点就在于只要复用的节点不在头尾，则一定得移动复用的真实 dom。并且受头尾影响，假如头尾是两个新节点，就一直不能头尾复用，剩下的所有节点复用，只可能走 keyToOldIdxMap 的方法，在头尾直接寻找复用元素，并移动它。试想一下，如果头尾直接的元素都是可被复用的，并且更新前后的相对顺序未发生变化，则所有的移动几乎都是额外的性能开销。是否可以有其他方案，尽可能在复用 old 子节点的同时，也复用其相对顺序，把移动真实 dom 的次数降到最低，较少性能消耗。后面 vue3 的 diff 算法提供了一个解决此问题的更好思路。</span></p><p data-lake-id=\"ubedad33c\" id=\"ubedad33c\"><br></p><h2 data-lake-id=\"c449f9f6\" id=\"c449f9f6\"><span data-lake-id=\"u2911ab8c\" id=\"u2911ab8c\">vue3 的 diff 算法</span></h2><p data-lake-id=\"uc6a01608\" id=\"uc6a01608\"><br></p><p data-lake-id=\"ufda1878c\" id=\"ufda1878c\"><span data-lake-id=\"udb582fec\" id=\"udb582fec\">vue3 的 diff 算法借鉴了字符串 diff 的一些思路。</span></p><p data-lake-id=\"u6b1d6dab\" id=\"u6b1d6dab\"><br></p><p data-lake-id=\"uf4f0766f\" id=\"uf4f0766f\"><span data-lake-id=\"ucab87f83\" id=\"ucab87f83\">首先进行预处理，将前置和后置可复用的节点找出，且是不需要移动的。<br /></span><span data-lake-id=\"uebe766cd\" id=\"uebe766cd\">判断是否存在剩余节点。如果 old 子节点存在剩余节点，new 子节点不存在，比对完成，移除多余的 old 子节点对应的真实 dom。如果 old 子节点不存在剩余节点，new 子节点存在，比对完成，新建多余的 new 子节点对应的真实 dom 并插入。如果 old 和 new 子节点都存在剩余子节点，则将剩余部分进行比对复用。<br /></span><span data-lake-id=\"u6619dfb7\" id=\"u6619dfb7\">剩余部分比对非 vue2 的比对方式，用到了最长递增子序列，复用与最长递增子序列内的节点对应的 old 真实 dom 时，无需移动。进一步减少移动次数，提高了性能。</span></p><p data-lake-id=\"ub505142b\" id=\"ub505142b\"><br></p><h3 data-lake-id=\"55c5b1df\" id=\"55c5b1df\"><span data-lake-id=\"u1b04618b\" id=\"u1b04618b\">vue3 算法优劣分析</span></h3><p data-lake-id=\"u080c7c5c\" id=\"u080c7c5c\"><br></p><p data-lake-id=\"u1b4cf768\" id=\"u1b4cf768\"><span data-lake-id=\"uc69670e3\" id=\"uc69670e3\">该算法引入最长递增子序列，尽可能复用了原来的顺序，减少移动次数，提升了性能。发散一下，该算法是移动次数最少的方法吗？还有没有其他更好的算法思路，有待进一步研究。</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-06-30T07:35:50.000Z",
  "deleted_at": null,
  "created_at": "2022-06-30T07:35:36.000Z",
  "updated_at": "2022-06-30T07:35:50.000Z",
  "published_at": "2022-06-30T07:35:50.000Z",
  "first_published_at": "2022-06-30T07:35:49.868Z",
  "word_count": 1244,
  "cover": null,
  "description": "diff 算法解决的问题vnode 更新，diff 算法寻求最佳性能同步更新真实 dom。必须明确 old vnode 和 old 真实 dom 是过去时，new vnode 对应的 new 真实 dom 是我们最终想要的。基于 old，得到 new，如果让性能最好？最简单粗暴就是把 old ...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}