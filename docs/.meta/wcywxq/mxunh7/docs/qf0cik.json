{
  "id": 72212121,
  "slug": "qf0cik",
  "title": "react 性能优化",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"BANVM\"></a>\n## 开发过程中\n1. 函数式组件使用 React.Memo 来缓存组件避免组件重渲染\n2. 使用 useMemo 缓存大量计算\n3. 类组件使用 React.PureComponent，shouldComponentUpdate避免组件重渲染\n4. 避免使用内联对象\n5. 避免使用匿名函数\n6. 延迟加载不是立即需要的组件(React.lazy + React.Suspense)\n7. 调整 css 而不是强制组件加载和卸载\n8. 使用 React.Fragment 避免添加额外的 DOM\n9. 不在 render 中处理数据\n10. 使用 web worker 做密集型的任务处理\n11. 使用唯一的键值迭代\n<a name=\"xa67Q\"></a>\n## 上线后首屏及运行状态\n\n- 首屏优化一般涉及到几个指标 FP、FCP、FMP；要有一个良好的体验是尽可能的把 FCP 提前，需要做一些工程化的处理，去优化资源的加载\n   - FP: 页面在导航后首次呈现出不同于导航前内容的时间点;\n   - FCP: 首次绘制任何文本，图像，非空白 canvas 或 SVG 的时间点;\n   - FMP: 是由 Google 工程师引入的一种现代性能指标，它告诉我们页面何时 **有用**。其本质上是通过一种算法来猜测某个时间点可能是 FMP\n- 方式及分包策略，资源的减少是最有效的加快首屏打开的方式\n- 对于 CSR 的应用，FCP 的过程一般是首先加载 js 与 css 资源，js 在本地执行完成，然后加载数据回来，做内容初始化渲染，这中间就有几次的网络反复请求的过程；所以 CSR 可以考虑使用骨架屏及预渲染（部分结构预渲染）、suspence 与 lazy 做懒加载动态组件的方式\n- 当然还有另外一种方式就是 SSR 的方式，SSR 对于首屏的优化有一定的优势，但是这种瓶颈一般在 Node 服务端的处理，建议使用 stream 流的方式来处理，对于体验与 node 端的内存管理等，都有优势；\n- 不管对于 CSR 或者 SSR，都建议配合使用 Service worker，来控制资源的调配及骨架屏秒开的体验\n- react 项目上线之后，首先需要保障的是可用性，所以可以通过 React.Profiler 分析组件的渲染次数及耗时的一些任务，但是 Profile 记录的是 commit 阶段的数据，所以对于 react 的调和阶段就需要结合 performance API 一起分析\n- 由于 React 是父级 props 改变之后，所有与 props 不相关子组件在没有添加条件控制的情况之下，也会触发 render 渲染，这是没有必要的，可以结合 React 的 PureComponent 以及 React.memo 等做浅比较处理，这中间有涉及到不可变数据的处理，当然也可以结合使用 ShouldComponentUpdate 做深比较处理\n- 所有的运行状态优化，都是减少不必要的 render，React.useMemo 与 React.useCallback 也是可以做很多优化的地方\n- 在很多应用中，都会涉及到使用 redux 以及使用 context，这两个都可能造成许多不必要的 render，所以在使用的时候，也需要谨慎的处理一些数据\n- 最后就是保证整个应用的可用性，为组件创建错误边界，可以使用 componentDidCatch 来处理\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"BANVM\"><span>开发过程中</span></h2><ol><li><span style=\"color: #444444;\">函数式组件使用 React.Memo 来缓存组件</span><span class=\"lake-card-label\" style=\"background-color: #DEE8FC; color: #061178;\">避免组件重渲染</span></li><li><span style=\"color: #444444;\">使用 useMemo 缓存大量计算</span></li><li><span style=\"color: #444444;\">类组件使用 React.PureComponent，shouldComponentUpdate</span><span class=\"lake-card-label\" style=\"background-color: #DEE8FC; color: #061178;\">避免组件重渲染</span></li><li><span style=\"color: #444444;\">避免使用内联对象</span></li><li><span style=\"color: #444444;\">避免使用匿名函数</span></li><li><span style=\"color: #444444;\">延迟加载不是立即需要的组件(React.lazy + React.Suspense)</span></li><li><span style=\"color: #444444;\">调整 css 而不是强制组件加载和卸载</span></li><li><span style=\"color: #444444;\">使用 React.Fragment 避免添加额外的 DOM</span></li><li><span style=\"color: #444444;\">不在 render 中处理数据</span></li><li><span style=\"color: #444444;\">使用 web worker 做密集型的任务处理</span></li><li><span style=\"color: #444444;\">使用唯一的键值迭代</span></li></ol><h2 id=\"xa67Q\"><span>上线后首屏及运行状态</span></h2><ul><li><span style=\"color: #444444;\">首屏优化一般涉及到几个指标 FP、FCP、FMP；要有一个良好的体验是尽可能的把 FCP 提前，需要做一些工程化的处理，去优化资源的加载</span></li></ul><ul data-lake-indent=\"1\"><li><span style=\"color: #444444;\">FP: 页面在导航后首次呈现出不同于导航前内容的时间点;</span></li><li><span style=\"color: #444444;\">FCP: 首次绘制任何文本，图像，非空白 canvas 或 SVG 的时间点;</span></li><li><span style=\"color: #444444;\">FMP: 是由 Google 工程师引入的一种现代性能指标，它告诉我们页面何时</span><span style=\"color: #444444;\"> </span><strong><span style=\"color: #444444;\">有用</span></strong><span style=\"color: #444444;\">。其本质上是通过一种算法来猜测某个时间点可能是 FMP</span></li></ul><ul><li><span style=\"color: #444444;\">方式及分包策略，资源的减少是最有效的加快首屏打开的方式</span></li><li><span style=\"color: #444444;\">对于 CSR 的应用，FCP 的过程一般是首先加载 js 与 css 资源，js 在本地执行完成，然后加载数据回来，做内容初始化渲染，这中间就有几次的网络反复请求的过程；所以 CSR 可以考虑使用骨架屏及预渲染（部分结构预渲染）、suspence 与 lazy 做懒加载动态组件的方式</span></li><li><span style=\"color: #444444;\">当然还有另外一种方式就是 SSR 的方式，SSR 对于首屏的优化有一定的优势，但是这种瓶颈一般在 Node 服务端的处理，建议使用 stream 流的方式来处理，对于体验与 node 端的内存管理等，都有优势；</span></li><li><span style=\"color: #444444;\">不管对于 CSR 或者 SSR，都建议配合使用 Service worker，来控制资源的调配及骨架屏秒开的体验</span></li><li><span style=\"color: #444444;\">react 项目上线之后，首先需要保障的是可用性，所以可以通过 React.Profiler 分析组件的渲染次数及耗时的一些任务，但是 Profile 记录的是 commit 阶段的数据，所以对于 react 的调和阶段就需要结合 performance API 一起分析</span></li><li><span style=\"color: #444444;\">由于 React 是父级 props 改变之后，所有与 props 不相关子组件在没有添加条件控制的情况之下，也会触发 render 渲染，这是没有必要的，可以结合 React 的 PureComponent 以及 React.memo 等做浅比较处理，这中间有涉及到不可变数据的处理，当然也可以结合使用 ShouldComponentUpdate 做深比较处理</span></li><li><span style=\"color: #444444;\">所有的运行状态优化，都是减少不必要的 render，React.useMemo 与 React.useCallback 也是可以做很多优化的地方</span></li><li><span style=\"color: #444444;\">在很多应用中，都会涉及到使用 redux 以及使用 context，这两个都可能造成许多不必要的 render，所以在使用的时候，也需要谨慎的处理一些数据</span></li><li><span style=\"color: #444444;\">最后就是保证整个应用的可用性，为组件创建错误边界，可以使用 componentDidCatch 来处理</span><span><br /><br /></span></li></ul><p data-lake-id=\"u1f635324\"><br /></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"BANVM\" id=\"BANVM\"><span data-lake-id=\"u53262de7\" id=\"u53262de7\">开发过程中</span></h2><ol list=\"u58477b5b\"><li fid=\"u6c38ab3e\" data-lake-id=\"u992ca449\" id=\"u992ca449\"><span data-lake-id=\"ucff9909b\" id=\"ucff9909b\" style=\"color: rgb(68, 68, 68)\">函数式组件使用 React.Memo 来缓存组件</span><card type=\"inline\" name=\"label\" value=\"data:%7B%22label%22%3A%22%E9%81%BF%E5%85%8D%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%22%2C%22colorIndex%22%3A5%2C%22id%22%3A%22P1oYW%22%7D\"></card></li><li fid=\"u6c38ab3e\" data-lake-id=\"u5c235c15\" id=\"u5c235c15\"><span data-lake-id=\"ue6bb2af4\" id=\"ue6bb2af4\" style=\"color: rgb(68, 68, 68)\">使用 useMemo 缓存大量计算</span></li><li fid=\"u6c38ab3e\" data-lake-id=\"u04b672ea\" id=\"u04b672ea\"><span data-lake-id=\"u875ae7d7\" id=\"u875ae7d7\" style=\"color: rgb(68, 68, 68)\">类组件使用 React.PureComponent，shouldComponentUpdate</span><card type=\"inline\" name=\"label\" value=\"data:%7B%22label%22%3A%22%E9%81%BF%E5%85%8D%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%22%2C%22colorIndex%22%3A5%2C%22id%22%3A%22dDWSo%22%7D\"></card></li><li fid=\"u6c38ab3e\" data-lake-id=\"u5054d715\" id=\"u5054d715\"><span data-lake-id=\"ua548ea09\" id=\"ua548ea09\" style=\"color: rgb(68, 68, 68)\">避免使用内联对象</span></li><li fid=\"u6c38ab3e\" data-lake-id=\"u7d7afbc1\" id=\"u7d7afbc1\"><span data-lake-id=\"uc341e8e6\" id=\"uc341e8e6\" style=\"color: rgb(68, 68, 68)\">避免使用匿名函数</span></li><li fid=\"u6c38ab3e\" data-lake-id=\"u4da60bec\" id=\"u4da60bec\"><span data-lake-id=\"ucd1532a1\" id=\"ucd1532a1\" style=\"color: rgb(68, 68, 68)\">延迟加载不是立即需要的组件(React.lazy + React.Suspense)</span></li><li fid=\"u6c38ab3e\" data-lake-id=\"u40e7d70a\" id=\"u40e7d70a\"><span data-lake-id=\"u73d33aaf\" id=\"u73d33aaf\" style=\"color: rgb(68, 68, 68)\">调整 css 而不是强制组件加载和卸载</span></li><li fid=\"u6c38ab3e\" data-lake-id=\"ue157be17\" id=\"ue157be17\"><span data-lake-id=\"u415a84af\" id=\"u415a84af\" style=\"color: rgb(68, 68, 68)\">使用 React.Fragment 避免添加额外的 DOM</span></li><li fid=\"u6c38ab3e\" data-lake-id=\"u535a2d6f\" id=\"u535a2d6f\"><span data-lake-id=\"ud0ac327b\" id=\"ud0ac327b\" style=\"color: rgb(68, 68, 68)\">不在 render 中处理数据</span></li><li fid=\"u6c38ab3e\" data-lake-id=\"u10dbfaad\" id=\"u10dbfaad\"><span data-lake-id=\"u9f2e557e\" id=\"u9f2e557e\" style=\"color: rgb(68, 68, 68)\">使用 web worker 做密集型的任务处理</span></li><li fid=\"u6c38ab3e\" data-lake-id=\"u90f315b0\" id=\"u90f315b0\"><span data-lake-id=\"u94a449dd\" id=\"u94a449dd\" style=\"color: rgb(68, 68, 68)\">使用唯一的键值迭代</span></li></ol><h2 data-lake-id=\"xa67Q\" id=\"xa67Q\"><span data-lake-id=\"u450d7929\" id=\"u450d7929\">上线后首屏及运行状态</span></h2><ul list=\"u04d69bb5\"><li fid=\"u843f80f7\" data-lake-id=\"u206d62d5\" id=\"u206d62d5\"><span data-lake-id=\"u29d80846\" id=\"u29d80846\" style=\"color: rgb(68, 68, 68)\">首屏优化一般涉及到几个指标 FP、FCP、FMP；要有一个良好的体验是尽可能的把 FCP 提前，需要做一些工程化的处理，去优化资源的加载</span></li></ul><ul list=\"u04d69bb5\" data-lake-indent=\"1\"><li fid=\"uee0e27d3\" data-lake-id=\"ua94bd148\" id=\"ua94bd148\"><span data-lake-id=\"u19bef6f8\" id=\"u19bef6f8\" style=\"color: rgb(68, 68, 68)\">FP: 页面在导航后首次呈现出不同于导航前内容的时间点;</span></li><li fid=\"uee0e27d3\" data-lake-id=\"uf62c5050\" id=\"uf62c5050\"><span data-lake-id=\"ud6477c48\" id=\"ud6477c48\" style=\"color: rgb(68, 68, 68)\">FCP: 首次绘制任何文本，图像，非空白 canvas 或 SVG 的时间点;</span></li><li fid=\"uee0e27d3\" data-lake-id=\"u33f930bd\" id=\"u33f930bd\"><span data-lake-id=\"u1dce156f\" id=\"u1dce156f\" style=\"color: rgb(68, 68, 68)\">FMP: 是由 Google 工程师引入的一种现代性能指标，它告诉我们页面何时</span><span data-lake-id=\"uc1c444b9\" id=\"uc1c444b9\" style=\"color: rgb(68, 68, 68)\"> </span><strong><span data-lake-id=\"u22070f74\" id=\"u22070f74\" style=\"color: rgb(68, 68, 68)\">有用</span></strong><span data-lake-id=\"u8498d0e3\" id=\"u8498d0e3\" style=\"color: rgb(68, 68, 68)\">。其本质上是通过一种算法来猜测某个时间点可能是 FMP</span></li></ul><ul list=\"u04d69bb5\" start=\"2\"><li fid=\"u843f80f7\" data-lake-id=\"u04e91cd8\" id=\"u04e91cd8\"><span data-lake-id=\"u250e9cc4\" id=\"u250e9cc4\" style=\"color: rgb(68, 68, 68)\">方式及分包策略，资源的减少是最有效的加快首屏打开的方式</span></li><li fid=\"u843f80f7\" data-lake-id=\"ufd750b92\" id=\"ufd750b92\"><span data-lake-id=\"u55491d7a\" id=\"u55491d7a\" style=\"color: rgb(68, 68, 68)\">对于 CSR 的应用，FCP 的过程一般是首先加载 js 与 css 资源，js 在本地执行完成，然后加载数据回来，做内容初始化渲染，这中间就有几次的网络反复请求的过程；所以 CSR 可以考虑使用骨架屏及预渲染（部分结构预渲染）、suspence 与 lazy 做懒加载动态组件的方式</span></li><li fid=\"u843f80f7\" data-lake-id=\"u8ac470b9\" id=\"u8ac470b9\"><span data-lake-id=\"u95c498d6\" id=\"u95c498d6\" style=\"color: rgb(68, 68, 68)\">当然还有另外一种方式就是 SSR 的方式，SSR 对于首屏的优化有一定的优势，但是这种瓶颈一般在 Node 服务端的处理，建议使用 stream 流的方式来处理，对于体验与 node 端的内存管理等，都有优势；</span></li><li fid=\"u843f80f7\" data-lake-id=\"uffbc967f\" id=\"uffbc967f\"><span data-lake-id=\"u4efe5dd7\" id=\"u4efe5dd7\" style=\"color: rgb(68, 68, 68)\">不管对于 CSR 或者 SSR，都建议配合使用 Service worker，来控制资源的调配及骨架屏秒开的体验</span></li><li fid=\"u843f80f7\" data-lake-id=\"u0e0f1a53\" id=\"u0e0f1a53\"><span data-lake-id=\"u0de622ca\" id=\"u0de622ca\" style=\"color: rgb(68, 68, 68)\">react 项目上线之后，首先需要保障的是可用性，所以可以通过 React.Profiler 分析组件的渲染次数及耗时的一些任务，但是 Profile 记录的是 commit 阶段的数据，所以对于 react 的调和阶段就需要结合 performance API 一起分析</span></li><li fid=\"u843f80f7\" data-lake-id=\"u7e9072c6\" id=\"u7e9072c6\"><span data-lake-id=\"u4c0040b4\" id=\"u4c0040b4\" style=\"color: rgb(68, 68, 68)\">由于 React 是父级 props 改变之后，所有与 props 不相关子组件在没有添加条件控制的情况之下，也会触发 render 渲染，这是没有必要的，可以结合 React 的 PureComponent 以及 React.memo 等做浅比较处理，这中间有涉及到不可变数据的处理，当然也可以结合使用 ShouldComponentUpdate 做深比较处理</span></li><li fid=\"u843f80f7\" data-lake-id=\"u1c75eef8\" id=\"u1c75eef8\"><span data-lake-id=\"u5b3823c4\" id=\"u5b3823c4\" style=\"color: rgb(68, 68, 68)\">所有的运行状态优化，都是减少不必要的 render，React.useMemo 与 React.useCallback 也是可以做很多优化的地方</span></li><li fid=\"u843f80f7\" data-lake-id=\"ue3f88af2\" id=\"ue3f88af2\"><span data-lake-id=\"u49dcc908\" id=\"u49dcc908\" style=\"color: rgb(68, 68, 68)\">在很多应用中，都会涉及到使用 redux 以及使用 context，这两个都可能造成许多不必要的 render，所以在使用的时候，也需要谨慎的处理一些数据</span></li><li fid=\"u843f80f7\" data-lake-id=\"u7fd9c2a0\" id=\"u7fd9c2a0\"><span data-lake-id=\"uc1351601\" id=\"uc1351601\" style=\"color: rgb(68, 68, 68)\">最后就是保证整个应用的可用性，为组件创建错误边界，可以使用 componentDidCatch 来处理</span><span data-lake-id=\"u2cd69033\" id=\"u2cd69033\"><br /><br /></span></li></ul><p data-lake-id=\"u1f635324\" id=\"u1f635324\"><br></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:08.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:08.000Z",
  "updated_at": "2022-05-10T15:12:39.000Z",
  "published_at": "2022-04-04T11:33:08.000Z",
  "first_published_at": "2022-04-04T11:33:07.773Z",
  "word_count": 870,
  "cover": null,
  "description": "开发过程中函数式组件使用 React.Memo 来缓存组件避免组件重渲染使用 useMemo 缓存大量计算类组件使用 React.PureComponent，shouldComponentUpdate避免组件重渲染避免使用内联对象避免使用匿名函数延迟加载不是立即需要的组件(React.lazy...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}