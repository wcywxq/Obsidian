{
  "id": 72212125,
  "slug": "yr6q8p",
  "title": "react 新版本特性",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"fXrAl\"></a>\n## React 16.x 新特性\n- Time Slicing 时间切片\n\n（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能\n\n- Suspense\n\n解决网络 IO 问题）和 lazy 配合，实现异步加载组件。能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非常的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式\n\n- componentDidCatch\n\n此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件\n<a name=\"F0bwU\"></a>\n### React 16.8\n加入了 hooks\n\n- useState\n- useEffect\n- useContext\n- useReducer\n- useCallback\n- useMemo\n- useRef\n- useImperativeMethods\n- useMutationEffect\n- useLayoutEffect\n<a name=\"fN6Ta\"></a>\n### React 16.9\n\n- 重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出\n- 废弃 javascrip: 形式的 URL。以 javascript: 开头的 URL 非常容易遭受攻击，造成安全漏洞。\n- 废弃\"Factory\"组件。 工厂组件会导致 React 变大且变慢。\n- act() 也支持异步函数，并且你可以在调用它时使用 await。\n- 使用 <React.ProfiLer> 进行性能评估。在较大的应用中追踪性能回归可能会很方便\n<a name=\"uHa3f\"></a>\n### React 16.13.0\n\n- 支持在渲染期间调用 setState，但仅适用于同一组件\n- 可检测冲突的样式规则并记录警告\n- 废弃 unstable_createPortal，使用 CreatePortal\n- 将组件堆栈添加到其开发警告中，使开发人员能够隔离 bug 并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。\t\n<a name=\"t6ijF\"></a>\n## React 18 新特性\n\n1. 新的客户端渲染 API：ReactDOM.createRoot(用于替换 ReactDOM.render)重要\n2. 服务端渲染 API 更新，完全支持了服务端的 Suspense 和流式 SSR重要\n3. 自动批处理优化(解决了异步回调中无法批处理的问题)重要\n4. 不再存在并发模式(Concurrent Mode)，而是并发特性(Concurrent Feature)，侵入性更低重要\n5. 新增 Hooks API\n   1. useId: 为组件生成唯一的 ID。\n   2. useSyncExternalStore：可以在并行渲染时避免 UI 状态和外部数据源割裂，官方推荐所有三方状态库都切换为这个 API，[react-redux 8.0.0-alpha 已切换为此 API](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Freact-redux%2Freleases%2Ftag%2Fv8.0.0-alpha.1)。\n   3. useInsertionEffect：用于给 CSS 库在全局插入 DOM 节点，比如 <style> 或 SVG <defs>，相比 useLayoutEffect，这个方法的回调过程中拿不到 DOM 节点的 ref。\n   4. 用于并发渲染的 useDeferredValue、startTransition、useTransition。\n6. Suspense API 更新\n   1. React 16 - 17 的 Suspense API 仅限于客户端，仅和 React.lazy 进行搭配。\n   2. 而 React 18 起的 Suspense API 将支持内部组件的异步加载状态，同时支持流式 SSR。\n   3. Suspense 不再依赖 fallback 属性来定义边界。\n7. 删除了 “setState on unmounted component” 警告。\n8. 不再支持任何版本的 IE 浏览器。是因为 React 18 中引入的新特性是使用现代浏览器特性构建的，比如微任务，这些特性在 IE 中是无法充分填充的。而 IE 浏览器也将于 2022 年 6 月 15 日停止支持。\n<a name=\"TvKtw\"></a>\n### 自动批处理\nReact 18 通过默认执行更多批处理来增加开箱即用的性能改进，无需在应用程序或库代码中手动批处理更新。\n\n批处理是 React 将多个状态更新分组到单个重新渲染中以获得更好的性能。简单来说，批处理（分组）意味着将多个状态更新组合到一个渲染中。每当您使用 setState 更改任何函数内的变量时，React 会收集所有 setState，然后一起执行它们，而不是在每个 setState 上进行渲染。这称为批处理。\n```javascript\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n\n  function handleClick() {\n    setCount(c => c + 1); // Does not re-render yet\n    setFlag(f => !f); // Does not re-render yet\n    // React will only re-render once at the end (that's batching!)\n  }\n\n  return (\n    <div>\n      <button onClick={handleClick}>Next</button>\n      <h1 style={{ color: flag ? \"blue\" : \"black\" }}>{count}</h1>\n    </div>\n  );\n}\n```\n这对性能非常有用，因为它避免了不必要的重新渲染。\n<a name=\"nl4zs\"></a>\n### 服务端渲染\n服务端渲染是一种在服务器端将JS数据渲染成HTML的方式，以节省前端的计算量。在大多数情况下，这会导致更快的初始页面加载。\n\nReact 分 4 个连续步骤执行服务端渲染：\n\n1. 在服务器上，为每个组件获取数据。\n2. 在服务器上，整个应用程序被渲染为 HTML 并发送到客户端。\n3. 在客户端，获取整个应用程序的 JavaScript 代码。\n4. 在客户端，JavaScript 将 React 连接到服务器生成的 HTML，即Hydration。在普通版本中（直到 React 17），SSR 必须先加载整个页面，然后才能开始对页面进行保湿。\n\n这在 React18 中发生了变化，现在我们可以使用将 React 组件分解成更小的块 .\n<a name=\"adgvC\"></a>\n### 流式 HTML\n通过将组件包装其中：\n```jsx\n<Suspense fallback={<Spinner />}>{children}</Suspense> \n```\n我们告诉 React 它不需要等待为页面的其余部分流式传输 HTML，这时React 将发送占位符（一个spinner）。<br />当数据在服务器上准备好时，React 会将额外的 HTML 发送到同一个流中，以及一个最小的内联脚本标签，以将该 HTML 放在“正确的位置”。\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"fXrAl\"><span class=\"ne-text\">React 16.x 新特性</span></h2><ul class=\"ne-ul\"><li id=\"u1f749607\"><span class=\"ne-text\">Time Slicing 时间切片</span></li></ul><p id=\"u8d643253\" class=\"ne-p\"><span class=\"ne-text\">（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能</span></p><ul class=\"ne-ul\"><li id=\"u7338aef1\"><span class=\"ne-text\">Suspense</span></li></ul><p id=\"u79938f82\" class=\"ne-p\"><span class=\"ne-text\">解决网络 IO 问题）和 lazy 配合，实现异步加载组件。能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非常的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式</span></p><ul class=\"ne-ul\"><li id=\"ud3ab8ec2\"><span class=\"ne-text\">componentDidCatch</span></li></ul><p id=\"u14f486e4\" class=\"ne-p\"><span class=\"ne-text\">此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件</span></p><h3 id=\"F0bwU\"><span class=\"ne-text\">React 16.8</span></h3><p id=\"u3e64668b\" class=\"ne-p\"><span class=\"ne-text\">加入了 hooks</span></p><ul class=\"ne-ul\"><li id=\"ud4fb17ec\"><span class=\"ne-text\">useState</span></li><li id=\"u22d28745\"><span class=\"ne-text\">useEffect</span></li><li id=\"u8a12198c\"><span class=\"ne-text\">useContext</span></li><li id=\"u6a13c1d2\"><span class=\"ne-text\">useReducer</span></li><li id=\"u1e941952\"><span class=\"ne-text\">useCallback</span></li><li id=\"ude3cbe5a\"><span class=\"ne-text\">useMemo</span></li><li id=\"u79554103\"><span class=\"ne-text\">useRef</span></li><li id=\"u08462f3e\"><span class=\"ne-text\">useImperativeMethods</span></li><li id=\"u24b77b6b\"><span class=\"ne-text\">useMutationEffect</span></li><li id=\"u6dcc8b3e\"><span class=\"ne-text\">useLayoutEffect</span></li></ul><h3 id=\"fN6Ta\"><span class=\"ne-text\">React 16.9</span></h3><ul class=\"ne-ul\"><li id=\"ue5304ad9\"><span class=\"ne-text\">重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出</span></li><li id=\"u31166a33\"><span class=\"ne-text\">废弃 javascrip: 形式的 URL。以 javascript: 开头的 URL 非常容易遭受攻击，造成安全漏洞。</span></li><li id=\"u9924fc29\"><span class=\"ne-text\">废弃&quot;Factory&quot;组件。 工厂组件会导致 React 变大且变慢。</span></li><li id=\"ue95025ba\"><span class=\"ne-text\">act() 也支持异步函数，并且你可以在调用它时使用 await。</span></li><li id=\"ue830f831\"><span class=\"ne-text\">使用 &lt;React.ProfiLer&gt; 进行性能评估。在较大的应用中追踪性能回归可能会很方便</span></li></ul><h3 id=\"uHa3f\"><span class=\"ne-text\">React 16.13.0</span></h3><ul class=\"ne-ul\"><li id=\"u3050d852\"><span class=\"ne-text\">支持在渲染期间调用 setState，但仅适用于同一组件</span></li><li id=\"u0a218530\"><span class=\"ne-text\">可检测冲突的样式规则并记录警告</span></li><li id=\"u7e073b3f\"><span class=\"ne-text\">废弃 unstable_createPortal，使用 CreatePortal</span></li><li id=\"u9b28a732\"><span class=\"ne-text\">将组件堆栈添加到其开发警告中，使开发人员能够隔离 bug 并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。\t</span></li></ul><h2 id=\"t6ijF\"><span class=\"ne-text\">React 18 新特性</span></h2><ol class=\"ne-ol\"><li id=\"uf7496eda\"><span class=\"ne-text\">新的客户端渲染 API：ReactDOM.createRoot(用于替换 ReactDOM.render)</span><span data-color=\"0\" id=\"M8Vto\" class=\"ne-label\">重要</span></li><li id=\"u38ea8cbc\"><span class=\"ne-text\">服务端渲染 API 更新，完全支持了服务端的 Suspense 和流式 SSR</span><span data-color=\"0\" id=\"g8L8B\" class=\"ne-label\">重要</span></li><li id=\"u31355cd3\"><span class=\"ne-text\">自动批处理优化(解决了异步回调中无法批处理的问题)</span><span data-color=\"0\" id=\"yYgpQ\" class=\"ne-label\">重要</span></li><li id=\"u868e12c2\"><span class=\"ne-text\">不再存在并发模式(Concurrent Mode)，而是并发特性(Concurrent Feature)，侵入性更低</span><span data-color=\"0\" id=\"rNdBn\" class=\"ne-label\">重要</span></li><li id=\"u053bc7b1\"><span class=\"ne-text\">新增 Hooks API</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" class=\"ne-ol\"><li id=\"ua04c2c77\"><span class=\"ne-text\">useId: 为组件生成唯一的 ID。</span></li><li id=\"ud089791b\"><span class=\"ne-text\">useSyncExternalStore</span><span class=\"ne-text\">：可以在并行渲染时避免 UI 状态和外部数据源割裂，官方推荐所有三方状态库都切换为这个 API，</span><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Freact-redux%2Freleases%2Ftag%2Fv8.0.0-alpha.1\" data-href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Freact-redux%2Freleases%2Ftag%2Fv8.0.0-alpha.1\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">react-redux 8.0.0-alpha 已切换为此 API</span></a><span class=\"ne-text\">。</span></li><li id=\"u17656df2\"><span class=\"ne-text\">useInsertionEffect</span><span class=\"ne-text\">：用于给 CSS 库在全局插入 DOM 节点，比如 </span><span class=\"ne-text\">&lt;style&gt;</span><span class=\"ne-text\"> 或 SVG </span><span class=\"ne-text\">&lt;defs&gt;</span><span class=\"ne-text\">，相比 </span><span class=\"ne-text\">useLayoutEffect</span><span class=\"ne-text\">，这个方法的回调过程中拿不到 DOM 节点的 ref。</span></li><li id=\"ub4a29e8a\"><span class=\"ne-text\">用于并发渲染的 useDeferredValue、startTransition、useTransition。</span></li></ol></ol><ol start=\"6\" class=\"ne-ol\"><li id=\"u2f653393\"><span class=\"ne-text\">Suspense API 更新</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" class=\"ne-ol\"><li id=\"ucb235916\"><span class=\"ne-text\">React 16 - 17 的 Suspense API 仅限于客户端，仅和 React.lazy 进行搭配。</span></li><li id=\"u4fe1bfb4\"><span class=\"ne-text\">而 React 18 起的 Suspense API 将支持内部组件的异步加载状态，同时支持流式 SSR。</span></li><li id=\"u41fce5db\"><span class=\"ne-text\">Suspense 不再依赖 fallback 属性来定义边界。</span></li></ol></ol><ol start=\"7\" class=\"ne-ol\"><li id=\"uc611b282\"><span class=\"ne-text\">删除了 “setState on unmounted component” 警告。</span></li><li id=\"ubee0ecb8\"><span class=\"ne-text\">不再支持任何版本的 IE 浏览器。是因为 React 18 中引入的新特性是使用现代浏览器特性构建的，比如微任务，这些特性在 IE 中是无法充分填充的。而 IE 浏览器也将于 2022 年 6 月 15 日停止支持。</span></li></ol><h3 id=\"TvKtw\"><span class=\"ne-text\">自动批处理</span></h3><p id=\"u43d4b4f2\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">React 18 通过默认执行更多批处理来增加开箱即用的性能改进，无需在应用程序或库代码中手动批处理更新。</span></p><p id=\"u393f0c0c\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u9b9fb4ab\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">批处理是 React 将多个状态更新分组到单个重新渲染中以获得更好的性能。简单来说，批处理（分组）意味着将多个状态更新组合到一个渲染中。每当您使用 setState 更改任何函数内的变量时，React 会收集所有 setState，然后一起执行它们，而不是在每个 setState 上进行渲染。这称为批处理。</span></p><pre data-language=\"javascript\" id=\"Bekm5\" class=\"ne-codeblock language-javascript\">function App() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n\n  function handleClick() {\n    setCount(c =&gt; c + 1); // Does not re-render yet\n    setFlag(f =&gt; !f); // Does not re-render yet\n    // React will only re-render once at the end (that's batching!)\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={handleClick}&gt;Next&lt;/button&gt;\n      &lt;h1 style={{ color: flag ? &quot;blue&quot; : &quot;black&quot; }}&gt;{count}&lt;/h1&gt;\n    &lt;/div&gt;\n  );\n}</pre><p id=\"uf856a1ad\" class=\"ne-p\"><span class=\"ne-text\">这对性能非常有用，因为它避免了不必要的重新渲染。</span></p><h3 id=\"nl4zs\"><span class=\"ne-text\">服务端渲染</span></h3><p id=\"u5d0b35ef\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">服务端渲染是一种在服务器端将JS数据渲染成HTML的方式，以节省前端的计算量。在大多数情况下，这会导致更快的初始页面加载。</span></p><p id=\"udda17840\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"uc33d77df\" class=\"ne-p\"><span class=\"ne-text\">React 分 4 个连续步骤执行服务端渲染：</span></p><ol class=\"ne-ol\"><li id=\"u031f37dc\"><span class=\"ne-text\">在服务器上，为每个组件获取数据。</span></li><li id=\"ue7d99fb1\"><span class=\"ne-text\">在服务器上，整个应用程序被渲染为 HTML 并发送到客户端。</span></li><li id=\"u831d920f\"><span class=\"ne-text\">在客户端，获取整个应用程序的 JavaScript 代码。</span></li><li id=\"u7dc51bc6\"><span class=\"ne-text\">在客户端，JavaScript 将 React 连接到服务器生成的 HTML，即Hydration。在普通版本中（直到 React 17），SSR 必须先加载整个页面，然后才能开始对页面进行保湿。</span></li></ol><p id=\"u9340cc67\" class=\"ne-p\"><span class=\"ne-text\">这在 React18 中发生了变化，现在我们可以使用将 React 组件分解成更小的块 .</span></p><h3 id=\"adgvC\"><span class=\"ne-text\">流式 HTML</span></h3><p id=\"u1da386bd\" class=\"ne-p\"><span class=\"ne-text\">通过将组件包装其中：</span></p><pre data-language=\"jsx\" id=\"CKfz0\" class=\"ne-codeblock language-jsx\">&lt;Suspense fallback={&lt;Spinner /&gt;}&gt;{children}&lt;/Suspense&gt; </pre><p id=\"u6a660782\" class=\"ne-p\"><span class=\"ne-text\">我们告诉 React 它不需要等待为页面的其余部分流式传输 HTML，这时React 将发送占位符（一个spinner）。</span></p><p id=\"ufa9a43e3\" class=\"ne-p\"><span class=\"ne-text\">当数据在服务器上准备好时，React 会将额外的 HTML 发送到同一个流中，以及一个最小的内联脚本标签，以将该 HTML 放在“正确的位置”。</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"fXrAl\" id=\"fXrAl\"><span data-lake-id=\"u63e4e2bd\" id=\"u63e4e2bd\">React 16.x 新特性</span></h2><ul list=\"u90bf88ad\"><li fid=\"u302914ed\" data-lake-id=\"u1f749607\" id=\"u1f749607\"><span data-lake-id=\"ucabecf7b\" id=\"ucabecf7b\">Time Slicing 时间切片</span></li></ul><p data-lake-id=\"u8d643253\" id=\"u8d643253\"><span data-lake-id=\"u28f2dc65\" id=\"u28f2dc65\">（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能</span></p><ul list=\"u90bf88ad\" start=\"2\"><li fid=\"u302914ed\" data-lake-id=\"u7338aef1\" id=\"u7338aef1\"><span data-lake-id=\"u4f8514a3\" id=\"u4f8514a3\">Suspense</span></li></ul><p data-lake-id=\"u79938f82\" id=\"u79938f82\"><span data-lake-id=\"u7a5bb240\" id=\"u7a5bb240\">解决网络 IO 问题）和 lazy 配合，实现异步加载组件。能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非常的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式</span></p><ul list=\"u8f0c0151\"><li fid=\"u4118a90a\" data-lake-id=\"ud3ab8ec2\" id=\"ud3ab8ec2\"><span data-lake-id=\"u91a772e3\" id=\"u91a772e3\">componentDidCatch</span></li></ul><p data-lake-id=\"u14f486e4\" id=\"u14f486e4\"><span data-lake-id=\"u5df92acc\" id=\"u5df92acc\">此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件</span></p><h3 data-lake-id=\"F0bwU\" id=\"F0bwU\"><span data-lake-id=\"ue29ddc06\" id=\"ue29ddc06\">React 16.8</span></h3><p data-lake-id=\"u3e64668b\" id=\"u3e64668b\"><span data-lake-id=\"ud0a7ec0c\" id=\"ud0a7ec0c\">加入了 hooks</span></p><ul list=\"uddf368a7\"><li fid=\"u23a09f27\" data-lake-id=\"ud4fb17ec\" id=\"ud4fb17ec\"><span data-lake-id=\"u49dfd526\" id=\"u49dfd526\">useState</span></li><li fid=\"u23a09f27\" data-lake-id=\"u22d28745\" id=\"u22d28745\"><span data-lake-id=\"u2f8f8600\" id=\"u2f8f8600\">useEffect</span></li><li fid=\"u23a09f27\" data-lake-id=\"u8a12198c\" id=\"u8a12198c\"><span data-lake-id=\"u000b0d11\" id=\"u000b0d11\">useContext</span></li><li fid=\"u23a09f27\" data-lake-id=\"u6a13c1d2\" id=\"u6a13c1d2\"><span data-lake-id=\"u380c8ab2\" id=\"u380c8ab2\">useReducer</span></li><li fid=\"u23a09f27\" data-lake-id=\"u1e941952\" id=\"u1e941952\"><span data-lake-id=\"u29c6626b\" id=\"u29c6626b\">useCallback</span></li><li fid=\"u23a09f27\" data-lake-id=\"ude3cbe5a\" id=\"ude3cbe5a\"><span data-lake-id=\"ucc4ed624\" id=\"ucc4ed624\">useMemo</span></li><li fid=\"u23a09f27\" data-lake-id=\"u79554103\" id=\"u79554103\"><span data-lake-id=\"u5398420b\" id=\"u5398420b\">useRef</span></li><li fid=\"u23a09f27\" data-lake-id=\"u08462f3e\" id=\"u08462f3e\"><span data-lake-id=\"uaa92cc1b\" id=\"uaa92cc1b\">useImperativeMethods</span></li><li fid=\"u23a09f27\" data-lake-id=\"u24b77b6b\" id=\"u24b77b6b\"><span data-lake-id=\"u032942db\" id=\"u032942db\">useMutationEffect</span></li><li fid=\"u23a09f27\" data-lake-id=\"u6dcc8b3e\" id=\"u6dcc8b3e\"><span data-lake-id=\"ubb17d3e3\" id=\"ubb17d3e3\">useLayoutEffect</span></li></ul><h3 data-lake-id=\"fN6Ta\" id=\"fN6Ta\"><span data-lake-id=\"u454e967a\" id=\"u454e967a\">React 16.9</span></h3><ul list=\"uddf368a7\" start=\"11\"><li fid=\"u23a09f27\" data-lake-id=\"ue5304ad9\" id=\"ue5304ad9\"><span data-lake-id=\"ue8a0f5b9\" id=\"ue8a0f5b9\">重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出</span></li><li fid=\"u23a09f27\" data-lake-id=\"u31166a33\" id=\"u31166a33\"><span data-lake-id=\"u0d98a765\" id=\"u0d98a765\">废弃 javascrip: 形式的 URL。以 javascript: 开头的 URL 非常容易遭受攻击，造成安全漏洞。</span></li><li fid=\"u23a09f27\" data-lake-id=\"u9924fc29\" id=\"u9924fc29\"><span data-lake-id=\"ucb102fed\" id=\"ucb102fed\">废弃&quot;Factory&quot;组件。 工厂组件会导致 React 变大且变慢。</span></li><li fid=\"u23a09f27\" data-lake-id=\"ue95025ba\" id=\"ue95025ba\"><span data-lake-id=\"uc19eb289\" id=\"uc19eb289\">act() 也支持异步函数，并且你可以在调用它时使用 await。</span></li><li fid=\"u23a09f27\" data-lake-id=\"ue830f831\" id=\"ue830f831\"><span data-lake-id=\"u856b3065\" id=\"u856b3065\">使用 &lt;React.ProfiLer&gt; 进行性能评估。在较大的应用中追踪性能回归可能会很方便</span></li></ul><h3 data-lake-id=\"uHa3f\" id=\"uHa3f\"><span data-lake-id=\"u4bcc228b\" id=\"u4bcc228b\">React 16.13.0</span></h3><ul list=\"uddf368a7\" start=\"16\"><li fid=\"u23a09f27\" data-lake-id=\"u3050d852\" id=\"u3050d852\"><span data-lake-id=\"u64fd9cc9\" id=\"u64fd9cc9\">支持在渲染期间调用 setState，但仅适用于同一组件</span></li><li fid=\"u23a09f27\" data-lake-id=\"u0a218530\" id=\"u0a218530\"><span data-lake-id=\"u74ad0b40\" id=\"u74ad0b40\">可检测冲突的样式规则并记录警告</span></li><li fid=\"u23a09f27\" data-lake-id=\"u7e073b3f\" id=\"u7e073b3f\"><span data-lake-id=\"u3c350eb5\" id=\"u3c350eb5\">废弃 unstable_createPortal，使用 CreatePortal</span></li><li fid=\"u23a09f27\" data-lake-id=\"u9b28a732\" id=\"u9b28a732\"><span data-lake-id=\"u9edb3b54\" id=\"u9edb3b54\">将组件堆栈添加到其开发警告中，使开发人员能够隔离 bug 并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。\t</span></li></ul><h2 data-lake-id=\"t6ijF\" id=\"t6ijF\"><span data-lake-id=\"u5a5e2132\" id=\"u5a5e2132\">React 18 新特性</span></h2><ol list=\"u1fd68bae\"><li fid=\"ufd79171d\" data-lake-id=\"uf7496eda\" id=\"uf7496eda\"><span data-lake-id=\"u386fc34f\" id=\"u386fc34f\">新的客户端渲染 API：ReactDOM.createRoot(用于替换 ReactDOM.render)</span><card type=\"inline\" name=\"label\" value=\"data:%7B%22label%22%3A%22%E9%87%8D%E8%A6%81%22%2C%22colorIndex%22%3A0%2C%22id%22%3A%22M8Vto%22%7D\"></card></li><li fid=\"ufd79171d\" data-lake-id=\"u38ea8cbc\" id=\"u38ea8cbc\"><span data-lake-id=\"u82c97d22\" id=\"u82c97d22\">服务端渲染 API 更新，完全支持了服务端的 Suspense 和流式 SSR</span><card type=\"inline\" name=\"label\" value=\"data:%7B%22label%22%3A%22%E9%87%8D%E8%A6%81%22%2C%22colorIndex%22%3A0%2C%22id%22%3A%22g8L8B%22%7D\"></card></li><li fid=\"ufd79171d\" data-lake-id=\"u31355cd3\" id=\"u31355cd3\"><span data-lake-id=\"ucc40693c\" id=\"ucc40693c\">自动批处理优化(解决了异步回调中无法批处理的问题)</span><card type=\"inline\" name=\"label\" value=\"data:%7B%22label%22%3A%22%E9%87%8D%E8%A6%81%22%2C%22colorIndex%22%3A0%2C%22id%22%3A%22yYgpQ%22%7D\"></card></li><li fid=\"ufd79171d\" data-lake-id=\"u868e12c2\" id=\"u868e12c2\"><span data-lake-id=\"u475ff03f\" id=\"u475ff03f\">不再存在并发模式(Concurrent Mode)，而是并发特性(Concurrent Feature)，侵入性更低</span><card type=\"inline\" name=\"label\" value=\"data:%7B%22label%22%3A%22%E9%87%8D%E8%A6%81%22%2C%22colorIndex%22%3A0%2C%22id%22%3A%22rNdBn%22%7D\"></card></li><li fid=\"ufd79171d\" data-lake-id=\"u053bc7b1\" id=\"u053bc7b1\"><span data-lake-id=\"u543af551\" id=\"u543af551\">新增 Hooks API</span></li></ol><ol list=\"u1fd68bae\" data-lake-indent=\"1\"><li fid=\"u4f0da6e9\" data-lake-id=\"ua04c2c77\" id=\"ua04c2c77\"><span data-lake-id=\"u2ad2a344\" id=\"u2ad2a344\">useId: 为组件生成唯一的 ID。</span></li><li fid=\"u4f0da6e9\" data-lake-id=\"ud089791b\" id=\"ud089791b\"><span data-lake-id=\"u990e754b\" id=\"u990e754b\">useSyncExternalStore</span><span data-lake-id=\"u7148bdb3\" id=\"u7148bdb3\">：可以在并行渲染时避免 UI 状态和外部数据源割裂，官方推荐所有三方状态库都切换为这个 API，</span><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Freact-redux%2Freleases%2Ftag%2Fv8.0.0-alpha.1\" target=\"_blank\" data-lake-id=\"ubd1df649\" id=\"ubd1df649\"><span data-lake-id=\"ue6e6b82e\" id=\"ue6e6b82e\">react-redux 8.0.0-alpha 已切换为此 API</span></a><span data-lake-id=\"u70b95e95\" id=\"u70b95e95\">。</span></li><li fid=\"u4f0da6e9\" data-lake-id=\"u17656df2\" id=\"u17656df2\"><span data-lake-id=\"ua01a4290\" id=\"ua01a4290\">useInsertionEffect</span><span data-lake-id=\"uf1b0c232\" id=\"uf1b0c232\">：用于给 CSS 库在全局插入 DOM 节点，比如 </span><span data-lake-id=\"u5bd704eb\" id=\"u5bd704eb\">&lt;style&gt;</span><span data-lake-id=\"ud98b3848\" id=\"ud98b3848\"> 或 SVG </span><span data-lake-id=\"u1f4a81be\" id=\"u1f4a81be\">&lt;defs&gt;</span><span data-lake-id=\"ua3a5592d\" id=\"ua3a5592d\">，相比 </span><span data-lake-id=\"u36baedd0\" id=\"u36baedd0\">useLayoutEffect</span><span data-lake-id=\"ue592d203\" id=\"ue592d203\">，这个方法的回调过程中拿不到 DOM 节点的 ref。</span></li><li fid=\"u4f0da6e9\" data-lake-id=\"ub4a29e8a\" id=\"ub4a29e8a\"><span data-lake-id=\"u5f77dcd8\" id=\"u5f77dcd8\">用于并发渲染的 useDeferredValue、startTransition、useTransition。</span></li></ol><ol list=\"u1fd68bae\" start=\"6\"><li fid=\"ufd79171d\" data-lake-id=\"u2f653393\" id=\"u2f653393\"><span data-lake-id=\"uf1b0ea04\" id=\"uf1b0ea04\">Suspense API 更新</span></li></ol><ol list=\"u1fd68bae\" data-lake-indent=\"1\"><li fid=\"ud3ac5fc6\" data-lake-id=\"ucb235916\" id=\"ucb235916\"><span data-lake-id=\"ub024e028\" id=\"ub024e028\">React 16 - 17 的 Suspense API 仅限于客户端，仅和 React.lazy 进行搭配。</span></li><li fid=\"ud3ac5fc6\" data-lake-id=\"u4fe1bfb4\" id=\"u4fe1bfb4\"><span data-lake-id=\"uc79a1e53\" id=\"uc79a1e53\">而 React 18 起的 Suspense API 将支持内部组件的异步加载状态，同时支持流式 SSR。</span></li><li fid=\"ud3ac5fc6\" data-lake-id=\"u41fce5db\" id=\"u41fce5db\"><span data-lake-id=\"uf79a90f4\" id=\"uf79a90f4\">Suspense 不再依赖 fallback 属性来定义边界。</span></li></ol><ol list=\"u1fd68bae\" start=\"7\"><li fid=\"ufd79171d\" data-lake-id=\"uc611b282\" id=\"uc611b282\"><span data-lake-id=\"u7861f59a\" id=\"u7861f59a\">删除了 “setState on unmounted component” 警告。</span></li><li fid=\"ufd79171d\" data-lake-id=\"ubee0ecb8\" id=\"ubee0ecb8\"><span data-lake-id=\"u057899f7\" id=\"u057899f7\">不再支持任何版本的 IE 浏览器。是因为 React 18 中引入的新特性是使用现代浏览器特性构建的，比如微任务，这些特性在 IE 中是无法充分填充的。而 IE 浏览器也将于 2022 年 6 月 15 日停止支持。</span></li></ol><h3 data-lake-id=\"TvKtw\" id=\"TvKtw\"><span data-lake-id=\"ue3d54902\" id=\"ue3d54902\">自动批处理</span></h3><p data-lake-id=\"u43d4b4f2\" id=\"u43d4b4f2\" style=\"text-indent: 2em\"><span data-lake-id=\"u108da8cf\" id=\"u108da8cf\">React 18 通过默认执行更多批处理来增加开箱即用的性能改进，无需在应用程序或库代码中手动批处理更新。</span></p><p data-lake-id=\"u393f0c0c\" id=\"u393f0c0c\"><span data-lake-id=\"ua962882f\" id=\"ua962882f\">​</span><br></p><p data-lake-id=\"u9b9fb4ab\" id=\"u9b9fb4ab\" style=\"text-indent: 2em\"><span data-lake-id=\"ufc0b0d2a\" id=\"ufc0b0d2a\">批处理是 React 将多个状态更新分组到单个重新渲染中以获得更好的性能。简单来说，批处理（分组）意味着将多个状态更新组合到一个渲染中。每当您使用 setState 更改任何函数内的变量时，React 会收集所有 setState，然后一起执行它们，而不是在每个 setState 上进行渲染。这称为批处理。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20App()%20%7B%5Cn%20%20const%20%5Bcount%2C%20setCount%5D%20%3D%20useState(0)%3B%5Cn%20%20const%20%5Bflag%2C%20setFlag%5D%20%3D%20useState(false)%3B%5Cn%5Cn%20%20function%20handleClick()%20%7B%5Cn%20%20%20%20setCount(c%20%3D%3E%20c%20%2B%201)%3B%20%2F%2F%20Does%20not%20re-render%20yet%5Cn%20%20%20%20setFlag(f%20%3D%3E%20!f)%3B%20%2F%2F%20Does%20not%20re-render%20yet%5Cn%20%20%20%20%2F%2F%20React%20will%20only%20re-render%20once%20at%20the%20end%20(that's%20batching!)%5Cn%20%20%7D%5Cn%5Cn%20%20return%20(%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%3Cbutton%20onClick%3D%7BhandleClick%7D%3ENext%3C%2Fbutton%3E%5Cn%20%20%20%20%20%20%3Ch1%20style%3D%7B%7B%20color%3A%20flag%20%3F%20%5C%22blue%5C%22%20%3A%20%5C%22black%5C%22%20%7D%7D%3E%7Bcount%7D%3C%2Fh1%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B13%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22Bekm5%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"uf856a1ad\" id=\"uf856a1ad\"><span data-lake-id=\"u7a546266\" id=\"u7a546266\">这对性能非常有用，因为它避免了不必要的重新渲染。</span></p><h3 data-lake-id=\"nl4zs\" id=\"nl4zs\"><span data-lake-id=\"u69954b2b\" id=\"u69954b2b\">服务端渲染</span></h3><p data-lake-id=\"u5d0b35ef\" id=\"u5d0b35ef\" style=\"text-indent: 2em\"><span data-lake-id=\"ufa3b4bc6\" id=\"ufa3b4bc6\">服务端渲染是一种在服务器端将JS数据渲染成HTML的方式，以节省前端的计算量。在大多数情况下，这会导致更快的初始页面加载。</span></p><p data-lake-id=\"udda17840\" id=\"udda17840\"><span data-lake-id=\"u8989a5d7\" id=\"u8989a5d7\">​</span><br></p><p data-lake-id=\"uc33d77df\" id=\"uc33d77df\"><span data-lake-id=\"u2c8a21bb\" id=\"u2c8a21bb\">React 分 4 个连续步骤执行服务端渲染：</span></p><ol list=\"u93085b37\"><li fid=\"u2ebf4a30\" data-lake-id=\"u031f37dc\" id=\"u031f37dc\"><span data-lake-id=\"u2328bd09\" id=\"u2328bd09\">在服务器上，为每个组件获取数据。</span></li><li fid=\"u2ebf4a30\" data-lake-id=\"ue7d99fb1\" id=\"ue7d99fb1\"><span data-lake-id=\"u9d9df059\" id=\"u9d9df059\">在服务器上，整个应用程序被渲染为 HTML 并发送到客户端。</span></li><li fid=\"u2ebf4a30\" data-lake-id=\"u831d920f\" id=\"u831d920f\"><span data-lake-id=\"uc786b814\" id=\"uc786b814\">在客户端，获取整个应用程序的 JavaScript 代码。</span></li><li fid=\"u2ebf4a30\" data-lake-id=\"u7dc51bc6\" id=\"u7dc51bc6\"><span data-lake-id=\"u2e1e619d\" id=\"u2e1e619d\">在客户端，JavaScript 将 React 连接到服务器生成的 HTML，即Hydration。在普通版本中（直到 React 17），SSR 必须先加载整个页面，然后才能开始对页面进行保湿。</span></li></ol><p data-lake-id=\"u9340cc67\" id=\"u9340cc67\"><span data-lake-id=\"u8e422d75\" id=\"u8e422d75\">这在 React18 中发生了变化，现在我们可以使用将 React 组件分解成更小的块 .</span></p><h3 data-lake-id=\"adgvC\" id=\"adgvC\"><span data-lake-id=\"uad09983c\" id=\"uad09983c\">流式 HTML</span></h3><p data-lake-id=\"u1da386bd\" id=\"u1da386bd\"><span data-lake-id=\"u16e9da93\" id=\"u16e9da93\">通过将组件包装其中：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%3CSuspense%20fallback%3D%7B%3CSpinner%20%2F%3E%7D%3E%7Bchildren%7D%3C%2FSuspense%3E%20%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22CKfz0%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u6a660782\" id=\"u6a660782\"><span data-lake-id=\"u9c954299\" id=\"u9c954299\">我们告诉 React 它不需要等待为页面的其余部分流式传输 HTML，这时React 将发送占位符（一个spinner）。</span></p><p data-lake-id=\"ufa9a43e3\" id=\"ufa9a43e3\"><span data-lake-id=\"ua45d3cd5\" id=\"ua45d3cd5\">当数据在服务器上准备好时，React 会将额外的 HTML 发送到同一个流中，以及一个最小的内联脚本标签，以将该 HTML 放在“正确的位置”。</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-07-12T15:22:24.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:09.000Z",
  "updated_at": "2022-07-12T15:22:24.000Z",
  "published_at": "2022-07-12T15:22:24.000Z",
  "first_published_at": "2022-04-04T11:33:09.382Z",
  "word_count": 1512,
  "cover": null,
  "description": "React 16.x 新特性Time Slicing 时间切片（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能Suspense解决网络 IO 问题）和 lazy 配合，实现异步加载组件。能暂停当...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}