{
  "id": 72212055,
  "slug": "fheyn3",
  "title": "react fiber",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "在 v16 之前的 React 里，是直接递归遍历 vdom，通过 dom api 增删改 dom 的方式来渲染的。但当 vdom 过大，频繁调用 dom api 会比较耗时，而且递归又不能打断，所以有性能问题。\n\n<a name=\"POcFz\"></a>\n## ![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647511348804-5a7c26da-9b6f-4357-beb4-affab3126a86.png#clientId=ue2eba416-b7db-4&from=paste&height=444&id=u4805bdbf&originHeight=444&originWidth=1080&originalType=binary&ratio=1&size=121987&status=done&style=none&taskId=uce761c91-3344-4a76-b052-793475e6194&width=1080)\n后来就引入了 fiber 架构，先把 vdom 树转成 fiber 链表，然后再渲染 fiber。\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647511376273-b755b3ac-be47-4087-8724-a0d7780626e9.png#clientId=ue2eba416-b7db-4&from=paste&height=934&id=u50aa42cc&originHeight=934&originWidth=1304&originalType=binary&ratio=1&size=315748&status=done&style=none&taskId=u9c6a7f78-4539-418a-9f7c-3be39bd42d4&width=1304)\n<a name=\"hkeRd\"></a>\n## 概述\nreact fiber 是对核心算法的一次重新实现，随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。其中的关键点就是**同步阻塞**。在之前的调度算法中，react 需要实例化每个类组件，生成一颗组件树，使用**同步递归**的方式进行遍历渲染，而这个过程中最大的问题就是**无法暂停和恢复**。\n\n- 在 react 16 将调度算法进行了重构，将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的**单链表树遍历算法**。通过指针映射，每个单元都记录着遍历当下的上一步和下一步，从而使遍历变得可以被暂停和重启。\n- 可以理解为任务分割调度算法，主要是将以前同步更新渲染的任务分割成一个个独立的小任务，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制\n\n---\n\n<a name=\"WoocU\"></a>\n## 什么是 fiber\n\n- fiber 是一种基于浏览器的**单线程调度算法**\n- fiber 是一个执行单元，每次执行完一个执行单元，react 就会检查还剩多少事件，如果没有时间则将控制权转让\n> 利用浏览器的 requestIdleCallback api 实现，其中如果浏览器一直很忙(如：1000 / 60 ~ 16ms 时间间隔内都有任务执行)，则会判断 requestIdleCallback 的 timeout 函数，如果超过 timeout 的值，或者该回调中的任务的优先级较高，则会在下一帧强制执行回调中的任务，避免卡顿现象。\n\n:::warning\n利用 requestIdleCallback 的回调可以充分的通过利用浏览器空闲时间来解决任务调度问题，由于 requestIdleCallback 的兼容性很差，所以 react 采用了 messageChannel 模拟实现了这一 api 的功能\n:::\n\n- fiber 是一种数据结构，react fiber 就是采用链表实现的，每个虚拟 dom 都可以表示为 fiber\n- fiber 实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务\n:::info\n浏览器很忙的时候，如 1000 / 60 ～ 16ms 时间间隔内都有任务执行，则会通过判断 requestIdleCallback 的 timeout \n:::\n<a name=\"XfUva\"></a>\n## react 任务的优先级\n\n1. Immediate：最高优先级，这个优先级的任务应该被马上执行，不能中断\n2. UserBlocking：这些任务一般是用户交互的结果，需要即时得到反馈\n3. Normal：不需要用户立即就感受到变化，比如网络请求\n4. Low：这些任务可以延后，但是最终也需要执行\n5. Idle：可以被无限期延后\n<a name=\"tX5RZ\"></a>\n## fiber 解决的问题/fiber 的背景\n\n- 为了使 react 渲染过程中可以被中断，可以将控制权交还给浏览器，可以让位给高优先级的任务，浏览器空闲后再恢复渲染\n- 对于计算量较大的 js 计算或者 dom 计算，就不会显得特别卡断，而是一帧一帧的有规律的执行任务\n- react 16.x 之前采用的是递归 diff，想要中断递归是很困到难的。为了解决这个问题，我们将大型计算拆分成一个个小型计算，然后按照执行顺序异步调用，这样就不会长时间霸占线程，UI 也能够在两次计算执行的间隙进行更新，从而给用户及时的反馈\n<a name=\"ebu4e\"></a>\n## fiber 的执行流程\n\n1. 用户操作引起 setState 被调用，进而初始化一些数据结构\n2. 根据优先级插入队列相应位置，初始化两个更新的队列\n3. 开始进行任务分片调度，首先更新每个 fiber 的优先级，当 fiber 返回 null 时找到父级节点，然后将所有变化归到 root\n4. 把当前的更新添加到调度任务中，根据当前是否异步渲染，作异步调用\n5. 判断浏览器空闲时，完成下一个分片的工作，如果没有工作完毕，将会放弃\n6. 执行调和阶段和调度阶段\n<a name=\"FiAqV\"></a>\n## fiber 实现原理\n\n- 拆分：把渲染过程拆分成多个小任务\n- 检查：每次执行完一个小任务，就去队列中检查是否有新的响应需要处理\n- 继续执行：如果有就执行优化及更高的响应时间，如果没有则继续执行后续任务\n<a name=\"inxO8\"></a>\n## fiber 的数据结构\nfiber 其实指的是一种数据结构，它可以利用 javaScript 对象来表示：\n```javascript\nconst fiber = {\n\tstateNode, // 节点实例\n  child, // 子节点\n  sibling, // 兄弟节点\n  return, // 父节点\n}\n```\nfiber 是一个链表，有 child 和 sibling 属性，指向第一个子节点和相邻的兄弟节点，从而构成 fiber tree。return 属性指向其父节点\n\n- 更新队列，updateQueue 是一个链表，有 first 和 last 两个属性，指向第一个和最后一个 update 对象\n- 每个 fiber 有一个属性 updateQueue 指向其对应的更新队列\n- 每个 fiber (当前 fiber 可以称为 current)有一个属性 alternate，开始时指向一个自己的 clone 体，update 的变化会线更新到 alternate 上，当更新完毕，alternate 替换 current\n<a name=\"z5p0p\"></a>\n## fiber 的基本规则\n\n- 调和阶段\n\n找出需要更新的工作 (diff fiber tree)，就是一个计算阶段，计算结果可以被缓存，也可被打断\n\n- 交付阶段\n\n提交所有更新并渲染，为了防止页面都懂，不能被打断\n",
  "body_draft": "",
  "body_html": "<!doctype html><p data-lake-id=\"u42bb06ad\"><span class=\"lake-fontsize-12\" style=\"color: #333333;\">在 v16 之前的 React 里，是直接递归遍历 vdom，通过 dom api 增删改 dom 的方式来渲染的。但当 vdom 过大，频繁调用 dom api 会比较耗时，而且递归又不能打断，所以有性能问题。</span></p><p data-lake-id=\"u2cc15424\"><span>​</span><br /></p><h2 id=\"POcFz\"><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647511348804-5a7c26da-9b6f-4357-beb4-affab3126a86.png#clientId=ue2eba416-b7db-4&amp;from=paste&amp;height=444&amp;id=u4805bdbf&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=444&amp;originWidth=1080&amp;originalType=binary&amp;ratio=1&amp;size=121987&amp;status=done&amp;style=none&amp;taskId=uce761c91-3344-4a76-b052-793475e6194&amp;width=1080\" style=\"max-width: 600px; width: 1080px;\" /></h2><p data-lake-id=\"uf31fdc4c\"><span class=\"lake-fontsize-12\" style=\"color: #333333;\">后来就引入了 fiber 架构，先把 vdom 树转成 fiber 链表，然后再渲染 fiber。</span></p><p data-lake-id=\"u94a42680\"><span><br /></span><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647511376273-b755b3ac-be47-4087-8724-a0d7780626e9.png#clientId=ue2eba416-b7db-4&amp;from=paste&amp;height=934&amp;id=u50aa42cc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=934&amp;originWidth=1304&amp;originalType=binary&amp;ratio=1&amp;size=315748&amp;status=done&amp;style=none&amp;taskId=u9c6a7f78-4539-418a-9f7c-3be39bd42d4&amp;width=1304\" style=\"max-width: 600px; width: 1304px;\" /></p><h2 id=\"hkeRd\"><span>概述</span></h2><p data-lake-id=\"u153567ba\"><span>react fiber 是对核心算法的一次重新实现，随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。其中的关键点就是</span><strong><span>同步阻塞</span></strong><span>。在之前的调度算法中，react 需要实例化每个类组件，生成一颗组件树，使用</span><strong><span>同步递归</span></strong><span>的方式进行遍历渲染，而这个过程中最大的问题就是</span><strong><span>无法暂停和恢复</span></strong><span>。</span></p><ul><li><span>在 react 16 将调度算法进行了重构，将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的</span><strong><span>单链表树遍历算法</span></strong><span>。通过指针映射，每个单元都记录着遍历当下的上一步和下一步，从而使遍历变得可以被暂停和重启。</span></li><li><span>可以理解为任务分割调度算法，主要是将以前同步更新渲染的任务分割成一个个独立的小任务，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制</span></li></ul><hr /><h2 id=\"WoocU\"><span>什么是 fiber</span></h2><ul><li><span>fiber 是一种基于浏览器的</span><strong><span>单线程调度算法</span></strong></li><li><span>fiber 是一个执行单元，每次执行完一个执行单元，react 就会检查还剩多少事件，如果没有时间则将控制权转让</span></li></ul><blockquote><p data-lake-id=\"u8645bac4\"><span>利用浏览器的 requestIdleCallback api 实现，其中如果浏览器一直很忙(如：1000 / 60 ~ 16ms 时间间隔内都有任务执行)，则会判断 requestIdleCallback 的 timeout 函数，如果超过 timeout 的值，或者该回调中的任务的优先级较高，则会在下一帧强制执行回调中的任务，避免卡顿现象。</span></p></blockquote><blockquote class=\"lake-alert lake-alert-warning\"><p data-lake-id=\"ub22bdc17\"><span>利用 requestIdleCallback 的回调可以充分的通过利用浏览器空闲时间来解决任务调度问题，由于 requestIdleCallback 的兼容性很差，所以 react 采用了 messageChannel 模拟实现了这一 api 的功能</span></p></blockquote><ul><li><span>fiber 是一种数据结构，react fiber 就是采用链表实现的，每个虚拟 dom 都可以表示为 fiber</span></li><li><span>fiber 实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务</span></li></ul><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"uf5cd4621\"><span>浏览器很忙的时候，如 1000 / 60 ～ 16ms 时间间隔内都有任务执行，则会通过判断 requestIdleCallback 的 timeout </span></p></blockquote><h2 id=\"XfUva\"><span>react 任务的优先级</span></h2><ol><li><span>Immediate：最高优先级，这个优先级的任务应该被马上执行，不能中断</span></li><li><span>UserBlocking：这些任务一般是用户交互的结果，需要即时得到反馈</span></li><li><span>Normal：不需要用户立即就感受到变化，比如网络请求</span></li><li><span>Low：这些任务可以延后，但是最终也需要执行</span></li><li><span>Idle：可以被无限期延后</span></li></ol><h2 id=\"tX5RZ\"><span>fiber 解决的问题/fiber 的背景</span></h2><ul><li><span>为了使 react 渲染过程中可以被中断，可以将控制权交还给浏览器，可以让位给高优先级的任务，浏览器空闲后再恢复渲染</span></li><li><span>对于计算量较大的 js 计算或者 dom 计算，就不会显得特别卡断，而是一帧一帧的有规律的执行任务</span></li><li><span>react 16.x 之前采用的是递归 diff，想要中断递归是很困到难的。为了解决这个问题，我们将大型计算拆分成一个个小型计算，然后按照执行顺序异步调用，这样就不会长时间霸占线程，UI 也能够在两次计算执行的间隙进行更新，从而给用户及时的反馈</span></li></ul><h2 id=\"ebu4e\"><span>fiber 的执行流程</span></h2><ol><li><span>用户操作引起 setState 被调用，进而初始化一些数据结构</span></li><li><span>根据优先级插入队列相应位置，初始化两个更新的队列</span></li><li><span>开始进行任务分片调度，首先更新每个 fiber 的优先级，当 fiber 返回 null 时找到父级节点，然后将所有变化归到 root</span></li><li><span>把当前的更新添加到调度任务中，根据当前是否异步渲染，作异步调用</span></li><li><span>判断浏览器空闲时，完成下一个分片的工作，如果没有工作完毕，将会放弃</span></li><li><span>执行调和阶段和调度阶段</span></li></ol><h2 id=\"FiAqV\"><span>fiber 实现原理</span></h2><ul><li><span>拆分：把渲染过程拆分成多个小任务</span></li><li><span>检查：每次执行完一个小任务，就去队列中检查是否有新的响应需要处理</span></li><li><span>继续执行：如果有就执行优化及更高的响应时间，如果没有则继续执行后续任务</span></li></ul><h2 id=\"inxO8\"><span>fiber 的数据结构</span></h2><p data-lake-id=\"u2ddcc6cf\"><span>fiber 其实指的是一种数据结构，它可以利用 javaScript 对象来表示：</span></p><pre data-lang=\"javascript\"><code>const fiber = {\n\tstateNode, // 节点实例\n  child, // 子节点\n  sibling, // 兄弟节点\n  return, // 父节点\n}</code></pre><p data-lake-id=\"u0c3a126b\"><span>fiber 是一个链表，有 child 和 sibling 属性，指向第一个子节点和相邻的兄弟节点，从而构成 fiber tree。return 属性指向其父节点</span></p><ul><li><span>更新队列，updateQueue 是一个链表，有 first 和 last 两个属性，指向第一个和最后一个 update 对象</span></li><li><span>每个 fiber 有一个属性 updateQueue 指向其对应的更新队列</span></li><li><span>每个 fiber (当前 fiber 可以称为 current)有一个属性 alternate，开始时指向一个自己的 clone 体，update 的变化会线更新到 alternate 上，当更新完毕，alternate 替换 current</span></li></ul><h2 id=\"z5p0p\"><span>fiber 的基本规则</span></h2><ul><li><span>调和阶段</span></li></ul><p data-lake-id=\"u817b1f3a\"><span>找出需要更新的工作 (diff fiber tree)，就是一个计算阶段，计算结果可以被缓存，也可被打断</span></p><ul><li><span>交付阶段</span></li></ul><p data-lake-id=\"u376dd1ab\"><span>提交所有更新并渲染，为了防止页面都懂，不能被打断</span></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u42bb06ad\" id=\"u42bb06ad\"><span data-lake-id=\"u94abed88\" id=\"u94abed88\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">在 v16 之前的 React 里，是直接递归遍历 vdom，通过 dom api 增删改 dom 的方式来渲染的。但当 vdom 过大，频繁调用 dom api 会比较耗时，而且递归又不能打断，所以有性能问题。</span></p><p data-lake-id=\"u2cc15424\" id=\"u2cc15424\"><span data-lake-id=\"u05546bb7\" id=\"u05546bb7\">​</span><br></p><h2 data-lake-id=\"POcFz\" id=\"POcFz\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647511348804-5a7c26da-9b6f-4357-beb4-affab3126a86.png%22%2C%22taskId%22%3A%22uce761c91-3344-4a76-b052-793475e6194%22%2C%22clientId%22%3A%22ue2eba416-b7db-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A1080%2C%22height%22%3A444%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A121987%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A1080%2C%22originHeight%22%3A444%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22UL%20CHIDREN%20RENDER(%E5%A2%9E%E5%88%A0%E6%94%B9%20DOM)%20DOM%20%5C%22QQ%2C%20%5C%22AA%5C%22%20%5C%22CC%5C%22%20PATCH(DIFF%2B%E5%A2%9E%E5%88%A0%E6%94%B9DOM)%20%2CXXXX%5C%22%20%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E5%8C%BA%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A356.5951%2C%22y%22%3A58.995102%2C%22width%22%3A33.64474000000001%2C%22height%22%3A23.211417999999995%2C%22text%22%3A%22UL%22%7D%2C%7B%22x%22%3A348.50085%2C%22y%22%3A116.532425%2C%22width%22%3A76.27548999999999%2C%22height%22%3A20.715985000000003%2C%22text%22%3A%22CHIDREN%22%7D%2C%7B%22x%22%3A697.7649%2C%22y%22%3A185.34525%2C%22width%22%3A195.85749999999996%2C%22height%22%3A22.706260000000015%2C%22text%22%3A%22RENDER(%E5%A2%9E%E5%88%A0%E6%94%B9%20DOM)%22%7D%2C%7B%22x%22%3A952.81055%2C%22y%22%3A222.70659%2C%22width%22%3A58.835249999999974%2C%22height%22%3A21.805970000000002%2C%22text%22%3A%22DOM%22%7D%2C%7B%22x%22%3A288.64548%2C%22y%22%3A289.15768%2C%22width%22%3A66.81359999999995%2C%22height%22%3A27.64883999999995%2C%22text%22%3A%22%5C%22QQ%2C%22%7D%2C%7B%22x%22%3A137.14189%2C%22y%22%3A290.51852%2C%22width%22%3A54.42273%2C%22height%22%3A23.252079999999978%2C%22text%22%3A%22%5C%22AA%5C%22%22%7D%2C%7B%22x%22%3A557.83374%2C%22y%22%3A289.92535%2C%22width%22%3A56.17151000000001%2C%22height%22%3A25.628150000000005%2C%22text%22%3A%22%5C%22CC%5C%22%22%7D%2C%7B%22x%22%3A682.16473%2C%22y%22%3A289.7252%2C%22width%22%3A246.37667%2C%22height%22%3A28.289170000000013%2C%22text%22%3A%22PATCH(DIFF%2B%E5%A2%9E%E5%88%A0%E6%94%B9DOM)%22%7D%2C%7B%22x%22%3A417.50238%2C%22y%22%3A378.3842%2C%22width%22%3A63.698699999999974%2C%22height%22%3A23.66874999999999%2C%22text%22%3A%22%2CXXXX%5C%22%22%7D%2C%7B%22x%22%3A921.2231%2C%22y%22%3A407.93622%2C%22width%22%3A148.08879999999988%2C%22height%22%3A23.966880000000003%2C%22text%22%3A%22%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E5%8C%BA%22%7D%5D%2C%22id%22%3A%22u4805bdbf%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></h2><p data-lake-id=\"uf31fdc4c\" id=\"uf31fdc4c\"><span data-lake-id=\"u590927f0\" id=\"u590927f0\" class=\"lake-fontsize-12\" style=\"color: rgb(51, 51, 51)\">后来就引入了 fiber 架构，先把 vdom 树转成 fiber 链表，然后再渲染 fiber。</span></p><p data-lake-id=\"u94a42680\" id=\"u94a42680\"><span data-lake-id=\"u14ab5a0f\" id=\"u14ab5a0f\"><br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647511376273-b755b3ac-be47-4087-8724-a0d7780626e9.png%22%2C%22taskId%22%3A%22u9c6a7f78-4539-418a-9f7c-3be39bd42d4%22%2C%22clientId%22%3A%22ue2eba416-b7db-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A1304%2C%22height%22%3A934%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A315748%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A1304%2C%22originHeight%22%3A934%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22UL%20CHIDREN%20%5C%22AA%5C%22%20%5C%22QQ%2C%20'CC%5C%22%20*XXX%2C%2C%20RECONCILE(YDOM%20%E8%BD%ACFIBER%2C%E7%A1%AE%E5%AE%9A%E5%A2%9E%2F%E5%88%A0%2F%E6%94%B9%2B%E5%88%9B%E5%BB%BA%E7%94%A8%E5%88%B0%E7%9A%84DOM)%20(%E7%A9%BA%E9%97%B2%E6%97%B6%20RECONCILE%20%E5%90%8E%E9%9D%A2%E7%9A%84%20FIBER)%20SCHEDULE%20UL%20%E4%B8%87%E4%B8%AA%20CHILD%20RETURN%20RETURN%20RETURN%20SIBLING%20SIBLING%20COMMIT(%E5%A2%9E%E5%88%A0%E6%94%B9%20DOM)%20LI%20DOM%20RETURN%20CHILD%20CHILD%20CHILD%20%2FSIBLING%20%5C%22CC%5C%22%20'BB%2C%20%5C%22AA%5C%22%5C%22%20RETURN%20CHILD%20%5C%22XXX%2C%20%40%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A515.71075%2C%22y%22%3A68.80363%2C%22width%22%3A37.93940000000009%2C%22height%22%3A26.800020000000004%2C%22text%22%3A%22UL%22%7D%2C%7B%22x%22%3A509.1082%2C%22y%22%3A128.4202%2C%22width%22%3A77.89156000000003%2C%22height%22%3A21.531380000000013%2C%22text%22%3A%22CHIDREN%22%7D%2C%7B%22x%22%3A293.9226%2C%22y%22%3A305.5344%2C%22width%22%3A56.167370000000005%2C%22height%22%3A24.888239999999996%2C%22text%22%3A%22%5C%22AA%5C%22%22%7D%2C%7B%22x%22%3A450.53915%2C%22y%22%3A306.08826%2C%22width%22%3A60.121849999999995%2C%22height%22%3A24.74920000000003%2C%22text%22%3A%22%5C%22QQ%2C%22%7D%2C%7B%22x%22%3A723.8078%2C%22y%22%3A307.08142%2C%22width%22%3A54.816299999999956%2C%22height%22%3A24.562929999999994%2C%22text%22%3A%22'CC%5C%22%22%7D%2C%7B%22x%22%3A579.68756%2C%22y%22%3A396.72818%2C%22width%22%3A65.68774000000008%2C%22height%22%3A21.693569999999966%2C%22text%22%3A%22*XXX%2C%2C%22%7D%2C%7B%22x%22%3A552.1738%2C%22y%22%3A472.73984%2C%22width%22%3A574.1403%2C%22height%22%3A22.98870999999997%2C%22text%22%3A%22RECONCILE(YDOM%20%E8%BD%ACFIBER%2C%E7%A1%AE%E5%AE%9A%E5%A2%9E%2F%E5%88%A0%2F%E6%94%B9%2B%E5%88%9B%E5%BB%BA%E7%94%A8%E5%88%B0%E7%9A%84DOM)%22%7D%2C%7B%22x%22%3A107.85752%2C%22y%22%3A520.3903%2C%22width%22%3A299.50897999999995%2C%22height%22%3A22.353169999999977%2C%22text%22%3A%22(%E7%A9%BA%E9%97%B2%E6%97%B6%20RECONCILE%20%E5%90%8E%E9%9D%A2%E7%9A%84%20FIBER)%22%7D%2C%7B%22x%22%3A1.2310154%2C%22y%22%3A523.8229%2C%22width%22%3A94.06539459999999%2C%22height%22%3A19.985199999999963%2C%22text%22%3A%22SCHEDULE%22%7D%2C%7B%22x%22%3A519.3417%2C%22y%22%3A553.7199%2C%22width%22%3A39.950000000000045%2C%22height%22%3A24.112999999999943%2C%22text%22%3A%22UL%22%7D%2C%7B%22x%22%3A515.89777%2C%22y%22%3A594.57605%2C%22width%22%3A42.64946999999995%2C%22height%22%3A22.450680000000034%2C%22text%22%3A%22%E4%B8%87%E4%B8%AA%22%7D%2C%7B%22x%22%3A388.3053%2C%22y%22%3A600.55975%2C%22width%22%3A47.088900000000024%2C%22height%22%3A19.202210000000036%2C%22text%22%3A%22CHILD%22%7D%2C%7B%22x%22%3A630.0855%2C%22y%22%3A604.57574%2C%22width%22%3A56.90985999999998%2C%22height%22%3A16.660060000000044%2C%22text%22%3A%22RETURN%22%7D%2C%7B%22x%22%3A456.83057%2C%22y%22%3A621.0657%2C%22width%22%3A137.17452999999995%2C%22height%22%3A21.297000000000025%2C%22text%22%3A%22RETURN%20RETURN%22%7D%2C%7B%22x%22%3A404.34875%2C%22y%22%3A664.9062%2C%22width%22%3A64.18200999999999%2C%22height%22%3A19.061399999999935%2C%22text%22%3A%22SIBLING%22%7D%2C%7B%22x%22%3A605.43866%2C%22y%22%3A667.04364%2C%22width%22%3A64.04529000000002%2C%22height%22%3A19.89661000000001%2C%22text%22%3A%22SIBLING%22%7D%2C%7B%22x%22%3A843.1747%2C%22y%22%3A680.35284%2C%22width%22%3A210.52070000000003%2C%22height%22%3A23.718259999999987%2C%22text%22%3A%22COMMIT(%E5%A2%9E%E5%88%A0%E6%94%B9%20DOM)%22%7D%2C%7B%22x%22%3A526.0118%2C%22y%22%3A680.51215%2C%22width%22%3A26.51694999999995%2C%22height%22%3A28.13945000000001%2C%22text%22%3A%22LI%22%7D%2C%7B%22x%22%3A1123.7411%2C%22y%22%3A725.6355%2C%22width%22%3A63.118400000000065%2C%22height%22%3A22.81370000000004%2C%22text%22%3A%22DOM%22%7D%2C%7B%22x%22%3A592.7129%2C%22y%22%3A727.61%2C%22width%22%3A58.16890000000001%2C%22height%22%3A17.11119999999994%2C%22text%22%3A%22RETURN%22%7D%2C%7B%22x%22%3A679.4594%2C%22y%22%3A730.46356%2C%22width%22%3A44.57940000000008%2C%22height%22%3A18.768799999999942%2C%22text%22%3A%22CHILD%22%7D%2C%7B%22x%22%3A455.81555%2C%22y%22%3A730.9083%2C%22width%22%3A47.27759000000003%2C%22height%22%3A22.264699999999948%2C%22text%22%3A%22CHILD%22%7D%2C%7B%22x%22%3A265.7777%2C%22y%22%3A739.4252%2C%22width%22%3A46.27568000000002%2C%22height%22%3A17.099199999999996%2C%22text%22%3A%22CHILD%22%7D%2C%7B%22x%22%3A508.89133%2C%22y%22%3A758.7117%2C%22width%22%3A65.52461999999997%2C%22height%22%3A18.53460000000007%2C%22text%22%3A%22%2FSIBLING%22%7D%2C%7B%22x%22%3A721.5501%2C%22y%22%3A786.8192%2C%22width%22%3A58.480050000000006%2C%22height%22%3A24.47289999999998%2C%22text%22%3A%22%5C%22CC%5C%22%22%7D%2C%7B%22x%22%3A454.51477%2C%22y%22%3A787.7881%2C%22width%22%3A56.11041%2C%22height%22%3A23.210860000000025%2C%22text%22%3A%22'BB%2C%22%7D%2C%7B%22x%22%3A299.84433%2C%22y%22%3A790.3126%2C%22width%22%3A51.21691999999996%2C%22height%22%3A22.484300000000076%2C%22text%22%3A%22%5C%22AA%5C%22%5C%22%22%7D%2C%7B%22x%22%3A643.9869%2C%22y%22%3A827.5173%2C%22width%22%3A58.302099999999996%2C%22height%22%3A17.060600000000022%2C%22text%22%3A%22RETURN%22%7D%2C%7B%22x%22%3A539.79584%2C%22y%22%3A835.6516%2C%22width%22%3A48.94439%2C%22height%22%3A18.76843999999994%2C%22text%22%3A%22CHILD%22%7D%2C%7B%22x%22%3A578.9624%2C%22y%22%3A874.202%2C%22width%22%3A72.9248%2C%22height%22%3A28.711599999999976%2C%22text%22%3A%22%5C%22XXX%2C%22%7D%2C%7B%22x%22%3A1117.6687%2C%22y%22%3A888.82996%2C%22width%22%3A164.81349999999998%2C%22height%22%3A21.005980000000022%2C%22text%22%3A%22%40%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%7D%5D%2C%22id%22%3A%22u50aa42cc%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h2 data-lake-id=\"hkeRd\" id=\"hkeRd\"><span data-lake-id=\"ue1e0e381\" id=\"ue1e0e381\">概述</span></h2><p data-lake-id=\"u153567ba\" id=\"u153567ba\"><span data-lake-id=\"u42935a13\" id=\"u42935a13\">react fiber 是对核心算法的一次重新实现，随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。其中的关键点就是</span><strong><span data-lake-id=\"u720c93a9\" id=\"u720c93a9\">同步阻塞</span></strong><span data-lake-id=\"ud4515d89\" id=\"ud4515d89\">。在之前的调度算法中，react 需要实例化每个类组件，生成一颗组件树，使用</span><strong><span data-lake-id=\"u17093f8f\" id=\"u17093f8f\">同步递归</span></strong><span data-lake-id=\"ue64f39cc\" id=\"ue64f39cc\">的方式进行遍历渲染，而这个过程中最大的问题就是</span><strong><span data-lake-id=\"u1373f2dc\" id=\"u1373f2dc\">无法暂停和恢复</span></strong><span data-lake-id=\"uca4c6894\" id=\"uca4c6894\">。</span></p><ul list=\"uaf778384\"><li fid=\"u746b5e06\" data-lake-id=\"u23b60818\" id=\"u23b60818\"><span data-lake-id=\"udf371c52\" id=\"udf371c52\">在 react 16 将调度算法进行了重构，将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的</span><strong><span data-lake-id=\"uab097757\" id=\"uab097757\">单链表树遍历算法</span></strong><span data-lake-id=\"uf7a46f85\" id=\"uf7a46f85\">。通过指针映射，每个单元都记录着遍历当下的上一步和下一步，从而使遍历变得可以被暂停和重启。</span></li><li fid=\"u746b5e06\" data-lake-id=\"ufe676b2e\" id=\"ufe676b2e\"><span data-lake-id=\"u623b503b\" id=\"u623b503b\">可以理解为任务分割调度算法，主要是将以前同步更新渲染的任务分割成一个个独立的小任务，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制</span></li></ul><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22sJXkI%22%7D\"></card><h2 data-lake-id=\"WoocU\" id=\"WoocU\"><span data-lake-id=\"ud29f5f37\" id=\"ud29f5f37\">什么是 fiber</span></h2><ul list=\"uc1b02963\"><li fid=\"u85d751b7\" data-lake-id=\"ufcef4733\" id=\"ufcef4733\"><span data-lake-id=\"ub42584de\" id=\"ub42584de\">fiber 是一种基于浏览器的</span><strong><span data-lake-id=\"uca318100\" id=\"uca318100\">单线程调度算法</span></strong></li><li fid=\"u85d751b7\" data-lake-id=\"u3bd9a6e5\" id=\"u3bd9a6e5\"><span data-lake-id=\"u1aa2f8fd\" id=\"u1aa2f8fd\">fiber 是一个执行单元，每次执行完一个执行单元，react 就会检查还剩多少事件，如果没有时间则将控制权转让</span></li></ul><blockquote data-lake-id=\"u37e11b36\" id=\"u37e11b36\"><p data-lake-id=\"u8645bac4\" id=\"u8645bac4\"><span data-lake-id=\"ufaeee3f3\" id=\"ufaeee3f3\">利用浏览器的 requestIdleCallback api 实现，其中如果浏览器一直很忙(如：1000 / 60 ~ 16ms 时间间隔内都有任务执行)，则会判断 requestIdleCallback 的 timeout 函数，如果超过 timeout 的值，或者该回调中的任务的优先级较高，则会在下一帧强制执行回调中的任务，避免卡顿现象。</span></p></blockquote><blockquote data-lake-id=\"ue0d99b3b\" id=\"ue0d99b3b\" class=\"lake-alert lake-alert-warning\"><p data-lake-id=\"ub22bdc17\" id=\"ub22bdc17\"><span data-lake-id=\"u6ed26c40\" id=\"u6ed26c40\">利用 requestIdleCallback 的回调可以充分的通过利用浏览器空闲时间来解决任务调度问题，由于 requestIdleCallback 的兼容性很差，所以 react 采用了 messageChannel 模拟实现了这一 api 的功能</span></p></blockquote><ul list=\"ucf815431\"><li fid=\"u5378b3fa\" data-lake-id=\"u2d0abd9e\" id=\"u2d0abd9e\"><span data-lake-id=\"u5227a816\" id=\"u5227a816\">fiber 是一种数据结构，react fiber 就是采用链表实现的，每个虚拟 dom 都可以表示为 fiber</span></li><li fid=\"u5378b3fa\" data-lake-id=\"u84b567e0\" id=\"u84b567e0\"><span data-lake-id=\"u5623dc3f\" id=\"u5623dc3f\">fiber 实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务</span></li></ul><blockquote data-lake-id=\"u7b4ad6b8\" id=\"u7b4ad6b8\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"uf5cd4621\" id=\"uf5cd4621\"><span data-lake-id=\"u11086669\" id=\"u11086669\">浏览器很忙的时候，如 1000 / 60 ～ 16ms 时间间隔内都有任务执行，则会通过判断 requestIdleCallback 的 timeout </span></p></blockquote><h2 data-lake-id=\"XfUva\" id=\"XfUva\"><span data-lake-id=\"u5566f90b\" id=\"u5566f90b\">react 任务的优先级</span></h2><ol list=\"u7a80622e\"><li fid=\"u4916304a\" data-lake-id=\"u5bad8581\" id=\"u5bad8581\"><span data-lake-id=\"uc20a5bea\" id=\"uc20a5bea\">Immediate：最高优先级，这个优先级的任务应该被马上执行，不能中断</span></li><li fid=\"u4916304a\" data-lake-id=\"u79951b68\" id=\"u79951b68\"><span data-lake-id=\"u9b24375c\" id=\"u9b24375c\">UserBlocking：这些任务一般是用户交互的结果，需要即时得到反馈</span></li><li fid=\"u4916304a\" data-lake-id=\"uf68df4ba\" id=\"uf68df4ba\"><span data-lake-id=\"udbe213b4\" id=\"udbe213b4\">Normal：不需要用户立即就感受到变化，比如网络请求</span></li><li fid=\"u4916304a\" data-lake-id=\"u79548f81\" id=\"u79548f81\"><span data-lake-id=\"u2b5bc7d1\" id=\"u2b5bc7d1\">Low：这些任务可以延后，但是最终也需要执行</span></li><li fid=\"u4916304a\" data-lake-id=\"u28c316b9\" id=\"u28c316b9\"><span data-lake-id=\"ub7ac8271\" id=\"ub7ac8271\">Idle：可以被无限期延后</span></li></ol><h2 data-lake-id=\"tX5RZ\" id=\"tX5RZ\"><span data-lake-id=\"u2201ccea\" id=\"u2201ccea\">fiber 解决的问题/fiber 的背景</span></h2><ul list=\"u82d8bb89\"><li fid=\"u4026b117\" data-lake-id=\"u57629b0f\" id=\"u57629b0f\"><span data-lake-id=\"u3e3df491\" id=\"u3e3df491\">为了使 react 渲染过程中可以被中断，可以将控制权交还给浏览器，可以让位给高优先级的任务，浏览器空闲后再恢复渲染</span></li><li fid=\"u4026b117\" data-lake-id=\"u044afb21\" id=\"u044afb21\"><span data-lake-id=\"uf69d9a59\" id=\"uf69d9a59\">对于计算量较大的 js 计算或者 dom 计算，就不会显得特别卡断，而是一帧一帧的有规律的执行任务</span></li><li fid=\"u4026b117\" data-lake-id=\"u58be9ed2\" id=\"u58be9ed2\"><span data-lake-id=\"ua96e5d0f\" id=\"ua96e5d0f\">react 16.x 之前采用的是递归 diff，想要中断递归是很困到难的。为了解决这个问题，我们将大型计算拆分成一个个小型计算，然后按照执行顺序异步调用，这样就不会长时间霸占线程，UI 也能够在两次计算执行的间隙进行更新，从而给用户及时的反馈</span></li></ul><h2 data-lake-id=\"ebu4e\" id=\"ebu4e\"><span data-lake-id=\"u86f0943e\" id=\"u86f0943e\">fiber 的执行流程</span></h2><ol list=\"u39447b14\"><li fid=\"u133bd232\" data-lake-id=\"uf22c6965\" id=\"uf22c6965\"><span data-lake-id=\"u12653621\" id=\"u12653621\">用户操作引起 setState 被调用，进而初始化一些数据结构</span></li><li fid=\"u133bd232\" data-lake-id=\"u86364a1f\" id=\"u86364a1f\"><span data-lake-id=\"u530d587d\" id=\"u530d587d\">根据优先级插入队列相应位置，初始化两个更新的队列</span></li><li fid=\"u133bd232\" data-lake-id=\"ufc135b2d\" id=\"ufc135b2d\"><span data-lake-id=\"uf743a658\" id=\"uf743a658\">开始进行任务分片调度，首先更新每个 fiber 的优先级，当 fiber 返回 null 时找到父级节点，然后将所有变化归到 root</span></li><li fid=\"u133bd232\" data-lake-id=\"u7f10f3b1\" id=\"u7f10f3b1\"><span data-lake-id=\"uf3acb5e9\" id=\"uf3acb5e9\">把当前的更新添加到调度任务中，根据当前是否异步渲染，作异步调用</span></li><li fid=\"u133bd232\" data-lake-id=\"u83255d2d\" id=\"u83255d2d\"><span data-lake-id=\"u8f28fea7\" id=\"u8f28fea7\">判断浏览器空闲时，完成下一个分片的工作，如果没有工作完毕，将会放弃</span></li><li fid=\"u133bd232\" data-lake-id=\"u078c4e9e\" id=\"u078c4e9e\"><span data-lake-id=\"u41051062\" id=\"u41051062\">执行调和阶段和调度阶段</span></li></ol><h2 data-lake-id=\"FiAqV\" id=\"FiAqV\"><span data-lake-id=\"u5c484671\" id=\"u5c484671\">fiber 实现原理</span></h2><ul list=\"u204f857a\"><li fid=\"u6927f360\" data-lake-id=\"uff16bbe5\" id=\"uff16bbe5\"><span data-lake-id=\"u1b76bfef\" id=\"u1b76bfef\">拆分：把渲染过程拆分成多个小任务</span></li><li fid=\"u6927f360\" data-lake-id=\"u9221642b\" id=\"u9221642b\"><span data-lake-id=\"u2cc036b5\" id=\"u2cc036b5\">检查：每次执行完一个小任务，就去队列中检查是否有新的响应需要处理</span></li><li fid=\"u6927f360\" data-lake-id=\"u207d1b65\" id=\"u207d1b65\"><span data-lake-id=\"ub1b70ec4\" id=\"ub1b70ec4\">继续执行：如果有就执行优化及更高的响应时间，如果没有则继续执行后续任务</span></li></ul><h2 data-lake-id=\"inxO8\" id=\"inxO8\"><span data-lake-id=\"u0028a4dd\" id=\"u0028a4dd\">fiber 的数据结构</span></h2><p data-lake-id=\"u2ddcc6cf\" id=\"u2ddcc6cf\"><span data-lake-id=\"uae4a4835\" id=\"uae4a4835\">fiber 其实指的是一种数据结构，它可以利用 javaScript 对象来表示：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20fiber%20%3D%20%7B%5Cn%5CtstateNode%2C%20%2F%2F%20%E8%8A%82%E7%82%B9%E5%AE%9E%E4%BE%8B%5Cn%20%20child%2C%20%2F%2F%20%E5%AD%90%E8%8A%82%E7%82%B9%5Cn%20%20sibling%2C%20%2F%2F%20%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%5Cn%20%20return%2C%20%2F%2F%20%E7%88%B6%E8%8A%82%E7%82%B9%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22Pt9c2%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u0c3a126b\" id=\"u0c3a126b\"><span data-lake-id=\"u826f547a\" id=\"u826f547a\">fiber 是一个链表，有 child 和 sibling 属性，指向第一个子节点和相邻的兄弟节点，从而构成 fiber tree。return 属性指向其父节点</span></p><ul list=\"uc0537651\"><li fid=\"uf971a03d\" data-lake-id=\"u7ad8192f\" id=\"u7ad8192f\"><span data-lake-id=\"u566cf10a\" id=\"u566cf10a\">更新队列，updateQueue 是一个链表，有 first 和 last 两个属性，指向第一个和最后一个 update 对象</span></li><li fid=\"uf971a03d\" data-lake-id=\"u6ccf9e63\" id=\"u6ccf9e63\"><span data-lake-id=\"ue1495879\" id=\"ue1495879\">每个 fiber 有一个属性 updateQueue 指向其对应的更新队列</span></li><li fid=\"uf971a03d\" data-lake-id=\"ua306c77e\" id=\"ua306c77e\"><span data-lake-id=\"u1bcba153\" id=\"u1bcba153\">每个 fiber (当前 fiber 可以称为 current)有一个属性 alternate，开始时指向一个自己的 clone 体，update 的变化会线更新到 alternate 上，当更新完毕，alternate 替换 current</span></li></ul><h2 data-lake-id=\"z5p0p\" id=\"z5p0p\"><span data-lake-id=\"ub4cb62bd\" id=\"ub4cb62bd\">fiber 的基本规则</span></h2><ul list=\"ua66f1166\"><li fid=\"udff1cc04\" data-lake-id=\"ufa460b70\" id=\"ufa460b70\"><span data-lake-id=\"u0758a78d\" id=\"u0758a78d\">调和阶段</span></li></ul><p data-lake-id=\"u817b1f3a\" id=\"u817b1f3a\"><span data-lake-id=\"u39048727\" id=\"u39048727\">找出需要更新的工作 (diff fiber tree)，就是一个计算阶段，计算结果可以被缓存，也可被打断</span></p><ul list=\"ua66f1166\" start=\"2\"><li fid=\"udff1cc04\" data-lake-id=\"u14352450\" id=\"u14352450\"><span data-lake-id=\"u0090ea64\" id=\"u0090ea64\">交付阶段</span></li></ul><p data-lake-id=\"u376dd1ab\" id=\"u376dd1ab\"><span data-lake-id=\"u0dcad710\" id=\"u0dcad710\">提交所有更新并渲染，为了防止页面都懂，不能被打断</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:32:46.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:46.000Z",
  "updated_at": "2022-05-10T15:12:42.000Z",
  "published_at": "2022-04-04T11:32:46.000Z",
  "first_published_at": "2022-04-04T11:32:45.538Z",
  "word_count": 1652,
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1647511348804-5a7c26da-9b6f-4357-beb4-affab3126a86.png",
  "description": "在 v16 之前的 React 里，是直接递归遍历 vdom，通过 dom api 增删改 dom 的方式来渲染的。但当 vdom 过大，频繁调用 dom api 会比较耗时，而且递归又不能打断，所以有性能问题。后来就引入了 fiber 架构，先把 vdom 树转成 fiber 链表，然后再渲...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}