{
  "id": 72212247,
  "slug": "vc6k8l",
  "title": "promise",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": ":::info\n**基本过程：**\n\n1. 初始化 Promise 状态（pending）\n2. 立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理\n3. 执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）\n4. Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。\n:::\n<a name=\"EUl0K\"></a>\n### Promise 中的 then、catch、finally\n\n- promise 必须为：等待态 Pending、执行态 Fulfilled 和拒绝态 Rejected 中的一种，一旦 promise 转台发生改变，将不能够再迁移到其他任何状态(即：状态 immutable)\n- .then 和 .catch 都会返回一个新的 Promise\n- catch 无论被连接到哪里，都能够捕获上层的错误\n- 在 promise 中，返回任意一个非 promise 的值都会被包裹成 promise 对象\n- promise 的 .then 或 .catch 可以被调用多次，当 promise 内部的状态一经改变，并且有了一个值，那么后续每次调用 .then 或 .catch 时都会直接拿到该值\n- .then 或 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获\n- .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环\n- .then 或 .catch 的参数期望是函数，传入非函数则会发生值穿透\n- .then 方法可以接受两个参数，第一个是处理成功的函数，第二个是处理失败的函数，在某些时候可以认为 catch 是 .then 第二个参数的简便写法\n- .finally 方法也会返回一个 promise，它在 promise 结束的时候，无论结果为 resolved 还是 rejected，都会执行里面的回调函数\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><div data-type=\"info\" class=\"ne-alert\"><p id=\"u0fbdb884\" class=\"ne-p\"><strong><span class=\"ne-text\">基本过程：</span></strong></p><ol class=\"ne-ol\"><li id=\"u20cdbf58\"><span class=\"ne-text\">初始化 Promise 状态（pending）</span></li><li id=\"u845b8cbd\"><span class=\"ne-text\">立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</span></li><li id=\"ufab86ed3\"><span class=\"ne-text\">执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</span></li><li id=\"u870515d1\"><span class=\"ne-text\">Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</span></li></ol></div><h3 id=\"EUl0K\"><span class=\"ne-text\">Promise 中的 then、catch、finally</span></h3><ul class=\"ne-ul\"><li id=\"u3a0f87c9\"><span class=\"ne-text\">promise 必须为：等待态 Pending、执行态 Fulfilled 和拒绝态 Rejected 中的一种，一旦 promise 转台发生改变，将不能够再迁移到其他任何状态(即：状态 immutable)</span></li><li id=\"ua99bf8f7\"><span class=\"ne-text\">.then 和 .catch 都会返回一个新的 Promise</span></li><li id=\"u97873b18\"><span class=\"ne-text\">catch 无论被连接到哪里，都能够捕获上层的错误</span></li><li id=\"ue8a41c41\"><span class=\"ne-text\">在 promise 中，返回任意一个非 promise 的值都会被包裹成 promise 对象</span></li><li id=\"u7de6cb1a\"><span class=\"ne-text\">promise 的 .then 或 .catch 可以被调用多次，当 promise 内部的状态一经改变，并且有了一个值，那么后续每次调用 .then 或 .catch 时都会直接拿到该值</span></li><li id=\"u5bf605ae\"><span class=\"ne-text\">.then 或 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获</span></li><li id=\"ub0efa458\"><span class=\"ne-text\">.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环</span></li><li id=\"u4abfdb85\"><span class=\"ne-text\">.then 或 .catch 的参数期望是函数，传入非函数则会发生值穿透</span></li><li id=\"u839fad5d\"><span class=\"ne-text\">.then 方法可以接受两个参数，第一个是处理成功的函数，第二个是处理失败的函数，在某些时候可以认为 catch 是 .then 第二个参数的简便写法</span></li><li id=\"ufb1e4cda\"><span class=\"ne-text\">.finally 方法也会返回一个 promise，它在 promise 结束的时候，无论结果为 resolved 还是 rejected，都会执行里面的回调函数</span></li></ul></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><blockquote data-lake-id=\"uc2447e0a\" id=\"uc2447e0a\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u0fbdb884\" id=\"u0fbdb884\"><strong><span data-lake-id=\"uf2df4722\" id=\"uf2df4722\">基本过程：</span></strong></p><ol list=\"u63ff93c6\"><li fid=\"u00023e7d\" data-lake-id=\"u20cdbf58\" id=\"u20cdbf58\"><span data-lake-id=\"u7c20af74\" id=\"u7c20af74\">初始化 Promise 状态（pending）</span></li><li fid=\"u00023e7d\" data-lake-id=\"u845b8cbd\" id=\"u845b8cbd\"><span data-lake-id=\"ud4682a85\" id=\"ud4682a85\">立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</span></li><li fid=\"u00023e7d\" data-lake-id=\"ufab86ed3\" id=\"ufab86ed3\"><span data-lake-id=\"ucff22ade\" id=\"ucff22ade\">执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</span></li><li fid=\"u00023e7d\" data-lake-id=\"u870515d1\" id=\"u870515d1\"><span data-lake-id=\"ue14be9eb\" id=\"ue14be9eb\">Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</span></li></ol></blockquote><h3 data-lake-id=\"EUl0K\" id=\"EUl0K\"><span data-lake-id=\"ue6c63f2f\" id=\"ue6c63f2f\">Promise 中的 then、catch、finally</span></h3><ul list=\"u9ac0d508\"><li fid=\"u4b333cc6\" data-lake-id=\"u3a0f87c9\" id=\"u3a0f87c9\"><span data-lake-id=\"ubb858022\" id=\"ubb858022\">promise 必须为：等待态 Pending、执行态 Fulfilled 和拒绝态 Rejected 中的一种，一旦 promise 转台发生改变，将不能够再迁移到其他任何状态(即：状态 immutable)</span></li><li fid=\"u4b333cc6\" data-lake-id=\"ua99bf8f7\" id=\"ua99bf8f7\"><span data-lake-id=\"u38738e4b\" id=\"u38738e4b\">.then 和 .catch 都会返回一个新的 Promise</span></li><li fid=\"u4b333cc6\" data-lake-id=\"u97873b18\" id=\"u97873b18\"><span data-lake-id=\"u6fd96c9d\" id=\"u6fd96c9d\">catch 无论被连接到哪里，都能够捕获上层的错误</span></li><li fid=\"u4b333cc6\" data-lake-id=\"ue8a41c41\" id=\"ue8a41c41\"><span data-lake-id=\"uc98b8b69\" id=\"uc98b8b69\">在 promise 中，返回任意一个非 promise 的值都会被包裹成 promise 对象</span></li><li fid=\"u4b333cc6\" data-lake-id=\"u7de6cb1a\" id=\"u7de6cb1a\"><span data-lake-id=\"u9e41fc69\" id=\"u9e41fc69\">promise 的 .then 或 .catch 可以被调用多次，当 promise 内部的状态一经改变，并且有了一个值，那么后续每次调用 .then 或 .catch 时都会直接拿到该值</span></li><li fid=\"u4b333cc6\" data-lake-id=\"u5bf605ae\" id=\"u5bf605ae\"><span data-lake-id=\"uaf68d703\" id=\"uaf68d703\">.then 或 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获</span></li><li fid=\"u4b333cc6\" data-lake-id=\"ub0efa458\" id=\"ub0efa458\"><span data-lake-id=\"u84852436\" id=\"u84852436\">.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环</span></li><li fid=\"u4b333cc6\" data-lake-id=\"u4abfdb85\" id=\"u4abfdb85\"><span data-lake-id=\"u2d905911\" id=\"u2d905911\">.then 或 .catch 的参数期望是函数，传入非函数则会发生值穿透</span></li><li fid=\"u4b333cc6\" data-lake-id=\"u839fad5d\" id=\"u839fad5d\"><span data-lake-id=\"u7daa9d41\" id=\"u7daa9d41\">.then 方法可以接受两个参数，第一个是处理成功的函数，第二个是处理失败的函数，在某些时候可以认为 catch 是 .then 第二个参数的简便写法</span></li><li fid=\"u4b333cc6\" data-lake-id=\"ufb1e4cda\" id=\"ufb1e4cda\"><span data-lake-id=\"u08e0726e\" id=\"u08e0726e\">.finally 方法也会返回一个 promise，它在 promise 结束的时候，无论结果为 resolved 还是 rejected，都会执行里面的回调函数</span></li></ul>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-24T11:12:02.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:50.000Z",
  "updated_at": "2022-04-24T11:12:02.000Z",
  "published_at": "2022-04-24T11:12:02.000Z",
  "first_published_at": "2022-04-04T11:33:49.999Z",
  "word_count": 474,
  "cover": null,
  "description": "基本过程：初始化 Promise 状态（pending）立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}