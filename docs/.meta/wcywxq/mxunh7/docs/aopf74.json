{
  "id": 72212215,
  "slug": "aopf74",
  "title": "props 相关问题",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"rialk\"></a>\n## state 和 props 有什么区别\n- props\n\nprops 是一个从外部传进组件的参数，主要作用就是从父组件向子组件传递数据，它具有可读性和不可变性，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。\n\n- state\n\nstate 的主要作用是用于组件保存、控制以及修改自己的状态，它只能在 constructor 中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的 this.setState 来修改，修改 state 属性会导致组件的重新渲染。\n:::info\n区别：\n\n1. props 是传递给组件的(类似于函数的形参)，而 state 是在组件内被组件自己管理的(类似于在一个函数内声明的变量)。\n2. props 是不可修改的，所有 react 组件都必须像纯函数一样保护它们的 props 不被更改。\n3. state 是在组件中创建的，一般在 constructor 中初始化 state。state 是对变的、可以修改，每次 setState 都是异步更新的。\n:::\n<a name=\"SuDHN\"></a>\n## props 为什么是只读的\nthis.props 是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。<br />提到函数式编程就要提一个概念：纯函数。它有几个特点：\n\n- 给定相同的输入，总是返回相同的输出。\n- 过程没有副作用。\n- 不依赖外部状态。\n\nthis.props 就是汲取了纯函数的思想。props 的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用\n<a name=\"uZjWx\"></a>\n## props 改变时更新组件的方法有哪些\n在一个组件传入的 props 更新时重新渲染该组件常用的方法是在 componentWillReceiveProps 中将新的 props 更新到组件的state 中(这种state被成为派生状态（Derived State）)，从而实现重新渲染。React 16.3 中还引入了一个新的钩子函数getDerivedStateFromProps 来专门实现这一需求。\n\n- **componentWillReceiveProps（已废弃）**\n\n在 react 的 componentWillReceiveProps(nextProps)生命周期中，可以在子组件的 render 函数执行前，通过 this.props 获取旧的属性，通过 nextProps 获取新的 props，对比两次 props 是否相同，从而更新子组件自己的 state。\n\n这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从 componentWillReceiveProps(nextProps) 中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。\n\n- **getDerivedStateFromProps（16.3引入）**\n\n这个生命周期函数是为了替代 componentWillReceiveProps 存在的，所以在需要使用 componentWillReceiveProps 时，就可以考虑使用 getDerivedStateFromProps 来进行替代。<br />两者的参数是不相同的，而 getDerivedStateFromProps 是一个静态函数，也就是这个函数不能通过 this 访问到 class 的属性，也并不推荐直接访问属性。而是应该通过参数提供的 nextProps 以及 prevState 来进行判断，根据新传入的 props 来映射到state。\n\n需要注意的是，**如果props传入的内容不需要影响到你的state，那么就需要返回一个null**，这个返回值是必须的，所以尽量将其写到函数的末尾：\n```jsx\nstatic getDerivedStateFromProps(nextProps, prevState) {\n    const {type} = nextProps;\n    // 当传入的type发生变化的时候，更新state\n    if (type !== prevState.type) {\n        return {\n            type,\n        };\n    }\n    // 否则，对于state不进行任何操作\n    return null;\n}\n```\n<a name=\"Kso9W\"></a>\n## 检验 props 的方式，验证 props 的目的\n**React **为我们提供了 **PropTypes **以供验证使用。当我们向 **Props **传入的数据无效（向 Props 传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。\n```jsx\nimport PropTypes from 'prop-types';\n\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <h1>Hello, {this.props.name}</h1>\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: PropTypes.string\n};\n```\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"rialk\"><span>state 和 props 有什么区别</span></h2><ul><li><span>props</span></li></ul><p data-lake-id=\"ub5111aff\" style=\"text-indent: 2em;\"><span>props 是一个从外部传进组件的参数，主要作用就是从父组件向子组件传递数据，它具有可读性和不可变性，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。</span></p><ul><li><span>state</span></li></ul><p data-lake-id=\"u7fd2dfe5\" style=\"text-indent: 2em;\"><span>state 的主要作用是用于组件保存、控制以及修改自己的状态，它只能在 constructor 中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的 this.setState 来修改，修改 state 属性会导致组件的重新渲染。</span></p><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"uf03403e3\"><span>区别：</span></p><ol><li><span>props 是传递给组件的(类似于函数的形参)，而 state 是在组件内被组件自己管理的(类似于在一个函数内声明的变量)。</span></li><li><span>props 是不可修改的，所有 react 组件都必须像纯函数一样保护它们的 props 不被更改。</span></li><li><span>state 是在组件中创建的，一般在 constructor 中初始化 state。state 是对变的、可以修改，每次 setState 都是异步更新的。</span></li></ol></blockquote><h2 id=\"SuDHN\"><span>props 为什么是只读的</span></h2><p data-lake-id=\"u3870f384\" style=\"text-indent: 2em;\"><span>this.props 是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。</span></p><p data-lake-id=\"u6b321410\"><span>提到函数式编程就要提一个概念：纯函数。它有几个特点：</span></p><ul><li><span>给定相同的输入，总是返回相同的输出。</span></li><li><span>过程没有副作用。</span></li><li><span>不依赖外部状态。</span></li></ul><p data-lake-id=\"u10f80964\"><span>​</span><br /></p><p data-lake-id=\"ue4873703\"><span>this.props 就是汲取了纯函数的思想。props 的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用</span></p><h2 id=\"uZjWx\"><span>props 改变时更新组件的方法有哪些</span></h2><p data-lake-id=\"ub5b96fb3\" style=\"text-indent: 2em;\"><span>在一个组件传入的 props 更新时重新渲染该组件常用的方法是在 componentWillReceiveProps 中将新的 props 更新到组件的state 中(这种state被成为派生状态（Derived State）)，从而实现重新渲染。React 16.3 中还引入了一个新的钩子函数getDerivedStateFromProps 来专门实现这一需求。</span></p><ul><li><strong><span>componentWillReceiveProps（已废弃）</span></strong></li></ul><p data-lake-id=\"u6c2c7100\" style=\"text-indent: 2em;\"><span>在 react 的 componentWillReceiveProps(nextProps)生命周期中，可以在子组件的 render 函数执行前，通过 this.props 获取旧的属性，通过 nextProps 获取新的 props，对比两次 props 是否相同，从而更新子组件自己的 state。</span></p><p data-lake-id=\"ue4c752c0\"><span>​</span><br /></p><p data-lake-id=\"u62728377\" style=\"text-indent: 2em;\"><span>这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从 componentWillReceiveProps(nextProps) 中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</span></p><ul><li><strong><span>getDerivedStateFromProps（16.3引入）</span></strong></li></ul><p data-lake-id=\"u6354652f\" style=\"text-indent: 2em;\"><span>这个生命周期函数是为了替代 componentWillReceiveProps 存在的，所以在需要使用 componentWillReceiveProps 时，就可以考虑使用 getDerivedStateFromProps 来进行替代。</span></p><p data-lake-id=\"u8f4908ba\" style=\"text-indent: 2em;\"><span>两者的参数是不相同的，而 getDerivedStateFromProps 是一个静态函数，也就是这个函数不能通过 this 访问到 class 的属性，也并不推荐直接访问属性。而是应该通过参数提供的 nextProps 以及 prevState 来进行判断，根据新传入的 props 来映射到state。</span></p><p data-lake-id=\"u0ca511a8\"><span>​</span><br /></p><p data-lake-id=\"uc844e135\"><span>需要注意的是，</span><strong><span>如果props传入的内容不需要影响到你的state，那么就需要返回一个null</span></strong><span>，这个返回值是必须的，所以尽量将其写到函数的末尾：</span></p><pre data-lang=\"jsx\"><code>static getDerivedStateFromProps(nextProps, prevState) {\n    const {type} = nextProps;\n    // 当传入的type发生变化的时候，更新state\n    if (type !== prevState.type) {\n        return {\n            type,\n        };\n    }\n    // 否则，对于state不进行任何操作\n    return null;\n}</code></pre><h2 id=\"Kso9W\"><span>检验 props 的方式，验证 props 的目的</span></h2><p data-lake-id=\"u1e4bbb81\" style=\"text-indent: 2em;\"><strong><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">React </span></strong><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">为我们提供了 </span><strong><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">PropTypes </span></strong><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">以供验证使用。当我们向 </span><strong><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">Props </span></strong><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">传入的数据无效（向 Props 传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。</span></p><pre data-lang=\"jsx\"><code>import PropTypes from 'prop-types';\n\nclass Greeting extends React.Component {\n  render() {\n    return (\n      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: PropTypes.string\n};</code></pre>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"rialk\" id=\"rialk\"><span data-lake-id=\"u95dcdb4d\" id=\"u95dcdb4d\">state 和 props 有什么区别</span></h2><ul list=\"ud6fc18c6\"><li fid=\"u234733cf\" data-lake-id=\"ub441d9c9\" id=\"ub441d9c9\"><span data-lake-id=\"u1e60d26b\" id=\"u1e60d26b\">props</span></li></ul><p data-lake-id=\"ub5111aff\" id=\"ub5111aff\" style=\"text-indent: 2em\"><span data-lake-id=\"u8d5c26ae\" id=\"u8d5c26ae\">props 是一个从外部传进组件的参数，主要作用就是从父组件向子组件传递数据，它具有可读性和不可变性，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。</span></p><ul list=\"ud6fc18c6\" start=\"2\"><li fid=\"u234733cf\" data-lake-id=\"u286e785d\" id=\"u286e785d\"><span data-lake-id=\"u14374403\" id=\"u14374403\">state</span></li></ul><p data-lake-id=\"u7fd2dfe5\" id=\"u7fd2dfe5\" style=\"text-indent: 2em\"><span data-lake-id=\"ueab0fa93\" id=\"ueab0fa93\">state 的主要作用是用于组件保存、控制以及修改自己的状态，它只能在 constructor 中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的 this.setState 来修改，修改 state 属性会导致组件的重新渲染。</span></p><blockquote data-lake-id=\"uc2ce50f7\" id=\"uc2ce50f7\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"uf03403e3\" id=\"uf03403e3\"><span data-lake-id=\"ue2b220d5\" id=\"ue2b220d5\">区别：</span></p><ol list=\"ucf43f604\"><li fid=\"u14eafdbd\" data-lake-id=\"ua0942445\" id=\"ua0942445\"><span data-lake-id=\"ue279386e\" id=\"ue279386e\">props 是传递给组件的(类似于函数的形参)，而 state 是在组件内被组件自己管理的(类似于在一个函数内声明的变量)。</span></li><li fid=\"u14eafdbd\" data-lake-id=\"u44273991\" id=\"u44273991\"><span data-lake-id=\"u947f9a95\" id=\"u947f9a95\">props 是不可修改的，所有 react 组件都必须像纯函数一样保护它们的 props 不被更改。</span></li><li fid=\"u14eafdbd\" data-lake-id=\"u1a2de431\" id=\"u1a2de431\"><span data-lake-id=\"u4ec220a7\" id=\"u4ec220a7\">state 是在组件中创建的，一般在 constructor 中初始化 state。state 是对变的、可以修改，每次 setState 都是异步更新的。</span></li></ol></blockquote><h2 data-lake-id=\"SuDHN\" id=\"SuDHN\"><span data-lake-id=\"ud9223f28\" id=\"ud9223f28\">props 为什么是只读的</span></h2><p data-lake-id=\"u3870f384\" id=\"u3870f384\" style=\"text-indent: 2em\"><span data-lake-id=\"u1082aca6\" id=\"u1082aca6\">this.props 是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。</span></p><p data-lake-id=\"u6b321410\" id=\"u6b321410\"><span data-lake-id=\"u996dcad0\" id=\"u996dcad0\">提到函数式编程就要提一个概念：纯函数。它有几个特点：</span></p><ul list=\"u3ea8a6a5\"><li fid=\"ue838e510\" data-lake-id=\"u49ce7263\" id=\"u49ce7263\"><span data-lake-id=\"u3164519f\" id=\"u3164519f\">给定相同的输入，总是返回相同的输出。</span></li><li fid=\"ue838e510\" data-lake-id=\"uec57d20e\" id=\"uec57d20e\"><span data-lake-id=\"u8b09f6dc\" id=\"u8b09f6dc\">过程没有副作用。</span></li><li fid=\"ue838e510\" data-lake-id=\"uba2f4398\" id=\"uba2f4398\"><span data-lake-id=\"uf534a90a\" id=\"uf534a90a\">不依赖外部状态。</span></li></ul><p data-lake-id=\"u10f80964\" id=\"u10f80964\"><span data-lake-id=\"u3cd1b559\" id=\"u3cd1b559\">​</span><br></p><p data-lake-id=\"ue4873703\" id=\"ue4873703\"><span data-lake-id=\"uf3fbb378\" id=\"uf3fbb378\">this.props 就是汲取了纯函数的思想。props 的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用</span></p><h2 data-lake-id=\"uZjWx\" id=\"uZjWx\"><span data-lake-id=\"u0869f98d\" id=\"u0869f98d\">props 改变时更新组件的方法有哪些</span></h2><p data-lake-id=\"ub5b96fb3\" id=\"ub5b96fb3\" style=\"text-indent: 2em\"><span data-lake-id=\"u5780fd0f\" id=\"u5780fd0f\">在一个组件传入的 props 更新时重新渲染该组件常用的方法是在 componentWillReceiveProps 中将新的 props 更新到组件的state 中(这种state被成为派生状态（Derived State）)，从而实现重新渲染。React 16.3 中还引入了一个新的钩子函数getDerivedStateFromProps 来专门实现这一需求。</span></p><ul list=\"u6efcf673\"><li fid=\"u0c99fe40\" data-lake-id=\"u3f5c6a31\" id=\"u3f5c6a31\"><strong><span data-lake-id=\"u599c73a0\" id=\"u599c73a0\">componentWillReceiveProps（已废弃）</span></strong></li></ul><p data-lake-id=\"u6c2c7100\" id=\"u6c2c7100\" style=\"text-indent: 2em\"><span data-lake-id=\"uab41b36c\" id=\"uab41b36c\">在 react 的 componentWillReceiveProps(nextProps)生命周期中，可以在子组件的 render 函数执行前，通过 this.props 获取旧的属性，通过 nextProps 获取新的 props，对比两次 props 是否相同，从而更新子组件自己的 state。</span></p><p data-lake-id=\"ue4c752c0\" id=\"ue4c752c0\"><span data-lake-id=\"u555e4f83\" id=\"u555e4f83\">​</span><br></p><p data-lake-id=\"u62728377\" id=\"u62728377\" style=\"text-indent: 2em\"><span data-lake-id=\"u28dbdfd4\" id=\"u28dbdfd4\">这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从 componentWillReceiveProps(nextProps) 中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</span></p><ul list=\"u9fee2a0e\"><li fid=\"ud091d9a4\" data-lake-id=\"u84d55117\" id=\"u84d55117\"><strong><span data-lake-id=\"ub76f34fb\" id=\"ub76f34fb\">getDerivedStateFromProps（16.3引入）</span></strong></li></ul><p data-lake-id=\"u6354652f\" id=\"u6354652f\" style=\"text-indent: 2em\"><span data-lake-id=\"u8d0517cf\" id=\"u8d0517cf\">这个生命周期函数是为了替代 componentWillReceiveProps 存在的，所以在需要使用 componentWillReceiveProps 时，就可以考虑使用 getDerivedStateFromProps 来进行替代。</span></p><p data-lake-id=\"u8f4908ba\" id=\"u8f4908ba\" style=\"text-indent: 2em\"><span data-lake-id=\"u1c249584\" id=\"u1c249584\">两者的参数是不相同的，而 getDerivedStateFromProps 是一个静态函数，也就是这个函数不能通过 this 访问到 class 的属性，也并不推荐直接访问属性。而是应该通过参数提供的 nextProps 以及 prevState 来进行判断，根据新传入的 props 来映射到state。</span></p><p data-lake-id=\"u0ca511a8\" id=\"u0ca511a8\"><span data-lake-id=\"u7d98b47a\" id=\"u7d98b47a\">​</span><br></p><p data-lake-id=\"uc844e135\" id=\"uc844e135\"><span data-lake-id=\"ue37d55d8\" id=\"ue37d55d8\">需要注意的是，</span><strong><span data-lake-id=\"u5c856b5e\" id=\"u5c856b5e\">如果props传入的内容不需要影响到你的state，那么就需要返回一个null</span></strong><span data-lake-id=\"u7547d385\" id=\"u7547d385\">，这个返回值是必须的，所以尽量将其写到函数的末尾：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22static%20getDerivedStateFromProps(nextProps%2C%20prevState)%20%7B%5Cn%20%20%20%20const%20%7Btype%7D%20%3D%20nextProps%3B%5Cn%20%20%20%20%2F%2F%20%E5%BD%93%E4%BC%A0%E5%85%A5%E7%9A%84type%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%9B%B4%E6%96%B0state%5Cn%20%20%20%20if%20(type%20!%3D%3D%20prevState.type)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20type%2C%5Cn%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F%2F%20%E5%90%A6%E5%88%99%EF%BC%8C%E5%AF%B9%E4%BA%8Estate%E4%B8%8D%E8%BF%9B%E8%A1%8C%E4%BB%BB%E4%BD%95%E6%93%8D%E4%BD%9C%5Cn%20%20%20%20return%20null%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22qPQs1%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"Kso9W\" id=\"Kso9W\"><span data-lake-id=\"u9f02a479\" id=\"u9f02a479\">检验 props 的方式，验证 props 的目的</span></h2><p data-lake-id=\"u1e4bbb81\" id=\"u1e4bbb81\" style=\"text-indent: 2em\"><strong><span data-lake-id=\"u2add38a6\" id=\"u2add38a6\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">React </span></strong><span data-lake-id=\"u7f93a5af\" id=\"u7f93a5af\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">为我们提供了 </span><strong><span data-lake-id=\"uec3d86e3\" id=\"uec3d86e3\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">PropTypes </span></strong><span data-lake-id=\"u5b1216fd\" id=\"u5b1216fd\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">以供验证使用。当我们向 </span><strong><span data-lake-id=\"uc16e2359\" id=\"uc16e2359\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">Props </span></strong><span data-lake-id=\"u86338f03\" id=\"u86338f03\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">传入的数据无效（向 Props 传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22import%20PropTypes%20from%20'prop-types'%3B%5Cn%5Cnclass%20Greeting%20extends%20React.Component%20%7B%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Ch1%3EHello%2C%20%7Bthis.props.name%7D%3C%2Fh1%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5CnGreeting.propTypes%20%3D%20%7B%5Cn%20%20name%3A%20PropTypes.string%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22y8Ofg%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:39.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:39.000Z",
  "updated_at": "2022-05-10T15:12:35.000Z",
  "published_at": "2022-04-04T11:33:39.000Z",
  "first_published_at": "2022-04-04T11:33:39.255Z",
  "word_count": 1124,
  "cover": null,
  "description": "state 和 props 有什么区别propsprops 是一个从外部传进组件的参数，主要作用就是从父组件向子组件传递数据，它具有可读性和不可变性，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。statestate 的主要作用是用...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}