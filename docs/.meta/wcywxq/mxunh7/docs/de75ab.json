{
  "id": 72212258,
  "slug": "de75ab",
  "title": "vite 的热更新原理",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。\n\n- 服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。\n- 客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。\n```javascript\nexport const clientPublicPath = `/vite/client`\nconst devInjectionCode = `\\n<script type=\"module\">import \"${clientPublicPath}\"</script>\\n`\nasync function rewriteHtml(importer: string, html: string) {\n  return injectScriptToHtml(html, devInjectionCode)\n}\n```\n当 request.path 路径是 /vite/client 时，请求获取已经提前写好的关于 websocket 的代码。因此在客户端中我们创建了一个 websocket 服务并与服务端建立了连接。\n\nVite 会接受到来自客户端的消息。通过不同的消息触发一些事件。做到浏览器端的即时热模块更换（热更新）。包括 connect、vue-reload、vue-rerender 等事件，分别触发组件vue 的重新加载，render等。\n```javascript\nsocket.addEventListener('message', async ({ data }) => {\n  const payload = JSON.parse(data) as HMRPayload | MultiUpdatePayload\n  if (payload.type === 'multi') {\n    payload.updates.forEach(handleMessage)\n  } else {\n    handleMessage(payload)\n  }\n})\n\nasync function handleMessage(payload: HMRPayload) {\n  const { path, changeSrcPath, timestamp } = payload as UpdatePayload\n  console.log(path)\n  switch (payload.type) {\n    case 'connected':\n      console.log(`[vite] connected.`)\n      break\n    case 'vue-reload':\n      queueUpdate(\n        import(`${path}?t=${timestamp}`)\n          .catch((err) => warnFailedFetch(err, path))\n          .then((m) => () => {\n            __VUE_HMR_RUNTIME__.reload(path, m.default)\n            console.log(`[vite] ${path} reloaded.`)\n          })\n      )\n      break\n    case 'vue-rerender':\n      const templatePath = `${path}?type=template`\n      import(`${templatePath}&t=${timestamp}`).then((m) => {\n        __VUE_HMR_RUNTIME__.rerender(path, m.render)\n        console.log(`[vite] ${path} template updated.`)\n      })\n      break\n    case 'style-update':\n      // check if this is referenced in html via <link>\n      const el = document.querySelector(`link[href*='${path}']`)\n      if (el) {\n        el.setAttribute(\n          'href',\n          `${path}${path.includes('?') ? '&' : '?'}t=${timestamp}`\n        )\n        break\n      }\n      const importQuery = path.includes('?') ? '&import' : '?import'\n      await import(`${path}${importQuery}&t=${timestamp}`)\n      console.log(`[vite] ${path} updated.`)\n      break\n    case 'js-update':\n      queueUpdate(updateModule(path, changeSrcPath, timestamp))\n      break\n    case 'custom':\n      const cbs = customUpdateMap.get(payload.id)\n      if (cbs) {\n        cbs.forEach((cb) => cb(payload.customData))\n      }\n      break\n    case 'full-reload':\n      if (path.endsWith('.html')) {\n        // if html file is edited, only reload the page if the browser is\n        // currently on that page.\n        const pagePath = location.pathname\n        if (\n          pagePath === path ||\n          (pagePath.endsWith('/') && pagePath + 'index.html' === path)\n        ) {\n          location.reload()\n        }\n        return\n      } else {\n       location.reload()\n      }\n  }\n}\n```\n",
  "body_draft": "",
  "body_html": "<!doctype html><p data-lake-id=\"ub299e57d\"><span>Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。</span></p><ul><li><span>服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。</span></li><li><span>客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。</span></li></ul><pre data-lang=\"javascript\"><code>export const clientPublicPath = `/vite/client`\nconst devInjectionCode = `\\n&lt;script type=&quot;module&quot;&gt;import &quot;${clientPublicPath}&quot;&lt;/script&gt;\\n`\nasync function rewriteHtml(importer: string, html: string) {\n  return injectScriptToHtml(html, devInjectionCode)\n}</code></pre><p data-lake-id=\"u611310df\"><span>当 request.path 路径是 /vite/client 时，请求获取已经提前写好的关于 websocket 的代码。因此在客户端中我们创建了一个 websocket 服务并与服务端建立了连接。</span></p><p data-lake-id=\"udd068f5a\"><span>​</span><br /></p><p data-lake-id=\"u7f74aca3\"><span>Vite 会接受到来自客户端的消息。通过不同的消息触发一些事件。做到浏览器端的即时热模块更换（热更新）。包括 connect、vue-reload、vue-rerender 等事件，分别触发组件vue 的重新加载，render等。</span></p><pre data-lang=\"javascript\"><code>socket.addEventListener('message', async ({ data }) =&gt; {\n  const payload = JSON.parse(data) as HMRPayload | MultiUpdatePayload\n  if (payload.type === 'multi') {\n    payload.updates.forEach(handleMessage)\n  } else {\n    handleMessage(payload)\n  }\n})\n\nasync function handleMessage(payload: HMRPayload) {\n  const { path, changeSrcPath, timestamp } = payload as UpdatePayload\n  console.log(path)\n  switch (payload.type) {\n    case 'connected':\n      console.log(`[vite] connected.`)\n      break\n    case 'vue-reload':\n      queueUpdate(\n        import(`${path}?t=${timestamp}`)\n          .catch((err) =&gt; warnFailedFetch(err, path))\n          .then((m) =&gt; () =&gt; {\n            __VUE_HMR_RUNTIME__.reload(path, m.default)\n            console.log(`[vite] ${path} reloaded.`)\n          })\n      )\n      break\n    case 'vue-rerender':\n      const templatePath = `${path}?type=template`\n      import(`${templatePath}&amp;t=${timestamp}`).then((m) =&gt; {\n        __VUE_HMR_RUNTIME__.rerender(path, m.render)\n        console.log(`[vite] ${path} template updated.`)\n      })\n      break\n    case 'style-update':\n      // check if this is referenced in html via &lt;link&gt;\n      const el = document.querySelector(`link[href*='${path}']`)\n      if (el) {\n        el.setAttribute(\n          'href',\n          `${path}${path.includes('?') ? '&amp;' : '?'}t=${timestamp}`\n        )\n        break\n      }\n      const importQuery = path.includes('?') ? '&amp;import' : '?import'\n      await import(`${path}${importQuery}&amp;t=${timestamp}`)\n      console.log(`[vite] ${path} updated.`)\n      break\n    case 'js-update':\n      queueUpdate(updateModule(path, changeSrcPath, timestamp))\n      break\n    case 'custom':\n      const cbs = customUpdateMap.get(payload.id)\n      if (cbs) {\n        cbs.forEach((cb) =&gt; cb(payload.customData))\n      }\n      break\n    case 'full-reload':\n      if (path.endsWith('.html')) {\n        // if html file is edited, only reload the page if the browser is\n        // currently on that page.\n        const pagePath = location.pathname\n        if (\n          pagePath === path ||\n          (pagePath.endsWith('/') &amp;&amp; pagePath + 'index.html' === path)\n        ) {\n          location.reload()\n        }\n        return\n      } else {\n       location.reload()\n      }\n  }\n}</code></pre>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"ub299e57d\" id=\"ub299e57d\"><span data-lake-id=\"u01cf96f2\" id=\"u01cf96f2\">Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。</span></p><ul list=\"u0ab64df9\"><li fid=\"u03d25c61\" data-lake-id=\"u554a7a6d\" id=\"u554a7a6d\"><span data-lake-id=\"u895069f7\" id=\"u895069f7\">服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。</span></li><li fid=\"u03d25c61\" data-lake-id=\"u9c10f99f\" id=\"u9c10f99f\"><span data-lake-id=\"u2def14d0\" id=\"u2def14d0\">客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。</span></li></ul><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22export%20const%20clientPublicPath%20%3D%20%60%2Fvite%2Fclient%60%5Cnconst%20devInjectionCode%20%3D%20%60%5C%5Cn%3Cscript%20type%3D%5C%22module%5C%22%3Eimport%20%5C%22%24%7BclientPublicPath%7D%5C%22%3C%2Fscript%3E%5C%5Cn%60%5Cnasync%20function%20rewriteHtml(importer%3A%20string%2C%20html%3A%20string)%20%7B%5Cn%20%20return%20injectScriptToHtml(html%2C%20devInjectionCode)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22Pm5JW%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u611310df\" id=\"u611310df\"><span data-lake-id=\"ud5519b58\" id=\"ud5519b58\">当 request.path 路径是 /vite/client 时，请求获取已经提前写好的关于 websocket 的代码。因此在客户端中我们创建了一个 websocket 服务并与服务端建立了连接。</span></p><p data-lake-id=\"udd068f5a\" id=\"udd068f5a\"><span data-lake-id=\"ud9af7c39\" id=\"ud9af7c39\">​</span><br></p><p data-lake-id=\"u7f74aca3\" id=\"u7f74aca3\"><span data-lake-id=\"uee59b5ca\" id=\"uee59b5ca\">Vite 会接受到来自客户端的消息。通过不同的消息触发一些事件。做到浏览器端的即时热模块更换（热更新）。包括 connect、vue-reload、vue-rerender 等事件，分别触发组件vue 的重新加载，render等。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22socket.addEventListener('message'%2C%20async%20(%7B%20data%20%7D)%20%3D%3E%20%7B%5Cn%20%20const%20payload%20%3D%20JSON.parse(data)%20as%20HMRPayload%20%7C%20MultiUpdatePayload%5Cn%20%20if%20(payload.type%20%3D%3D%3D%20'multi')%20%7B%5Cn%20%20%20%20payload.updates.forEach(handleMessage)%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20handleMessage(payload)%5Cn%20%20%7D%5Cn%7D)%5Cn%5Cnasync%20function%20handleMessage(payload%3A%20HMRPayload)%20%7B%5Cn%20%20const%20%7B%20path%2C%20changeSrcPath%2C%20timestamp%20%7D%20%3D%20payload%20as%20UpdatePayload%5Cn%20%20console.log(path)%5Cn%20%20switch%20(payload.type)%20%7B%5Cn%20%20%20%20case%20'connected'%3A%5Cn%20%20%20%20%20%20console.log(%60%5Bvite%5D%20connected.%60)%5Cn%20%20%20%20%20%20break%5Cn%20%20%20%20case%20'vue-reload'%3A%5Cn%20%20%20%20%20%20queueUpdate(%5Cn%20%20%20%20%20%20%20%20import(%60%24%7Bpath%7D%3Ft%3D%24%7Btimestamp%7D%60)%5Cn%20%20%20%20%20%20%20%20%20%20.catch((err)%20%3D%3E%20warnFailedFetch(err%2C%20path))%5Cn%20%20%20%20%20%20%20%20%20%20.then((m)%20%3D%3E%20()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20__VUE_HMR_RUNTIME__.reload(path%2C%20m.default)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20console.log(%60%5Bvite%5D%20%24%7Bpath%7D%20reloaded.%60)%5Cn%20%20%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20)%5Cn%20%20%20%20%20%20break%5Cn%20%20%20%20case%20'vue-rerender'%3A%5Cn%20%20%20%20%20%20const%20templatePath%20%3D%20%60%24%7Bpath%7D%3Ftype%3Dtemplate%60%5Cn%20%20%20%20%20%20import(%60%24%7BtemplatePath%7D%26t%3D%24%7Btimestamp%7D%60).then((m)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20__VUE_HMR_RUNTIME__.rerender(path%2C%20m.render)%5Cn%20%20%20%20%20%20%20%20console.log(%60%5Bvite%5D%20%24%7Bpath%7D%20template%20updated.%60)%5Cn%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20break%5Cn%20%20%20%20case%20'style-update'%3A%5Cn%20%20%20%20%20%20%2F%2F%20check%20if%20this%20is%20referenced%20in%20html%20via%20%3Clink%3E%5Cn%20%20%20%20%20%20const%20el%20%3D%20document.querySelector(%60link%5Bhref*%3D'%24%7Bpath%7D'%5D%60)%5Cn%20%20%20%20%20%20if%20(el)%20%7B%5Cn%20%20%20%20%20%20%20%20el.setAttribute(%5Cn%20%20%20%20%20%20%20%20%20%20'href'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%60%24%7Bpath%7D%24%7Bpath.includes('%3F')%20%3F%20'%26'%20%3A%20'%3F'%7Dt%3D%24%7Btimestamp%7D%60%5Cn%20%20%20%20%20%20%20%20)%5Cn%20%20%20%20%20%20%20%20break%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20const%20importQuery%20%3D%20path.includes('%3F')%20%3F%20'%26import'%20%3A%20'%3Fimport'%5Cn%20%20%20%20%20%20await%20import(%60%24%7Bpath%7D%24%7BimportQuery%7D%26t%3D%24%7Btimestamp%7D%60)%5Cn%20%20%20%20%20%20console.log(%60%5Bvite%5D%20%24%7Bpath%7D%20updated.%60)%5Cn%20%20%20%20%20%20break%5Cn%20%20%20%20case%20'js-update'%3A%5Cn%20%20%20%20%20%20queueUpdate(updateModule(path%2C%20changeSrcPath%2C%20timestamp))%5Cn%20%20%20%20%20%20break%5Cn%20%20%20%20case%20'custom'%3A%5Cn%20%20%20%20%20%20const%20cbs%20%3D%20customUpdateMap.get(payload.id)%5Cn%20%20%20%20%20%20if%20(cbs)%20%7B%5Cn%20%20%20%20%20%20%20%20cbs.forEach((cb)%20%3D%3E%20cb(payload.customData))%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20break%5Cn%20%20%20%20case%20'full-reload'%3A%5Cn%20%20%20%20%20%20if%20(path.endsWith('.html'))%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20if%20html%20file%20is%20edited%2C%20only%20reload%20the%20page%20if%20the%20browser%20is%5Cn%20%20%20%20%20%20%20%20%2F%2F%20currently%20on%20that%20page.%5Cn%20%20%20%20%20%20%20%20const%20pagePath%20%3D%20location.pathname%5Cn%20%20%20%20%20%20%20%20if%20(%5Cn%20%20%20%20%20%20%20%20%20%20pagePath%20%3D%3D%3D%20path%20%7C%7C%5Cn%20%20%20%20%20%20%20%20%20%20(pagePath.endsWith('%2F')%20%26%26%20pagePath%20%2B%20'index.html'%20%3D%3D%3D%20path)%5Cn%20%20%20%20%20%20%20%20)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20location.reload()%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%5Cn%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20location.reload()%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%20Listen%20for%20messages%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22z0KRv%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:53.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:53.000Z",
  "updated_at": "2022-05-10T15:12:33.000Z",
  "published_at": "2022-04-04T11:33:53.000Z",
  "first_published_at": "2022-04-04T11:33:53.355Z",
  "word_count": 523,
  "cover": null,
  "description": "Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。客户端：Vi...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}