{
  "id": 72212201,
  "slug": "nnwww9",
  "title": "MVVM、MVC、MVP 的区别",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": ":::info\nMVC 代表模型、视图、控制器，视图可以直接访问模型。所以，视图里面会包含模型信息，MVC 关注的是模型不变，所以 MVC 中，模型不依赖视图，但是视图依赖模型。\n\nMVVM 代表模型、视图和 VM，VM 作为模型和视图之间的桥梁，当模型层数据发生改变，VM 会检测到并通知视图层进行响应的修改。\n:::\n\nMVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。\n\n在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。\n\n<a name=\"fv7nZ\"></a>\n## MVC\nMVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 <br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647784994188-a3981c03-8c9b-4993-bc11-a0dd3f2f8602.png#clientId=u265d3927-1a93-4&from=paste&height=277&id=u74428e0c&originHeight=277&originWidth=363&originalType=binary&ratio=1&size=39847&status=done&style=none&taskId=u3b964a67-de49-4a7b-b3ca-00cefe806c3&width=363)\n\n<a name=\"NkpSx\"></a>\n## MVVM\nMVVM 分为 Model、View、ViewModel：\n\n- Model代表数据模型，数据和业务逻辑都在Model层中定义；\n- View代表UI视图，负责数据的展示；\n- ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；\n\nModel和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。\n\n这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647785016964-614dbf0d-8f21-4dc8-94e4-5cb2be224e2e.png#clientId=u265d3927-1a93-4&from=paste&height=174&id=u70ccb1dd&originHeight=174&originWidth=576&originalType=binary&ratio=1&size=40999&status=done&style=none&taskId=ue53fabfd-c6de-4111-8bdc-cd4787a414a&width=576)\n<a name=\"oG5DE\"></a>\n## MVP\nMVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。\n\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u79ca8fc3\"><span>MVC 代表模型、视图、控制器，视图可以直接访问模型。所以，视图里面会包含模型信息，MVC 关注的是模型不变，所以 MVC 中，模型不依赖视图，但是视图依赖模型。</span></p><p data-lake-id=\"uffdd28f1\"><span>​</span><br /></p><p data-lake-id=\"u50002550\"><span>MVVM 代表模型、视图和 VM，VM 作为模型和视图之间的桥梁，当模型层数据发生改变，VM 会检测到并通知视图层进行响应的修改。</span></p></blockquote><p data-lake-id=\"u239db92d\"><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">​</span><br /></p><p data-lake-id=\"u3f00b44d\"><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</span></p><p data-lake-id=\"u27da7b8a\"><span class=\"lake-fontsize-1515\" style=\"color: #383838;\">​</span><br /></p><p data-lake-id=\"u41a661a3\"><span>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</span></p><p data-lake-id=\"u8bec4050\"><br /></p><h2 id=\"fv7nZ\"><span>MVC</span></h2><p data-lake-id=\"ude7e0eda\"><span>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 </span></p><p data-lake-id=\"u93229d0c\"><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647784994188-a3981c03-8c9b-4993-bc11-a0dd3f2f8602.png#clientId=u265d3927-1a93-4&amp;from=paste&amp;height=277&amp;id=u74428e0c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=277&amp;originWidth=363&amp;originalType=binary&amp;ratio=1&amp;size=39847&amp;status=done&amp;style=none&amp;taskId=u3b964a67-de49-4a7b-b3ca-00cefe806c3&amp;width=363\" style=\"max-width: 600px; width: 363px;\" /></p><p data-lake-id=\"u89d4e2e4\"><br /></p><h2 id=\"NkpSx\"><span>MVVM</span></h2><p data-lake-id=\"u60344c27\"><span>MVVM 分为 Model、View、ViewModel：</span></p><ul><li><span>Model代表数据模型，数据和业务逻辑都在Model层中定义；</span></li><li><span>View代表UI视图，负责数据的展示；</span></li><li><span>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</span></li></ul><p data-lake-id=\"u072c1483\"><span>​</span><br /></p><p data-lake-id=\"u1537ae91\"><span>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</span></p><p data-lake-id=\"u4ea70134\"><span>​</span><br /></p><p data-lake-id=\"u00cae91b\"><span>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。</span></p><p data-lake-id=\"u2fc1294d\"><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647785016964-614dbf0d-8f21-4dc8-94e4-5cb2be224e2e.png#clientId=u265d3927-1a93-4&amp;from=paste&amp;height=174&amp;id=u70ccb1dd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=174&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;size=40999&amp;status=done&amp;style=none&amp;taskId=ue53fabfd-c6de-4111-8bdc-cd4787a414a&amp;width=576\" style=\"max-width: 600px; width: 576px;\" /></p><h2 id=\"oG5DE\"><span>MVP</span></h2><p data-lake-id=\"ud4b84b03\"><span>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</span></p><p data-lake-id=\"ud8352969\"><span>​</span><br /></p><p data-lake-id=\"udd666622\"><span>​</span><br /></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><blockquote data-lake-id=\"u1623baa8\" id=\"u1623baa8\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u79ca8fc3\" id=\"u79ca8fc3\"><span data-lake-id=\"u3eba179b\" id=\"u3eba179b\">MVC 代表模型、视图、控制器，视图可以直接访问模型。所以，视图里面会包含模型信息，MVC 关注的是模型不变，所以 MVC 中，模型不依赖视图，但是视图依赖模型。</span></p><p data-lake-id=\"uffdd28f1\" id=\"uffdd28f1\"><span data-lake-id=\"ua19e127f\" id=\"ua19e127f\">​</span><br></p><p data-lake-id=\"u50002550\" id=\"u50002550\"><span data-lake-id=\"ue26924ad\" id=\"ue26924ad\">MVVM 代表模型、视图和 VM，VM 作为模型和视图之间的桥梁，当模型层数据发生改变，VM 会检测到并通知视图层进行响应的修改。</span></p></blockquote><p data-lake-id=\"u239db92d\" id=\"u239db92d\"><span data-lake-id=\"u0ce6a893\" id=\"u0ce6a893\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">​</span><br></p><p data-lake-id=\"u3f00b44d\" id=\"u3f00b44d\"><span data-lake-id=\"u2dfc1d7c\" id=\"u2dfc1d7c\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</span></p><p data-lake-id=\"u27da7b8a\" id=\"u27da7b8a\"><span data-lake-id=\"u26dd9b85\" id=\"u26dd9b85\" class=\"lake-fontsize-1515\" style=\"color: rgb(56, 56, 56)\">​</span><br></p><p data-lake-id=\"u41a661a3\" id=\"u41a661a3\"><span data-lake-id=\"u8e66654d\" id=\"u8e66654d\">在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</span></p><p data-lake-id=\"u8bec4050\" id=\"u8bec4050\"><br></p><h2 data-lake-id=\"fv7nZ\" id=\"fv7nZ\"><span data-lake-id=\"ue100e5ac\" id=\"ue100e5ac\">MVC</span></h2><p data-lake-id=\"ude7e0eda\" id=\"ude7e0eda\"><span data-lake-id=\"u1aa08704\" id=\"u1aa08704\">MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 </span></p><p data-lake-id=\"u93229d0c\" id=\"u93229d0c\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647784994188-a3981c03-8c9b-4993-bc11-a0dd3f2f8602.png%22%2C%22taskId%22%3A%22u3b964a67-de49-4a7b-b3ca-00cefe806c3%22%2C%22clientId%22%3A%22u265d3927-1a93-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A363%2C%22height%22%3A277%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A39847%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A363%2C%22originHeight%22%3A277%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22VIEW%20%E5%8A%A8%E4%BD%9C%E6%8C%87%E4%BB%A4%20%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%20%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B%20CONTROLLER%20MODEL%20%40%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A159.75838%2C%22y%22%3A43.63113%2C%22width%22%3A36.98625000000001%2C%22height%22%3A14.46302%2C%22text%22%3A%22VIEW%22%7D%2C%7B%22x%22%3A84.56198%2C%22y%22%3A128.5119%2C%22width%22%3A64.00486999999998%2C%22height%22%3A16.58238%2C%22text%22%3A%22%E5%8A%A8%E4%BD%9C%E6%8C%87%E4%BB%A4%22%7D%2C%7B%22x%22%3A215.0655%2C%22y%22%3A132.7545%2C%22width%22%3A63.676300000000026%2C%22height%22%3A16.54989999999998%2C%22text%22%3A%22%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%22%7D%2C%7B%22x%22%3A145.60684%2C%22y%22%3A218.21289%2C%22width%22%3A65.24601999999999%2C%22height%22%3A17.160360000000026%2C%22text%22%3A%22%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B%22%7D%2C%7B%22x%22%3A13.558253%2C%22y%22%3A219.3556%2C%22width%22%3A73.00440699999999%2C%22height%22%3A15.419359999999983%2C%22text%22%3A%22CONTROLLER%22%7D%2C%7B%22x%22%3A289.72794%2C%22y%22%3A219.57861%2C%22width%22%3A46.74170000000004%2C%22height%22%3A13.755089999999996%2C%22text%22%3A%22MODEL%22%7D%2C%7B%22x%22%3A187.928%2C%22y%22%3A244.32307%2C%22width%22%3A161.15769999999998%2C%22height%22%3A20.64552999999998%2C%22text%22%3A%22%40%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%7D%5D%2C%22id%22%3A%22u74428e0c%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u89d4e2e4\" id=\"u89d4e2e4\"><br></p><h2 data-lake-id=\"NkpSx\" id=\"NkpSx\"><span data-lake-id=\"u624c6615\" id=\"u624c6615\">MVVM</span></h2><p data-lake-id=\"u60344c27\" id=\"u60344c27\"><span data-lake-id=\"u7b4a18b7\" id=\"u7b4a18b7\">MVVM 分为 Model、View、ViewModel：</span></p><ul list=\"udb55fc89\"><li fid=\"ua1b92e7d\" data-lake-id=\"u74ede6a1\" id=\"u74ede6a1\"><span data-lake-id=\"u1868bd5e\" id=\"u1868bd5e\">Model代表数据模型，数据和业务逻辑都在Model层中定义；</span></li><li fid=\"ua1b92e7d\" data-lake-id=\"u6d24c37f\" id=\"u6d24c37f\"><span data-lake-id=\"ud64d55d5\" id=\"ud64d55d5\">View代表UI视图，负责数据的展示；</span></li><li fid=\"ua1b92e7d\" data-lake-id=\"u538cfaee\" id=\"u538cfaee\"><span data-lake-id=\"ude9e8ecb\" id=\"ude9e8ecb\">ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</span></li></ul><p data-lake-id=\"u072c1483\" id=\"u072c1483\"><span data-lake-id=\"u361abcb4\" id=\"u361abcb4\">​</span><br></p><p data-lake-id=\"u1537ae91\" id=\"u1537ae91\"><span data-lake-id=\"ucc39e4de\" id=\"ucc39e4de\">Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</span></p><p data-lake-id=\"u4ea70134\" id=\"u4ea70134\"><span data-lake-id=\"u09a08659\" id=\"u09a08659\">​</span><br></p><p data-lake-id=\"u00cae91b\" id=\"u00cae91b\"><span data-lake-id=\"u45b25d74\" id=\"u45b25d74\">这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。</span></p><p data-lake-id=\"u2fc1294d\" id=\"u2fc1294d\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647785016964-614dbf0d-8f21-4dc8-94e4-5cb2be224e2e.png%22%2C%22taskId%22%3A%22ue53fabfd-c6de-4111-8bdc-cd4787a414a%22%2C%22clientId%22%3A%22u265d3927-1a93-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A576%2C%22height%22%3A174%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A40999%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A576%2C%22originHeight%22%3A174%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%20VIEWMODEL%20MODEL%20VIEW%20DATABINDING%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%20%E5%9B%9B%E4%BC%9F%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A264.83963%2C%22y%22%3A7.3459105%2C%22width%22%3A50.98057%2C%22height%22%3A13.389015500000003%2C%22text%22%3A%22%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%22%7D%2C%7B%22x%22%3A379.36954%2C%22y%22%3A91.23989%2C%22width%22%3A50.166990000000055%2C%22height%22%3A13.053969999999993%2C%22text%22%3A%22%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%22%7D%2C%7B%22x%22%3A253.13652%2C%22y%22%3A115.06827%2C%22width%22%3A70.30268000000004%2C%22height%22%3A14.670820000000006%2C%22text%22%3A%22VIEWMODEL%22%7D%2C%7B%22x%22%3A501.67136%2C%22y%22%3A115.51234%2C%22width%22%3A48.54818000000006%2C%22height%22%3A14.000509999999991%2C%22text%22%3A%22MODEL%22%7D%2C%7B%22x%22%3A31.079428%2C%22y%22%3A115.929016%2C%22width%22%3A36.741167%2C%22height%22%3A14.737503999999987%2C%22text%22%3A%22VIEW%22%7D%2C%7B%22x%22%3A131.72424%2C%22y%22%3A117.03768%2C%22width%22%3A70.21763999999999%2C%22height%22%3A13.790060000000011%2C%22text%22%3A%22DATABINDING%22%7D%2C%7B%22x%22%3A384.09848%2C%22y%22%3A136.92336%2C%22width%22%3A56.62232%2C%22height%22%3A14.500820000000004%2C%22text%22%3A%22%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%22%7D%2C%7B%22x%22%3A402.33484%2C%22y%22%3A144.58862%2C%22width%22%3A164.53442000000007%2C%22height%22%3A19.65959000000001%2C%22text%22%3A%22%E5%9B%9B%E4%BC%9F%E5%9C%9F%E6%8E%98%E9%87%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%22%7D%5D%2C%22id%22%3A%22u70ccb1dd%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h2 data-lake-id=\"oG5DE\" id=\"oG5DE\"><span data-lake-id=\"u58e01646\" id=\"u58e01646\">MVP</span></h2><p data-lake-id=\"ud4b84b03\" id=\"ud4b84b03\"><span data-lake-id=\"u60bd1f60\" id=\"u60bd1f60\">MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</span></p><p data-lake-id=\"ud8352969\" id=\"ud8352969\"><span data-lake-id=\"u1db6090f\" id=\"u1db6090f\">​</span><br></p><p data-lake-id=\"udd666622\" id=\"udd666622\"><span data-lake-id=\"uc178207c\" id=\"uc178207c\">​</span><br></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:35.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:35.000Z",
  "updated_at": "2022-05-10T15:12:35.000Z",
  "published_at": "2022-04-04T11:33:35.000Z",
  "first_published_at": "2022-04-04T11:33:34.999Z",
  "word_count": 951,
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1647784994188-a3981c03-8c9b-4993-bc11-a0dd3f2f8602.png",
  "description": "MVC 代表模型、视图、控制器，视图可以直接访问模型。所以，视图里面会包含模型信息，MVC 关注的是模型不变，所以 MVC 中，模型不依赖视图，但是视图依赖模型。MVVM 代表模型、视图和 VM，VM 作为模型和视图之间的桥梁，当模型层数据发生改变，VM 会检测到并通知视图层进行响应的修改。M...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}