{
  "id": 72212086,
  "slug": "ga86yq",
  "title": "generator 和 async",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"kSwZu\"></a>\n## generator 函数\n<a name=\"RIwE0\"></a>\n### 概念\nGenerator 是 ES6 标准引入的新的数据类型，Generator 可以理解为一个状态机，内部封装了很多状态，同时返回一个迭代器 Iterator 对象。可以通过这个迭代器遍历相关的值及状态。Generator 的显著特点是可以多次返回，每次的返回值作为迭代器的一部分保存下来，可以被我们显示调用。\n\n<a name=\"hrR0T\"></a>\n### 声明方式\n一般的函数使用 function 声明，return 作为回调，只可以回调 1 次。而 Generator 函数使用 function* 定义，除了 return，还可以使用 yield 返回多次\n```javascript\nfunction* foo(x) {\n\tyield x + 1\n  yield x + 2\n  return x + 3\n}\nconst res = foo(0) // foo {<suspended>}\nres.next() // { value: 1, done: false }\nres.next() // { value: 2, done: false }\nres.next() // { value: 3, done: true }\nres.next() // { value: undefined, done: true }\n```\n:::tips\n在上面的例子中，可以看到，在执行 foo 函数后返回了一个 Generator 函数的实例。它具有 suspended 和 closed，suspended 代表暂停，closed 则为结束，但是这个状态是无法捕获的，我们只能通过 Generator 函数提供的方法获取当前的状态。在执行 next 方法后，顺序执行了 yield 的返回值。返回值有 value 和 done 两个状态。value 为返回值，可以是任意类型。done 的状态为 true/false，true 即为执行完毕。在执行完毕后再次调用返回 `{ value: undefined, done: true }`\n:::\n:::warning\n注意：在遇到 return 的时候，所有剩下的 yield 不再执行，直接返回 `{ value: undefined, done: true }`\n:::\n<a name=\"MfcBU\"></a>\n### 方法介绍\nGenerator 函数提供了 3 个方法：next、return、throw\n\n- next：按步执行，每次返回一个值，同时也可以每次传入新的值作为计算\n- return：直接跳过所有步骤，直接返回 `{value: undefined, done: true}`\n- throw：根据函数中书写 try...catch 返回 catch 中的内容，如果没有写 try，则直接抛出异常\n<a name=\"CiLqY\"></a>\n### 遍历\nGenerator 函数的返回值是一个带有状态的 Generator 实例。它可以被 for...of 调用，进行遍历，并且仅仅只能被 for...of 调用\n```javascript\nfunction* foo(x) {\n\tconsole.log('start')\n  yield x + 1\n  console.log('state 1')\n  yield x + 2\n  console.log('end')\n}\n\nconst res = foo(0) // foo {<suspended>}\n\nfor (let i of res) {\n\tconsole.log(i)\n}\n// state -> 1 -> state 1 -> 2 -> end\nres.next() // { value: undefined, done: true }\n```\n:::tips\n调用 for...of 后，在后台调用 next()，当 done 属性为 true 的时候，循环退出。因此 Generator 函数的实例将顺序执行一遍，再次调用时，状态为已完成\n:::\n<a name=\"e0vC2\"></a>\n### 状态存储和改变\nGenerator 函数中 yield 返回的值是可以被变量存储和改变的\n```javascript\nfunction* foo(x) {\n\tlet a = yield x + 0\n  let b = yield a + 2\n  yield x\n  yield a\n  yield b\n}\nconst res = foo(0)\nres.next() // { value: 0, done: false }\nres.next(2) // { value: 4, done: false }\nres.next(3) // { value: 0, done: false }\nres.next(4) // { value: 2, done: false }\nres.next(5) // { value: 3, done: false }\n```\n:::tips\n以上的执行结果中，我们可以看到，在第二步的时候，我们传入 2 这个参数，foo 函数中的 a 的变量的值 0 被替换为 2，并且在第 4 次迭代的时候，返回的是 2。而第三次迭代的时候，传入的 3 参数，替换了 b 的值 4，并在第 5 次迭代的时候返回了 3。所以传入的参数，是替代上一次迭代的生成值。\n:::\n<a name=\"fSy0U\"></a>\n### yield* 委托\n在 Generator 函数中，我们有时需要将多个迭代器的值合并，我们可以使用 yield *  的形式，将执行委托给另外一个 Generator 函数\n```javascript\nfunction* foo1() {\n\tyield 1\n  yield 2\n  return 'foo1 end'\n}\nfunction* foo2() {\n\tyield 3\n  yield 4\n}\nfunction* foo() {\n  yield* foo1()\n  yield* foo2()\n  yield 5\n}\nconst result = foo()\nconsole.log(iterator.next()) // { value: 1, done: false }\nconsole.log(iterator.next()) // { value: 2, done: false }\nconsole.log(iterator.next()) // { value: 3, done: false }\nconsole.log(iterator.next()) // { value: 4, done: false }\nconsole.log(iterator.next()) // { value: 5, done: false }\nconsole.log(iterator.next()) // { value: undefined, done: true }\n```\n:::tips\nfoo 在执行的时候，首先委托给了 foo1，等 foo1 执行完毕，再委托给 foo2。但是我们发现，'foo1 end' 这一句并没有输出。在整个 Generator 中，return 只能有一次，在委托的时候，所有的 yield 都是以函数表达式的形式出现。return 的值是表达式的结果，在委托结束之前其内部都是暂停的，等待到表达式的结果的时候，将结果直接返回给 foo。此时 foo 内部没有接收到变量，所以未打印。如果我们希望捕获这个值，可以使用 yield foo() 的方式进行获取。\n:::\n<a name=\"N7QiH\"></a>\n## async 关键字\n<a name=\"D0Rdx\"></a>\n### 实现原理\nasync 函数是 Generator 函数的语法糖，使用关键字 async 来表示，在函数内部使用 await 来表示异步\n<a name=\"o0PiC\"></a>\n### 简单实现\nasync/await 语法糖就是使用 **Generator 函数 + 自动执行器** 来运作的\n```javascript\n// 定义一个 promise，用来模拟异步请求，作用是传入参数\nfunction getNum(num) {\n\treturn new Promise((resolve, reject) => {\n  \tsetTimeout(() => {\n    \tresolve(num + 1)\n    }, 1000)\n  })\n}\n\n// 自动执行器，如果一个 Generator 函数没有执行完，则会递归调用\nfunction asyncFactory(fn) {\n\tconst gen = fn()\n  function next(data) {\n  \tconst res = gen.next(data)\n    if (res.done) return res.value\n    res.value.then(data => {\n    \tnext(data)\n    })\n  }\n  next()\n}\n\n// 所需要执行的 Generator 函数，内部的数据在执行完成一步的 promise 之后，再调用下一步\nconst fn = function* () {\n\tconst f1 = yield getNum(1)\n  const f2 = yield getNum(f1)\n  console.log(f2)\n}\n\nasyncFactory(fn)\n```\n:::tips\n在执行过程中，判断一个函数的 promise 是否完成，如果已经完成，将结果传入下一个函数，继续重复此步骤\n:::\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"kSwZu\"><span>generator 函数</span></h2><h3 id=\"RIwE0\"><span>概念</span></h3><p data-lake-id=\"uabbfa020\"><span>Generator 是 ES6 标准引入的新的数据类型，Generator 可以理解为一个状态机，内部封装了很多状态，同时返回一个迭代器 Iterator 对象。可以通过这个迭代器遍历相关的值及状态。Generator 的显著特点是可以多次返回，每次的返回值作为迭代器的一部分保存下来，可以被我们显示调用。</span></p><p data-lake-id=\"uf77b621c\"><br /></p><h3 id=\"hrR0T\"><span>声明方式</span></h3><p data-lake-id=\"u929699fa\"><span>一般的函数使用 function 声明，return 作为回调，只可以回调 1 次。而 Generator 函数使用 function* 定义，除了 return，还可以使用 yield 返回多次</span></p><pre data-lang=\"javascript\"><code>function* foo(x) {\n\tyield x + 1\n  yield x + 2\n  return x + 3\n}\nconst res = foo(0) // foo {&lt;suspended&gt;}\nres.next() // { value: 1, done: false }\nres.next() // { value: 2, done: false }\nres.next() // { value: 3, done: true }\nres.next() // { value: undefined, done: true }</code></pre><blockquote class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"u00091da8\"><span>在上面的例子中，可以看到，在执行 foo 函数后返回了一个 Generator 函数的实例。它具有 suspended 和 closed，suspended 代表暂停，closed 则为结束，但是这个状态是无法捕获的，我们只能通过 Generator 函数提供的方法获取当前的状态。在执行 next 方法后，顺序执行了 yield 的返回值。返回值有 value 和 done 两个状态。value 为返回值，可以是任意类型。done 的状态为 true/false，true 即为执行完毕。在执行完毕后再次调用返回 </span><code><span>{ value: undefined, done: true }</span></code></p></blockquote><blockquote class=\"lake-alert lake-alert-warning\"><p data-lake-id=\"uddf3a8bb\"><span>注意：在遇到 return 的时候，所有剩下的 yield 不再执行，直接返回 </span><code><span>{ value: undefined, done: true }</span></code></p></blockquote><h3 id=\"MfcBU\"><span>方法介绍</span></h3><p data-lake-id=\"uc0dc5c6e\"><span>Generator 函数提供了 3 个方法：next、return、throw</span></p><ul><li><span>next：按步执行，每次返回一个值，同时也可以每次传入新的值作为计算</span></li><li><span>return：直接跳过所有步骤，直接返回 </span><code><span>{value: undefined, done: true}</span></code></li><li><span>throw：根据函数中书写 try...catch 返回 catch 中的内容，如果没有写 try，则直接抛出异常</span></li></ul><h3 id=\"CiLqY\"><span>遍历</span></h3><p data-lake-id=\"u4c6925de\"><span>Generator 函数的返回值是一个带有状态的 Generator 实例。它可以被 for...of 调用，进行遍历，并且仅仅只能被 for...of 调用</span></p><pre data-lang=\"javascript\"><code>function* foo(x) {\n\tconsole.log('start')\n  yield x + 1\n  console.log('state 1')\n  yield x + 2\n  console.log('end')\n}\n\nconst res = foo(0) // foo {&lt;suspended&gt;}\n\nfor (let i of res) {\n\tconsole.log(i)\n}\n// state -&gt; 1 -&gt; state 1 -&gt; 2 -&gt; end\nres.next() // { value: undefined, done: true }</code></pre><blockquote class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"u2aa2ba2a\"><span>调用 for...of 后，在后台调用 next()，当 done 属性为 true 的时候，循环退出。因此 Generator 函数的实例将顺序执行一遍，再次调用时，状态为已完成</span></p></blockquote><h3 id=\"e0vC2\"><span>状态存储和改变</span></h3><p data-lake-id=\"u09d57d2d\"><span>Generator 函数中 yield 返回的值是可以被变量存储和改变的</span></p><pre data-lang=\"javascript\"><code>function* foo(x) {\n\tlet a = yield x + 0\n  let b = yield a + 2\n  yield x\n  yield a\n  yield b\n}\nconst res = foo(0)\nres.next() // { value: 0, done: false }\nres.next(2) // { value: 4, done: false }\nres.next(3) // { value: 0, done: false }\nres.next(4) // { value: 2, done: false }\nres.next(5) // { value: 3, done: false }</code></pre><blockquote class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"u839c68f6\"><span>以上的执行结果中，我们可以看到，在第二步的时候，我们传入 2 这个参数，foo 函数中的 a 的变量的值 0 被替换为 2，并且在第 4 次迭代的时候，返回的是 2。而第三次迭代的时候，传入的 3 参数，替换了 b 的值 4，并在第 5 次迭代的时候返回了 3。所以传入的参数，是替代上一次迭代的生成值。</span></p></blockquote><h3 id=\"fSy0U\"><span>yield* 委托</span></h3><p data-lake-id=\"u15105ab1\"><span>在 Generator 函数中，我们有时需要将多个迭代器的值合并，我们可以使用 yield *  的形式，将执行委托给另外一个 Generator 函数</span></p><pre data-lang=\"javascript\"><code>function* foo1() {\n\tyield 1\n  yield 2\n  return 'foo1 end'\n}\nfunction* foo2() {\n\tyield 3\n  yield 4\n}\nfunction* foo() {\n  yield* foo1()\n  yield* foo2()\n  yield 5\n}\nconst result = foo()\nconsole.log(iterator.next()) // { value: 1, done: false }\nconsole.log(iterator.next()) // { value: 2, done: false }\nconsole.log(iterator.next()) // { value: 3, done: false }\nconsole.log(iterator.next()) // { value: 4, done: false }\nconsole.log(iterator.next()) // { value: 5, done: false }\nconsole.log(iterator.next()) // { value: undefined, done: true }</code></pre><blockquote class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"u3be90acd\"><span>foo 在执行的时候，首先委托给了 foo1，等 foo1 执行完毕，再委托给 foo2。但是我们发现，'foo1 end' 这一句并没有输出。在整个 Generator 中，return 只能有一次，在委托的时候，所有的 yield 都是以函数表达式的形式出现。return 的值是表达式的结果，在委托结束之前其内部都是暂停的，等待到表达式的结果的时候，将结果直接返回给 foo。此时 foo 内部没有接收到变量，所以未打印。如果我们希望捕获这个值，可以使用 yield foo() 的方式进行获取。</span></p></blockquote><h2 id=\"N7QiH\"><span>async 关键字</span></h2><h3 id=\"D0Rdx\"><span>实现原理</span></h3><p data-lake-id=\"u39d5bae5\"><span>async 函数是 Generator 函数的语法糖，使用关键字 async 来表示，在函数内部使用 await 来表示异步</span></p><h3 id=\"o0PiC\"><span>简单实现</span></h3><p data-lake-id=\"u9e7280f9\"><span>async/await 语法糖就是使用 </span><strong><span>Generator 函数 + 自动执行器</span></strong><span> 来运作的</span></p><pre data-lang=\"javascript\"><code>// 定义一个 promise，用来模拟异步请求，作用是传入参数\nfunction getNum(num) {\n\treturn new Promise((resolve, reject) =&gt; {\n  \tsetTimeout(() =&gt; {\n    \tresolve(num + 1)\n    }, 1000)\n  })\n}\n\n// 自动执行器，如果一个 Generator 函数没有执行完，则会递归调用\nfunction asyncFactory(fn) {\n\tconst gen = fn()\n  function next(data) {\n  \tconst res = gen.next(data)\n    if (res.done) return res.value\n    res.value.then(data =&gt; {\n    \tnext(data)\n    })\n  }\n  next()\n}\n\n// 所需要执行的 Generator 函数，内部的数据在执行完成一步的 promise 之后，再调用下一步\nconst fn = function* () {\n\tconst f1 = yield getNum(1)\n  const f2 = yield getNum(f1)\n  console.log(f2)\n}\n\nasyncFactory(fn)</code></pre><blockquote class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"uacbe9b4c\"><span>在执行过程中，判断一个函数的 promise 是否完成，如果已经完成，将结果传入下一个函数，继续重复此步骤</span></p></blockquote>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"kSwZu\" id=\"kSwZu\"><span data-lake-id=\"u0b8d7c4e\" id=\"u0b8d7c4e\">generator 函数</span></h2><h3 data-lake-id=\"RIwE0\" id=\"RIwE0\"><span data-lake-id=\"uf40a5105\" id=\"uf40a5105\">概念</span></h3><p data-lake-id=\"uabbfa020\" id=\"uabbfa020\"><span data-lake-id=\"udeb3fad0\" id=\"udeb3fad0\">Generator 是 ES6 标准引入的新的数据类型，Generator 可以理解为一个状态机，内部封装了很多状态，同时返回一个迭代器 Iterator 对象。可以通过这个迭代器遍历相关的值及状态。Generator 的显著特点是可以多次返回，每次的返回值作为迭代器的一部分保存下来，可以被我们显示调用。</span></p><p data-lake-id=\"uf77b621c\" id=\"uf77b621c\"><br></p><h3 data-lake-id=\"hrR0T\" id=\"hrR0T\"><span data-lake-id=\"u46bb1391\" id=\"u46bb1391\">声明方式</span></h3><p data-lake-id=\"u929699fa\" id=\"u929699fa\"><span data-lake-id=\"uf09b1ac2\" id=\"uf09b1ac2\">一般的函数使用 function 声明，return 作为回调，只可以回调 1 次。而 Generator 函数使用 function* 定义，除了 return，还可以使用 yield 返回多次</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function*%20foo(x)%20%7B%5Cn%5Ctyield%20x%20%2B%201%5Cn%20%20yield%20x%20%2B%202%5Cn%20%20return%20x%20%2B%203%5Cn%7D%5Cnconst%20res%20%3D%20foo(0)%20%2F%2F%20foo%20%7B%3Csuspended%3E%7D%5Cnres.next()%20%2F%2F%20%7B%20value%3A%201%2C%20done%3A%20false%20%7D%5Cnres.next()%20%2F%2F%20%7B%20value%3A%202%2C%20done%3A%20false%20%7D%5Cnres.next()%20%2F%2F%20%7B%20value%3A%203%2C%20done%3A%20true%20%7D%5Cnres.next()%20%2F%2F%20%7B%20value%3A%20undefined%2C%20done%3A%20true%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22eD4oL%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><blockquote data-lake-id=\"u941fe92b\" id=\"u941fe92b\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"u00091da8\" id=\"u00091da8\"><span data-lake-id=\"u0a0854ab\" id=\"u0a0854ab\">在上面的例子中，可以看到，在执行 foo 函数后返回了一个 Generator 函数的实例。它具有 suspended 和 closed，suspended 代表暂停，closed 则为结束，但是这个状态是无法捕获的，我们只能通过 Generator 函数提供的方法获取当前的状态。在执行 next 方法后，顺序执行了 yield 的返回值。返回值有 value 和 done 两个状态。value 为返回值，可以是任意类型。done 的状态为 true/false，true 即为执行完毕。在执行完毕后再次调用返回 </span><code data-lake-id=\"ud3f79e7e\" id=\"ud3f79e7e\"><span data-lake-id=\"ue4ff016b\" id=\"ue4ff016b\">{ value: undefined, done: true }</span></code></p></blockquote><blockquote data-lake-id=\"u36f6cdde\" id=\"u36f6cdde\" class=\"lake-alert lake-alert-warning\"><p data-lake-id=\"uddf3a8bb\" id=\"uddf3a8bb\"><span data-lake-id=\"u34441175\" id=\"u34441175\">注意：在遇到 return 的时候，所有剩下的 yield 不再执行，直接返回 </span><code data-lake-id=\"u08248f7c\" id=\"u08248f7c\"><span data-lake-id=\"u1c0fd82a\" id=\"u1c0fd82a\">{ value: undefined, done: true }</span></code></p></blockquote><h3 data-lake-id=\"MfcBU\" id=\"MfcBU\"><span data-lake-id=\"u23d9f721\" id=\"u23d9f721\">方法介绍</span></h3><p data-lake-id=\"uc0dc5c6e\" id=\"uc0dc5c6e\"><span data-lake-id=\"u9bce544f\" id=\"u9bce544f\">Generator 函数提供了 3 个方法：next、return、throw</span></p><ul list=\"u06059895\"><li fid=\"ucddb7b63\" data-lake-id=\"ua6e00fac\" id=\"ua6e00fac\"><span data-lake-id=\"u8bdc2518\" id=\"u8bdc2518\">next：按步执行，每次返回一个值，同时也可以每次传入新的值作为计算</span></li><li fid=\"ucddb7b63\" data-lake-id=\"u8c4e133a\" id=\"u8c4e133a\"><span data-lake-id=\"u38e224d5\" id=\"u38e224d5\">return：直接跳过所有步骤，直接返回 </span><code data-lake-id=\"ufad40a42\" id=\"ufad40a42\"><span data-lake-id=\"ua0ae0ef2\" id=\"ua0ae0ef2\">{value: undefined, done: true}</span></code></li><li fid=\"ucddb7b63\" data-lake-id=\"u6186aa0d\" id=\"u6186aa0d\"><span data-lake-id=\"u27c0826f\" id=\"u27c0826f\">throw：根据函数中书写 try...catch 返回 catch 中的内容，如果没有写 try，则直接抛出异常</span></li></ul><h3 data-lake-id=\"CiLqY\" id=\"CiLqY\"><span data-lake-id=\"u0b49aa90\" id=\"u0b49aa90\">遍历</span></h3><p data-lake-id=\"u4c6925de\" id=\"u4c6925de\"><span data-lake-id=\"u7dbf0368\" id=\"u7dbf0368\">Generator 函数的返回值是一个带有状态的 Generator 实例。它可以被 for...of 调用，进行遍历，并且仅仅只能被 for...of 调用</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function*%20foo(x)%20%7B%5Cn%5Ctconsole.log('start')%5Cn%20%20yield%20x%20%2B%201%5Cn%20%20console.log('state%201')%5Cn%20%20yield%20x%20%2B%202%5Cn%20%20console.log('end')%5Cn%7D%5Cn%5Cnconst%20res%20%3D%20foo(0)%20%2F%2F%20foo%20%7B%3Csuspended%3E%7D%5Cn%5Cnfor%20(let%20i%20of%20res)%20%7B%5Cn%5Ctconsole.log(i)%5Cn%7D%5Cn%2F%2F%20state%20-%3E%201%20-%3E%20state%201%20-%3E%202%20-%3E%20end%5Cnres.next()%20%2F%2F%20%7B%20value%3A%20undefined%2C%20done%3A%20true%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22k5W61%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><blockquote data-lake-id=\"u0269d8e2\" id=\"u0269d8e2\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"u2aa2ba2a\" id=\"u2aa2ba2a\"><span data-lake-id=\"u8fc047e0\" id=\"u8fc047e0\">调用 for...of 后，在后台调用 next()，当 done 属性为 true 的时候，循环退出。因此 Generator 函数的实例将顺序执行一遍，再次调用时，状态为已完成</span></p></blockquote><h3 data-lake-id=\"e0vC2\" id=\"e0vC2\"><span data-lake-id=\"u8e617e78\" id=\"u8e617e78\">状态存储和改变</span></h3><p data-lake-id=\"u09d57d2d\" id=\"u09d57d2d\"><span data-lake-id=\"u331ff377\" id=\"u331ff377\">Generator 函数中 yield 返回的值是可以被变量存储和改变的</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function*%20foo(x)%20%7B%5Cn%5Ctlet%20a%20%3D%20yield%20x%20%2B%200%5Cn%20%20let%20b%20%3D%20yield%20a%20%2B%202%5Cn%20%20yield%20x%5Cn%20%20yield%20a%5Cn%20%20yield%20b%5Cn%7D%5Cnconst%20res%20%3D%20foo(0)%5Cnres.next()%20%2F%2F%20%7B%20value%3A%200%2C%20done%3A%20false%20%7D%5Cnres.next(2)%20%2F%2F%20%7B%20value%3A%204%2C%20done%3A%20false%20%7D%5Cnres.next(3)%20%2F%2F%20%7B%20value%3A%200%2C%20done%3A%20false%20%7D%5Cnres.next(4)%20%2F%2F%20%7B%20value%3A%202%2C%20done%3A%20false%20%7D%5Cnres.next(5)%20%2F%2F%20%7B%20value%3A%203%2C%20done%3A%20false%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22pvTNo%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><blockquote data-lake-id=\"u3346c537\" id=\"u3346c537\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"u839c68f6\" id=\"u839c68f6\"><span data-lake-id=\"u88ee1fda\" id=\"u88ee1fda\">以上的执行结果中，我们可以看到，在第二步的时候，我们传入 2 这个参数，foo 函数中的 a 的变量的值 0 被替换为 2，并且在第 4 次迭代的时候，返回的是 2。而第三次迭代的时候，传入的 3 参数，替换了 b 的值 4，并在第 5 次迭代的时候返回了 3。所以传入的参数，是替代上一次迭代的生成值。</span></p></blockquote><h3 data-lake-id=\"fSy0U\" id=\"fSy0U\"><span data-lake-id=\"ub817f626\" id=\"ub817f626\">yield* 委托</span></h3><p data-lake-id=\"u15105ab1\" id=\"u15105ab1\"><span data-lake-id=\"u8f40fed7\" id=\"u8f40fed7\">在 Generator 函数中，我们有时需要将多个迭代器的值合并，我们可以使用 yield *  的形式，将执行委托给另外一个 Generator 函数</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function*%20foo1()%20%7B%5Cn%5Ctyield%201%5Cn%20%20yield%202%5Cn%20%20return%20'foo1%20end'%5Cn%7D%5Cnfunction*%20foo2()%20%7B%5Cn%5Ctyield%203%5Cn%20%20yield%204%5Cn%7D%5Cnfunction*%20foo()%20%7B%5Cn%20%20yield*%20foo1()%5Cn%20%20yield*%20foo2()%5Cn%20%20yield%205%5Cn%7D%5Cnconst%20result%20%3D%20foo()%5Cnconsole.log(iterator.next())%20%2F%2F%20%7B%20value%3A%201%2C%20done%3A%20false%20%7D%5Cnconsole.log(iterator.next())%20%2F%2F%20%7B%20value%3A%202%2C%20done%3A%20false%20%7D%5Cnconsole.log(iterator.next())%20%2F%2F%20%7B%20value%3A%203%2C%20done%3A%20false%20%7D%5Cnconsole.log(iterator.next())%20%2F%2F%20%7B%20value%3A%204%2C%20done%3A%20false%20%7D%5Cnconsole.log(iterator.next())%20%2F%2F%20%7B%20value%3A%205%2C%20done%3A%20false%20%7D%5Cnconsole.log(iterator.next())%20%2F%2F%20%7B%20value%3A%20undefined%2C%20done%3A%20true%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22NjL8Q%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><blockquote data-lake-id=\"ucf478fc2\" id=\"ucf478fc2\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"u3be90acd\" id=\"u3be90acd\"><span data-lake-id=\"u71a8e289\" id=\"u71a8e289\">foo 在执行的时候，首先委托给了 foo1，等 foo1 执行完毕，再委托给 foo2。但是我们发现，'foo1 end' 这一句并没有输出。在整个 Generator 中，return 只能有一次，在委托的时候，所有的 yield 都是以函数表达式的形式出现。return 的值是表达式的结果，在委托结束之前其内部都是暂停的，等待到表达式的结果的时候，将结果直接返回给 foo。此时 foo 内部没有接收到变量，所以未打印。如果我们希望捕获这个值，可以使用 yield foo() 的方式进行获取。</span></p></blockquote><h2 data-lake-id=\"N7QiH\" id=\"N7QiH\"><span data-lake-id=\"u70676307\" id=\"u70676307\">async 关键字</span></h2><h3 data-lake-id=\"D0Rdx\" id=\"D0Rdx\"><span data-lake-id=\"u52b7e45f\" id=\"u52b7e45f\">实现原理</span></h3><p data-lake-id=\"u39d5bae5\" id=\"u39d5bae5\"><span data-lake-id=\"u56fb4fdd\" id=\"u56fb4fdd\">async 函数是 Generator 函数的语法糖，使用关键字 async 来表示，在函数内部使用 await 来表示异步</span></p><h3 data-lake-id=\"o0PiC\" id=\"o0PiC\"><span data-lake-id=\"ud68ece16\" id=\"ud68ece16\">简单实现</span></h3><p data-lake-id=\"u9e7280f9\" id=\"u9e7280f9\"><span data-lake-id=\"u386bbcd3\" id=\"u386bbcd3\">async/await 语法糖就是使用 </span><strong><span data-lake-id=\"uf5b26993\" id=\"uf5b26993\">Generator 函数 + 自动执行器</span></strong><span data-lake-id=\"u344236bd\" id=\"u344236bd\"> 来运作的</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%20promise%EF%BC%8C%E7%94%A8%E6%9D%A5%E6%A8%A1%E6%8B%9F%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%5Cnfunction%20getNum(num)%20%7B%5Cn%5Ctreturn%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%5Cn%20%20%5CtsetTimeout(()%20%3D%3E%20%7B%5Cn%20%20%20%20%5Ctresolve(num%20%2B%201)%5Cn%20%20%20%20%7D%2C%201000)%5Cn%20%20%7D)%5Cn%7D%5Cn%5Cn%2F%2F%20%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%20Generator%20%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%E5%AE%8C%EF%BC%8C%E5%88%99%E4%BC%9A%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%5Cnfunction%20asyncFactory(fn)%20%7B%5Cn%5Ctconst%20gen%20%3D%20fn()%5Cn%20%20function%20next(data)%20%7B%5Cn%20%20%5Ctconst%20res%20%3D%20gen.next(data)%5Cn%20%20%20%20if%20(res.done)%20return%20res.value%5Cn%20%20%20%20res.value.then(data%20%3D%3E%20%7B%5Cn%20%20%20%20%5Ctnext(data)%5Cn%20%20%20%20%7D)%5Cn%20%20%7D%5Cn%20%20next()%5Cn%7D%5Cn%5Cn%2F%2F%20%E6%89%80%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%20Generator%20%E5%87%BD%E6%95%B0%EF%BC%8C%E5%86%85%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90%E4%B8%80%E6%AD%A5%E7%9A%84%20promise%20%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%86%8D%E8%B0%83%E7%94%A8%E4%B8%8B%E4%B8%80%E6%AD%A5%5Cnconst%20fn%20%3D%20function*%20()%20%7B%5Cn%5Ctconst%20f1%20%3D%20yield%20getNum(1)%5Cn%20%20const%20f2%20%3D%20yield%20getNum(f1)%5Cn%20%20console.log(f2)%5Cn%7D%5Cn%5CnasyncFactory(fn)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22zwZnH%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><blockquote data-lake-id=\"u55c034f6\" id=\"u55c034f6\" class=\"lake-alert lake-alert-tips\"><p data-lake-id=\"uacbe9b4c\" id=\"uacbe9b4c\"><span data-lake-id=\"u0fed97cb\" id=\"u0fed97cb\">在执行过程中，判断一个函数的 promise 是否完成，如果已经完成，将结果传入下一个函数，继续重复此步骤</span></p></blockquote>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:32:58.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:58.000Z",
  "updated_at": "2022-05-10T15:12:41.000Z",
  "published_at": "2022-04-04T11:32:58.000Z",
  "first_published_at": "2022-04-04T11:32:57.542Z",
  "word_count": 1472,
  "cover": null,
  "description": "generator 函数概念Generator 是 ES6 标准引入的新的数据类型，Generator 可以理解为一个状态机，内部封装了很多状态，同时返回一个迭代器 Iterator 对象。可以通过这个迭代器遍历相关的值及状态。Generator 的显著特点是可以多次返回，每次的返回值作为迭代...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}