{
  "id": 72212052,
  "slug": "hmvf8u",
  "title": "虚拟 dom",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "在原生的 `JavaScript` 程序中，我们直接对 `DOM` 进行创建和更改，而 `DOM` 元素通过我们监听的事件和我们的应用程序进行通讯。<br />而 `React` 会先将你的代码转换成一个 `JavaScript` 对象，然后这个 `JavaScript` 对象再转换成真实 `DOM`。这个 `JavaScript` 对象就是所谓的虚拟 `DOM`。<br />当我们需要创建或更新元素时， `React` 首先会让这个 `VitrualDom` 对象进行创建和更改，然后再将 `VitrualDom` 对象渲染成真实 `DOM`。<br />当我们需要对 `DOM` 进行事件监听时，首先对 `VitrualDom` 进行事件监听， `VitrualDom` 会代理原生的 `DOM` 事件从而做出响应。\n\n<a name=\"k4XyL\"></a>\n### 虚拟 dom 的引入与直接操作原生 dom 相比，哪一个效率更高\n虚拟 `DOM` 相对原生的 `DOM` 不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 `DOM` 的操作无论如何都不可能比真实的 `DOM` 操作更快。在首次渲染大量 `DOM` 时，由于多了一层虚拟 `DOM` 的计算，虚拟 `DOM` 也会比 `innerHTML` 插入慢。它能保证性能下限，在真实 `DOM` 操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。\n\n在整个 `DOM` 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验/研发效率。虚拟 `DOM` 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 `DOM` 并不一定会带来更好的性能，`React` 官方也从来没有把虚拟 `DOM` 作为性能层面的卖点对外输出过。**虚拟 **`**DOM**`** 的优越之处在于：它能够在提供更爽、更高效的研发模式（也就是函数式的 **`**UI**`** 编程方式）的同时，仍然保持一个还不错的性能。**\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u7eb8104a\" class=\"ne-p\" style=\"text-align: justify; text-indent: 2em\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">在原生的 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">JavaScript</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 程序中，我们直接对 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">DOM</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 进行创建和更改，而 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">DOM</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 元素通过我们监听的事件和我们的应用程序进行通讯。</span></p><p id=\"u00230e26\" class=\"ne-p\" style=\"text-align: justify; text-indent: 2em\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">而 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">React</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 会先将你的代码转换成一个 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">JavaScript</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 对象，然后这个 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">JavaScript</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 对象再转换成真实 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">DOM</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">。这个 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">JavaScript</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 对象就是所谓的虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">DOM</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">。</span></p><p id=\"u6caa0c87\" class=\"ne-p\" style=\"text-align: justify; text-indent: 2em\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">当我们需要创建或更新元素时， </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">React</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 首先会让这个 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">VitrualDom</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 对象进行创建和更改，然后再将 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">VitrualDom</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 对象渲染成真实 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">DOM</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">。</span></p><p id=\"ud24f4702\" class=\"ne-p\" style=\"text-align: justify; text-indent: 2em\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">当我们需要对 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">DOM</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 进行事件监听时，首先对 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">VitrualDom</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 进行事件监听， </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">VitrualDom</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 会代理原生的 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\">DOM</span></code><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"> 事件从而做出响应。</span></p><p id=\"u191b9304\" class=\"ne-p\" style=\"text-align: justify; text-indent: 2em\"><span class=\"ne-text\" style=\"font-size: 16px; color: rgb(68, 68, 68)\"></span></p><h3 id=\"k4XyL\"><span class=\"ne-text\">虚拟 dom 的引入与直接操作原生 dom 相比，哪一个效率更高</span></h3><p id=\"u83df2bb2\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 相对原生的 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 的操作无论如何都不可能比真实的 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 操作更快。在首次渲染大量 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 时，由于多了一层虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 的计算，虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 也会比 </span><code class=\"ne-code\"><span class=\"ne-text\">innerHTML</span></code><span class=\"ne-text\"> 插入慢。它能保证性能下限，在真实 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。</span></p><p id=\"ua2c27f9e\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u89564277\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\">在整个 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验/研发效率。虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 并不一定会带来更好的性能，</span><code class=\"ne-code\"><span class=\"ne-text\">React</span></code><span class=\"ne-text\"> 官方也从来没有把虚拟 </span><code class=\"ne-code\"><span class=\"ne-text\">DOM</span></code><span class=\"ne-text\"> 作为性能层面的卖点对外输出过。</span><strong><span class=\"ne-text\">虚拟 </span></strong><code class=\"ne-code\"><strong><span class=\"ne-text\">DOM</span></strong></code><strong><span class=\"ne-text\"> 的优越之处在于：它能够在提供更爽、更高效的研发模式（也就是函数式的 </span></strong><code class=\"ne-code\"><strong><span class=\"ne-text\">UI</span></strong></code><strong><span class=\"ne-text\"> 编程方式）的同时，仍然保持一个还不错的性能。</span></strong></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u7eb8104a\" id=\"u7eb8104a\" style=\"text-align: justify; text-indent: 2em\"><span data-lake-id=\"u9ca077b8\" id=\"u9ca077b8\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">在原生的 </span><code data-lake-id=\"ue3e01068\" id=\"ue3e01068\"><span data-lake-id=\"u1e79485f\" id=\"u1e79485f\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">JavaScript</span></code><span data-lake-id=\"u390b9e4d\" id=\"u390b9e4d\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 程序中，我们直接对 </span><code data-lake-id=\"ua8681b06\" id=\"ua8681b06\"><span data-lake-id=\"uef50e5d8\" id=\"uef50e5d8\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">DOM</span></code><span data-lake-id=\"uaf389c91\" id=\"uaf389c91\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 进行创建和更改，而 </span><code data-lake-id=\"u6a192749\" id=\"u6a192749\"><span data-lake-id=\"u395e2f63\" id=\"u395e2f63\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">DOM</span></code><span data-lake-id=\"uf7565eb5\" id=\"uf7565eb5\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 元素通过我们监听的事件和我们的应用程序进行通讯。</span></p><p data-lake-id=\"u00230e26\" id=\"u00230e26\" style=\"text-align: justify; text-indent: 2em\"><span data-lake-id=\"u03edef40\" id=\"u03edef40\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">而 </span><code data-lake-id=\"u6308678c\" id=\"u6308678c\"><span data-lake-id=\"u3658c2bb\" id=\"u3658c2bb\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">React</span></code><span data-lake-id=\"uaa313204\" id=\"uaa313204\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 会先将你的代码转换成一个 </span><code data-lake-id=\"ua054e543\" id=\"ua054e543\"><span data-lake-id=\"u1fe0b0df\" id=\"u1fe0b0df\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">JavaScript</span></code><span data-lake-id=\"ubea8e577\" id=\"ubea8e577\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 对象，然后这个 </span><code data-lake-id=\"u72943af1\" id=\"u72943af1\"><span data-lake-id=\"u234a55a0\" id=\"u234a55a0\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">JavaScript</span></code><span data-lake-id=\"u5df63cae\" id=\"u5df63cae\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 对象再转换成真实 </span><code data-lake-id=\"u1fa05b75\" id=\"u1fa05b75\"><span data-lake-id=\"u7965c2fd\" id=\"u7965c2fd\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">DOM</span></code><span data-lake-id=\"u98c4301b\" id=\"u98c4301b\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">。这个 </span><code data-lake-id=\"u0619945b\" id=\"u0619945b\"><span data-lake-id=\"ucb6742af\" id=\"ucb6742af\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">JavaScript</span></code><span data-lake-id=\"u82293152\" id=\"u82293152\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 对象就是所谓的虚拟 </span><code data-lake-id=\"u18032dff\" id=\"u18032dff\"><span data-lake-id=\"ue8606ba9\" id=\"ue8606ba9\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">DOM</span></code><span data-lake-id=\"u26e525e6\" id=\"u26e525e6\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">。</span></p><p data-lake-id=\"u6caa0c87\" id=\"u6caa0c87\" style=\"text-align: justify; text-indent: 2em\"><span data-lake-id=\"u835dabeb\" id=\"u835dabeb\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">当我们需要创建或更新元素时， </span><code data-lake-id=\"ua86c31b8\" id=\"ua86c31b8\"><span data-lake-id=\"ud1118349\" id=\"ud1118349\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">React</span></code><span data-lake-id=\"ua95956f0\" id=\"ua95956f0\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 首先会让这个 </span><code data-lake-id=\"u67cf3298\" id=\"u67cf3298\"><span data-lake-id=\"u850a92df\" id=\"u850a92df\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">VitrualDom</span></code><span data-lake-id=\"uf5ff6226\" id=\"uf5ff6226\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 对象进行创建和更改，然后再将 </span><code data-lake-id=\"u9fdae058\" id=\"u9fdae058\"><span data-lake-id=\"u05b2f8f0\" id=\"u05b2f8f0\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">VitrualDom</span></code><span data-lake-id=\"u67fc1663\" id=\"u67fc1663\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 对象渲染成真实 </span><code data-lake-id=\"u6cd521b4\" id=\"u6cd521b4\"><span data-lake-id=\"ub50b63ad\" id=\"ub50b63ad\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">DOM</span></code><span data-lake-id=\"ub7661945\" id=\"ub7661945\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">。</span></p><p data-lake-id=\"ud24f4702\" id=\"ud24f4702\" style=\"text-align: justify; text-indent: 2em\"><span data-lake-id=\"u13149c8f\" id=\"u13149c8f\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">当我们需要对 </span><code data-lake-id=\"u8d429d45\" id=\"u8d429d45\"><span data-lake-id=\"u10019142\" id=\"u10019142\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">DOM</span></code><span data-lake-id=\"u875dcd9b\" id=\"u875dcd9b\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 进行事件监听时，首先对 </span><code data-lake-id=\"u392552d3\" id=\"u392552d3\"><span data-lake-id=\"ue170ccc3\" id=\"ue170ccc3\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">VitrualDom</span></code><span data-lake-id=\"uf5722d31\" id=\"uf5722d31\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 进行事件监听， </span><code data-lake-id=\"u2907091c\" id=\"u2907091c\"><span data-lake-id=\"ua44245ad\" id=\"ua44245ad\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">VitrualDom</span></code><span data-lake-id=\"ud3d2fa50\" id=\"ud3d2fa50\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 会代理原生的 </span><code data-lake-id=\"u75b14b7a\" id=\"u75b14b7a\"><span data-lake-id=\"ueffd9a59\" id=\"ueffd9a59\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">DOM</span></code><span data-lake-id=\"ud5918904\" id=\"ud5918904\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\"> 事件从而做出响应。</span></p><p data-lake-id=\"u191b9304\" id=\"u191b9304\" style=\"text-align: justify; text-indent: 2em\"><span data-lake-id=\"u8f044cff\" id=\"u8f044cff\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">​</span><br></p><h3 data-lake-id=\"k4XyL\" id=\"k4XyL\"><span data-lake-id=\"u35e04df7\" id=\"u35e04df7\">虚拟 dom 的引入与直接操作原生 dom 相比，哪一个效率更高</span></h3><p data-lake-id=\"u83df2bb2\" id=\"u83df2bb2\" style=\"text-indent: 2em\"><span data-lake-id=\"ua0f34c05\" id=\"ua0f34c05\">虚拟 </span><code data-lake-id=\"u0dcd49c9\" id=\"u0dcd49c9\"><span data-lake-id=\"uf13018fb\" id=\"uf13018fb\">DOM</span></code><span data-lake-id=\"u58ee3829\" id=\"u58ee3829\"> 相对原生的 </span><code data-lake-id=\"ua03627c9\" id=\"ua03627c9\"><span data-lake-id=\"ua2eb37df\" id=\"ua2eb37df\">DOM</span></code><span data-lake-id=\"ucd8fbf91\" id=\"ucd8fbf91\"> 不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 </span><code data-lake-id=\"u632bd60b\" id=\"u632bd60b\"><span data-lake-id=\"ud373ee02\" id=\"ud373ee02\">DOM</span></code><span data-lake-id=\"uc8b27473\" id=\"uc8b27473\"> 的操作无论如何都不可能比真实的 </span><code data-lake-id=\"uf46353a7\" id=\"uf46353a7\"><span data-lake-id=\"u292d0827\" id=\"u292d0827\">DOM</span></code><span data-lake-id=\"u174e82aa\" id=\"u174e82aa\"> 操作更快。在首次渲染大量 </span><code data-lake-id=\"u9cdbf5ce\" id=\"u9cdbf5ce\"><span data-lake-id=\"u98504d2e\" id=\"u98504d2e\">DOM</span></code><span data-lake-id=\"u66d4193b\" id=\"u66d4193b\"> 时，由于多了一层虚拟 </span><code data-lake-id=\"ube31a098\" id=\"ube31a098\"><span data-lake-id=\"ua8063f3f\" id=\"ua8063f3f\">DOM</span></code><span data-lake-id=\"u3d58d5ba\" id=\"u3d58d5ba\"> 的计算，虚拟 </span><code data-lake-id=\"u14b0c164\" id=\"u14b0c164\"><span data-lake-id=\"ua301ce9b\" id=\"ua301ce9b\">DOM</span></code><span data-lake-id=\"ucea904cf\" id=\"ucea904cf\"> 也会比 </span><code data-lake-id=\"u75188d67\" id=\"u75188d67\"><span data-lake-id=\"u04cd01bd\" id=\"u04cd01bd\">innerHTML</span></code><span data-lake-id=\"u1b82be0e\" id=\"u1b82be0e\"> 插入慢。它能保证性能下限，在真实 </span><code data-lake-id=\"u88291049\" id=\"u88291049\"><span data-lake-id=\"ueb03d90b\" id=\"ueb03d90b\">DOM</span></code><span data-lake-id=\"ud25ed8e3\" id=\"ud25ed8e3\"> 操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。</span></p><p data-lake-id=\"ua2c27f9e\" id=\"ua2c27f9e\"><span data-lake-id=\"u6f363f34\" id=\"u6f363f34\">​</span><br></p><p data-lake-id=\"u89564277\" id=\"u89564277\" style=\"text-indent: 2em\"><span data-lake-id=\"u709837e6\" id=\"u709837e6\">在整个 </span><code data-lake-id=\"uc248c4c4\" id=\"uc248c4c4\"><span data-lake-id=\"u8ae53e12\" id=\"u8ae53e12\">DOM</span></code><span data-lake-id=\"uf64cbb73\" id=\"uf64cbb73\"> 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验/研发效率。虚拟 </span><code data-lake-id=\"ue1f0d03e\" id=\"ue1f0d03e\"><span data-lake-id=\"uf7962bf6\" id=\"uf7962bf6\">DOM</span></code><span data-lake-id=\"u5a633dfc\" id=\"u5a633dfc\"> 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 </span><code data-lake-id=\"udc2b9b9a\" id=\"udc2b9b9a\"><span data-lake-id=\"uc728a526\" id=\"uc728a526\">DOM</span></code><span data-lake-id=\"ud852336f\" id=\"ud852336f\"> 并不一定会带来更好的性能，</span><code data-lake-id=\"ub345850e\" id=\"ub345850e\"><span data-lake-id=\"uf7af4222\" id=\"uf7af4222\">React</span></code><span data-lake-id=\"ufc682fcb\" id=\"ufc682fcb\"> 官方也从来没有把虚拟 </span><code data-lake-id=\"ua23d2050\" id=\"ua23d2050\"><span data-lake-id=\"u7e05135f\" id=\"u7e05135f\">DOM</span></code><span data-lake-id=\"u9760f593\" id=\"u9760f593\"> 作为性能层面的卖点对外输出过。</span><strong><span data-lake-id=\"u942c41f9\" id=\"u942c41f9\">虚拟 </span></strong><code data-lake-id=\"u4c78fb21\" id=\"u4c78fb21\"><strong><span data-lake-id=\"u6a8a7742\" id=\"u6a8a7742\">DOM</span></strong></code><strong><span data-lake-id=\"u280dcd40\" id=\"u280dcd40\"> 的优越之处在于：它能够在提供更爽、更高效的研发模式（也就是函数式的 </span></strong><code data-lake-id=\"u3a807f8f\" id=\"u3a807f8f\"><strong><span data-lake-id=\"u62ee6582\" id=\"u62ee6582\">UI</span></strong></code><strong><span data-lake-id=\"ua476a6f5\" id=\"ua476a6f5\"> 编程方式）的同时，仍然保持一个还不错的性能。</span></strong></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-28T16:48:06.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:32:44.000Z",
  "updated_at": "2022-04-28T16:48:06.000Z",
  "published_at": "2022-04-28T16:48:06.000Z",
  "first_published_at": "2022-04-04T11:32:44.484Z",
  "word_count": 543,
  "cover": null,
  "description": "在原生的 JavaScript 程序中，我们直接对 DOM 进行创建和更改，而 DOM 元素通过我们监听的事件和我们的应用程序进行通讯。而 React 会先将你的代码转换成一个 JavaScript 对象，然后这个 JavaScript 对象再转换成真实 DOM。这个 JavaScript 对...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}