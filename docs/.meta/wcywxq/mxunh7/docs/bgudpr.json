{
  "id": 72212195,
  "slug": "bgudpr",
  "title": "实现原理",
  "book_id": 26225124,
  "book": {
    "id": 26225124,
    "type": "Book",
    "slug": "mxunh7",
    "name": "八股文 eight-part essay writing",
    "user_id": 732231,
    "description": "前端八股文",
    "creator_id": 732231,
    "public": 0,
    "items_count": 239,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:57.023Z",
    "updated_at": "2023-11-11T18:15:57.000Z",
    "created_at": "2022-04-04T11:31:45.000Z",
    "namespace": "wcywxq/mxunh7",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "vue-router 通过 hash 和 history 两种方式实现前端路由。更新视图但不重新请求页面，而是前端路由原理的核心之一。\n<a name=\"L1bbR\"></a>\n## hash 模式和 history 模式\n\nhash 采用了 window.location.hash 的值来获取 URL 中 # 后面的内容。\n:::info\n**hash 特点：**<br />hash 虽然出现在 url 中，但不会被包含在 http 请求中，他是用来描述浏览器动作的，但是对服务端无效。因此改变 hash 不会重新加载页面，每一次改变 hash，都会在浏览器历史中增加一个记录，利用 hash 的这些特点，就可以实现前端路由。\n:::\n\nhistory 实际采用了HTML5 中提供的 API 来实现。主要有 history.pushState() 和 history.replaceState()。\n:::info\n**pushState 和 replaceState 共同特点：**<br />当前调用他们修改浏览器历史栈后，虽然当前 url 改变了，但浏览器不会立即发送请求 url，这就为单页面前端路由、更新视图但不重新请求页面提供了基础。\n:::\n:::danger\nhistory 模式需要后面服务器进行路径重写，否则会出现 404 错误\n:::\n<a name=\"u1zti\"></a>\n## router-link 和 $router.push 实现原理\n<a name=\"DcQFK\"></a>\n### router-link\n默认会被渲染为 a 标签，可以通过 tag 属性修改为其他标签。自动为 a 标签添加 click 时间，然后执行 $router.push 实现跳转\n<a name=\"WWbJU\"></a>\n### $router.push\n根据路由配置的 mode 确定使用 html5 history 还是 hash history 来实现跳转\n\n- html5 history：调用 window.history.pushState() 跳转\n- hash history：调用 HashHistory.push() 跳转\n",
  "body_draft": "",
  "body_html": "<!doctype html><p data-lake-id=\"u5958132c\"><span>vue-router 通过 hash 和 history 两种方式实现前端路由。更新视图但不重新请求页面，而是前端路由原理的核心之一。</span></p><h2 id=\"L1bbR\"><span>hash 模式和 history 模式</span></h2><p data-lake-id=\"u1d564c63\"><span>​</span><br /></p><p data-lake-id=\"u3d13c720\" style=\"text-align: justify;\"><span class=\"lake-fontsize-12\" style=\"color: #444444;\">hash 采用了 window.location.hash 的值来获取 URL 中 # 后面的内容。</span></p><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u9bb8c512\" style=\"text-align: justify;\"><strong><span class=\"lake-fontsize-12\" style=\"color: #444444;\">hash 特点：</span></strong></p><p data-lake-id=\"ucc37240c\" style=\"text-align: justify; text-indent: 2em;\"><span class=\"lake-fontsize-12\" style=\"color: #444444;\">hash 虽然出现在 url 中，但不会被包含在 http 请求中，他是用来描述浏览器动作的，但是对服务端无效。因此改变 hash 不会重新加载页面，每一次改变 hash，都会在浏览器历史中增加一个记录，利用 hash 的这些特点，就可以实现前端路由。</span></p></blockquote><p data-lake-id=\"u2cff36c5\" style=\"text-align: justify;\"><span class=\"lake-fontsize-12\" style=\"color: #444444;\">​</span><br /></p><p data-lake-id=\"u5d7597ed\" style=\"text-align: justify;\"><span class=\"lake-fontsize-12\" style=\"color: #444444;\">history 实际采用了HTML5 中提供的 API 来实现。主要有 history.pushState() 和 history.replaceState()。</span></p><blockquote class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u1653f277\" style=\"text-align: justify;\"><strong><span class=\"lake-fontsize-12\" style=\"color: #444444;\">pushState 和 replaceState 共同特点：</span></strong></p><p data-lake-id=\"ucf990a56\" style=\"text-align: justify; text-indent: 2em;\"><span class=\"lake-fontsize-12\" style=\"color: #444444;\">当前调用他们修改浏览器历史栈后，虽然当前 url 改变了，但浏览器不会立即发送请求 url，这就为单页面前端路由、更新视图但不重新请求页面提供了基础。</span></p></blockquote><blockquote class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"u2d1ca4a5\"><span>history 模式需要后面服务器进行路径重写，否则会出现 404 错误</span></p></blockquote><h2 id=\"u1zti\"><span>router-link 和 $router.push 实现原理</span></h2><h3 id=\"DcQFK\"><span>router-link</span></h3><p data-lake-id=\"uf1beb0e8\"><span>默认会被渲染为 a 标签，可以通过 tag 属性修改为其他标签。自动为 a 标签添加 click 时间，然后执行 $router.push 实现跳转</span></p><h3 id=\"WWbJU\"><span>$router.push</span></h3><p data-lake-id=\"u6cfc1371\"><span>根据路由配置的 mode 确定使用 html5 history 还是 hash history 来实现跳转</span></p><ul><li><span>html5 history：调用 window.history.pushState() 跳转</span></li><li><span>hash history：调用 HashHistory.push() 跳转</span></li></ul>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u5958132c\" id=\"u5958132c\"><span data-lake-id=\"ub0d621e8\" id=\"ub0d621e8\">vue-router 通过 hash 和 history 两种方式实现前端路由。更新视图但不重新请求页面，而是前端路由原理的核心之一。</span></p><h2 data-lake-id=\"L1bbR\" id=\"L1bbR\"><span data-lake-id=\"uefd16518\" id=\"uefd16518\">hash 模式和 history 模式</span></h2><p data-lake-id=\"u1d564c63\" id=\"u1d564c63\"><span data-lake-id=\"ua3c8105c\" id=\"ua3c8105c\">​</span><br></p><p data-lake-id=\"u3d13c720\" id=\"u3d13c720\" style=\"text-align: justify\"><span data-lake-id=\"ud38479c9\" id=\"ud38479c9\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">hash 采用了 window.location.hash 的值来获取 URL 中 # 后面的内容。</span></p><blockquote data-lake-id=\"u88732407\" id=\"u88732407\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u9bb8c512\" id=\"u9bb8c512\" style=\"text-align: justify\"><strong><span data-lake-id=\"ue51c1f0e\" id=\"ue51c1f0e\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">hash 特点：</span></strong></p><p data-lake-id=\"ucc37240c\" id=\"ucc37240c\" style=\"text-align: justify; text-indent: 2em\"><span data-lake-id=\"uf3e91554\" id=\"uf3e91554\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">hash 虽然出现在 url 中，但不会被包含在 http 请求中，他是用来描述浏览器动作的，但是对服务端无效。因此改变 hash 不会重新加载页面，每一次改变 hash，都会在浏览器历史中增加一个记录，利用 hash 的这些特点，就可以实现前端路由。</span></p></blockquote><p data-lake-id=\"u2cff36c5\" id=\"u2cff36c5\" style=\"text-align: justify\"><span data-lake-id=\"ucaf9c140\" id=\"ucaf9c140\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">​</span><br></p><p data-lake-id=\"u5d7597ed\" id=\"u5d7597ed\" style=\"text-align: justify\"><span data-lake-id=\"u3f9877f6\" id=\"u3f9877f6\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">history 实际采用了HTML5 中提供的 API 来实现。主要有 history.pushState() 和 history.replaceState()。</span></p><blockquote data-lake-id=\"u66dd0712\" id=\"u66dd0712\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u1653f277\" id=\"u1653f277\" style=\"text-align: justify\"><strong><span data-lake-id=\"u7d354e69\" id=\"u7d354e69\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">pushState 和 replaceState 共同特点：</span></strong></p><p data-lake-id=\"ucf990a56\" id=\"ucf990a56\" style=\"text-align: justify; text-indent: 2em\"><span data-lake-id=\"u7c890bb7\" id=\"u7c890bb7\" class=\"lake-fontsize-12\" style=\"color: rgb(68, 68, 68)\">当前调用他们修改浏览器历史栈后，虽然当前 url 改变了，但浏览器不会立即发送请求 url，这就为单页面前端路由、更新视图但不重新请求页面提供了基础。</span></p></blockquote><blockquote data-lake-id=\"uf0e73821\" id=\"uf0e73821\" class=\"lake-alert lake-alert-danger\"><p data-lake-id=\"u2d1ca4a5\" id=\"u2d1ca4a5\"><span data-lake-id=\"u7a902207\" id=\"u7a902207\">history 模式需要后面服务器进行路径重写，否则会出现 404 错误</span></p></blockquote><h2 data-lake-id=\"u1zti\" id=\"u1zti\"><span data-lake-id=\"u10972f46\" id=\"u10972f46\">router-link 和 $router.push 实现原理</span></h2><h3 data-lake-id=\"DcQFK\" id=\"DcQFK\"><span data-lake-id=\"u5dcbf95b\" id=\"u5dcbf95b\">router-link</span></h3><p data-lake-id=\"uf1beb0e8\" id=\"uf1beb0e8\"><span data-lake-id=\"u7f7a9cc3\" id=\"u7f7a9cc3\">默认会被渲染为 a 标签，可以通过 tag 属性修改为其他标签。自动为 a 标签添加 click 时间，然后执行 $router.push 实现跳转</span></p><h3 data-lake-id=\"WWbJU\" id=\"WWbJU\"><span data-lake-id=\"u1114d211\" id=\"u1114d211\">$router.push</span></h3><p data-lake-id=\"u6cfc1371\" id=\"u6cfc1371\"><span data-lake-id=\"u1a58c413\" id=\"u1a58c413\">根据路由配置的 mode 确定使用 html5 history 还是 hash history 来实现跳转</span></p><ul list=\"u90542e47\"><li fid=\"u822e52c8\" data-lake-id=\"u35dd721c\" id=\"u35dd721c\"><span data-lake-id=\"u339feb13\" id=\"u339feb13\">html5 history：调用 window.history.pushState() 跳转</span></li><li fid=\"u822e52c8\" data-lake-id=\"ue1b7d02d\" id=\"ue1b7d02d\"><span data-lake-id=\"u693c7bfd\" id=\"u693c7bfd\">hash history：调用 HashHistory.push() 跳转</span></li></ul>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-04-04T11:33:33.000Z",
  "deleted_at": null,
  "created_at": "2022-04-04T11:33:33.000Z",
  "updated_at": "2022-05-10T15:12:36.000Z",
  "published_at": "2022-04-04T11:33:33.000Z",
  "first_published_at": "2022-04-04T11:33:33.348Z",
  "word_count": 392,
  "cover": null,
  "description": "vue-router 通过 hash 和 history 两种方式实现前端路由。更新视图但不重新请求页面，而是前端路由原理的核心之一。hash 模式和 history 模式hash 采用了 window.location.hash 的值来获取 URL 中 # 后面的内容。hash 特点：has...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}