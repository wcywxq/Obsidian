{
  "id": 11435960,
  "slug": "ub10iw",
  "title": "集合",
  "book_id": 24854102,
  "book": {
    "id": 24854102,
    "type": "Book",
    "slug": "gm8h7g",
    "name": "算法 algorithm",
    "user_id": 732231,
    "description": "算法基础、leetCode",
    "creator_id": 732231,
    "public": 0,
    "items_count": 18,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:30.855Z",
    "updated_at": "2023-11-11T18:15:31.000Z",
    "created_at": "2022-02-21T07:49:26.000Z",
    "namespace": "wcywxq/gm8h7g",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 18,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-13T09:32:35.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 732231,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 18,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-13T09:32:35.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "[链接](https://www.cnblogs.com/jaxu/p/11287315.html)<br />\n\n与数学中的集合概念类似，集合由一组无序的元素组成，且集合中的每个元素都是唯一存在的。可以回顾一下中学数学中集合的概念，我们这里所要定义的集合也具有空集（即集合的内容为空）、交集、并集、差集、子集的特性。<br />在 ES6 中，原生的 Set 类已经实现了集合的全部特性，稍后我们会介绍它的用法。<br />我们使用 JavaSctipt 的对象来表示集合，下面是集合类的主要实现方法：<br />\n\n```javascript\nclass Set {\n    constructor() {\n        this.items = {}\n    }\n\n    add(value) {\n        // 向集合中添加元素\n        if (!this.has(value)) {\n            this.items[value] = value\n            return true\n        }\n        return false\n    }\n\n    delete(value) {\n        // 从集合中删除对应的元素\n        if (this.has(value)) {\n            delete this.items[value]\n            return true\n        }\n        return false\n    }\n\n    has(value) {\n        // 判断给定的元素在集合中是否存在\n        return this.items.hasOwnProperty(value)\n    }\n\n    clear() {\n        // 清空集合内容\n        this.items = {}\n    }\n\n    size() {\n        // 获取集合的长度\n        return Object.keys(this.items).length\n    }\n\n    values() {\n        // 返回集合中所有元素的内容\n        return Object.values(this.items)\n    }\n}\n```\n\n在使用 JavaScript 对象{ }来表示集合时，我们可以像操作数组一样通过[ ]来设置和获取集合内元素的值。通过这种方式，在设置集合元素的值时，如果元素不存在，则创建一个新元素，如果元素存在，则修改对应的值；在获取集合元素的值时，如果元素存在，则返回对应的值，如果元素不存在，则返回 undefined。此外，JavaScript 对象还提供了一些基础方法以方便我们对集合进行一些操作，例如 hasOwenProperty()方法返回一个表明对象是否具有特定属性的布尔值，Object.keys()方法返回指定对象的所有属性名称的数组，Object.values()方法方法指定对象的所有属性值的数组。<br />上述代码很简单，这里就不再详细解释了。下面是一些测试用例和测试结果：<br />\n\n```javascript\nlet set = new Set()\nset.add(1)\nconsole.log(set.values()) // [ 1 ]\nconsole.log(set.has(1)) // true\nconsole.log(set.size()) // 1\n\nset.add(2)\nconsole.log(set.values()) // [ 1, 2 ]\nconsole.log(set.has(2)) // true\nconsole.log(set.size()) // 2\n\nset.delete(1)\nconsole.log(set.values()) // [ 2 ]\n\nset.delete(2)\nconsole.log(set.values()) // []\n```\n\n下面我们来看看集合的数学运算：并集、交集、差集、子集。\n\n<a name=\"c4d10be6\"></a>\n### 并集\n\n对于给定的两个集合，并集返回一个包含两个集合中所有元素的新集合。示意图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368291000-33752d8e-74a9-4dec-adc2-754f613ea52d.png#clientId=u57a81b8d-3e62-4&from=paste&id=ud956b69d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=410&originalType=url&ratio=1&size=14644&status=done&style=none&taskId=udc2fe1d1-fe39-4d66-882e-5a81aacb8cb#id=usqpl&originHeight=290&originWidth=410&originalType=binary&ratio=1&status=done&style=none)<br />并集的实现代码：<br />\n\n```javascript\nunion (otherSet) { // 并集\n    let unionSet = new Set();\n    this.values().forEach(value => unionSet.add(value));\n    otherSet.values().forEach(value => unionSet.add(value));\n    return unionSet;\n}\n```\n\n首先遍历第一个集合，将所有的元素添加到新集合中，然后再遍历第二个集合，将所有的元素添加到新集合中。然后返回新集合。不用担心会添加重复的元素，因为集合的 add()方法会自动排除掉已添加的元素。<br />测试用例及结果：\n\n```javascript\nlet setA = new Set()\nsetA.add(\"first\")\nsetA.add(\"second\")\nsetA.add(\"third\")\n\nlet setB = new Set()\nsetB.add(\"third\")\nsetB.add(\"fourth\")\nsetB.add(\"fifth\")\nsetB.add(\"sixth\")\n\nconsole.log(setA.union(setB).values()) // [ 'first', 'second', 'third', 'fourth', 'fifth', 'sixth' ]\n```\n\n<a name=\"5a48d8c5\"></a>\n### 交集\n\n对于给定的两个集合，交集返回一个包含两个集合中共有元素的新集合。示意图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368317389-e49911e6-ca1a-440b-b454-e5b4b68f2584.png#clientId=u57a81b8d-3e62-4&from=paste&id=u6a7f3a65&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=410&originalType=url&ratio=1&size=12269&status=done&style=none&taskId=u067af691-1849-46c7-a246-d6b4f226f3f#id=ra6DZ&originHeight=290&originWidth=410&originalType=binary&ratio=1&status=done&style=none)<br />交集的实现代码：\n\n```javascript\nintersection (otherSet) { // 交集\n    let intersectionSet = new Set();\n    this.values().forEach(value => {\n       if (otherSet.has(value)) intersectionSet.add(value);\n    });\n    return intersectionSet;\n}\n```\n\n遍历第一个集合，如果元素出现在第二个集合中，则将它添加到新集合。然后返回新集合。<br />测试用例及结果：\n\n```javascript\nlet setA = new Set()\nsetA.add(\"first\")\nsetA.add(\"second\")\nsetA.add(\"third\")\n\nlet setB = new Set()\nsetB.add(\"second\")\nsetB.add(\"third\")\nsetB.add(\"fourth\")\n\nconsole.log(setA.intersection(setB).values()) // [ 'second', 'third' ]\n```\n\n<a name=\"e75b500f\"></a>\n### 差集\n\n对于给定的两个集合，差集返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。示意图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368342830-5ee4d804-f8a6-494d-aa9d-3d54aebc20aa.png#clientId=u57a81b8d-3e62-4&from=paste&id=uac4f74cb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=410&originalType=url&ratio=1&size=13913&status=done&style=none&taskId=u106e9d75-e01c-4dd7-947e-559896c3971#id=xZkpu&originHeight=290&originWidth=410&originalType=binary&ratio=1&status=done&style=none)<br />差集的实现代码：\n\n```javascript\ndifference (otherSet) { // 差集\n    let differenceSet = new Set();\n    this.values().forEach(value => {\n       if (!otherSet.has(value)) differenceSet.add(value);\n    });\n    return differenceSet;\n}\n```\n\n遍历第一个集合，如果元素没有出现在第二个集合中，则将它添加到新集合。然后返回新集合。<br />测试用例及结果：\n\n```javascript\nlet setA = new Set()\nsetA.add(\"first\")\nsetA.add(\"second\")\nsetA.add(\"third\")\n\nlet setB = new Set()\nsetB.add(\"second\")\nsetB.add(\"third\")\nsetB.add(\"fourth\")\n\nconsole.log(setA.difference(setB).values()) // [ 'first' ]\n```\n\n<a name=\"f6a25ee8\"></a>\n### 子集\n\n验证一个给定集合是否是另一个集合的子集，即判断给定的集合中的所有元素是否都存在于另一个集合中，如果是，则这个集合就是另一个集合的子集，反之则不是。示意图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368372311-38bd59f7-641a-42ae-ae94-1cb7536e4ed8.png#clientId=u57a81b8d-3e62-4&from=paste&id=u094c04dd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=410&originalType=url&ratio=1&size=12628&status=done&style=none&taskId=ub2e3bb05-2fcd-4d6a-be7c-dd43123842e#id=p3hP4&originHeight=290&originWidth=410&originalType=binary&ratio=1&status=done&style=none)<br />子集的实现代码：\n\n```javascript\nsubset (otherSet) { // 子集\n    if (this.size() > otherSet.size()) return false;\n\n    let isSubset = true;\n    this.values().every(value => {\n        if (!otherSet.has(value)) {\n            isSubset = false;\n            return false;\n        }\n        return true;\n    });\n\n    return isSubset;\n}\n```\n\n如果集合 A 比集合 B 的长度大，则直接返回 false，因为这种情况 A 不可能是 B 的子集。然后使用 every()函数遍历集合 A 的所有元素，一旦碰到其中的元素没有在集合 B 中出现，则直接返回 false，并终止遍历。这里我们没有使用 forEach 来遍历集合 A，是因为你无法根据某个条件来终止 forEach 循环。考虑下面这种情况：\n\n```javascript\nvar arr = [\"first\", \"second\", \"third\", \"fourth\"]\narr.forEach(item => {\n    if (item === \"third\") return true\n    console.log(item)\n})\n```\n\n输出结果是：\n\n```\nfirst\nsecond\nfourth\n```\n\n很显然，这里的 return true 语句并不能退出 forEach 循环，它只能保证本次循环中余下的语句不被执行，而接下来其它的元素还是会被遍历到。<br />在我们的 subset()方法中，如果使用 forEach 语句，每一次都会遍历集合中的所有元素，如果遇到其中的元素没有在集合 B 中出现，就将 isSubset 变量的值设置为 false，但并不能退出 forEach，isSubset 变量的值可能会被多次覆盖。为了提高执行效率，推荐使用 every()函数，它会遍历集合中的元素，直到其中一个返回结果为 false，就终止遍历，并返回 false，否则就遍历所有的元素并返回 true。有关 every()函数的详细介绍可以看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every)。与 every()函数功能相似还有一个 some()函数，它在遍历集合的过程中，遇到返回结果为 true 时就终止遍历，具体内容可以看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some)。<br />差集的测试用例及结果：\n\n```javascript\nlet setA = new Set()\nsetA.add(\"first\")\nsetA.add(\"second\")\n\nlet setB = new Set()\nsetB.add(\"first\")\nsetB.add(\"second\")\nsetB.add(\"third\")\n\nlet setC = new Set()\nsetC.add(\"second\")\nsetC.add(\"third\")\nsetC.add(\"fourth\")\n\nconsole.log(setA.subset(setB)) // true\nconsole.log(setA.subset(setC)) // false\n```\n\n文章的开头说过，ES6 提供了原生的 Set 类，让我们来看看它的一些使用方法：\n\n```javascript\nlet set = new Set()\nset.add(1)\nset.add(2)\nset.add(3)\nconsole.log(set.values()) // [Set Iterator] { 1, 2, 3 }\nconsole.log(set.has(1)) // true\nconsole.log(set.size) // 2\n\nset.delete(1)\nconsole.log(set.values()) // [Set Iterator] { 2, 3 }\n\nset.clear()\nconsole.log(set.values()) // [Set Iterator] {  }\n```\n\n和前面我们自定义的 Set 类稍微有一点不同，values()方法返回的不是一个数组，而是 Iterator 迭代器。另一个就是这里的 size 是一个属性而不是方法，其它部分都和我们前面定义的 Set 类相同。由于 ES6 的 Set 类不包含对集合的数学运算，我们可以按照前面我们提供的方法来对其进行扩充。\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><p id=\"uc7be4870\" class=\"ne-p\"><a href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">链接</span></a><span class=\"ne-text\"><br /></span><span class=\"ne-text\"></span></p><p id=\"u5d484a15\" class=\"ne-p\"><br></p><p id=\"uea146fbe\" class=\"ne-p\"><span class=\"ne-text\">与数学中的集合概念类似，集合由一组无序的元素组成，且集合中的每个元素都是唯一存在的。可以回顾一下中学数学中集合的概念，我们这里所要定义的集合也具有空集（即集合的内容为空）、交集、并集、差集、子集的特性。<br /></span><span class=\"ne-text\">在 ES6 中，原生的 Set 类已经实现了集合的全部特性，稍后我们会介绍它的用法。<br /></span><span class=\"ne-text\">我们使用 JavaSctipt 的对象来表示集合，下面是集合类的主要实现方法：<br /></span><span class=\"ne-text\"></span></p><p id=\"u229c7eff\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"e44f3e04\" class=\"ne-codeblock language-javascript\">class Set {\n    constructor() {\n        this.items = {}\n    }\n\n    add(value) {\n        // 向集合中添加元素\n        if (!this.has(value)) {\n            this.items[value] = value\n            return true\n        }\n        return false\n    }\n\n    delete(value) {\n        // 从集合中删除对应的元素\n        if (this.has(value)) {\n            delete this.items[value]\n            return true\n        }\n        return false\n    }\n\n    has(value) {\n        // 判断给定的元素在集合中是否存在\n        return this.items.hasOwnProperty(value)\n    }\n\n    clear() {\n        // 清空集合内容\n        this.items = {}\n    }\n\n    size() {\n        // 获取集合的长度\n        return Object.keys(this.items).length\n    }\n\n    values() {\n        // 返回集合中所有元素的内容\n        return Object.values(this.items)\n    }\n}</pre><p id=\"u8b876a33\" class=\"ne-p\"><br></p><p id=\"ue89687c6\" class=\"ne-p\"><span class=\"ne-text\">在使用 JavaScript 对象{ }来表示集合时，我们可以像操作数组一样通过[ ]来设置和获取集合内元素的值。通过这种方式，在设置集合元素的值时，如果元素不存在，则创建一个新元素，如果元素存在，则修改对应的值；在获取集合元素的值时，如果元素存在，则返回对应的值，如果元素不存在，则返回 undefined。此外，JavaScript 对象还提供了一些基础方法以方便我们对集合进行一些操作，例如 hasOwenProperty()方法返回一个表明对象是否具有特定属性的布尔值，Object.keys()方法返回指定对象的所有属性名称的数组，Object.values()方法方法指定对象的所有属性值的数组。<br /></span><span class=\"ne-text\">上述代码很简单，这里就不再详细解释了。下面是一些测试用例和测试结果：<br /></span><span class=\"ne-text\"></span></p><p id=\"u3599b0c9\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"31c5f8bc\" class=\"ne-codeblock language-javascript\">let set = new Set()\nset.add(1)\nconsole.log(set.values()) // [ 1 ]\nconsole.log(set.has(1)) // true\nconsole.log(set.size()) // 1\n\nset.add(2)\nconsole.log(set.values()) // [ 1, 2 ]\nconsole.log(set.has(2)) // true\nconsole.log(set.size()) // 2\n\nset.delete(1)\nconsole.log(set.values()) // [ 2 ]\n\nset.delete(2)\nconsole.log(set.values()) // []</pre><p id=\"u8ce311e6\" class=\"ne-p\"><br></p><p id=\"ub7fa639d\" class=\"ne-p\"><span class=\"ne-text\">下面我们来看看集合的数学运算：并集、交集、差集、子集。</span></p><p id=\"u5ddecf3e\" class=\"ne-p\"><br></p><h3 id=\"c4d10be6\"><span class=\"ne-text\">并集</span></h3><p id=\"u623dddcf\" class=\"ne-p\"><br></p><p id=\"u814c7b0d\" class=\"ne-p\"><span class=\"ne-text\">对于给定的两个集合，并集返回一个包含两个集合中所有元素的新集合。示意图如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368291000-33752d8e-74a9-4dec-adc2-754f613ea52d.png#clientId=u57a81b8d-3e62-4&amp;from=paste&amp;id=ud956b69d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=290&amp;originWidth=410&amp;originalType=url&amp;ratio=1&amp;size=14644&amp;status=done&amp;style=none&amp;taskId=udc2fe1d1-fe39-4d66-882e-5a81aacb8cb\" width=\"410\" id=\"usqpl\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">并集的实现代码：<br /></span><span class=\"ne-text\"></span></p><p id=\"ub175c79d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"e54012af\" class=\"ne-codeblock language-javascript\">union (otherSet) { // 并集\n    let unionSet = new Set();\n    this.values().forEach(value =&gt; unionSet.add(value));\n    otherSet.values().forEach(value =&gt; unionSet.add(value));\n    return unionSet;\n}</pre><p id=\"uca3e9811\" class=\"ne-p\"><br></p><p id=\"u0110352d\" class=\"ne-p\"><span class=\"ne-text\">首先遍历第一个集合，将所有的元素添加到新集合中，然后再遍历第二个集合，将所有的元素添加到新集合中。然后返回新集合。不用担心会添加重复的元素，因为集合的 add()方法会自动排除掉已添加的元素。<br /></span><span class=\"ne-text\">测试用例及结果：</span></p><p id=\"u7b56ffb0\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"561c2596\" class=\"ne-codeblock language-javascript\">let setA = new Set()\nsetA.add(&quot;first&quot;)\nsetA.add(&quot;second&quot;)\nsetA.add(&quot;third&quot;)\n\nlet setB = new Set()\nsetB.add(&quot;third&quot;)\nsetB.add(&quot;fourth&quot;)\nsetB.add(&quot;fifth&quot;)\nsetB.add(&quot;sixth&quot;)\n\nconsole.log(setA.union(setB).values()) // [ 'first', 'second', 'third', 'fourth', 'fifth', 'sixth' ]</pre><p id=\"u8ec4cae5\" class=\"ne-p\"><br></p><h3 id=\"5a48d8c5\"><span class=\"ne-text\">交集</span></h3><p id=\"u34bfcf90\" class=\"ne-p\"><br></p><p id=\"u89e771ed\" class=\"ne-p\"><span class=\"ne-text\">对于给定的两个集合，交集返回一个包含两个集合中共有元素的新集合。示意图如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368317389-e49911e6-ca1a-440b-b454-e5b4b68f2584.png#clientId=u57a81b8d-3e62-4&amp;from=paste&amp;id=u6a7f3a65&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=290&amp;originWidth=410&amp;originalType=url&amp;ratio=1&amp;size=12269&amp;status=done&amp;style=none&amp;taskId=u067af691-1849-46c7-a246-d6b4f226f3f\" width=\"410\" id=\"ra6DZ\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">交集的实现代码：</span></p><p id=\"u0e274324\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"b84cd0aa\" class=\"ne-codeblock language-javascript\">intersection (otherSet) { // 交集\n    let intersectionSet = new Set();\n    this.values().forEach(value =&gt; {\n       if (otherSet.has(value)) intersectionSet.add(value);\n    });\n    return intersectionSet;\n}</pre><p id=\"u9107ed10\" class=\"ne-p\"><br></p><p id=\"ua6b4778c\" class=\"ne-p\"><span class=\"ne-text\">遍历第一个集合，如果元素出现在第二个集合中，则将它添加到新集合。然后返回新集合。<br /></span><span class=\"ne-text\">测试用例及结果：</span></p><p id=\"u82ad6d9b\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"e021b893\" class=\"ne-codeblock language-javascript\">let setA = new Set()\nsetA.add(&quot;first&quot;)\nsetA.add(&quot;second&quot;)\nsetA.add(&quot;third&quot;)\n\nlet setB = new Set()\nsetB.add(&quot;second&quot;)\nsetB.add(&quot;third&quot;)\nsetB.add(&quot;fourth&quot;)\n\nconsole.log(setA.intersection(setB).values()) // [ 'second', 'third' ]</pre><p id=\"u61ddda2d\" class=\"ne-p\"><br></p><h3 id=\"e75b500f\"><span class=\"ne-text\">差集</span></h3><p id=\"u801f2808\" class=\"ne-p\"><br></p><p id=\"u400721fe\" class=\"ne-p\"><span class=\"ne-text\">对于给定的两个集合，差集返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。示意图如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368342830-5ee4d804-f8a6-494d-aa9d-3d54aebc20aa.png#clientId=u57a81b8d-3e62-4&amp;from=paste&amp;id=uac4f74cb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=290&amp;originWidth=410&amp;originalType=url&amp;ratio=1&amp;size=13913&amp;status=done&amp;style=none&amp;taskId=u106e9d75-e01c-4dd7-947e-559896c3971\" width=\"410\" id=\"xZkpu\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">差集的实现代码：</span></p><p id=\"uc8e169f8\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ec33797f\" class=\"ne-codeblock language-javascript\">difference (otherSet) { // 差集\n    let differenceSet = new Set();\n    this.values().forEach(value =&gt; {\n       if (!otherSet.has(value)) differenceSet.add(value);\n    });\n    return differenceSet;\n}</pre><p id=\"uc26e9b25\" class=\"ne-p\"><br></p><p id=\"ua3d056ba\" class=\"ne-p\"><span class=\"ne-text\">遍历第一个集合，如果元素没有出现在第二个集合中，则将它添加到新集合。然后返回新集合。<br /></span><span class=\"ne-text\">测试用例及结果：</span></p><p id=\"ud97600ac\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"b7a2ce15\" class=\"ne-codeblock language-javascript\">let setA = new Set()\nsetA.add(&quot;first&quot;)\nsetA.add(&quot;second&quot;)\nsetA.add(&quot;third&quot;)\n\nlet setB = new Set()\nsetB.add(&quot;second&quot;)\nsetB.add(&quot;third&quot;)\nsetB.add(&quot;fourth&quot;)\n\nconsole.log(setA.difference(setB).values()) // [ 'first' ]</pre><p id=\"u9e1dda7d\" class=\"ne-p\"><br></p><h3 id=\"f6a25ee8\"><span class=\"ne-text\">子集</span></h3><p id=\"u35b500b9\" class=\"ne-p\"><br></p><p id=\"u1390e6ad\" class=\"ne-p\"><span class=\"ne-text\">验证一个给定集合是否是另一个集合的子集，即判断给定的集合中的所有元素是否都存在于另一个集合中，如果是，则这个集合就是另一个集合的子集，反之则不是。示意图如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368372311-38bd59f7-641a-42ae-ae94-1cb7536e4ed8.png#clientId=u57a81b8d-3e62-4&amp;from=paste&amp;id=u094c04dd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=290&amp;originWidth=410&amp;originalType=url&amp;ratio=1&amp;size=12628&amp;status=done&amp;style=none&amp;taskId=ub2e3bb05-2fcd-4d6a-be7c-dd43123842e\" width=\"410\" id=\"p3hP4\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">子集的实现代码：</span></p><p id=\"uc320555c\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"637f02b0\" class=\"ne-codeblock language-javascript\">subset (otherSet) { // 子集\n    if (this.size() &gt; otherSet.size()) return false;\n\n    let isSubset = true;\n    this.values().every(value =&gt; {\n        if (!otherSet.has(value)) {\n            isSubset = false;\n            return false;\n        }\n        return true;\n    });\n\n    return isSubset;\n}</pre><p id=\"u2bcbc18d\" class=\"ne-p\"><br></p><p id=\"u967aa68a\" class=\"ne-p\"><span class=\"ne-text\">如果集合 A 比集合 B 的长度大，则直接返回 false，因为这种情况 A 不可能是 B 的子集。然后使用 every()函数遍历集合 A 的所有元素，一旦碰到其中的元素没有在集合 B 中出现，则直接返回 false，并终止遍历。这里我们没有使用 forEach 来遍历集合 A，是因为你无法根据某个条件来终止 forEach 循环。考虑下面这种情况：</span></p><p id=\"u6f79ebcf\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"cd4d250f\" class=\"ne-codeblock language-javascript\">var arr = [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;]\narr.forEach(item =&gt; {\n    if (item === &quot;third&quot;) return true\n    console.log(item)\n})</pre><p id=\"ud6d75eb1\" class=\"ne-p\"><br></p><p id=\"udcf6efc7\" class=\"ne-p\"><span class=\"ne-text\">输出结果是：</span></p><p id=\"ua0c90eb1\" class=\"ne-p\"><br></p><pre data-language=\"plain\" id=\"73be3229\" class=\"ne-codeblock language-plain\">first\nsecond\nfourth</pre><p id=\"u4b0f9c9d\" class=\"ne-p\"><br></p><p id=\"u86f2fc21\" class=\"ne-p\"><span class=\"ne-text\">很显然，这里的 return true 语句并不能退出 forEach 循环，它只能保证本次循环中余下的语句不被执行，而接下来其它的元素还是会被遍历到。<br /></span><span class=\"ne-text\">在我们的 subset()方法中，如果使用 forEach 语句，每一次都会遍历集合中的所有元素，如果遇到其中的元素没有在集合 B 中出现，就将 isSubset 变量的值设置为 false，但并不能退出 forEach，isSubset 变量的值可能会被多次覆盖。为了提高执行效率，推荐使用 every()函数，它会遍历集合中的元素，直到其中一个返回结果为 false，就终止遍历，并返回 false，否则就遍历所有的元素并返回 true。有关 every()函数的详细介绍可以看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">这里</span></a><span class=\"ne-text\">。与 every()函数功能相似还有一个 some()函数，它在遍历集合的过程中，遇到返回结果为 true 时就终止遍历，具体内容可以看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">这里</span></a><span class=\"ne-text\">。<br /></span><span class=\"ne-text\">差集的测试用例及结果：</span></p><p id=\"ue5f42c99\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"86a7ff47\" class=\"ne-codeblock language-javascript\">let setA = new Set()\nsetA.add(&quot;first&quot;)\nsetA.add(&quot;second&quot;)\n\nlet setB = new Set()\nsetB.add(&quot;first&quot;)\nsetB.add(&quot;second&quot;)\nsetB.add(&quot;third&quot;)\n\nlet setC = new Set()\nsetC.add(&quot;second&quot;)\nsetC.add(&quot;third&quot;)\nsetC.add(&quot;fourth&quot;)\n\nconsole.log(setA.subset(setB)) // true\nconsole.log(setA.subset(setC)) // false</pre><p id=\"uf8f250a5\" class=\"ne-p\"><br></p><p id=\"u8528a61d\" class=\"ne-p\"><span class=\"ne-text\">文章的开头说过，ES6 提供了原生的 Set 类，让我们来看看它的一些使用方法：</span></p><p id=\"ucc169225\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"2448d7ae\" class=\"ne-codeblock language-javascript\">let set = new Set()\nset.add(1)\nset.add(2)\nset.add(3)\nconsole.log(set.values()) // [Set Iterator] { 1, 2, 3 }\nconsole.log(set.has(1)) // true\nconsole.log(set.size) // 2\n\nset.delete(1)\nconsole.log(set.values()) // [Set Iterator] { 2, 3 }\n\nset.clear()\nconsole.log(set.values()) // [Set Iterator] {  }</pre><p id=\"u527eace4\" class=\"ne-p\"><br></p><p id=\"uebcc9570\" class=\"ne-p\"><span class=\"ne-text\">和前面我们自定义的 Set 类稍微有一点不同，values()方法返回的不是一个数组，而是 Iterator 迭代器。另一个就是这里的 size 是一个属性而不是方法，其它部分都和我们前面定义的 Set 类相同。由于 ES6 的 Set 类不包含对集合的数学运算，我们可以按照前面我们提供的方法来对其进行扩充。</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"traditional\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"uc7be4870\" id=\"uc7be4870\"><a href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" target=\"_blank\" data-lake-id=\"uf02a28a9\" id=\"uf02a28a9\"><span data-lake-id=\"ubc8b93e9\" id=\"ubc8b93e9\">链接</span></a><span data-lake-id=\"uae4d6d83\" id=\"uae4d6d83\"><br /></span><span data-lake-id=\"ube952943\" id=\"ube952943\">​</span></p><p data-lake-id=\"u5d484a15\" id=\"u5d484a15\"><br></p><p data-lake-id=\"uea146fbe\" id=\"uea146fbe\"><span data-lake-id=\"u37b19e25\" id=\"u37b19e25\">与数学中的集合概念类似，集合由一组无序的元素组成，且集合中的每个元素都是唯一存在的。可以回顾一下中学数学中集合的概念，我们这里所要定义的集合也具有空集（即集合的内容为空）、交集、并集、差集、子集的特性。<br /></span><span data-lake-id=\"u2df14359\" id=\"u2df14359\">在 ES6 中，原生的 Set 类已经实现了集合的全部特性，稍后我们会介绍它的用法。<br /></span><span data-lake-id=\"u9909108b\" id=\"u9909108b\">我们使用 JavaSctipt 的对象来表示集合，下面是集合类的主要实现方法：<br /></span><span data-lake-id=\"u78c1d7de\" id=\"u78c1d7de\">​</span></p><p data-lake-id=\"u229c7eff\" id=\"u229c7eff\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20Set%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20this.items%20%3D%20%7B%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20add(value)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%90%91%E9%9B%86%E5%90%88%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%5Cn%20%20%20%20%20%20%20%20if%20(!this.has(value))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.items%5Bvalue%5D%20%3D%20value%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20true%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20false%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20delete(value)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E4%BB%8E%E9%9B%86%E5%90%88%E4%B8%AD%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%83%E7%B4%A0%5Cn%20%20%20%20%20%20%20%20if%20(this.has(value))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20delete%20this.items%5Bvalue%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20true%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20false%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20has(value)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%88%A4%E6%96%AD%E7%BB%99%E5%AE%9A%E7%9A%84%E5%85%83%E7%B4%A0%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%5Cn%20%20%20%20%20%20%20%20return%20this.items.hasOwnProperty(value)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20clear()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E6%B8%85%E7%A9%BA%E9%9B%86%E5%90%88%E5%86%85%E5%AE%B9%5Cn%20%20%20%20%20%20%20%20this.items%20%3D%20%7B%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20size()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E8%8E%B7%E5%8F%96%E9%9B%86%E5%90%88%E7%9A%84%E9%95%BF%E5%BA%A6%5Cn%20%20%20%20%20%20%20%20return%20Object.keys(this.items).length%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20values()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E9%9B%86%E5%90%88%E4%B8%AD%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%86%85%E5%AE%B9%5Cn%20%20%20%20%20%20%20%20return%20Object.values(this.items)%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22e44f3e04%22%7D\"></card><p data-lake-id=\"u8b876a33\" id=\"u8b876a33\"><br></p><p data-lake-id=\"ue89687c6\" id=\"ue89687c6\"><span data-lake-id=\"u5e78f42a\" id=\"u5e78f42a\">在使用 JavaScript 对象{ }来表示集合时，我们可以像操作数组一样通过[ ]来设置和获取集合内元素的值。通过这种方式，在设置集合元素的值时，如果元素不存在，则创建一个新元素，如果元素存在，则修改对应的值；在获取集合元素的值时，如果元素存在，则返回对应的值，如果元素不存在，则返回 undefined。此外，JavaScript 对象还提供了一些基础方法以方便我们对集合进行一些操作，例如 hasOwenProperty()方法返回一个表明对象是否具有特定属性的布尔值，Object.keys()方法返回指定对象的所有属性名称的数组，Object.values()方法方法指定对象的所有属性值的数组。<br /></span><span data-lake-id=\"ua1040a17\" id=\"ua1040a17\">上述代码很简单，这里就不再详细解释了。下面是一些测试用例和测试结果：<br /></span><span data-lake-id=\"uc659798a\" id=\"uc659798a\">​</span></p><p data-lake-id=\"u3599b0c9\" id=\"u3599b0c9\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20set%20%3D%20new%20Set()%5Cnset.add(1)%5Cnconsole.log(set.values())%20%2F%2F%20%5B%201%20%5D%5Cnconsole.log(set.has(1))%20%2F%2F%20true%5Cnconsole.log(set.size())%20%2F%2F%201%5Cn%5Cnset.add(2)%5Cnconsole.log(set.values())%20%2F%2F%20%5B%201%2C%202%20%5D%5Cnconsole.log(set.has(2))%20%2F%2F%20true%5Cnconsole.log(set.size())%20%2F%2F%202%5Cn%5Cnset.delete(1)%5Cnconsole.log(set.values())%20%2F%2F%20%5B%202%20%5D%5Cn%5Cnset.delete(2)%5Cnconsole.log(set.values())%20%2F%2F%20%5B%5D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2231c5f8bc%22%7D\"></card><p data-lake-id=\"u8ce311e6\" id=\"u8ce311e6\"><br></p><p data-lake-id=\"ub7fa639d\" id=\"ub7fa639d\"><span data-lake-id=\"ua82f398f\" id=\"ua82f398f\">下面我们来看看集合的数学运算：并集、交集、差集、子集。</span></p><p data-lake-id=\"u5ddecf3e\" id=\"u5ddecf3e\"><br></p><h3 data-lake-id=\"c4d10be6\" id=\"c4d10be6\"><span data-lake-id=\"u9aa08728\" id=\"u9aa08728\">并集</span></h3><p data-lake-id=\"u623dddcf\" id=\"u623dddcf\"><br></p><p data-lake-id=\"u814c7b0d\" id=\"u814c7b0d\"><span data-lake-id=\"u072468fc\" id=\"u072468fc\">对于给定的两个集合，并集返回一个包含两个集合中所有元素的新集合。示意图如下：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368291000-33752d8e-74a9-4dec-adc2-754f613ea52d.png%23clientId%3Du57a81b8d-3e62-4%26from%3Dpaste%26id%3Dud956b69d%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D290%26originWidth%3D410%26originalType%3Durl%26ratio%3D1%26size%3D14644%26status%3Ddone%26style%3Dnone%26taskId%3Dudc2fe1d1-fe39-4d66-882e-5a81aacb8cb%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A410%2C%22originHeight%22%3A290%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22id%22%3A%22usqpl%22%7D\"></card><span data-lake-id=\"ubbb7a036\" id=\"ubbb7a036\"><br /></span><span data-lake-id=\"u84e7772f\" id=\"u84e7772f\">并集的实现代码：<br /></span><span data-lake-id=\"u872e90da\" id=\"u872e90da\">​</span></p><p data-lake-id=\"ub175c79d\" id=\"ub175c79d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22union%20(otherSet)%20%7B%20%2F%2F%20%E5%B9%B6%E9%9B%86%5Cn%20%20%20%20let%20unionSet%20%3D%20new%20Set()%3B%5Cn%20%20%20%20this.values().forEach(value%20%3D%3E%20unionSet.add(value))%3B%5Cn%20%20%20%20otherSet.values().forEach(value%20%3D%3E%20unionSet.add(value))%3B%5Cn%20%20%20%20return%20unionSet%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22e54012af%22%7D\"></card><p data-lake-id=\"uca3e9811\" id=\"uca3e9811\"><br></p><p data-lake-id=\"u0110352d\" id=\"u0110352d\"><span data-lake-id=\"ue0bfa81f\" id=\"ue0bfa81f\">首先遍历第一个集合，将所有的元素添加到新集合中，然后再遍历第二个集合，将所有的元素添加到新集合中。然后返回新集合。不用担心会添加重复的元素，因为集合的 add()方法会自动排除掉已添加的元素。<br /></span><span data-lake-id=\"uf6e1cd30\" id=\"uf6e1cd30\">测试用例及结果：</span></p><p data-lake-id=\"u7b56ffb0\" id=\"u7b56ffb0\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20setA%20%3D%20new%20Set()%5CnsetA.add(%5C%22first%5C%22)%5CnsetA.add(%5C%22second%5C%22)%5CnsetA.add(%5C%22third%5C%22)%5Cn%5Cnlet%20setB%20%3D%20new%20Set()%5CnsetB.add(%5C%22third%5C%22)%5CnsetB.add(%5C%22fourth%5C%22)%5CnsetB.add(%5C%22fifth%5C%22)%5CnsetB.add(%5C%22sixth%5C%22)%5Cn%5Cnconsole.log(setA.union(setB).values())%20%2F%2F%20%5B%20'first'%2C%20'second'%2C%20'third'%2C%20'fourth'%2C%20'fifth'%2C%20'sixth'%20%5D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22561c2596%22%7D\"></card><p data-lake-id=\"u8ec4cae5\" id=\"u8ec4cae5\"><br></p><h3 data-lake-id=\"5a48d8c5\" id=\"5a48d8c5\"><span data-lake-id=\"u2e54a920\" id=\"u2e54a920\">交集</span></h3><p data-lake-id=\"u34bfcf90\" id=\"u34bfcf90\"><br></p><p data-lake-id=\"u89e771ed\" id=\"u89e771ed\"><span data-lake-id=\"u0a44541e\" id=\"u0a44541e\">对于给定的两个集合，交集返回一个包含两个集合中共有元素的新集合。示意图如下：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368317389-e49911e6-ca1a-440b-b454-e5b4b68f2584.png%23clientId%3Du57a81b8d-3e62-4%26from%3Dpaste%26id%3Du6a7f3a65%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D290%26originWidth%3D410%26originalType%3Durl%26ratio%3D1%26size%3D12269%26status%3Ddone%26style%3Dnone%26taskId%3Du067af691-1849-46c7-a246-d6b4f226f3f%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A410%2C%22originHeight%22%3A290%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22id%22%3A%22ra6DZ%22%7D\"></card><span data-lake-id=\"u28df53fb\" id=\"u28df53fb\"><br /></span><span data-lake-id=\"ue6be15e7\" id=\"ue6be15e7\">交集的实现代码：</span></p><p data-lake-id=\"u0e274324\" id=\"u0e274324\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22intersection%20(otherSet)%20%7B%20%2F%2F%20%E4%BA%A4%E9%9B%86%5Cn%20%20%20%20let%20intersectionSet%20%3D%20new%20Set()%3B%5Cn%20%20%20%20this.values().forEach(value%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20if%20(otherSet.has(value))%20intersectionSet.add(value)%3B%5Cn%20%20%20%20%7D)%3B%5Cn%20%20%20%20return%20intersectionSet%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22b84cd0aa%22%7D\"></card><p data-lake-id=\"u9107ed10\" id=\"u9107ed10\"><br></p><p data-lake-id=\"ua6b4778c\" id=\"ua6b4778c\"><span data-lake-id=\"u98c3827f\" id=\"u98c3827f\">遍历第一个集合，如果元素出现在第二个集合中，则将它添加到新集合。然后返回新集合。<br /></span><span data-lake-id=\"uc1a29db1\" id=\"uc1a29db1\">测试用例及结果：</span></p><p data-lake-id=\"u82ad6d9b\" id=\"u82ad6d9b\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20setA%20%3D%20new%20Set()%5CnsetA.add(%5C%22first%5C%22)%5CnsetA.add(%5C%22second%5C%22)%5CnsetA.add(%5C%22third%5C%22)%5Cn%5Cnlet%20setB%20%3D%20new%20Set()%5CnsetB.add(%5C%22second%5C%22)%5CnsetB.add(%5C%22third%5C%22)%5CnsetB.add(%5C%22fourth%5C%22)%5Cn%5Cnconsole.log(setA.intersection(setB).values())%20%2F%2F%20%5B%20'second'%2C%20'third'%20%5D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22e021b893%22%7D\"></card><p data-lake-id=\"u61ddda2d\" id=\"u61ddda2d\"><br></p><h3 data-lake-id=\"e75b500f\" id=\"e75b500f\"><span data-lake-id=\"u79610742\" id=\"u79610742\">差集</span></h3><p data-lake-id=\"u801f2808\" id=\"u801f2808\"><br></p><p data-lake-id=\"u400721fe\" id=\"u400721fe\"><span data-lake-id=\"u19a32f5e\" id=\"u19a32f5e\">对于给定的两个集合，差集返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。示意图如下：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368342830-5ee4d804-f8a6-494d-aa9d-3d54aebc20aa.png%23clientId%3Du57a81b8d-3e62-4%26from%3Dpaste%26id%3Duac4f74cb%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D290%26originWidth%3D410%26originalType%3Durl%26ratio%3D1%26size%3D13913%26status%3Ddone%26style%3Dnone%26taskId%3Du106e9d75-e01c-4dd7-947e-559896c3971%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A410%2C%22originHeight%22%3A290%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22id%22%3A%22xZkpu%22%7D\"></card><span data-lake-id=\"ue2fb1521\" id=\"ue2fb1521\"><br /></span><span data-lake-id=\"u767592af\" id=\"u767592af\">差集的实现代码：</span></p><p data-lake-id=\"uc8e169f8\" id=\"uc8e169f8\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22difference%20(otherSet)%20%7B%20%2F%2F%20%E5%B7%AE%E9%9B%86%5Cn%20%20%20%20let%20differenceSet%20%3D%20new%20Set()%3B%5Cn%20%20%20%20this.values().forEach(value%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20if%20(!otherSet.has(value))%20differenceSet.add(value)%3B%5Cn%20%20%20%20%7D)%3B%5Cn%20%20%20%20return%20differenceSet%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22ec33797f%22%7D\"></card><p data-lake-id=\"uc26e9b25\" id=\"uc26e9b25\"><br></p><p data-lake-id=\"ua3d056ba\" id=\"ua3d056ba\"><span data-lake-id=\"u11b8d64e\" id=\"u11b8d64e\">遍历第一个集合，如果元素没有出现在第二个集合中，则将它添加到新集合。然后返回新集合。<br /></span><span data-lake-id=\"uaecdbedc\" id=\"uaecdbedc\">测试用例及结果：</span></p><p data-lake-id=\"ud97600ac\" id=\"ud97600ac\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20setA%20%3D%20new%20Set()%5CnsetA.add(%5C%22first%5C%22)%5CnsetA.add(%5C%22second%5C%22)%5CnsetA.add(%5C%22third%5C%22)%5Cn%5Cnlet%20setB%20%3D%20new%20Set()%5CnsetB.add(%5C%22second%5C%22)%5CnsetB.add(%5C%22third%5C%22)%5CnsetB.add(%5C%22fourth%5C%22)%5Cn%5Cnconsole.log(setA.difference(setB).values())%20%2F%2F%20%5B%20'first'%20%5D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22b7a2ce15%22%7D\"></card><p data-lake-id=\"u9e1dda7d\" id=\"u9e1dda7d\"><br></p><h3 data-lake-id=\"f6a25ee8\" id=\"f6a25ee8\"><span data-lake-id=\"u69312fb6\" id=\"u69312fb6\">子集</span></h3><p data-lake-id=\"u35b500b9\" id=\"u35b500b9\"><br></p><p data-lake-id=\"u1390e6ad\" id=\"u1390e6ad\"><span data-lake-id=\"u2f37e7b3\" id=\"u2f37e7b3\">验证一个给定集合是否是另一个集合的子集，即判断给定的集合中的所有元素是否都存在于另一个集合中，如果是，则这个集合就是另一个集合的子集，反之则不是。示意图如下：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368372311-38bd59f7-641a-42ae-ae94-1cb7536e4ed8.png%23clientId%3Du57a81b8d-3e62-4%26from%3Dpaste%26id%3Du094c04dd%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D290%26originWidth%3D410%26originalType%3Durl%26ratio%3D1%26size%3D12628%26status%3Ddone%26style%3Dnone%26taskId%3Dub2e3bb05-2fcd-4d6a-be7c-dd43123842e%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A410%2C%22originHeight%22%3A290%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22id%22%3A%22p3hP4%22%7D\"></card><span data-lake-id=\"uc8f33125\" id=\"uc8f33125\"><br /></span><span data-lake-id=\"u66d808c9\" id=\"u66d808c9\">子集的实现代码：</span></p><p data-lake-id=\"uc320555c\" id=\"uc320555c\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22subset%20(otherSet)%20%7B%20%2F%2F%20%E5%AD%90%E9%9B%86%5Cn%20%20%20%20if%20(this.size()%20%3E%20otherSet.size())%20return%20false%3B%5Cn%5Cn%20%20%20%20let%20isSubset%20%3D%20true%3B%5Cn%20%20%20%20this.values().every(value%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(!otherSet.has(value))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20isSubset%20%3D%20false%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20true%3B%5Cn%20%20%20%20%7D)%3B%5Cn%5Cn%20%20%20%20return%20isSubset%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22637f02b0%22%7D\"></card><p data-lake-id=\"u2bcbc18d\" id=\"u2bcbc18d\"><br></p><p data-lake-id=\"u967aa68a\" id=\"u967aa68a\"><span data-lake-id=\"ub6a83f1f\" id=\"ub6a83f1f\">如果集合 A 比集合 B 的长度大，则直接返回 false，因为这种情况 A 不可能是 B 的子集。然后使用 every()函数遍历集合 A 的所有元素，一旦碰到其中的元素没有在集合 B 中出现，则直接返回 false，并终止遍历。这里我们没有使用 forEach 来遍历集合 A，是因为你无法根据某个条件来终止 forEach 循环。考虑下面这种情况：</span></p><p data-lake-id=\"u6f79ebcf\" id=\"u6f79ebcf\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20arr%20%3D%20%5B%5C%22first%5C%22%2C%20%5C%22second%5C%22%2C%20%5C%22third%5C%22%2C%20%5C%22fourth%5C%22%5D%5Cnarr.forEach(item%20%3D%3E%20%7B%5Cn%20%20%20%20if%20(item%20%3D%3D%3D%20%5C%22third%5C%22)%20return%20true%5Cn%20%20%20%20console.log(item)%5Cn%7D)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22cd4d250f%22%7D\"></card><p data-lake-id=\"ud6d75eb1\" id=\"ud6d75eb1\"><br></p><p data-lake-id=\"udcf6efc7\" id=\"udcf6efc7\"><span data-lake-id=\"u3a67f3a4\" id=\"u3a67f3a4\">输出结果是：</span></p><p data-lake-id=\"ua0c90eb1\" id=\"ua0c90eb1\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22first%5Cnsecond%5Cnfourth%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2273be3229%22%7D\"></card><p data-lake-id=\"u4b0f9c9d\" id=\"u4b0f9c9d\"><br></p><p data-lake-id=\"u86f2fc21\" id=\"u86f2fc21\"><span data-lake-id=\"uf6385b13\" id=\"uf6385b13\">很显然，这里的 return true 语句并不能退出 forEach 循环，它只能保证本次循环中余下的语句不被执行，而接下来其它的元素还是会被遍历到。<br /></span><span data-lake-id=\"u82485631\" id=\"u82485631\">在我们的 subset()方法中，如果使用 forEach 语句，每一次都会遍历集合中的所有元素，如果遇到其中的元素没有在集合 B 中出现，就将 isSubset 变量的值设置为 false，但并不能退出 forEach，isSubset 变量的值可能会被多次覆盖。为了提高执行效率，推荐使用 every()函数，它会遍历集合中的元素，直到其中一个返回结果为 false，就终止遍历，并返回 false，否则就遍历所有的元素并返回 true。有关 every()函数的详细介绍可以看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every\" target=\"_blank\" data-lake-id=\"udf622eeb\" id=\"udf622eeb\"><span data-lake-id=\"ub7804bdd\" id=\"ub7804bdd\">这里</span></a><span data-lake-id=\"u2f045cd2\" id=\"u2f045cd2\">。与 every()函数功能相似还有一个 some()函数，它在遍历集合的过程中，遇到返回结果为 true 时就终止遍历，具体内容可以看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some\" target=\"_blank\" data-lake-id=\"u25d3de54\" id=\"u25d3de54\"><span data-lake-id=\"ucf992827\" id=\"ucf992827\">这里</span></a><span data-lake-id=\"uc9442fc3\" id=\"uc9442fc3\">。<br /></span><span data-lake-id=\"u234e2fb1\" id=\"u234e2fb1\">差集的测试用例及结果：</span></p><p data-lake-id=\"ue5f42c99\" id=\"ue5f42c99\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20setA%20%3D%20new%20Set()%5CnsetA.add(%5C%22first%5C%22)%5CnsetA.add(%5C%22second%5C%22)%5Cn%5Cnlet%20setB%20%3D%20new%20Set()%5CnsetB.add(%5C%22first%5C%22)%5CnsetB.add(%5C%22second%5C%22)%5CnsetB.add(%5C%22third%5C%22)%5Cn%5Cnlet%20setC%20%3D%20new%20Set()%5CnsetC.add(%5C%22second%5C%22)%5CnsetC.add(%5C%22third%5C%22)%5CnsetC.add(%5C%22fourth%5C%22)%5Cn%5Cnconsole.log(setA.subset(setB))%20%2F%2F%20true%5Cnconsole.log(setA.subset(setC))%20%2F%2F%20false%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2286a7ff47%22%7D\"></card><p data-lake-id=\"uf8f250a5\" id=\"uf8f250a5\"><br></p><p data-lake-id=\"u8528a61d\" id=\"u8528a61d\"><span data-lake-id=\"u26d69cee\" id=\"u26d69cee\">文章的开头说过，ES6 提供了原生的 Set 类，让我们来看看它的一些使用方法：</span></p><p data-lake-id=\"ucc169225\" id=\"ucc169225\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20set%20%3D%20new%20Set()%5Cnset.add(1)%5Cnset.add(2)%5Cnset.add(3)%5Cnconsole.log(set.values())%20%2F%2F%20%5BSet%20Iterator%5D%20%7B%201%2C%202%2C%203%20%7D%5Cnconsole.log(set.has(1))%20%2F%2F%20true%5Cnconsole.log(set.size)%20%2F%2F%202%5Cn%5Cnset.delete(1)%5Cnconsole.log(set.values())%20%2F%2F%20%5BSet%20Iterator%5D%20%7B%202%2C%203%20%7D%5Cn%5Cnset.clear()%5Cnconsole.log(set.values())%20%2F%2F%20%5BSet%20Iterator%5D%20%7B%20%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%222448d7ae%22%7D\"></card><p data-lake-id=\"u527eace4\" id=\"u527eace4\"><br></p><p data-lake-id=\"uebcc9570\" id=\"uebcc9570\"><span data-lake-id=\"u9fb81416\" id=\"u9fb81416\">和前面我们自定义的 Set 类稍微有一点不同，values()方法返回的不是一个数组，而是 Iterator 迭代器。另一个就是这里的 size 是一个属性而不是方法，其它部分都和我们前面定义的 Set 类相同。由于 ES6 的 Set 类不包含对集合的数学运算，我们可以按照前面我们提供的方法来对其进行扩充。</span></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2022-03-04T04:34:39.000Z",
  "deleted_at": null,
  "created_at": "2020-08-09T08:03:37.000Z",
  "updated_at": "2022-03-04T04:34:39.000Z",
  "published_at": "2022-03-04T04:34:39.000Z",
  "first_published_at": "2020-08-09T08:03:37.000Z",
  "word_count": 1894,
  "cover": null,
  "description": "链接与数学中的集合概念类似，集合由一组无序的元素组成，且集合中的每个元素都是唯一存在的。可以回顾一下中学数学中集合的概念，我们这里所要定义的集合也具有空集（即集合的内容为空）、交集、并集、差集、子集的特性。在 ES6 中，原生的 Set 类已经实现了集合的全部特性，稍后我们会介绍它的用法。我们...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}