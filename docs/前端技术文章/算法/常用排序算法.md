---
title: 常用排序算法
url: https://www.yuque.com/wcywxq/xxble8/cwwn2a
---

<a name="RY5r7"></a>

## 插入排序

<a name="BU6C3"></a>

### 原理

第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第 3 个元素开始，向前对比，重复之前的操作。 <a name="xDMWu"></a>

### 实现

```javascript
function insertSort(arr) {
  // 外层控制循环次数
  for (let i = 1; i < arr.length; i++) {
    for (let j = i - 1; i >= 0 && arr[j] > arr[j + 1]; j--) {
      [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
    }
  }
  return arr;
}
```

<a name="Ga4Mk"></a>

### 时间复杂度

时间复杂度: O(n2)

***

<a name="AuEPb"></a>

## 堆排序

<a name="fMMHl"></a>

### 原理

堆排序利用了二叉堆的特性来做，二叉堆通常用数组来表示，并且二叉堆是一颗完全二叉树(除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列)。二叉堆分为大根堆和小根堆。

- 大根堆是某个节点的所有子节点的值都比它小
- 小根堆是某个节点的所有子节点的值都比它大

堆排序的原理就是组成一个大根堆或小根堆。以小跟堆为例，某个节点的左边子节点的索引是 i ✖️ 2 + 1，右边是 i ✖️ 2 + 2，父节点是 (i - 1) / 2 => i >> 1

1. 首先遍历数组，判断该节点的父节点是否比它小，如果小就交换位置并继续判断，直到它的父节点比它大
2. 重复以上操作 1，直到数组首位是最大值
3. 然后将首位和末尾交换位置并将数组长度减 1，表示数组末尾已经是最大值，不需要再比较大小
4. 对比左右节点哪个大，然后记住大的节点的索引的值并和父节点对比大小，如果子节点大就交换位置
5. 重复 3 - 4 直到整个数组都是大根堆 <a name="vyyO9"></a>

### 实现

```javascript
function heap(arr) {
    // 将最大值放到首位
    for (let i = 0; i < arr.length; i++) {
        heapInsert(arr, i);
    }
    // 交换队首和队尾
    [arr[0], arr[arr.length - 1]] = [arr[arr.length - 1], arr[0]];
    while (arr.length > 0) {
        heapify(arr, 0, arr.length - 1);
        [arr[0], [arr[arr.length - 1]]] = [arr[arr.length - 1], arr[0]];
    }
    return arr;
}
function heapInsert(arr, index) {
    // 如果当前节点比父节点大，就交换
    while(arr[index] > arr[index >> 1]) {
        // 交换
        [arr[index], arr[index >> 1]] = [arr[index >> 1], arr[index]];
        // 将索引变为父节点
        index = index >> 1;
    }
}
function heapify(arr, index, size) {
    let left = index << 1 + 1;
    while (left < size) {
        // 判断左右节点大小
        let largest = left + 1 < size && arr[left] < arr[left + 1] ? left + 1 : left;
        // 判断子节点和父节点大小
        largest = arr[index] < arr[largest] ? largest : index;
        if (largest === index) break;
        [arr[index], arr[largest]] = [arr[lagest], arr[index]];
        index = largest;
        left = index << 1 + 1;
    }
}
```

<a name="Qn227"></a>

### 时间复杂度

最佳: O(nlogn) 最差: O(nlogn) 平均: O(nlogn)

***

<a name="Fgk8d"></a>

## 归并排序

<a name="oC8Lf"></a>

### 原理

递归的将数组两两分开直到包含两个元素，然后将数组排序合并。最终合并为排序好的数组。

分冶思想，即将大问题拆成小问题，小问题解决后大问题自然就解决了。 <a name="bNZcJ"></a>

### 例子

\[3, 1, 2, 8, 9, 7, 6] 中间数索引为 3, 先排序数组 \[3, 1, 2, 8], 继续拆分直到变为数组包含两个元素, 如果数组长度为奇数, 有一个拆分到只剩下 1 个元素。然后排序数组 \[3, 1] \[2, 8], 再排序 \[1, 2, 3, 8], 这样左边数组就排序完毕，同理排序右边数组，最后排序左右数组合并后的结果 <a name="TzrjJ"></a>

### 实现

```javascript
// 拆分
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  let middle =  arr.length >> 1; // arr.length >> 1 等价于 Math.floot(arr.length / 2)
  let left = arr.slice(0, middle);
  let right = arr.slice(middle);
  return merge(mergeSort(left), mergeSort(right));
}
// 合并
function merge(left, right) {
  const result = [];
  while (left.length > 0 && right.length > 0) {
    if (left[0] <= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  return result.concat(left, right);
}
```

<a name="LG3Fg"></a>

### 时间复杂度

拆分数组需要 logn 步, 合并需要 n 步, 因此 O(nlogn)

***

<a name="be91b57e"></a>

## 基数排序

<a name="mPf0U"></a>

### 原理

基数排序是一种非比较型整数排序算法，也是桶排序的一种特殊情况。其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较

简单来说就是分成 10 个桶，按照每个数字的最后一位数字进行分桶，然后按顺序放入桶中，之后按照桶大小从桶底部按顺序放入数列中。第一轮完毕后将按照每个数字的倒数第二位数字进行分桶，原理同上，当没有位数时，将按 0 处理。 <a name="oR6aZ"></a>

### 实现

```javascript
/**
 *
 * @param arr 待排序数组
 * @param max 最大位数
 */
function radixSort(arr, max) {
  const buckets = [];
  let unit = 10,
    base = 1;
  for (let i = 0; i < max; i++, base *= 10, unit *= 10) {
    for (let j = 0; j < array.length; j++) {
      let index = ~~((array[j] % unit) / base); //依次过滤出个位，十位等等数字
      if (buckets[index] == null) {
        buckets[index] = []; //初始化桶
      }
      buckets[index].push(array[j]); //往不同桶里添加数据
    }
    let pos = 0,
      value;
    for (let j = 0, length = buckets.length; j < length; j++) {
      if (buckets[j] != null) {
        while ((value = buckets[j].shift()) != null) {
          array[pos++] = value; //将不同桶里数据挨个捞出来，为下一轮高位排序做准备，由于靠近桶底的元素排名靠前，因此从桶底先捞
        }
      }
    }
  }
  return arr;
}
```

***

<a name="uOcpR"></a>

## 计数排序

<a name="uzVZx"></a>

### 原理

对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。 <a name="i1t42"></a>

### 实现

```javascript
function countionSort(arr) {
  let obj = {};
  // 遍历原数组，给对象新增键值对，如果已经存在就对应的属性值++，如果不存在则新增键值对
  for (let i = 0; i < arr.length; i++) {
    if (!obj[arr[i]]) {
      obj[arr[i]] = 1;
    } else {
      obj[arr[i]]++;
    }
  }
  let index = 0;
  // 遍历对象属性名，按顺序放回覆盖原数组
  for (let key in obj) {
    while (obj[key] > 0) {
      arr[index] = Number(key);
      obj[key]--;
      index++;
    }
  }
  return arr;
}
```

***

<a name="ydBb0"></a>

## 快速排序

<a name="P9ohy"></a>

### 特点

快速排序的特点就是快，而且效率高。它是处理大数据最快的排序算法之一 <a name="W5oA8"></a>

### 原理

随机选取一个数组中的值作为基准值，从左至右取值与基准值比较大小。比基准值小的放到数组左边，比基准值大的放到数组右边，对比完成后将基准值和第一个比基准值大的值交换位置，然后将数组以基准值的位置分为两个部分，继续递归以上操作。

```javascript
function quickSort(arr) {
    if (arr.length <= 1) return arr;
    // 取基准点
    const middleIndex = arr.length >> 1;
    // 取基准点的值
    const middle = arr.splice(middleIndex, 1)[0];
    const left = [];
    const right = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] < middle) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat(middle, quickSort(right))
}
```

<a name="kazHZ"></a>

### 时间复杂度

最佳: O(nlogn) 最差: O(n2) 平均: O(nlogn)

***

<a name="UblUz"></a>

## 冒泡排序

<a name="Kncte"></a>

### 原理

从第一个元素开始，把当前元素和下一个索引元素进行比较，如果当前元素大，就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 2 的位置即可 <a name="dkeBR"></a>

### 实现

```javascript
function bubbleSort(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    for (let j = 0; j < i; j++) {
      // 索引大的数组值大于索引小的数组值，交换
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```

<a name="WrrPF"></a>

### 时间复杂度

时间复杂度: O(n2)

***

<a name="396d121b"></a>

## 桶排序

<a name="Hle0W"></a>

### 原理

桶排序是计数排序的升级版，也采用了分冶思想

1. 将要排序的数据分到有限数量的几个有序桶里
2. 每个桶里的数据再单独进行排序(一般用插入排序或者快速排序)
3. 桶内排完序后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了 <a name="dlvUu"></a>

### 实现

```javascript
function bucketSort(arr, bucketSize) {
  if (arr.length === 0) return arr;
  let i = 0;
  let min = arr[0];
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < min) {
      min = arr[i];
    } else if (arr[i] > max) {
      max = arr[i];
    }
  }

  // 初始化桶
  const DEFAULT_BUCKET_SIZE = 5; // 桶的数量
  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
  const bucketCount = Math.floor((max - min) / bucketSize) + 1;
  const buckets = new Array(bucketCount);
  for (let i = 0; i < buckets.length; i++) {
    buckets[i] = [];
  }

  // 利用映射函数将数据分配到各个桶中
  for (let i = 0; i < arr.length; i++) {
    buckets[Math.floor((arr[i] - min) / bucketSize)].push(arr[i]);
  }

  arr.length = 0;
  for (let i = 0; i < buckets.length; i++) {
    quickSort(bucket[i]);
    for (let j = 0; j < buckets[i].length; j++) {
      arr.push(buckets[i][j]);
    }
  }

  return arr;
}

function quickSort(arr) {
  if (arr.length <= 1) return arr;
  const middleIndex = arr.length >> 1;
  const middle = arr.splice(middleIndex, 1)[0];
  const left = [];
  const right = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < middle) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat(middle, quickSort(right));
}
```

***

<a name="6f523ee9"></a>

## 希尔排序

<a name="Fu3mP"></a>

### 原理

1. 先将整个待排序的记录序列分割为若干子序列
2. 分别进行直接插入排序
3. 待整个序列中的记录基本有序时，再对全体记录进行直接插入排序 <a name="FQ3De"></a>

### 例子

1. \[35, 33, 42, 10, 14, 19, 27, 44] 采用间隔为 4, 创建一个位于 4 个位置间隔的所有值的虚拟子列表 \[35, 14] \[33, 19] \[42, 27] \[10, 44]
2. 比较每个子列表的值，并在原始数组中交换它们。完成此步骤后，新数组应改为 \[14, 19, 27, 10, 35, 33, 42, 44]
3. 然后采用 2 间隔，产生两个虚拟子列表 \[14, 27, 35, 42] \[19, 10, 33, 44]
4. 比较并交换原始数组中的值。新数组变为 \[14, 10, 27, 19, 35, 33, 42, 44]
5. 最后，使用间隔为 1 对数组其余部分进行排序，使用插入排序对数组进行排序 <a name="Sh8KJ"></a>

### 实现

```javascript
function shellSort(arr) {
  let gap = 1; // 间隔
  let temp;
  while (gap < arr.length / 3) {
    // 动态定义间隔序列
    gap = gap * 3 + 1;
  }
  for (gap; gap > 0; gap = Math.floot(gap / 3)) {
    for (let i = gap; i < arr.length; i++) {
      for (j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {
        [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]];
      }
    }
  }
  return arr;
}
```

<a name="AKYow"></a>

### 时间复杂度

最佳: O(nlogn) 最差: O(nlog2n) 平均: O(nlog2n)

***

<a name="7da8b8bc"></a>

## 选择排序

<a name="KKCy6"></a>

### 思想

在冒泡排序上做了优化，减少了交换次数，首轮最大数放在第一项，一轮之后第一项就是有序的，第二轮开始选最大值放第二项，重复此操作。 <a name="DsZ5Z"></a>

### 原理

遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值。下次遍历就可以从索引 1 开始重复上述操作。 <a name="PUphp"></a>

### 实现

```javascript
function selectionSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < arr.length; j++) {
      minIndex = arr[j] < arr[minIndex] ? j : minIndex;
    }
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
  }
  return arr;
}
```

<a name="hnNa8"></a>

### 时间复杂度

时间复杂度: O(n2)
