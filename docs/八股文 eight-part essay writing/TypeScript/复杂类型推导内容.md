---
title: 复杂类型推导内容
url: https://www.yuque.com/wcywxq/mxunh7/bvhrsb
---

<a name="NcCzB"></a>

## implement UnionToIntersection

```typescript
type A = UnionToIntersection<{ a: string } | { b: string } | { c: string }>
// { a: string } & { b: string } & { c: string }

// 实现 UnionToIntersection<T>
type UnionToIntersection<U> = 
  (U extends any ? (k: U) => void : never) extends
    ((k: infer I) => void) ? I: never
```

<a name="Cem3Q"></a>

## implement ToNumber

```typescript
type A = ToNumber<'1'> // 1
type B = ToNumber<'40'> // 40
type C = ToNumber<'0'> // 0

// 实现 ToNumber
type ToNumber<T extends string, R extends any[] = []>	=
  T extends `${R[length]}` ? R['length'] : ToNumber<T, [1, ...R]>
```

<a name="sSFZf"></a>

## implement Add\<A, B>

```typescript
type A = Add<1, 2> // 3
type B = Add<0, 0> // 0

// 实现 ADD
type NumberToArray<T, R extends any[]> = 
  T extends R['length'] ? R : NumberToArray<T, [1, ...R]>
type Add<T, R> = [...NumberToArray<T, []>, ...NumberToArray<R, []>['length']]
```

<a name="rDWPU"></a>

## implement SmallerThan\<A, B>

```typescript
type A = SmallerThan<0, 1> // true
type B = SmallerThan<1, 0> // false
type C = SmallerThan<10, 9> // false

// 实现 SmallerThan
type SmallerThan<
  N extends number, 
  M extends number, 
  L extends any[] = [],
  R extends any[] = []
> = N extends L['length'] ? 
    M extends R['length'] ? false : true :
    M extends R['length'] ? false : SmallerThan<N, M[1, ...L], [1, ...R]>
```

<a name="xGILI"></a>

## implement LargerThan\<A, B>

```typescript
type A = LargerThan<0, 1> // false
type B = LargerThan<1, 0> // true
type C = LargerThan<10, 9> // true

// 实现 LargerThan
type LargerThan<
  N extends number,
  M extends number,
  L extends any[] = [],
  R extends any[] = []
> = N extends L['length'] ? false : 
    M extends R['length'] ? true :
    LargerThan<N, M, [1, ...L], [1, ...R]>
```

<a name="vPQFD"></a>

## implement isAny

```typescript
type A = IsAny<string> // false
type B = IsAny<any> // true
type C = IsAny<unknown> // false
type D = IsAny<never> // false

// 实现 IsAny
type IsAny<T> = 
  true extends (T extends never ? true : false) ?
  false extends (T extends never ? true : false) ?
  true : false : false

// 更简单的实现
type IsAny<T> = 0 extends (T & 1) ? true : false
```

<a name="V0YBU"></a>

## implement Filter\<T, A>

```typescript
type A = Filter<[1, 'BFE', 2, true, 'dev'], number> // [1, 2]
type B = Filter<[1, 'BFE', 2, true, 'dev'], string> // ['BFE', 'dev']
type C = Filter<[1, 'BFE', 2, any, 'dev'], string> // ['BFE', any, 'dev']

// 实现 Filter
type Filter<T extends any[], A, N extends any[] = []> =
  T extends [infer P, ...infer Q] ?
    0 extends (P & 1) ? Filter<Q, A, [...N, P]> :
    P extends A ? Filter<Q, A, [...N, P]> : Filter<Q, A, N> :
    N
```

<a name="k1pQ2"></a>

## implement TupleToString

```typescript
type A = TupleToString<['a']> // 'a'
type B = TupleToString<['B', 'F', 'E']> // 'BFE'
type C = TupleToString<[]> // ''

// 实现 TupleToString
type TupleToString<
  T extends any[], 
  S extends string = '',
  A extends any[] = []
> = A['length'] extends T['length'] ? 
    S : 
    TupleToString<T, `${S}${T[A['length']]}`, [1, ...A]>
```

<a name="kHXCx"></a>

## implement RepeatString\<T, C>

```typescript
type A = RepeatString<'a', 3> // 'aaa'
type B = RepeatString<'a', 0> // ''

// 实现 RepeatString
type RepeatString<
  T extends string,
  C extends number,
  S extends string = '',
  A extends any[] = []
> = A['length'] extends C ? 
    S : 
    RepeatString<T, C, `${T}${S}`, [1, ...A]>
```

<a name="X0udW"></a>

## implement Push\<T, I>

```typescript
type A = Push<[1, 2, 3], 4> // [1, 2, 3, 4]
type B = Push<[1], 2> // [1, 2]
type C = Push<[], string> // [string]

// 实现 Push
type Push<T extends any[], I> = T extends [...infer P] ? [...P, I] : [I]
```

<a name="qHNBF"></a>

## implement Flat

```typescript
type A = Flat<[1, 2, 3]> // [1, 2, 3]
type B = Flat<[1, [2, 3]], [4, [5, [6]]]> // [1, 2, 3, 4, 5, 6]
type C = Flat<[]> // []

// 实现 Flat
type Flat<T extends any[]> = 
  T extends [infer P, ...infer Q] ?
  P extends any[] ?
  [...Flat<P>, ...Flat<Q>] :
  [P, ...Flat<Q>] :
  []
```

<a name="pyemE"></a>

## implement Shift

```typescript
type A = Shift<[1,2,3]> // [2,3]
type B = Shift<[1]> // []
type C = Shift<[]> // []

// 实现 Shift
type Shift<T extends any[]> = T extends [infer P, ...infer Q] ? [...Q] : [];
```

<a name="Pwc4Y"></a>

## implement Repeat\<T, C>

```typescript
type A = Repeat<number, 3> // [number, number, number]
type B = Repeat<string, 2> // [string, string]
type C = Repeat<1, 1> // [1, 1]
type D = Repeat<0, 0> // []

// 实现 Repeat
type Repeat<T, C, R extends any[] = []> = 
    R['length'] extends C ? R : Repeat<T, C, [...R, T]>
```

<a name="d8lis"></a>

## implement ReverseTuple

```typescript
type A = ReverseTuple<[string, number, boolean]> // [boolean, number, string]
type B = ReverseTuple<[1, 2, 3]> // [3,2,1]
type C = ReverseTuple<[]> // []

// 实现ReverseTuple
type ReverseTuple<T extends any[], A extends any[] = []> =
    T extends [...infer Q, infer P] ? 
        A['length'] extends T['length'] ? A : ReverseTuple<Q, [...A, P]>
        : A
```

<a name="fnNyr"></a>

## implement UnwrapPromise

```typescript
type A = UnwrapPromise<Promise<string>> // string
type B = UnwrapPromise<Promise<null>> // null
type C = UnwrapPromise<null> // Error

// 实现UnwrapPromise
type UnwrapPromise<T> = T extends Promise<infer P> ? P : Error
```

<a name="Fntwf"></a>

## implement LengthOfString

```typescript
type A = LengthOfString<'BFE.dev'> // 7
type B = LengthOfString<''> // 0

// 实现 LengthOfString
type LengthOfString<T extends string, A extends any[] = []> =
    T extends `${infer P}${infer Q}` ? LengthOfString<Q, [1, ...A]> : A['length']
```

<a name="A1jva"></a>

## implement StringToTuple

```typescript
type A = StringToTuple<'BFE.dev'> // ['B', 'F', 'E', '.', 'd', 'e', 'v']
type B = StringToTuple<''> // []

// 实现
type StringToTuple<T extends string, A extends any[] = []> =
    T extends `${infer K}${infer P}` ? StringToTuple<P, [...A, K]> : A
```

<a name="UKomu"></a>

## implement LengthOfTuple

```typescript
type A = LengthOfTuple<['B', 'F', 'E']> // 3
type B = LengthOfTuple<[]> // 0

// 实现
type LengthOfTuple<T extends any[], R extends any[] = []> =
    R['length'] extends T['length'] ? R['length'] : LengthOfTuple<T, [...R, 1]>
```

<a name="qnQct"></a>

## implement LastItem

```typescript
type A = LastItem<[string, number, boolean]> // boolean
type B = LastItem<['B', 'F', 'E']> // 'E'
type C = LastItem<[]> // never

// 实现LastItem
type LastItem<T> = T extends [...infer P, infer Q] ? Q : never
```

<a name="HwpzB"></a>

## implement FirstItem

```typescript
type A = FirstItem<[string, number, boolean]> // string
type B = FirstItem<['B', 'F', 'E']> // 'B'

// 实现 FirstItem
type FirstItem<T> = T extends [infer P, ...infer Q] ? P : never
```

<a name="pyiKY"></a>

## implement FirstChar

```typescript
type A = FirstChar<'BFE'> // 'B'
type B = FirstChar<'dev'> // 'd'
type C = FirstChar<''> // never

// 实现FirstChar
type FirstChar<T> = T extends `${infer P}${infer Q}` ? P : never
```

<a name="ZNejT"></a>

## implement Pick\<T, K>

```typescript
type Foo = {
  a: string
  b: number
  c: boolean
}

type A = MyPick<Foo, 'a' | 'b'> // { a: string, b: number }
type B = MyPick<Foo, 'c'> // { c: boolean }
type C = MyPick<Foo, 'd'> // Error

// 实现MyPick<T, K>
type MyPick<T, K extends keyof T> = {
    [Key in K]: T[Key]
}
```

<a name="SnLac"></a>

## implement Readonly

```typescript
type Foo = {
  a: string
}

const a: Foo = {
  a: 'BFE.dev',
}
a.a = 'bigfrontend.dev'
// OK

const b: MyReadonly<Foo> = {
  a: 'BFE.dev'
}
b.a = 'bigfrontend.dev'
// Error

// 实现MyReadonly
type MyReadonly<T> = {
    readonly [K in keyof T]: T[K]
}
```

<a name="vJ57T"></a>

## implement Record\<K, V>

```typescript
type Key = 'a' | 'b' | 'c'

const a: Record<Key, string> = {
  a: 'BFE.dev',
  b: 'BFE.dev',
  c: 'BFE.dev'
}
a.a = 'bigfrontend.dev' // OK
a.b = 123 // Error
a.d = 'BFE.dev' // Error

type Foo = MyRecord<{ a: string }, string> // Error

// 实现 MyRecord
type MyRecord<K extends number | string | symbol, V> = {
    [Key in K]: V
}
```

<a name="YYcgo"></a>

## implement Exclude

```typescript
type Foo = 'a' | 'b' | 'c'

type A = MyExclude<Foo, 'a'> // 'b' | 'c'
type B = MyExclude<Foo, 'c'> // 'a' | 'b
type C = MyExclude<Foo, 'c' | 'd'>  // 'a' | 'b'
type D = MyExclude<Foo, 'a' | 'b' | 'c'>  // never

// 实现 MyExclude<T, K>
type MyExclude<T, K> = T extends K ? never : T
```

<a name="dBe6E"></a>

## implement Extract\<T, U>

```typescript
type Foo = 'a' | 'b' | 'c'

type A = MyExtract<Foo, 'a'> // 'a'
type B = MyExtract<Foo, 'a' | 'b'> // 'a' | 'b'
type C = MyExtract<Foo, 'b' | 'c' | 'd' | 'e'>  // 'b' | 'c'
type D = MyExtract<Foo, never>  // never

// 实现 MyExtract<T, U>
type MyExtract<T, U> = T extends U ? T : never
```

<a name="EEjXv"></a>

## implement Omit\<T, K>

```typescript
type Foo = {
  a: string
  b: number
  c: boolean
}

type A = MyOmit<Foo, 'a' | 'b'> // { c: boolean }
type B = MyOmit<Foo, 'c'> // { a: string, b: number }
type C = MyOmit<Foo, 'c' | 'd'> // { a: string, b: number }

// 实现MyOmit
type MyOmit<T, K extends number | string | symbol> = {
    [Key in Exclude<keyof T, K>]: T[Key]
}

type MyOmit<T, K extends number | string | symbol> = Pick<T, Exclude<keyof T, K>>
```

<a name="iecv7"></a>

## implement NonNullable

```typescript
type Foo = 'a' | 'b' | null | undefined

type A = MyNonNullable<Foo> // 'a' | 'b'

// 实现 NonNullable
type MyNonNullable<T> = T extends null | undefined ? never : T
```

<a name="nkrrB"></a>

## implement Parameters

```typescript
type Foo = (a: string, b: number, c: boolean) => string

type A = MyParameters<Foo> // [a: string, b: number, c: boolean]
type B = A[0] // string
type C = MyParameters<{a: string}> // Error

// 实现MyParameters<T>
type MyParameters<T extends (...params: any[]) => any> =
    T extends (...params: [...infer P]) => any ? P : never
```

<a name="Ks1FZ"></a>

## implement ConstructorParameters

```typescript
class Foo {
  constructor (a: string, b: number, c: boolean) {}
}

type C = MyConstructorParameters<typeof Foo> 
// [a: string, b: number, c: boolean]

// 实现 MyConstructorParameters<T>
type MyConstructorParameters<T extends new (...params: any[]) => any> =
    T extends new (...params: [...infer P]) => any ? P : never
```

<a name="FlXRN"></a>

## implement ReturnType

```typescript
type Foo = () => { a: string }

type A = MyReturnType<Foo> // { a: string }

// 实现 MyReturnType<T>
type MyReturnType<T extends (...params: any[]) => any> =
    T extends (...params: any[]) => infer P ? P : never
```

<a name="QdnPB"></a>

## implement InstanceType

```typescript
class Foo {}
type A = MyInstanceType<typeof Foo> // Foo
type B = MyInstanceType<() => string> // Error

// 实现 MyInstanceType<T>
type MyInstanceType<T extends new (...params: any[]) => any> =
    T extends new (...params: any[]) => infer P ? P : never
```

<a name="spEV9"></a>

## implement ThisParameterType

```typescript
function Foo(this: { a: string }) {}
function Bar() {}

type A = MyThisParameterType<typeof Foo> // { a: string }
type B = MyThisParameterType<typeof Bar> // unknown

// 实现 MyThisParameterType<T>
type MyThisParameterType<T extends (this: any, ...params: any[]) => any> =
    T extends (this: infer P, ...params: any[]) => any ? P : unknown
```

<a name="aHGr7"></a>

## implement TupleToUnion

```typescript
type Foo = [string, number, boolean]

type Bar = TupleToUnion<Foo> // string | number | boolean

// 实现 TupleToUnion<T>
type TupleToUnion<T extends any[], R = T[0]> =
    T extends [infer P, ...infer Q] ? TupleToUnion<Q, R | P> : R

// 其他回答
type TupleToUnion<T extends any[]> = T[number]
```

<a name="JlJhZ"></a>

## implement Partial

```typescript
type Foo = {
  a: string
  b: number
  c: boolean
}

// below are all valid

const a: MyPartial<Foo> = {}

const b: MyPartial<Foo> = {
  a: 'BFE.dev'
}

const c: MyPartial<Foo> = {
  b: 123
}

const d: MyPartial<Foo> = {
  b: 123,
  c: true
}

const e: MyPartial<Foo> = {
  a: 'BFE.dev',
  b: 123,
  c: true
}

// 实现 MyPartial<T>
type MyPartial<T> = {
    [K in keyof T]?: T[K]
}
```

<a name="tF6Zt"></a>

## Required

```typescript
// all properties are optional
type Foo = {
  a?: string
  b?: number
  c?: boolean
}


const a: MyRequired<Foo> = {}
// Error

const b: MyRequired<Foo> = {
  a: 'BFE.dev'
}
// Error

const c: MyRequired<Foo> = {
  b: 123
}
// Error

const d: MyRequired<Foo> = {
  b: 123,
  c: true
}
// Error

const e: MyRequired<Foo> = {
  a: 'BFE.dev',
  b: 123,
  c: true
}
// valid

// 实现 MyRequired<T>
type MyRequired<T> = {
    [K in keyof T]-?: T[K]
}
```

<a name="ClXzc"></a>

## implement LastChar

```typescript
type A = LastChar<'BFE'> // 'E'
type B = LastChar<'dev'> // 'v'
type C = LastChar<''> // never

// 实现 FirstChar<T>
type LastChar<T extends string, A extends string[] = []> =
    T extends `${infer P}${infer Q}` ?  LastChar<Q, [...A, P]> :
        A extends [...infer L, infer R] ? R : never
```

<a name="pzxhY"></a>

## implement IsNever

```typescript
type A = IsNever<never> // true
type B = IsNever<string> // false
type C = IsNever<undefined> // false

// 实现 IsNever<T>
type IsNever<T> = [T] extends [never] ? true : false
```

<a name="nrapo"></a>

## implement KeysToUnion

```typescript
type A = KeyToUnion<{
  a: string
  b: number
  c: symbol
}>
// 'a' | 'b' | 'c'

// 实现KeyToUnion
type KeyToUnion<T> = {
  [K in keyof T]: K
}[keyof T]
```

<a name="NNFHB"></a>

## implement ValuesToUnion

```typescript
type A = ValuesToUnion<{
  a: string
  b: number
  c: symbol
}>
// string | number | symbol

// ValuesToUnion
type ValuesToUnion<T> = T[keyof T]
```

<a name="mRn9V"></a>

## FindIndex\<T, E>

```typescript
type IsAny<T> = 0 extends (T & 1) ? true : false;
type IsNever<T> = [T] extends [never] ? true : false;

type TwoAny<A, B> = IsAny<A> extends IsAny<B> ? IsAny<A> : false
type TwoNever<A, B> = IsNever<A> extends IsNever<B> ? IsNever<A> : false

type SingleAny<A, B> = IsAny<A> extends true ? true : IsAny<B>
type SingleNever<A, B> = IsNever<A> extends true ? true : IsNever<B>


type FindIndex<T extends any[], E, A extends any[] = []> =
    T extends [infer P, ...infer Q] ?
        TwoAny<P, E> extends true ? 
            A['length']
            :
            TwoNever<P, E> extends true ?
                A['length']
                :
                SingleAny<P, E> extends true ?
                    FindIndex<Q, E, [1, ...A]>
                    :
                    SingleNever<P, E> extends true ?
                        FindIndex<Q, E, [1, ...A]>
                        :
                        P extends E ? A['length'] : FindIndex<Q, E, [1, ...A]>
        : 
        never
```

<a name="nqpRA"></a>

## implement Trim

```typescript
type A = Trim<'    BFE.dev'> // 'BFE'
type B = Trim<' BFE. dev  '> // 'BFE. dev'
type C = Trim<'  BFE .   dev  '> // 'BFE .   dev'

type StringToTuple<T extends string, A extends any[] = []> =
    T extends `${infer K}${infer P}` ? StringToTuple<P, [...A, K]> : A;

type TupleToString<T extends any[], S extends string = '', A extends any[] = []> =
    A['length'] extends T['length'] ? S : TupleToString<T, `${S}${T[A['length']]}`, [1, ...A]>

type Trim<T extends string, A extends any[] = StringToTuple<T>> =
    A extends [infer P, ...infer Q] ?
        P extends ' ' ?
            Trim<T, Q>
            :
            A extends [...infer M, infer N] ? 
                N extends ' ' ?
                    Trim<T, M>
                    :
                    TupleToString<A>
                :
                ''
        :
        ''
```
