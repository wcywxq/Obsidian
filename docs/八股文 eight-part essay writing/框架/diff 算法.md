---
title: diff 算法
url: https://www.yuque.com/wcywxq/mxunh7/op7dg1
---

<a name="K2rDx"></a>

## diff 算法策略

:::info
`diff` 算法的三个策略(观察的规律)

1. `dom` 节点的跨层级移动操作特别少，可以忽略不计
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构
3. 对于同一层级的一组子节点，可以通过唯一的 `id(key)` 进行区分
   ::: <a name="pu6qR"></a>

### tree diff

因为以上三个策略中的第一点，`dom` 节点的跨级操作比较少，那么 `diff` 算法只会对相同层级的 `dom` 节点进行比较。
如果发现节点不存在，那么会将该节点以及其子节点完全删除，不会再继续比较。
如果出现了 `dom` 节点的跨层级移动操作，那么会删除该节点以及其所有的子节点，然后再移动后的为重新创建。 <a name="gVsIr"></a>

### component diff

如果是同一类型的组件，那么会继续对比 `vm` (虚拟 `dom`)数。
如果不是同一类型的组件，那么会将其和子节点完全替换，不会再进行比对。
同一类型的组件，有可能 `vm` 没有任何的变化，如果可以确定的知道这一点，就可以节省大量的 diff 时间，所以用户可以设置 `shouldComponentUpdate` 判断段是否需要进行 `diff` 算法。 <a name="cuAh5"></a>

### element diff

当节点处于同一层级的时候时，有三种操作：`INSERT_MAKEUP` 插入、`MOVE_EXISTING` 移动、`REMOVE_NODE` 删除，这里 `react` 有一个优化策略，对于同一层级的同组子节点，添加唯一的 `key` 进行区分。
这样的话，就可以判断出来是否是移动节点。通过 `key` 发现新旧集合中的节点都会相同的节点，就只需要进行移动操作即可。 <a name="zZkou"></a>

## 重新渲染 render 会做些什么

- 会对新旧 `VNode` 进行对比，也就是 `diff` 算法
- 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面
- 遍历差异对象，根据差异的类型，根据对应规则更新 `VNode` <a name="wmsRg"></a>

## diff 算法的执行过程

1. 同级比较，然后比较子节点
2. 先判断一方有子节点而另外一方没有子节点的情况(如果新的 `children` 没有子节点，则将旧的子节点移除)
3. 比较双方都有子节点的情况 (核心 `diff`)
4. 递归比较子节点 <a name="oFlGt"></a>

## react 的 diff 算法

`diff` 算法是指生成更新补丁的方式，主要应用于虚拟 `DOM` 树变化后，更新真实 `DOM`。所以 `diff` 算法一定存在这样一个过程：**触发更新 → 生成补丁 → 应用补丁**。

`React` 的 `diff` 算法，触发更新的时机主要在 `state` 变化与 `hooks` 调用之后。此时触发虚拟 `DOM` 树变更遍历，采用了**深度优先遍历算法**。但传统的遍历方式，效率较低。为了优化效率，使用了**分治**的方式。将单一节点比对转化为了 `3` 种类型节点的比对，分别是**树、组件及元素**，以此提升效率。

- 树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 `DOM` 树只对同一层次的节点进行比较。
- 组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。
- 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 `DOM` 剪裁操作。

以上是经典的 `React diff` 算法内容。自 `React 16` 起，引入了 `Fiber` 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 `FiberNode` 与 `FiberTree` 进行重构。

`fiberNode` 使用了**双链表**的结构，可以直接找到兄弟节点与子节点。整个更新过程由 `current` 与 `workInProgress` 两株树双缓冲完成。`workInProgress` 更新完成后，再通过修改 `current` 相关指针指向新节点。 <a name="h6d6E"></a>

## vue 的 diff 算法

<https://juejin.cn/post/7113734401434845191>
正常 `diff` 两个树的时间复杂度是 `O(n^3)`，但实际情况下我们很少会跨层级去移动 `dom`，所以 `vue` 将 `diff` 进行了优化，将时间复杂度从 `O(n^3)`优化为 `O(n)`，只有当新旧 `children` 都为多个子节点时才需要用核心的 `diff` 算法来进行同层比较 <a name="d90cm"></a>

### diff 算法的核心-vue2

`vue2` 的核心 `diff` 算法采用了 **双端比较** 的算法，即同时从新旧 `children` 的两端开始进行比较(头尾指针)，借助 `key` 值找到可复用的节点，然后进行相关操作。对比于 `react` 的 `diff` 算法而言，在相同情况下可以**减少节点的移动次数**，从而减少不必要的性能损耗，整体而言更加优雅。 <a name="rmTp3"></a>

### diff 算法的核心-vue3

`vue3` 借鉴了 **ivi 算法** 和 **inferno 算法**，在创建 `vnode` 的时候就确定其类型，以及在 `mount`/`patch` 的过程中采用 **位运算 **来判断一个 `vnode` 的类型，在这个基础之上再配合核心的 `diff` 算法(双端比较算法)，使得性能上较 `vue2` 而言得到了显著的提升。另外，该算法中还运用了动态规划的思想求解最长递增子序列

```javascript
// 位运算
TEXT = 1 // --取值是1---表示具有动态textContent的元素
CLASS = 1 << 1 // --取值是2---表示有动态Class的元素
STYLE = 1 << 2 // --取值是4---表示动态样式（静态如style="color: pink"，也会提升至动态）
PROPS = 1 << 3 // --取值是8--- 表示具有非类/样式动态道具的元素
FULL_PROPS = 1 << 4 // --取值是16---表示带有动态键的道具的元素，与上面三种相斥
HYDRATE_EVENTS = 1 << 5 // --取值是32---表示带有事件监听器的元素
STABLE_FRAGMENT = 1 << 6 // --取值是64---表示其子顺序不变，不会改变自顺序的片段。
KEYED_FRAGMENT = 1 << 7 // --取值是128---表示带有键控或部分键控子元素的片段。
UNKEYED_FRAGMENT = 1 << 8 // --取值是256---子节点无key绑定的片段（fragment）
NEED_PATCH = 1 << 9 // --取值是512---表示只需要非属性补丁的元素，例如 ref 或 hooks
DYNAMIC_SLOTS = 1 << 10 // --取值是1024---表示具有动态插槽的元素
```

***

***

<a name="ZboGs"></a>

## vue2 和 vue3 的 diff 算法对比

- `vue3` 在 `vue2` 的双端比较算法上做了进一步优化，它只会比较动态节点而忽略静态节点，极大的提高了效率，在实现上采取了**双指针**的思想。另外，该算法中还运用了动态规划的思想求解最长递增子序列
- `vue3` 新增了 **静态标记 (**`**patch flag**`**)**，与上次虚拟节点对比，只会对比带有 `patch flag` 的节点 <a name="EzUzn"></a>

## React 与 Vue 的 diff 算法有何不同

`Vue` 的整体 `diff` 策略与 `React` 对齐，虽然缺乏时间切片能力，但这并不意味着 `Vue` 的性能更差，因为在 `Vue 3` 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 `Vue` 中其他的场景几乎都可以使用防抖和节流去提高响应性能。
