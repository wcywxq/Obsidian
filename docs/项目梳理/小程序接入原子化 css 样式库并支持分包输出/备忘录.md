---
title: 备忘录
url: https://www.yuque.com/wcywxq/aggvdq/pbxykl
---

<a name="WZxVH"></a>

## 第一阶段

<a name="lsGay"></a>

### 第一轮疑问

- \[x] 兼容性(兼容到哪个版本/特性的 tailwind / postcss)，这决定了未来 fork 哪个仓库哪个版本

> 最新版本，tailwind 和 windicss 同时支持

- \[ ] 类 tailwind 库的调研以及是否适配，例如 windicss(目前内置 JIT 后似乎差别不大，代确认)
- \[ ] postcss 和 npx 两种模式下的差异对比

> 在 v3 版本，原子类不多时性能接近，需要在 demo 手动引入大量原子类，或者粗糙地写一个重构工具，跑在小程序项目上

- \[x] 全局样式只能作用于 page 级，无法作用到 component 级 [参考文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html#%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F)
- \[x] 未来分包输出的粒度(page/component) ? 初步思路，按照分包划分，框架层，除主包页面，其余自动 import 分包原子类集合 (区别于目前 stylus 的显示操作)

> 按分包维度输出，分包内页面做 import 即可，组件开启 apply-shared 就可以拿到

- \[x] 未来是否要修改老代码？如果要，是否考虑自动化重构工具

> 未来会像 TypeScript 那样逐步改造并推动成为规范，重构工具待确认

- \[x] 自定义预设集的设计，以及未来是否以单独文档形式展示，甚至是提供一个 playground，能在原始 css 和类 tailwind 语法间进行双向转换
- \[x] 样式隔离

> 利用 apply-shared 实现

最重要的：融合 mpx 策略(分包策略，如何嵌入到目前的构建流程，如指令、cli)

<a name="lFIct"></a>

### 第一轮沟通结果

- 扫描 mpx 文件的过程中，记录原子类是在哪个分包下被使用，实现主包一份，每个分包一份的输出，在当前分包各页面 import 当前分包的原子类文件(测试：组件不用 import 就能拿到?)
- 对于组件在多分包间使用的情况，如果开启 apply-shared 能够将 app.wxss 注入，则无需特殊处理，如果不能，则需要

<a name="aHkMO"></a>

### 第一轮 TODO

- \[x] postcss 流程跑通
- \[x] 自定义预设集原理(以及 mpx issue 里提到的插件调研)
- \[x] 大量原子类时的生成性能
- \[x] JIT 开闭性能对比
- \~~postcss 插件原理~~
- \~~tailwind 原理~~
- \~~mpx 原理~~
  - \~~style-compiler (目前无需改动)~~
  - \~~getPackageInfo~~

<br />
<a name="IKr9m"></a>
### 进度记录

完善 demo

- 能力：多分包，组件分层嵌套，组件跨分包共享
- TODO: 模拟组件间无样式隔离时样式注入会产生 bug 的情况
- 已验证：npx 执行无需安装 postcss
- 待验证：验证 tailwind3 和 postcss8 在 mpx demo 上可以正常表现，并且 tailwind cli 形式比 tailwind2.x 有显著提升

***

<a name="AL1M9"></a>

## 第二阶段

<a name="oyq06"></a>

### 第二轮疑问

- \[x] 是否应该新建一个页面和逻辑稍微复杂的 demo (主要目的是面面聚到，包括：组件嵌套、分包能力、组件在分包间共享、store 划分)，如果已有，是否应该做适当升级

> 可以做，未来也可以考虑成为一个新的 mpx-example

- \[ ] 执行方式，loader 模式 or 手动执行 script 模式

> 暂时手动执行 cli 模式

- \[ ] 全量扫描 mpx 过程中对分包的记录

> 需要在denpendences 中进行修改，问题：如何在扫描过程中记录分包
> 最直观的通过 changedContent(tailwind 全量扫描 mpx 后缀文件得到的路径数组)，或者通过正则来过滤分包

- \[ ] 能否做到，只有在修改 class 部分时，才自动执行 tailwind
- \[ ] tailwindcss cli 下的 watch 模式
- \[ ] apply-shared 是否会与原来的样式隔离有冲突
- \[ ] 是否应该强依赖于某个库，未来如果该库不维护，或者项目内无人跟进新特性，造成的影响是多少
- \[ ] 预设的嵌入模式
- \[ ] 直接写在 tailwind.config.js
- \[ ] 加在项目 build 流程
- \[ ] 以预设包形式独立
- \[ ] 模仿 taro，以 plugin 的形式接入，设置项直接写在 plugin 配置里

<a name="DT8Mf"></a>

### 关于构建方式

- postcss cli 和 tailwind cli 代码设计差异
- 性能对比
- tailwind cli 有完整的 glob 支持 <https://www.tailwindcss.cn/docs/just-in-time-mode#styles-rebuild-in-an-infinite-loop>

<a name="lNw0M"></a>

### 关于接入版本

目前 tailwind3 和postcss8 在 mpx demo 均正常表现，并且 tailwind cli 速度比 v2 版本有较大提升，小程序项目将 postcss 升级到 8+ 有哪些阻力
autoprefixer 已被 postcss8 内置，结合 tailwind 是否有效，待验证

<a name="iFkV5"></a>

### 关于分包策略

直接与 tailwind 解耦，但需要对 h-\[918px] 这种动态 class 语法做兼容处理

<a name="dKVn6"></a>

### 关于复杂 class

windicss 可以在 template 中处理截断并用 js 处理 class, tailwind 不可能截断 class，把选择权交给使用者

<a name="PTuvs"></a>

### 关于与处理器冲突

后续改为扫描原生打包后的代码，解决了此问题

<a name="sMYla"></a>

### 关于预设

- 以什么形式维护
  - 直接写在 tailwind.config.js
  - 加到项目的 build 流程
  - 以预设包的形式独立出来
  - 模仿 taro、以 plugin 的形式接入，设置项直接写在 plugin 配置里
- 可能需要自定义的属性
  - 颜色、字体、背景...
  - 图片...
- 开发者自定义样式怎么组织
  - 在 tailwind.css 处定义：最接近原生，但感觉不易于按照模块进行区分，可以按照模块再划分子目录后合并(能实现图片素材中的几种管理，例如只有一张图，想找到对应组件很难，集中管理之后就可以直接在相应文件夹的图片列表中找到，也需要耐心和运气)
  - 像原来一样写死在组件内 style 里，但此时需要用传统 class 写法，想象一个自定义 className，可能会与原子类混用
- 如果所有使用 css 特性，在 tailwind 中无对应 match rule，tailwind 中是否有提示，没有的话是不是要自己增加 warning(如何与自定义 class 的区别)

<a name="WtYH8"></a>

### 关于抹平

- 特殊符号 `./` 的抹平思路
  - taro: 统一替换为下划线
  - 其他框架：-div-、-dot-
- theme 验证
- variant 验证
- corePlugin 验证
- 需要写哪些 plugin

<a name="uJrRH"></a>

### 测试 demo 及数据

- mpx 是否需要，新增或对某个已有 demo 进行改造，增强能力，主要目的是面面俱到，包括组件嵌套、分包能力、组件在分包间共享、store 划分...
- 性能测试数据
- 大量原子类场景下的性能以及体积验证
  - 从官网手动复制粘贴到 demo
  - 提前写一个粗糙的重构工具，完成从 selector 到 class 拼接的映射，用到滴滴小程序上再做验证

<a name="fWglg"></a>

### 第二轮沟通结果

- 扫描 dist
- 可以预见的优点
  - 不需要再全量扫描 mpx 文件所有内容，而是只扫 template / wxml 部分，提升性能
  - 基于打出来的原生小程序，利于开源
  - 解决了如果扫描源文件，还需要扫描依赖中第三方业务的问题
- postcss 升级
- componentMapping
- 非通用样式就以原生样式书写，尽量保持只有一份 config

<a name="mBVIh"></a>

### 分包策略

通过 node 脚本异步处理 dist/wx 下每一个分包，并在分包目录下输出样式文件

> 注意：此处需要额外做一个处理，tailwind 扫描文件的依据是 config.content，所以例如扫描 subpackage1 时，需要将当前 config.content 动态处理成 `['./dist/wx/subpackage1/**/*.wxml']`，以此类推

边界处理(是否要把 cli 内容给加到 node 脚本，粒度待讨论)

- 分包 page 自动 import 当前分包打出的样式
- 检查分包下所有 index.json 是否开启 apply-shared，没有则输出 warning 或者自动加上(添加 usingComponent 判断避免误伤)
  - 待确定：如果用户之前的 styleIsolation 设置为其他值应该如何处理
- 识别无 wxml 文件目录，跳过处理(是否借助 fast-glob，或者糅合 cli 流程)，或者等打出空目录之后，在公共样式提取阶段，对空文件进行删除
- 识别非分包目录，统一按主包文件扫描处理(待确认是否 ok)

<a name="L8grL"></a>

### 多分包共用原子类去重提重

删除并提取每个分包下的公共原子类，并提升到主包或独立样式分包(孰优孰劣待验证，如果会导致主包超级大，就改到独立样式分包)
方案：以 postcss 插件形式
Q: 是否增加去重策略，比如用户可以自定义分包重复 n 次的类才会提取到主包，以达到动态调整主包样式体积到最佳的目的

config 样式融合(怎样达到心智负担最低)
统一扫文件和记录 app.json 的方式(选择 fast-glob)
小程序只支持 import 相对路径
省略冗余操作，分包全扫，输出时全部获取

- 关闭分包内除第一层的操作

怎样区分主包和分包
策略模式优化
是否需要 import 主包样式
是否增加文件内部的重复判断(躲避 tailwind 或者其他原因产生的 bug)
原项目问题，未对主包做样式输出(只做了剔除处理)
粒度调整(重复 n 次)
是否应该保留 css 全量扫描，检测防止用户自定义 class 与 tailwind 命名冲突

<a name="Pa3dt"></a>

### 动态值语法抹平

参考：<https://www.tailwindcss.cn/docs/just-in-time-mode#arbitrary-value-support>
例如：色值，样式 url 等自定义样式可以直接写在方括号中，那么之前想的绝大部分需要自定义的场景都不需要了，工作就转换为怎样支持例如 `h-[918px]` `bg-[#1da1f1]` 这样的语法。如果解决成本很高，或者特别麻烦，则考虑

- 不用动态值，混用原来的写法
- 类似 taro 那样直接换用 windicss，windicss 可以直接支持 `h-[918px]` `bg-[#1da1f1]`

<a name="F3TIi"></a>

### 自定义样式

虽然 `[..]` 语法解决了绝大多数以前需要自定义的情况，但仍免不了开发时有可能需要手动自动义的情况，需要考虑自定义样式怎么写，会不会被覆盖的问题
初步拟定：只用一份 tailwind.config，再其下的分包划分子目录，对应分包的自定义样式放在对应文件下，最后全部合并(注：考虑第三方分包的情况)

<a name="Hs7Ks"></a>

### 接入 windicss

接入 windicss，让使用者可以自行选择

<a name="GSCbG"></a>

### Tailwind cli 兼容

问题升级：

- 学习 tailwind cli 中 rebuild 的思路，实现 rebuild 速度提升
- 如何兼容 cli 提供的配置

<a name="W0ygJ"></a>

### demo 完善

- 增加分包的组件目录
- 增加测试的原子类数据

<a name="QLhAw"></a>

### 自动重构工具

有三种情况可能需要重构工具

- 未来对滴滴小程序项目逐步重构
- 正式重构前，可能需要先对小程序项目粗糙地进行全量改造(用于性能和体积测试，评估效益)
- 方便外部使用者

尽量使用自动化重构 + 人工 review 的方案
参考 tailwind，对样式表做反向映射

<a name="gxBQI"></a>

### 确认版本

需要确认滴滴小程序 postcss 的配套插件都有能升级并兼容到 v8+ 的版本 <a name="Gwygs"></a>

### 第二轮进度

提重插件接入适配
探究 windi 的 input file 数组实现
tailwind 中动态更改 config content
脚手架化，自定义 config 配置设计，ali argvs 注入原生脚手架设计
fast-glob & node-glob (windi使用)调研，将原方法改造为 glob 扫描
windi 接入
分包扫描概念确定
分包名可能是类似 a/b/c，所以最佳还是通过 app.json 拼出分包路径再进行扫描

<a name="ejjFc"></a>

### 初步设想

- 思路

向外提供一套完整的原生小程序接入/重构 tailwind 方案(将以下能力集成并配置化)

- 用户可以选择切换 tailwind 模式或 windicss 模式
- 分包处理 + 公共样式提取(可配置场景：用户可以选择是否使用分包场景；可配置样式表生成方案，例如主包一份/分包各自一份/独立分包一份/指定分包输出)
- 更细化的小程序专用预设，以及提供给使用者更多的选择(解决动态值的抹平；针对 toB 和 toC 有格子定制场景，比如 toB 侧重复用模版，toC 侧重自定义值)
- 提供 demo + 配套的自动化重构工具
- 基于官方的 playground，写入自己的 config，然后生成分享链接，作为定制小程序语法的 playground

> 适用场景：所有原生小程序 + 所有原小程序框架处理后打包出的原生小程序文件

- 大致目录划分

```markdown
不知道取啥名              
├── lib
│ ├── processSubpackage.ts // 核心流程:按分包输出样式 + postcss插件提重         
│ ├── accessWatch.ts       // watch & rebuild
├── presets           // 针对小程序场景的内置预设
│ ├── tailwindPreset  // tailwind 预设集
│ └── windiPrset      // windicss 预设集
├── customStyle       // 用户自定义原子类
│ ├──subpackageName   // 根据app.json的扫描得到的分包自动生成目录
├── utils             // 工具集
│ ├── extractPlugin   // 用于提重的postcss插件
│ ├── refactHelper    // 自动重构工具
├── config.ts         // 用户配置文件(例如选择tail或windi/是否分包处理)
├── index.ts          // config.js 处理 & cli配置
└── example           // demo(自带分包+测试类)
```

- 优点
  - 基于原生，适用全场景，与小程序框架解耦
  - 基于 tailwind cli 和 windicss cli 上层封装，与 tailwind 和 windicss 源码本身解耦，可以随时间同步新特性
  - 高度自定义(将特性都做成用户可配置，例如样式库选择，分包输出策略 ，去重策略等)
  - 提供重构工具，快速改造旧项目

<a name="gCEGD"></a>

### 对当前最佳实践的探索

- vscode 插件：Tailwind Css IntelliSense 关联 mpx 以及 wxml
- 组件拿到页面样式：`"stylelsolation": "apply-shared"`
- demo 目前在 node v14.18.0 下不会报错

<a name="ibiyG"></a>

## 第三阶段

- 问题
  - 可调试性变差，之前可以直接在开发者工具增删改 css
  - windicss 给 web 调试提供了 windi:devtools，待验证小程序中是否生效
  - watch 提速
  - 增加 debug 模式，例如开启核心变量 console，debugger

<a name="unLPb"></a>

# 附

<a name="taezl"></a>

## 参考文档

系列文章：<https://developers.weixin.qq.com/community/personal/oCJUsw1GWHOwOLn7MZ4Rbb8T-FVE>
purge 分析：<https://gitee.com/sl1673495/pictures/issues/I3CJER?_from=gitee_search>
小程序文档-样式隔离：<https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html> <a name="TzYwE"></a>

## 参考仓库及分支

demo：<https://github.com/gloomyKevin/mpx-example-king>

- features 集成分支：dev
- 预设：<https://github.com/gloomyKevin/tailwindcss-miniprogram-preset>
- fork 下来后独立发包：<https://www.npmjs.com/package/mpx-tailwindcss-preset>

当前版本：2.1.4

- 插件：<https://github.com/theowenyoung/mini-tailwind>
- 新版 taro 插件：<https://github.com/pcdotfan/taro-plugin-tailwind>
- 旧版 taro 插件：<https://github.com/windedge/taro-tailwind>
