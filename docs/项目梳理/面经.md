---
title: 面经
url: https://www.yuque.com/wcywxq/aggvdq/uhv9t2
---

- 项目
  - 行程中，订单流转
  - 冒泡页，发单拦截
  - webx，任务队列，架构设计
- 八股文
- mpx 框架
  - mpx 响应式原理
    - 在构建编译过程中，将 template 模块转化为 renderFunction，提供了渲染模版时所需响应式数据的访问机制，并将 renderFunction 注入到运行时代码中
    - 在运行环节，mpx 通过创建一个小程序实例的代理对象，将小程序实例上的数据访问全部代理到 MPXProxy 实例上，而 MPXProxy 实例即 mpx 基于 mobx 去创建的一套响应式数据对象，首先将 data 数据转化为响应式数据，其次提供了 computed 计算属性，watch 方法等一些列增强的扩展属性/方法，虽然在业务代码中 page/component 实例 this 都是小程序提供的，但是最终经过代理机制，实际上访问的是 MPXProxy 所提供的增强功能，所以 mpx 也是通过这样一个代理对象去接管了小程序的实例。
    - 另外，mpx 将小程序官方提供的 setData 方法同样收敛到内部，这也是响应式系统提供的基础能力，即：开发者只需要关注业务开发，而有关小程序渲染运行，在 mpx 内部已经帮我们完成了
  - mpx 性能优化
    - 由于小程序的双线程的架构设计，逻辑层和视图层之间需要桥接 native bridge，如果要完成视图层的更新，那么逻辑层需要调用 setData 方法，数据经由 native bridge，再到渲染层，整体流程为：
      - 小程序逻辑层调用宿主环境的 setData 方法
      - 逻辑层执行 JSON.stringify 将待传输数据转换成字符串并凭借到特定的 js 脚本，并通过 evaluteJavascript 执行脚本将数据传输到渲染层
      - 渲染层接收后，webview js 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 webview 线程空闲时进行页面渲染
      - webview 线程开始执行渲染时，待更新数据会合并到视图层并保留原始 data 数据，并将新数据套用在 wxml 片段中得到新的虚拟节点树，经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到 ui 视图，同时将新的节点树替换旧节点树，用于下一次重渲染
    - 尽可能减少 setData 传输数据
    - 尽可能减少 setData 调用频率
  - mpx 条件编译
    - mpx 跨平台编译的额原则在于，能转则转，转不了则报错提示，对于无法抹平差异的部分，我们提供了完善的跨平台条件编译机制，便于用户处理因平台差异而无法相互转换的部分，也能够用于实现具有平台差异性的业务逻辑
    - mpx 中支持了三种维度的条件编译，分别是：文件维度、区块维度和代码维度，其中，文件维度和区块维度主要用于处理一些大块的平台差异性逻辑，而代码维度主要用于处理一些局部简单的平台差异
      - 文件维度：通过新建 xx.mode.mpx，使用对应平台的技术标准进行开发
      - 区块维度：只需要在区块标签中添加 mode 属性定义该区块的目标平台即可
      - 代码维度：使用 `__mpx_mode__` 进行逻辑处理
      - 属性维度：通过在组件上使用`@`和`｜`符号来指定某个节点或属性只能在某些平台下有效
      - env 环境维度：通过自定义 env 的形式实现在不同环境下编译产出不同代码
  - mpx 的 store
    - 基于 mobx 重新封装实现一个符合 vuex 规范的数据管理 store，能够方便地注入组件进行全局数据管理。为了提高跨团队开发的体验，对 store** 添加了多实例可合并**的特性，不同团队维护自己的 store，在需要时能够合并他人或者公共的 store 生成新的 store 实例，我们认为这是一种比 vuex 中 modules 更加灵活便捷的跨团队数据管理模式
- 小程序
- \[x] 微信小程序渲染流程
- \[ ] 微信小程序自定义事件的方式
- \[x] 微信小程序绑定事件的方式
- \[ ] 微信小程序订阅流程
- \[x] 微信小程序登陆流程
- \[x] h5 如何唤醒小程序
- \[ ] 小程序和 h5 的区别
- \[x] scroll-view 如何进行下拉刷新
- \[ ] 微信小程序如何实现页面之间的数据传递
- \[x] 微信小程序跳转的几种方式
- \[x] 微信小程序接收参数的几种方法
- \[ ] wxss 和 css 的区别
- 笔试
  - 输出结果

```vue
<template>
  <div id="container">{{ count }}</div>
</template>
<script>
  export default {
    data() {
      return { count: 0 }
    },
    watch: {
      count(newVal, oldVal) {
        // 打印几次，值是多少？1, 3
        console.log(newVal)
      }
    },
    mounted() {
      for (var i = 1; i <= 3; i++) {
        this.count += 1
      }
      // 值是多少? 0
      console.log(document.querySelector('#container').innerText)
    }
  }
</script>
```

- 原型输出

```javascript
function A() {}
var a = new A()
console.log(a.__proto__) // f A() {}
console.log(a.__proto__.__proto__) // f Object() {}
console.log(A.prototype.__proto__) // f Object() {}
console.log(typeof Object) // "function"
```

- \[x] 实现一个带缓存功能的请求函数
- \[ ] 实现字符串计算器
- \[ ] 处理时间，显示几分钟前
- \[ ] 实现 JSON.stringify
- \[ ] 实现 lodash.get 方法
- \[ ] js 格式化时间
- 算法
- \[ ] leetcode 岛屿问题
- \[ ] leetcode 接雨水
- \[ ] leetcode 无重复最长子串
- \[ ] leetcode 41 缺失的第一个整数
- \[ ] leetcode 628 三个数的最大乘积
- \[ ] leetcode 1249 移除无效的括号
- \[ ] 剑指 offer 50 第一个只出现一次的字符
- \[ ] 剑指 offer 1534 统计好三元组
- \[ ] 剑指 offer 29 顺时针螺旋矩阵
- 场景
  - 设计一个组件，该组件是一个 Input 输入框，有下拉功能，可以发请求
    - 防抖
    - 控制 response 时序
    - 大数据量处理
