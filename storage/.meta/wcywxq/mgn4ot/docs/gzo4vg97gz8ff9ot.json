{
  "id": 147068436,
  "slug": "gzo4vg97gz8ff9ot",
  "title": "javascript",
  "description": "进程和线程进程概念：进程是操作系统进行资源分配和管理的最小单位，是能够拥有系统资源的最小单位。一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值理解：任何程序运行都需要有它自己专属的内存空间，可以把这块内存空间简单理解为进程。每个应用至少有一个进程，进程之间相互独立，即使要通信，也需...",
  "cover": "https://cdn.nlark.com/yuque/0/2023/png/732231/1700232519829-78125731-5e57-45f0-a3a6-7830fb2ce120.png",
  "user_id": 732231,
  "book_id": 44240028,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"JEo5n\"><span class=\"ne-text\">进程和线程</span></h2><h3 id=\"nBfC3\"><span class=\"ne-text\">进程</span></h3><ul class=\"ne-ul\"><li id=\"u4e17911c\" data-lake-index-type=\"0\"><span class=\"ne-text\">概念：进程是操作系统进行资源分配和管理的最小单位，是能够拥有系统资源的最小单位。一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值</span></li><li id=\"ua586dc9a\" data-lake-index-type=\"0\"><span class=\"ne-text\">理解：任何程序运行都需要有它自己专属的内存空间，可以把这块内存空间简单理解为进程。每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意</span></li></ul><h3 id=\"GsUdR\"><span class=\"ne-text\">线程</span></h3><ul class=\"ne-ul\"><li id=\"u9c80d41f\" data-lake-index-type=\"0\"><span class=\"ne-text\">概念：线程是进程中执行运算的最小单位</span></li><li id=\"ua9643d6c\" data-lake-index-type=\"0\"><span class=\"ne-text\">理解：在拥有进程后，就可以运行程序代码，而运行代码的 &quot;人&quot; 称之为线程。一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程也被称为</span><strong><span class=\"ne-text\">主线程</span></strong><span class=\"ne-text\">。如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以</span><strong><span class=\"ne-text\">一个进程中可以包含多个线程</span></strong></li></ul><h3 id=\"oBx5h\"><span class=\"ne-text\">进程和线程的区别</span></h3><ul class=\"ne-ul\"><li id=\"u2c73120a\" data-lake-index-type=\"0\"><span class=\"ne-text\">进程是计算机管理运行程序的一种方式，一个进程下可包含一个或者多个线程。线程可以理解为子进程</span></li><li id=\"u8b62dd98\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(32, 33, 34)\">一个线程只能属于一个进程，而一个进程可以包含多个线程</span></li><li id=\"u6dbc0d2d\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(32, 33, 34)\">线程无地址空间，它包括在进程的地址空间里</span></li><li id=\"u0b7ffd9e\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(32, 33, 34)\">线程的开销和代价比进程小</span></li></ul><h3 id=\"b3IF7\"><span class=\"ne-text\">浏览器有哪些进程和线程</span></h3><p id=\"u4253d197\" class=\"ne-p\"><strong><span class=\"ne-text\">浏览器是一个多进程多线程的应用程序</span></strong><span class=\"ne-text\">，其内部工作极其复杂，为了避免各工作间相互影响，同时减少连环崩溃的几率，当启动浏览器后，它将会自动启动多个进程。（另外，可以在浏览器的任务管理器中查看当前的所有进程）</span></p><p id=\"ub9e6b2d1\" class=\"ne-p\"><span class=\"ne-text\">最主要的进程如下：</span></p><ol class=\"ne-ol\"><li id=\"ue939426b\" data-lake-index-type=\"0\"><span class=\"ne-text\">浏览器进程：主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务</span></li><li id=\"u19c85b21\" data-lake-index-type=\"0\"><span class=\"ne-text\">网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务</span></li><li id=\"u134104bd\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">渲染进程</span></strong><span class=\"ne-text\">：渲染进程启动后，会开启一个</span><strong><span class=\"ne-text\">渲染主线程</span></strong><span class=\"ne-text\">，它负责执行 html、css、js 代码</span></li></ol><p id=\"u3f3ea18a\" class=\"ne-p\"><span class=\"ne-text\">默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响（未来可能会限制同一个域下共用一个渲染进程，具体需要参考 </span><a href=\"https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability\" data-href=\"https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">chrome 官网文档</span></a><span class=\"ne-text\">）</span></p><h3 id=\"NuMU7\"><span class=\"ne-text\">渲染主线程是如何工作的</span></h3><p id=\"u72b75f93\" class=\"ne-p\"><span class=\"ne-text\">渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于</span></p><ul class=\"ne-ul\"><li id=\"uc9eebfd9\" data-lake-index-type=\"0\"><span class=\"ne-text\">解析 html</span></li><li id=\"u7eb71df5\" data-lake-index-type=\"0\"><span class=\"ne-text\">解析 css</span></li><li id=\"u4d3a8453\" data-lake-index-type=\"0\"><span class=\"ne-text\">计算样式</span></li><li id=\"u87bf95d4\" data-lake-index-type=\"0\"><span class=\"ne-text\">布局</span></li><li id=\"u79a5b695\" data-lake-index-type=\"0\"><span class=\"ne-text\">处理图层</span></li><li id=\"u6c78d1ec\" data-lake-index-type=\"0\"><span class=\"ne-text\">每秒把页面画 60 次</span></li><li id=\"u85857a32\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行全局 js 代码</span></li><li id=\"udf2e97ab\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行时间处理函数</span></li><li id=\"u8c685902\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行计时器的回调函数</span></li><li id=\"u092deb75\" data-lake-index-type=\"0\"><span class=\"ne-text\">......</span></li></ul><h3 id=\"npC5D\"><span class=\"ne-text\">为什么 js 是单线程</span></h3><p id=\"u1d9b89c5\" class=\"ne-p\"><span class=\"ne-text\">因为多个线程同时操作 dom，会发生冲突，出现意料之外的情况。所以说，</span><strong><span class=\"ne-text\">单线程是异步产生的原因</span></strong></p><h3 id=\"krL6t\"><span class=\"ne-text\">渲染主线程的排队机制（事件循环 or 消息循环）</span></h3><p id=\"ud2697bb6\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/732231/1700256055361-d609be7e-7f21-43d7-88f5-f464da0c450c.png\" width=\"451.2\" id=\"u27c65aec\" class=\"ne-image\"></p><ol class=\"ne-ol\"><li id=\"u57df05c6\" data-lake-index-type=\"0\"><span class=\"ne-text\">最开始时，渲染主线程会进入一个</span><strong><span class=\"ne-text\">无限循环</span></strong></li><li id=\"ubbd5141d\" data-lake-index-type=\"0\"><span class=\"ne-text\">每一次循环会</span><strong><span class=\"ne-text\">检查消息队列</span></strong><span class=\"ne-text\">中是否有任务存在。如果有，就取出第一个任务来执行，执行完当前任务后，进入下一次循环；如果没有任务等待被执行，则进入休眠状态</span></li><li id=\"u332c0373\" data-lake-index-type=\"0\"><span class=\"ne-text\">其他所有线程（包括其他进程的线程）可以随时向消息队列中添加任务。新任务会被添加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续通过循环来拿取任务</span></li></ol><h2 id=\"o1x4y\"><span class=\"ne-text\">事件循环</span></h2><h3 id=\"EqdKK\"><span class=\"ne-text\">如何理解 js 的异步</span></h3><ol class=\"ne-ol\"><li id=\"ue821a135\" data-lake-index-type=\"0\"><span class=\"ne-text\">js 是一门</span><strong><span class=\"ne-text\">单线程</span></strong><span class=\"ne-text\">的语言，这是因为它运行在浏览器的</span><strong><span class=\"ne-text\">渲染主线程</span></strong><span class=\"ne-text\">中，而</span><strong><span class=\"ne-text\">渲染主线程只有一个</span></strong><span class=\"ne-text\">。同时渲染主线程承担着诸多的工作，页面渲染、js 执行都在其中运行。</span></li><li id=\"uffb27c21\" data-lake-index-type=\"0\"><span class=\"ne-text\">如果采用同步的方式，极有可能导致主线程产生阻塞，从而导致</span><strong><span class=\"ne-text\">消息队列（事件队列）</span></strong><span class=\"ne-text\">中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白消耗时间，另一方面会导致页面无法及时更新，给用户造成页面卡死的现象</span></li><li id=\"uf073ecef\" data-lake-index-type=\"0\"><span class=\"ne-text\">因此浏览器采取异步的方式来避免以上情况。具体做法是：当某些任务发生时，如</span><strong><span class=\"ne-text\">计时器、网络、事件监听</span></strong><span class=\"ne-text\">等，</span><strong><span class=\"ne-text\">主线程</span></strong><span class=\"ne-text\">将任务</span><strong><span class=\"ne-text\">交给其他线程</span></strong><span class=\"ne-text\">去处理，</span><strong><span class=\"ne-text\">自身立即结束任务的执行</span></strong><span class=\"ne-text\">，转而</span><strong><span class=\"ne-text\">执行后续的任务</span></strong><span class=\"ne-text\">。当其他线程完成时，将事先传递的</span><strong><span class=\"ne-text\">回调函数包装成任务</span></strong><span class=\"ne-text\">，加入到</span><strong><span class=\"ne-text\">消息队列（事件队列）的末尾排队</span></strong><span class=\"ne-text\">，</span><strong><span class=\"ne-text\">等待主线程调度执行</span></strong></li><li id=\"udd36f866\" data-lake-index-type=\"0\"><span class=\"ne-text\">在这种异步模式下，浏览器永不阻塞，从而最大幅度的保证了单线程的流畅运行</span></li></ol><h3 id=\"ohRDl\"><span class=\"ne-text\">浏览器的事件循环机制 event loop</span></h3><ul class=\"ne-ul\"><li id=\"u809095e6\" data-lake-index-type=\"0\"><span class=\"ne-text\">事件循环又叫做消息循环（chrome 里叫 message loop），是</span><strong><span class=\"ne-text\">浏览器渲染主线程的工作方式</span></strong><span class=\"ne-text\">（也是</span><strong><span class=\"ne-text\">异步的实现方式</span></strong><span class=\"ne-text\">）</span></li><li id=\"ub23ce813\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 chrome 的源码中，它会开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时机将任务加入到队列末尾即可</span></li><li id=\"u9011d5c5\" data-lake-index-type=\"0\"><span class=\"ne-text\">过去把消息队列简单分为宏任务队列和微任务队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式</span></li><li id=\"u0b44947e\" data-lake-index-type=\"0\"><span class=\"ne-text\">根据 w3c 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须拥有一个微任务队列，微任务队列的任务一定具有最高的优先级，从而优先调度执行</span></li></ul><h3 id=\"l0hIq\"><span class=\"ne-text\">js 中计时器是否能做到精准计时</span></h3><p id=\"uf46db2c3\" class=\"ne-p\"><span class=\"ne-text\">无法做到精准计时</span></p><ol class=\"ne-ol\"><li id=\"u48c8409d\" data-lake-index-type=\"0\"><span class=\"ne-text\">计算机硬件没有原子钟，无法做到精准计时</span></li><li id=\"u080eefe8\" data-lake-index-type=\"0\"><span class=\"ne-text\">操作系统的计时函数本身就存在少量偏差，由于 js 计时器最终调用的是操作系统的函数，因此也会携带这些偏差</span></li><li id=\"uccab18b3\" data-lake-index-type=\"0\"><span class=\"ne-text\">根据 w3c 标准，浏览器在实现计时器时，如果嵌套层级超过 5 层，从第 6 层开始会带有 4ms 的延迟时间，因此在计时时间 &lt; 4ms 时又带来了些许偏差</span></li><li id=\"u67a9a1d1\" data-lake-index-type=\"0\"><span class=\"ne-text\">受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</span></li></ol><h3 id=\"HlZmO\"><span class=\"ne-text\">执行栈和事件队列</span></h3><ul class=\"ne-ul\"><li id=\"u241b834b\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行栈：类似</span><strong><span class=\"ne-text\">函数调用栈</span></strong><span class=\"ne-text\">的运行容器，执行栈为空时，js 引擎会检查事件队列是否为空，如果不为空，那么将第一个任务压入执行栈中执行</span></li><li id=\"u367aaffe\" data-lake-index-type=\"0\"><span class=\"ne-text\">事件队列 or 消息队列：一个</span><strong><span class=\"ne-text\">存储着待执行任务</span></strong><span class=\"ne-text\">的队列，其中的任务</span><strong><span class=\"ne-text\">严格按照时间顺序</span></strong><span class=\"ne-text\">来执行，</span><strong><span class=\"ne-text\">队首的任务率先执行</span></strong><span class=\"ne-text\">，</span><strong><span class=\"ne-text\">队尾的任务最后执行</span></strong><span class=\"ne-text\">。同时每次仅执行一个任务</span></li></ul><h3 id=\"TeWGN\"><span class=\"ne-text\">任务或消息队列的优先级</span></h3><p id=\"u01b25436\" class=\"ne-p\"><span class=\"ne-text\">任务没有优先级，它在消息队列中先进先出。然而</span><strong><span class=\"ne-text\">消息队列是有优先级的</span></strong></p><p id=\"u17f4bbe6\" class=\"ne-p\"><span class=\"ne-text\">根据 w3c 的最新解释：</span></p><ul class=\"ne-ul\"><li id=\"u39278466\" data-lake-index-type=\"0\"><span class=\"ne-text\">每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</span></li><li id=\"u803f4cf2\" data-lake-index-type=\"0\"><span class=\"ne-text\">浏览器必须准备好一个微任务队列，</span><a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" data-href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">微任务队列中的任务优先于所有其他任务执行</span></a></li></ul><h3 id=\"IKSWL\"><span class=\"ne-text\">任务队列都有哪些</span></h3><p id=\"u04917572\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/732231/1700232559234-0777bb5b-1f74-4b49-abd1-194c8be16c1d.png\" width=\"981\" id=\"yMEIq\" class=\"ne-image\"></p><p id=\"u27cf6e9d\" class=\"ne-p\"><span class=\"ne-text\">在目前的 chrome 的实现中，至少包含了下面的队列：</span></p><ul class=\"ne-ul\"><li id=\"uf919ec60\" data-lake-index-type=\"0\"><span class=\"ne-text\">延时队列：用以存放</span><strong><span class=\"ne-text\">计时器到达后的回调任务</span></strong><span class=\"ne-text\">，优先级 - 中</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u3f4f41df\" data-lake-index-type=\"0\"><span class=\"ne-text\">setTimeout</span></li><li id=\"ua8b02786\" data-lake-index-type=\"0\"><span class=\"ne-text\">setInterval</span></li><li id=\"u671cada8\" data-lake-index-type=\"0\"><span class=\"ne-text\">setImmediate</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u236a9d80\" data-lake-index-type=\"0\"><span class=\"ne-text\">交互队列：用于存放</span><strong><span class=\"ne-text\">用户操作后产生的事件处理任务</span></strong><span class=\"ne-text\">，优先级 - 高</span></li><li id=\"ubfa9013f\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列：用以存放</span><strong><span class=\"ne-text\">需要最快被执行的任务</span></strong><span class=\"ne-text\">，优先级 - 最高</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ua02fc8fa\" data-lake-index-type=\"0\"><span class=\"ne-text\">promise 回调 - 必须有 resolve or reject 结果，同一块作用域内多个 resolve 中，期中一个执行完毕后其余的皆不再执行</span></li><li id=\"u43b56753\" data-lake-index-type=\"0\"><span class=\"ne-text\">node.js 的 process.nextTick</span></li><li id=\"u9d186ac1\" data-lake-index-type=\"0\"><span class=\"ne-text\">MutationObserver -  对 dom 变化进行监听</span></li></ul></ul><div class=\"ne-quote\"><p id=\"u7a7bb360\" class=\"ne-p\"><span class=\"ne-text\">浏览器认为与用户交互相关的任务优先级可能比延时任务的优先级更高</span></p></div><h3 id=\"cUQDd\"><span class=\"ne-text\">requestAnimationFrame 和 requestIdleCallback</span></h3><p id=\"u6946777b\" class=\"ne-p\"><span class=\"ne-text\">前者是在渲染前执行的，因为动画会更改 dom 结构，后者是用来处理计算量大但不紧急的事件，当队列中没有任务执行时，会清空它内部的回调，也可以传入 timeout 参数，强制 timeout 秒后执行，但是会阻塞其他代码的执行</span></p><hr id=\"fArB5\" class=\"ne-hr\"><h3 id=\"KLzYc\"><span class=\"ne-text\">⚠️</span><span class=\"ne-text\"> 旧 - 浏览器事件循环机制 event loop</span></h3><ul class=\"ne-ul\"><li id=\"u517f16a2\" data-lake-index-type=\"0\"><span class=\"ne-text\">js 是单线程执行的，在代码执行的过程中，通过将不同函数的</span><strong><span class=\"ne-text\">执行上下文</span></strong><span class=\"ne-text\">压入</span><strong><span class=\"ne-text\">执行栈</span></strong><span class=\"ne-text\">中来保证代码的有序执行</span></li><li id=\"u307a10c8\" data-lake-index-type=\"0\"><span class=\"ne-text\">最开始将整个 </span><strong><span class=\"ne-text\">script 脚本作为一个宏任务</span></strong><span class=\"ne-text\">执行，执行过程中</span><strong><span class=\"ne-text\">同步代码</span></strong><span class=\"ne-text\">直接执行</span></li><li id=\"u4f08934c\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行同步代码时，如果遇到了异步事件，js 引擎将不会一直等待其返回结果，而是将这个事件暂时挂起，继续执行</span><strong><span class=\"ne-text\">执行栈</span></strong><span class=\"ne-text\">中的其它任务</span></li><li id=\"u9eb0ea70\" data-lake-index-type=\"0\"><span class=\"ne-text\">在异步事件执行完毕后，判断任务类型，将其回调函数插入分别插入到</span><strong><span class=\"ne-text\">宏任务队列</span></strong><span class=\"ne-text\">或</span><strong><span class=\"ne-text\">微任务队列，宏任务队列和微任务队列都属于消息队列</span></strong></li><li id=\"u282fe776\" data-lake-index-type=\"0\"><span class=\"ne-text\">当执行栈中的任务执行完毕后，js 引擎会首先判断</span><strong><span class=\"ne-text\">微任务队列</span></strong><span class=\"ne-text\">中是否有任务可以执行，如果有就将微任务队列队首的事件压入</span><strong><span class=\"ne-text\">执行栈</span></strong><span class=\"ne-text\">中等待执行，直到微任务队列的所有任务全部执行完毕，之后执行宏任务队列中的任务</span></li><li id=\"u5296b32a\" data-lake-index-type=\"0\"><span class=\"ne-text\">首先执行浏览器的 ui 线程渲染工作，渲染阶段会收到以下因素的影响</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ub68aa294\" data-lake-index-type=\"0\"><span class=\"ne-text\">屏幕分辨率改变，如果页面性能太差，为了不丢帧，浏览器会选择降低帧率</span></li><li id=\"u4b8535c0\" data-lake-index-type=\"0\"><span class=\"ne-text\">浏览器判断本次渲染是否会造成视觉上的改变，比如背景色改变</span></li><li id=\"u954a3872\" data-lake-index-type=\"0\"><span class=\"ne-text\">map of animation frame callbacks 为空</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u87e40d33\" data-lake-index-type=\"0\"><span class=\"ne-text\">接着检查是否有 web worker 任务，有则执行</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u5349296d\" data-lake-index-type=\"0\"><span class=\"ne-text\">对需要渲染的文档，如果窗口发生了变化，就会调用 resize 事件（resize 自带节流）</span></li><li id=\"ude3cb905\" data-lake-index-type=\"0\"><span class=\"ne-text\">对需要渲染的文档，如果页面发生了滚动，就会调用 scroll 事件（scroll 自带节流）</span></li><li id=\"ufc87720c\" data-lake-index-type=\"0\"><span class=\"ne-text\">对需要渲染的文档，执行 requestAnimationFrame 回调</span></li><li id=\"uc4d04713\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 IntersectionObserver 回调，重新渲染页面</span></li><li id=\"u2ae43486\" data-lake-index-type=\"0\"><span class=\"ne-text\">最后会检查宏任务队列和微任务队列是否为空，如果为空会调用 idle 空闲周期算法，检测 requestIdleCallback 是否为空，如果不为空就会执行里面的回调</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u1f44d563\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行完</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">本轮宏任务</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">后，执行</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">下一轮宏任务</span></strong></li></ul><hr id=\"qBCfp\" class=\"ne-hr\"><h3 id=\"ASXwF\"><span class=\"ne-text\">node.js 中事件循环的 6 个阶段</span></h3><p id=\"u1b71a0ab\" class=\"ne-p\"><span class=\"ne-text\">下面为 node 执行的整个过程，如果执行了任何非阻塞的异步代码，则会进入事件循环：</span></p><p id=\"u4f1b1453\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646662274965-6259f561-8bd7-4251-9810-67df3477bbcf.png\" width=\"980\" id=\"u2d752270\" class=\"ne-image\"></p><p id=\"uf5cbc935\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u72cb75d5\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">定时器 timers</span></strong><span class=\"ne-text\">：本阶段执行已经被 setTimeout 和 setInterval 的调度回调函数</span></li><li id=\"u9a553fb8\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">待定回调 pending callbacks</span></strong><span class=\"ne-text\">：执行延迟到下一个循环迭代的 I/O 回调</span></li><li id=\"ue8787399\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">idle，prepare</span></strong><span class=\"ne-text\">：仅系统内部使用</span></li><li id=\"u102afb60\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">轮询 poll</span></strong><span class=\"ne-text\">：检索新的 I/O 事件；执行与 I/O 相关的回调(几乎所有情况下，除了 close callbacks，那些由定时器和 setImmediate 调度的之外)，其余情况 node 将在适当的时候在此阻塞</span></li><li id=\"u3fbd4751\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">检测 check</span></strong><span class=\"ne-text\">：setImmediate 回调函数在这里执行</span></li><li id=\"u064f2b47\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">关闭的回调函数 close callbacks</span></strong><span class=\"ne-text\">：一些关闭的回调函数。如：</span><code class=\"ne-code\"><span class=\"ne-text\">socket.on('close', ...)</span></code></li></ul><div class=\"ne-quote\"><p id=\"u98c2e509\" class=\"ne-p\"><span class=\"ne-text\">每个阶段都会有一个 FIFO 先进先出的回调队列，都会尽可能地执行完当前阶段中所有的回调，或到达了系统相关限制后，才会进入下一阶段</span></p></div><div class=\"ne-quote\"><p id=\"ua63c03f6\" class=\"ne-p\"><span class=\"ne-text\">poll 阶段执行微任务的时机：每一个回调执行时执行相应的微任务</span></p><p id=\"ufd1e7c43\" class=\"ne-p\"><span class=\"ne-text\">timers 和 check 阶段执行微任务的时机：在所有回调执行完毕后，统一执行相应的微任务</span></p></div><h3 id=\"bh0wY\"><span class=\"ne-text\">node.js 中的微任务</span></h3><ul class=\"ne-ul\"><li id=\"u387e038f\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.nextTick 注册的回调函数 - nextTick task queue</span></li><li id=\"u84f4bd32\" data-lake-index-type=\"0\"><span class=\"ne-text\">promise.then 注册的回调函数 - promise task queue</span></li></ul><p id=\"u7f89bab0\" class=\"ne-p\"><span class=\"ne-text\">node.js 在执行微任务时，优先执行 nextTick task queue 中的任务，执行完后接着执行 promise task queue 中的任务，所以若二者同时处于主线程或事件循环的相同阶段，process.nextTick 回调函数的优先级 &gt; promise.then 回调函数的优先级</span></p><h3 id=\"h2KYD\"><span class=\"ne-text\">node.js 的事件循环</span></h3><ul class=\"ne-ul\"><li id=\"u39ece818\" data-lake-index-type=\"0\"><span class=\"ne-text\">当 node.js 启动后，会初始化事件循环，处理已提供的输入脚本，同时可能会调用一些异步 api、调度定时器、process.nextTick，然后开始处理事件循环</span></li><li id=\"ubcbb737d\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行事件循环的每个阶段</span></li><li id=\"ucd8e7051\" data-lake-index-type=\"0\"><span class=\"ne-text\">在相应阶段的回调函数执行时或执行完毕后，执行微任务</span></li></ul><div class=\"ne-quote\"><p id=\"u09707d6a\" class=\"ne-p\"><span class=\"ne-text\">node &lt; 10：执行 1-6 阶段的任务；执行 nextTick 中的任务；执行微任务队列中的任务</span></p><p id=\"u44f7fe33\" class=\"ne-p\"><span class=\"ne-text\">node &gt;= 11：node 在 setTimeout 执行后会手动清空微任务队列，用来保证计算结果和浏览器相近</span></p></div><h3 id=\"DFxcp\"><span class=\"ne-text\">node.js 中定时器和 process.nextTick 执行时机</span></h3><ul class=\"ne-ul\"><li id=\"u31ee1ea7\" data-lake-index-type=\"0\"><span class=\"ne-text\">setImmediate：触发一个异步回调，在事件循环的 check 阶段立即执行</span></li><li id=\"ue89e8f06\" data-lake-index-type=\"0\"><span class=\"ne-text\">setTimeout：触发一个异步回调，当计时器过期后，在事件循环的 timers 阶段执行，仅执行一次，可使用 clearTimeout 取消</span></li><li id=\"u745fdec9\" data-lake-index-type=\"0\"><span class=\"ne-text\">setInterval：触发一个异步回调，每次计时器过期后，都会在事件循环的 timers 阶段执行一次回调，可使用 clearInterval 取消</span></li><li id=\"u3f75bd92\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.nextTick：触发一个微任务异步回调，既可以在主线程 mainline 中执行，也可以在事件循环中的某一个阶段中执行</span></li></ul><h3 id=\"TJa6Z\"><span class=\"ne-text\">node.js 中事件循环的案例</span></h3><pre data-language=\"javascript\" id=\"ETy1X\" class=\"ne-codeblock language-javascript\"><code>async function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n \nasync function async2() {\n    console.log('async2')\n}\n \nconsole.log('script start')\n \nsetTimeout(function () {\n    console.log('setTimeout0')\n}, 0)\n \nsetTimeout(function () {\n    console.log('setTimeout2')\n}, 300)\n \nsetImmediate(() =&gt; console.log('setImmediate'));\n \nprocess.nextTick(() =&gt; console.log('nextTick1'));\n \nasync1();\n \nprocess.nextTick(() =&gt; console.log('nextTick2'));\n \nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve();\n    console.log('promise2')\n}).then(function () {\n    console.log('promise3')\n})\n \nconsole.log('script end')</code></pre><ul class=\"ne-ul\"><li id=\"u7a40a41e\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">先找到同步任务，输出 script start</span></li><li id=\"u20497a45\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</span></li><li id=\"uf7cca6e1\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第二个 setTimeout，300ms 后将里面的回调函数放到 timers 队列中</span></li><li id=\"uce150b27\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第一个 setImmediate，将里面的回调函数放到 check 队列中</span></li><li id=\"udb1c1194\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li id=\"ub4af3f8c\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 async1 函数，输出 async1 start</span></li><li id=\"u415792e2\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 async2 函数，输出 async2，async2 后面的输出 async1 end 进入微任务队列，等待下一轮的事件循环</span></li><li id=\"u5422cd44\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第二个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li id=\"u84245938\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</span></li><li id=\"uaa34cf68\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">then 里面的回调函数进入微任务队列</span></li><li id=\"u89bb1c55\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到同步任务，输出 script end</span></li><li id=\"u480356b6\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行下一轮回调函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</span></li><li id=\"u1f2d483f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">然后执行微任务队列，依次输出 async1 end、promise3</span></li><li id=\"uab245ab6\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 timers 队列，依次输出 setTimeout0</span></li><li id=\"u87013448\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">接着执行 check 队列，依次输出 setImmediate</span></li><li id=\"u44172c50\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">300ms 后，timer 队列存在任务，执行输出 setTimeout2</span></li></ul><p id=\"u34cd94b0\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">执行结果如下：</span></p><pre data-language=\"shell\" id=\"gF2iX\" class=\"ne-codeblock language-shell\"><code>script start\nasync1 start\nasync2\npromise1\npromise2\nscript end\nnextTick1\nnextTick2\nasync1 end\npromise3\nsetTimeout0\nsetImmediate\nsetTimeout2</code></pre><h2 id=\"rIfN9\"><span class=\"ne-text\">浏览器的渲染原理</span></h2><h3 id=\"ihQFN\"><span class=\"ne-text\">渲染流水线</span></h3><p id=\"u02fadf54\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/732231/1700342640685-6007ba92-0714-49d8-9735-03e806f3041d.png\" width=\"1016\" id=\"uaec3dc5e\" class=\"ne-image\"></p><h3 id=\"Y9GAc\"><span class=\"ne-text\">渲染完整过程</span></h3><p id=\"ufba9c796\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/732231/1700342664434-b95f893d-5c25-46c6-803a-cf90a77ba8aa.png\" width=\"993.5\" id=\"u1a49aea3\" class=\"ne-image\"></p><h3 id=\"SByHk\"><span class=\"ne-text\">浏览器如何对页面进行渲染</span></h3><p id=\"ueef1381d\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">当浏览器的网络线程收到 html 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程</span></p><p id=\"u0a9e329f\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">整个渲染流程分为多个阶段，分别是：</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「html 解析 parse」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「样式计算 style」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「布局 layout」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「分层 layer」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「绘制 paint」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「分块 tiling」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「光栅化 raster」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「画 draw」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。这样整个渲染流程就形成了一套组织严密的生产流水线</span></p><ul class=\"ne-ul\"><li id=\"u10ce90e8\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">渲染的第一步是解析 html</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u8ea908ab\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">解析过程中遇到 css 解析 css，遇到 js 执行 js。为了提高解析效率，浏览器在开始解析前，会启动一个</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">预解析的线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，率先下载 html 中的</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">外部 css 文件</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">和</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">外部的 js 文件</span></strong></li><li id=\"u882a14ba\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">如果主线程解析到 link 位置，此时外部的 css 文件还没有下载解析好，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">主线程不会等待</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，继续解析后续的 html。这是因为下载和解析 css 的工作是在</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">预解析线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中进行的。</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">这就是 css 不会阻塞 html 解析的根本原因</span></strong></li><li id=\"u27857434\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">如果主线程解析到 script 位置，会停止解析 html，转而等待 js 文件下载好，并将全局代码解析执行完成后，才能继续解析 html。这是因为 js 代码的执行过程</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">可能会修改当前的 dom 树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，所以 dom 树的生成</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">必须暂停</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">这就是 js 会阻塞 html 解析的根本原因</span></strong></li><li id=\"u29280a92\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">第一步完成后，会得到 </span><strong><span class=\"ne-text\" style=\"font-size: 14px\">dom 树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">和 </span><strong><span class=\"ne-text\" style=\"font-size: 14px\">cssom（css object model）树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，浏览器的</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">默认样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">内部样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">外部样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">行内样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">均会包含在 cssom 树中</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u66472295\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">渲染的下一步是样式计算</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uace2c64f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">主线程会遍历得到的 dom 树，依次为树中的每个节点计算出它最终的样式，称之为 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">Computed Style</span></code></li><li id=\"u0e577988\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">在这一过程中，很多预设值会变成绝对值，比如 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">red</span></code><span class=\"ne-text\" style=\"font-size: 14px\"> 会变成 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">rgb(255,0,0)</span></code><span class=\"ne-text\" style=\"font-size: 14px\">；相对单位会变成绝对单位，比如 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">em</span></code><span class=\"ne-text\" style=\"font-size: 14px\"> 会变成 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">px</span></code></li><li id=\"ub08f1fa0\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">这一步完成后，会</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">得到一颗带有样式的 dom 树</span></strong></li></ul></ul><ul class=\"ne-ul\"><li id=\"ub660ddfa\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">接下来是布局，布局完成后会得到布局树</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uc4d04074\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">布局阶段会依遍历 dom 树的每一个节点，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">计算每个节点的几何信息</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u9f8df374\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">例如节点的宽高、相对</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">包含块</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">的位置</span></li></ul></ul></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u91a3e8d7\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">大部分时候，dom 树和布局树并非一一对应。</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u8347daee\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">例如 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">display: none</span></code><span class=\"ne-text\" style=\"font-size: 14px\">的节点没有几何信息，因此不会生成到布局树</span></li><li id=\"u11ec29a8\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">又比如使用了伪元素选择器，虽然 dom 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中</span></li><li id=\"u211bf85e\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">还有</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">匿名行盒</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">匿名块盒</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">等等都会导致 dom 树和布局树无法一一对应</span></li></ul></ul></ul><ul class=\"ne-ul\"><li id=\"u5c0d3d61\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">下一步是分层</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ua18841b6\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">主线程会使用一套复杂的策略对整个布局树进行分层</span></li><li id=\"u1140322f\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\" style=\"font-size: 14px\">分层的好处</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">：将来某一个层改变后，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">仅仅只会对该层进行后续处理</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，从而</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">提升效率</span></strong></li><li id=\"u1dea6151\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过使用 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">will-change</span></code><span class=\"ne-text\" style=\"font-size: 14px\">属性更大程度的影响分层结果</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u6c9cb511\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">再下一步是绘制</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u6af5f92d\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">主线程会为每个层单独产生</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">绘制指令集</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，用于描述这一层的内容应该如何画出来</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u50f21b6f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">交给</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">合成线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">分块</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ubb4a6772\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">完成绘制后，主线程会将每个图层的绘制信息提交给</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">合成线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，剩余工作将会由合成线程来完成</span></li><li id=\"u08f3b198\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程首先对</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">每个图层进行分块</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，将其划分为更多的小区域</span></li><li id=\"uf8b31626\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">它会从</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">线程池</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中拿去多个线程来完成分块工作</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u5353b8d8\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">分块完成后，进入</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">光栅化</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">阶段</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u0f4995f4\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程会将块信息</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">交给 gpu 进程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，以极高的速度完成光栅化</span></li><li id=\"u0e967914\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">gpu 进程会开启多个线程来完成光栅化，并且</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">优先处理靠近视口区域</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">的块</span></li><li id=\"ub33bc434\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">光栅化的结果，就是一块一块的位图</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"ub9bcc39a\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">最后一个阶段就是画</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ued6ef728\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程拿到每个层、每个块的位图后，生成一个个</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「指引 quad」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">信息</span></li><li id=\"u9c394ffe\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">旋转、缩放</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">等变形</span></li><li id=\"u86b29ca4\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\" style=\"font-size: 14px\">变形发生在合成线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，与</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">渲染主线程无关</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">这就是 transform 效率高的本质原因</span></strong></li><li id=\"u47c5dbb0\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程会把 quad 提交给 gpu 进程，由 gpu 进程产生系统调用，提交给 gpu 硬件，最终完成屏幕成像</span></li></ul></ul><hr id=\"FEfyn\" class=\"ne-hr\"><p id=\"u3ddf85f2\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">包含块</span></p><p id=\"u035b9176\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">行盒，块盒 </span></p><p id=\"ua70ccb70\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">内容必须在行盒中</span></p><p id=\"u5003c1d2\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">行盒和块盒不能相邻 匿名行盒 </span></p><p id=\"uf59320cd\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\"></span></p><p id=\"ua3d7f67b\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程和渲染主线程在渲染进程里面，是放在沙盒里的，安全</span></p><hr id=\"s5V3a\" class=\"ne-hr\"><h3 id=\"WFMRQ\"><span class=\"ne-text\">什么是 reflow - 回流</span></h3><ul class=\"ne-ul\"><li id=\"uc1a51ffe\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">reflow 的本质就是重新计算</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">布局（layout）树</span></strong></li><li id=\"u1e00f20f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">当进行了会影响</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">布局（layout）树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">的操作后，需要重新计算布局树，会引发 layout</span></li><li id=\"u61727091\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">为了避免连续的多次操作导致</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">布局（layout）树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">反复计算，浏览器会</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">合并</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">这些操作，当 js 代码</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">全部完成</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">后再</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">进行统一计算</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。所以，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">改动属性</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">造成的 reflow 是</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">异步</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">完成的</span></li><li id=\"u5e674d4f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">也同样因为如此，当 js 获取布局属性时，就可能造成</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">无法获取到最新的</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">布局信息</span></li><li id=\"uf81d091c\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">浏览器在反复权衡下，最终决定获取属性时立即 reflow</span></li></ul><h3 id=\"lT9JU\"><span class=\"ne-text\">什么是 repaint - 重绘</span></h3><ul class=\"ne-ul\"><li id=\"ua27927eb\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">repaint 的本质就是重新根据</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">分层信息</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">计算了</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">绘制指令</span></strong></li><li id=\"u7b924f4d\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">当改动了</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">可见样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">后，就需要</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">重新计算</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，会引发 repaint</span></li><li id=\"u88ff1c39\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">由于</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">元素的布局信息</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">也属于</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">可见样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，所以 reflow 一定会引起 repaint</span></li></ul><h3 id=\"XMc3j\"><span class=\"ne-text\">为什么 transform 效率高</span></h3><ul class=\"ne-ul\"><li id=\"uc5a59c9c\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">因为 transform 既不会影响</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">布局（layout</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">），也不会影响</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">绘制指令</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，它影响的只是渲染流程的最后一个 - </span><strong><span class=\"ne-text\" style=\"font-size: 14px\">draw 阶段</span></strong></li><li id=\"u0d095d00\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">由于 </span><strong><span class=\"ne-text\" style=\"font-size: 14px\">draw 阶段</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">在</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">合成线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中，所以 transform 的变化</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">几乎不会影响渲染主线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化</span></li></ul><h2 id=\"i9uyF\"><span class=\"ne-text\">位运算</span></h2><h3 id=\"l9E0I\"><span class=\"ne-text\">位运算符</span></h3><ul class=\"ne-ul\"><li id=\"ue8107695\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位与 </span><strong><span class=\"ne-text\">&amp;</span></strong><span class=\"ne-text\"></span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u5d3019df\" data-lake-index-type=\"0\"><span class=\"ne-text\">a &amp; b：只有当 a 和 b 中对应的位都是 1 时，结果位才是 1</span></li><li id=\"ud787f28a\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：常用于位掩码</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u1c3ef920\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位或 </span><strong><span class=\"ne-text\">|</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ub0a7f439\" data-lake-index-type=\"0\"><span class=\"ne-text\">a | b：如果 a 和 b 中至少有一个对应位是 1，则结果位是 1</span></li><li id=\"u340deae5\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：设置位掩码</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u4277b90b\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位异或 </span><strong><span class=\"ne-text\">^</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u3a88eedc\" data-lake-index-type=\"0\"><span class=\"ne-text\">a ^ b：当 a 和 b 中对应位不相同时，结果位是 1</span></li><li id=\"u356c9bca\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：切换位掩码</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u2aecbbfd\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位非 </span><strong><span class=\"ne-text\">~</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u850e3894\" data-lake-index-type=\"0\"><span class=\"ne-text\">~a：反转 a 的所有位（1 变 0，0 变 1）</span></li><li id=\"u1c4741ed\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：常用于位掩码的反转</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u675a8365\" data-lake-index-type=\"0\"><span class=\"ne-text\">左移 </span><strong><span class=\"ne-text\">&lt;&lt;</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u5f5046cb\" data-lake-index-type=\"0\"><span class=\"ne-text\">a &lt;&lt; b：将 a 的二进制表示向左移动 b 位（从右侧补 0）</span></li><li id=\"ueab672f2\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：相当于乘以 2 的 b 次幂</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"ub2b78ac1\" data-lake-index-type=\"0\"><span class=\"ne-text\">有符号右移 </span><strong><span class=\"ne-text\">&gt;&gt;</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uce3f6def\" data-lake-index-type=\"0\"><span class=\"ne-text\">a &gt;&gt; b：将 a 的二进制表示向右移动 b 位，保留符号位（正数前面补 0，负数前面补-）</span></li><li id=\"ufcb6e0f5\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：相当于除以 2 的 b 次幂，保持符号</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"uc2f024ef\" data-lake-index-type=\"0\"><span class=\"ne-text\">无符号右移 </span><strong><span class=\"ne-text\">&gt;&gt;&gt;</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u81ecdf48\" data-lake-index-type=\"0\"><span class=\"ne-text\">a &gt;&gt;&gt; b：将 a 的二进制表示向右移动 b 位，不保留符号位（前面补 0）</span></li><li id=\"udaedf8cf\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：对于正数和负数的右移操作，结果总是正数</span></li></ul></ul><h3 id=\"X9BfX\"><span class=\"ne-text\">使用场景</span></h3><ol class=\"ne-ol\"><li id=\"u7a68ee33\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">设置和清除特定位</span></strong><span class=\"ne-text\">：使用 &amp;、| 和 ~ 来设置、清除或切换特定位。这在处理位掩码或状态标志时非常有用</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uab6b884c\" data-lake-index-type=\"0\"><span class=\"ne-text\">设置第 i 位：</span><code class=\"ne-code\"><span class=\"ne-text\">num |= (1 &lt;&lt; i)</span></code></li><li id=\"u5398f91d\" data-lake-index-type=\"0\"><span class=\"ne-text\">清除第 i 位：</span><code class=\"ne-code\"><span class=\"ne-text\">num &amp;= ~(1 &lt;&lt; i)</span></code></li><li id=\"u2fe5883a\" data-lake-index-type=\"0\"><span class=\"ne-text\">切换第 i 位：</span><code class=\"ne-code\"><span class=\"ne-text\">num ^= (1 &lt;&lt; i)</span></code></li><li id=\"u3733a173\" data-lake-index-type=\"0\"><span class=\"ne-text\">检查第 i 位是否设置：</span><code class=\"ne-code\"><span class=\"ne-text\">(num &amp; (1 &lt;&lt; i)) != 0</span></code></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u9d15a845\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">权限控制</span></strong><span class=\"ne-text\">：位运算常用于实现权限控制系统，其中每个位代表一种权限，通过位运算来添加、移除和检查权限</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u083b3dc0\" data-lake-index-type=\"0\"><span class=\"ne-text\">假设每个位代表一个权限，可以用位运算符来控制权限的开启和关闭</span></li><li id=\"ubf921bb5\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">permissions |= (1 &lt;&lt; READ)</span></code><span class=\"ne-text\"> 可以开启读权限</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u2efb5358\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">两数交换不用额外变量</span></strong><span class=\"ne-text\">：使用 ^ 可以在不使用临时变量的情况下交换两个数</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"gqKRM\" class=\"ne-codeblock language-javascript\"><code>let a = 5, b = 9\na ^= b // output: 12，a = 12，b = 9\nb ^= a // output: 5，b = 5，a = 12\na ^= b // output: 9，a = 9，b = 5</code></pre></span><ol start=\"4\" class=\"ne-ol\"><li id=\"u4e5ac8f8\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">计算两数的和</span></strong><span class=\"ne-text\">：通过 ^ 和 &amp; 操作，可以实现两个数的加法而不使用加号或减号</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"mQe04\" class=\"ne-codeblock language-javascript\"><code>while (b != 0) {\n    let carry = a &amp; b;\n    a = a ^ b;\n    b = carry &lt;&lt; 1;\n}</code></pre></span><ol start=\"5\" class=\"ne-ol\"><li id=\"u75c8a793\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">求绝对值</span></strong><span class=\"ne-text\">：利用 &gt;&gt; 和 ^ 操作可以计算一个数的绝对值</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"wQ8Oe\" class=\"ne-codeblock language-javascript\"><code>int abs(int x) {\n    int mask = x &gt;&gt; 31;\n    return (x ^ mask) - mask;\n}</code></pre></span><ol start=\"6\" class=\"ne-ol\"><li id=\"ue5395103\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">判断奇偶性</span></strong><span class=\"ne-text\">：使用 &amp; 检查一个数的最低位，可以快速判断一个数是奇数还是偶数</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"n8lHZ\" class=\"ne-codeblock language-javascript\"><code>// 利用最低位判断数字奇偶性\nif (num &amp; 1) {\n  // 奇数\n} else {\n// 偶数\n}</code></pre></span><ol start=\"7\" class=\"ne-ol\"><li id=\"ub44f12e0\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">乘除以 2 的幂</span></strong><span class=\"ne-text\">：使用 &lt;&lt; 和 &gt;&gt; 操作可以实现乘除以 2 的幂</span></li><li id=\"ud569ea7b\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">快速访问数组元素</span></strong><span class=\"ne-text\">：在处理像图像处理这样的大型数组时，位运算可以用于快速计算索引，提高效率</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ua31a2372\" data-lake-index-type=\"0\"><span class=\"ne-text\">在图像处理中，可以用位运算来计算像素的位置：</span><code class=\"ne-code\"><span class=\"ne-text\">let index = (row &lt;&lt; shift) + column</span></code></li><li id=\"udde1ca0f\" data-lake-index-type=\"0\"><span class=\"ne-text\">这里假设每行有 2 的幂个像素</span></li></ul></ul><ol start=\"9\" class=\"ne-ol\"><li id=\"uc245873a\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">单一位的状态切换</span></strong><span class=\"ne-text\">：使用 ^ 可以快速切换一个位的状态</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u0e54a91b\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">flag ^= (1 &lt;&lt; i)</span></code></li><li id=\"u0ab8bc65\" data-lake-index-type=\"0\"><span class=\"ne-text\">这可以快速切换第 i 位的状态</span></li></ul></ul><ol start=\"10\" class=\"ne-ol\"><li id=\"u227e51a4\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">二进制反转或位反转</span></strong><span class=\"ne-text\">：对整数进行位反转，这在某些特定的数学运算和算法问题中非常有用</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u8577dbaa\" data-lake-index-type=\"0\"><span class=\"ne-text\">将一个数的二进制表示反转：例如，将 0b1101 变为 0b1011</span></li></ul></ul><ol start=\"11\" class=\"ne-ol\"><li id=\"ua13881ab\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">求两数的最大公约数</span></strong><span class=\"ne-text\">：使用位运算结合递归或迭代方法可以高效求解最大公约数</span></li><li id=\"u06c7645f\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">求解子集问题</span></strong><span class=\"ne-text\">：在处理组合问题时，位运算可以用来枚举集合的所有子集</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"l76jf\" class=\"ne-codeblock language-javascript\"><code>for (let subset = 0; subset &lt; (1 &lt;&lt; n); ++subset) {\n  // 处理子集，n 是集合中元素数量\n}</code></pre></span></div>",
  "body": "<a name=\"JEo5n\"></a>\n## 进程和线程\n<a name=\"nBfC3\"></a>\n### 进程\n\n- 概念：进程是操作系统进行资源分配和管理的最小单位，是能够拥有系统资源的最小单位。一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值\n- 理解：任何程序运行都需要有它自己专属的内存空间，可以把这块内存空间简单理解为进程。每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意\n<a name=\"GsUdR\"></a>\n### 线程\n\n- 概念：线程是进程中执行运算的最小单位\n- 理解：在拥有进程后，就可以运行程序代码，而运行代码的 \"人\" 称之为线程。一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程也被称为**主线程**。如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以**一个进程中可以包含多个线程**\n<a name=\"oBx5h\"></a>\n### 进程和线程的区别\n\n- 进程是计算机管理运行程序的一种方式，一个进程下可包含一个或者多个线程。线程可以理解为子进程\n- 一个线程只能属于一个进程，而一个进程可以包含多个线程\n- 线程无地址空间，它包括在进程的地址空间里\n- 线程的开销和代价比进程小\n<a name=\"b3IF7\"></a>\n### 浏览器有哪些进程和线程\n**浏览器是一个多进程多线程的应用程序**，其内部工作极其复杂，为了避免各工作间相互影响，同时减少连环崩溃的几率，当启动浏览器后，它将会自动启动多个进程。（另外，可以在浏览器的任务管理器中查看当前的所有进程）<br />最主要的进程如下：\n\n1. 浏览器进程：主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务\n2. 网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务\n3. **渲染进程**：渲染进程启动后，会开启一个**渲染主线程**，它负责执行 html、css、js 代码\n\n默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响（未来可能会限制同一个域下共用一个渲染进程，具体需要参考 [chrome 官网文档](https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability)）\n<a name=\"NuMU7\"></a>\n### 渲染主线程是如何工作的\n渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于\n\n- 解析 html\n- 解析 css\n- 计算样式\n- 布局\n- 处理图层\n- 每秒把页面画 60 次\n- 执行全局 js 代码\n- 执行时间处理函数\n- 执行计时器的回调函数\n- ......\n<a name=\"npC5D\"></a>\n### 为什么 js 是单线程\n因为多个线程同时操作 dom，会发生冲突，出现意料之外的情况。所以说，**单线程是异步产生的原因**\n<a name=\"krL6t\"></a>\n### 渲染主线程的排队机制（事件循环 or 消息循环）\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/732231/1700256055361-d609be7e-7f21-43d7-88f5-f464da0c450c.png#averageHue=%23f7f6f4&clientId=udc20a255-187f-4&from=paste&height=228&id=u27c65aec&originHeight=570&originWidth=1128&originalType=binary&ratio=2.5&rotation=0&showTitle=false&size=79407&status=done&style=none&taskId=u8a63b048-eb85-4d08-b2a3-b98e9021903&title=&width=451.2)\n\n1. 最开始时，渲染主线程会进入一个**无限循环**\n2. 每一次循环会**检查消息队列**中是否有任务存在。如果有，就取出第一个任务来执行，执行完当前任务后，进入下一次循环；如果没有任务等待被执行，则进入休眠状态\n3. 其他所有线程（包括其他进程的线程）可以随时向消息队列中添加任务。新任务会被添加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续通过循环来拿取任务\n<a name=\"o1x4y\"></a>\n## 事件循环\n<a name=\"EqdKK\"></a>\n### 如何理解 js 的异步\n\n1. js 是一门**单线程**的语言，这是因为它运行在浏览器的**渲染主线程**中，而**渲染主线程只有一个**。同时渲染主线程承担着诸多的工作，页面渲染、js 执行都在其中运行。\n2. 如果采用同步的方式，极有可能导致主线程产生阻塞，从而导致**消息队列（事件队列）**中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白消耗时间，另一方面会导致页面无法及时更新，给用户造成页面卡死的现象\n3. 因此浏览器采取异步的方式来避免以上情况。具体做法是：当某些任务发生时，如**计时器、网络、事件监听**等，**主线程**将任务**交给其他线程**去处理，**自身立即结束任务的执行**，转而**执行后续的任务**。当其他线程完成时，将事先传递的**回调函数包装成任务**，加入到**消息队列（事件队列）的末尾排队**，**等待主线程调度执行**\n4. 在这种异步模式下，浏览器永不阻塞，从而最大幅度的保证了单线程的流畅运行\n<a name=\"ohRDl\"></a>\n### 浏览器的事件循环机制 event loop\n\n- 事件循环又叫做消息循环（chrome 里叫 message loop），是**浏览器渲染主线程的工作方式**（也是**异步的实现方式**）\n- 在 chrome 的源码中，它会开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时机将任务加入到队列末尾即可\n- 过去把消息队列简单分为宏任务队列和微任务队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式\n- 根据 w3c 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须拥有一个微任务队列，微任务队列的任务一定具有最高的优先级，从而优先调度执行\n<a name=\"l0hIq\"></a>\n### js 中计时器是否能做到精准计时\n无法做到精准计时\n\n1. 计算机硬件没有原子钟，无法做到精准计时\n2. 操作系统的计时函数本身就存在少量偏差，由于 js 计时器最终调用的是操作系统的函数，因此也会携带这些偏差\n3. 根据 w3c 标准，浏览器在实现计时器时，如果嵌套层级超过 5 层，从第 6 层开始会带有 4ms 的延迟时间，因此在计时时间 < 4ms 时又带来了些许偏差\n4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差\n<a name=\"HlZmO\"></a>\n### 执行栈和事件队列\n\n- 执行栈：类似**函数调用栈**的运行容器，执行栈为空时，js 引擎会检查事件队列是否为空，如果不为空，那么将第一个任务压入执行栈中执行\n- 事件队列 or 消息队列：一个**存储着待执行任务**的队列，其中的任务**严格按照时间顺序**来执行，**队首的任务率先执行**，**队尾的任务最后执行**。同时每次仅执行一个任务\n<a name=\"TeWGN\"></a>\n### 任务或消息队列的优先级\n任务没有优先级，它在消息队列中先进先出。然而**消息队列是有优先级的**<br />根据 w3c 的最新解释：\n\n- 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。\n- 浏览器必须准备好一个微任务队列，[微任务队列中的任务优先于所有其他任务执行](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint)\n<a name=\"IKSWL\"></a>\n### 任务队列都有哪些\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/732231/1700232559234-0777bb5b-1f74-4b49-abd1-194c8be16c1d.png#averageHue=%23f2d2cb&clientId=u82c408e8-81eb-4&from=paste&height=604&id=yMEIq&originHeight=604&originWidth=981&originalType=binary&ratio=1&rotation=0&showTitle=false&size=181774&status=done&style=none&taskId=u43c0b990-60bd-4445-9a2a-1bd44e35f06&title=&width=981)<br />在目前的 chrome 的实现中，至少包含了下面的队列：\n\n- 延时队列：用以存放**计时器到达后的回调任务**，优先级 - 中\n   - setTimeout\n   - setInterval\n   - setImmediate\n- 交互队列：用于存放**用户操作后产生的事件处理任务**，优先级 - 高\n- 微任务队列：用以存放**需要最快被执行的任务**，优先级 - 最高\n   - promise 回调 - 必须有 resolve or reject 结果，同一块作用域内多个 resolve 中，期中一个执行完毕后其余的皆不再执行\n   - node.js 的 process.nextTick\n   - MutationObserver -  对 dom 变化进行监听\n> 浏览器认为与用户交互相关的任务优先级可能比延时任务的优先级更高\n\n<a name=\"cUQDd\"></a>\n### requestAnimationFrame 和 requestIdleCallback\n前者是在渲染前执行的，因为动画会更改 dom 结构，后者是用来处理计算量大但不紧急的事件，当队列中没有任务执行时，会清空它内部的回调，也可以传入 timeout 参数，强制 timeout 秒后执行，但是会阻塞其他代码的执行\n\n---\n\n<a name=\"KLzYc\"></a>\n### ⚠️ 旧 - 浏览器事件循环机制 event loop\n\n- js 是单线程执行的，在代码执行的过程中，通过将不同函数的**执行上下文**压入**执行栈**中来保证代码的有序执行\n- 最开始将整个 **script 脚本作为一个宏任务**执行，执行过程中**同步代码**直接执行\n- 执行同步代码时，如果遇到了异步事件，js 引擎将不会一直等待其返回结果，而是将这个事件暂时挂起，继续执行**执行栈**中的其它任务\n- 在异步事件执行完毕后，判断任务类型，将其回调函数插入分别插入到**宏任务队列**或**微任务队列，宏任务队列和微任务队列都属于消息队列**\n- 当执行栈中的任务执行完毕后，js 引擎会首先判断**微任务队列**中是否有任务可以执行，如果有就将微任务队列队首的事件压入**执行栈**中等待执行，直到微任务队列的所有任务全部执行完毕，之后执行宏任务队列中的任务\n- 首先执行浏览器的 ui 线程渲染工作，渲染阶段会收到以下因素的影响\n   - 屏幕分辨率改变，如果页面性能太差，为了不丢帧，浏览器会选择降低帧率\n   - 浏览器判断本次渲染是否会造成视觉上的改变，比如背景色改变\n   - map of animation frame callbacks 为空\n- 接着检查是否有 web worker 任务，有则执行\n   - 对需要渲染的文档，如果窗口发生了变化，就会调用 resize 事件（resize 自带节流）\n   - 对需要渲染的文档，如果页面发生了滚动，就会调用 scroll 事件（scroll 自带节流）\n   - 对需要渲染的文档，执行 requestAnimationFrame 回调\n   - 调用 IntersectionObserver 回调，重新渲染页面\n   - 最后会检查宏任务队列和微任务队列是否为空，如果为空会调用 idle 空闲周期算法，检测 requestIdleCallback 是否为空，如果不为空就会执行里面的回调\n- 执行完**本轮宏任务**后，执行**下一轮宏任务**\n\n---\n\n<a name=\"ASXwF\"></a>\n### node.js 中事件循环的 6 个阶段\n下面为 node 执行的整个过程，如果执行了任何非阻塞的异步代码，则会进入事件循环：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646662274965-6259f561-8bd7-4251-9810-67df3477bbcf.png#averageHue=%23f9f2e5&clientId=u5d023ea2-a4d9-4&from=paste&height=556&id=u2d752270&originHeight=1112&originWidth=1960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=180079&status=done&style=none&taskId=uc7f19d61-bd9e-44f6-adb0-4e441a2adbd&title=&width=980)\n\n- **定时器 timers**：本阶段执行已经被 setTimeout 和 setInterval 的调度回调函数\n- **待定回调 pending callbacks**：执行延迟到下一个循环迭代的 I/O 回调\n- **idle，prepare**：仅系统内部使用\n- **轮询 poll**：检索新的 I/O 事件；执行与 I/O 相关的回调(几乎所有情况下，除了 close callbacks，那些由定时器和 setImmediate 调度的之外)，其余情况 node 将在适当的时候在此阻塞\n- **检测 check**：setImmediate 回调函数在这里执行\n- **关闭的回调函数 close callbacks**：一些关闭的回调函数。如：`socket.on('close', ...)`\n> 每个阶段都会有一个 FIFO 先进先出的回调队列，都会尽可能地执行完当前阶段中所有的回调，或到达了系统相关限制后，才会进入下一阶段\n\n> poll 阶段执行微任务的时机：每一个回调执行时执行相应的微任务\n> timers 和 check 阶段执行微任务的时机：在所有回调执行完毕后，统一执行相应的微任务\n\n<a name=\"bh0wY\"></a>\n### node.js 中的微任务\n\n- process.nextTick 注册的回调函数 - nextTick task queue\n- promise.then 注册的回调函数 - promise task queue\n\nnode.js 在执行微任务时，优先执行 nextTick task queue 中的任务，执行完后接着执行 promise task queue 中的任务，所以若二者同时处于主线程或事件循环的相同阶段，process.nextTick 回调函数的优先级 > promise.then 回调函数的优先级\n<a name=\"h2KYD\"></a>\n### node.js 的事件循环\n\n- 当 node.js 启动后，会初始化事件循环，处理已提供的输入脚本，同时可能会调用一些异步 api、调度定时器、process.nextTick，然后开始处理事件循环\n- 执行事件循环的每个阶段\n- 在相应阶段的回调函数执行时或执行完毕后，执行微任务\n> node < 10：执行 1-6 阶段的任务；执行 nextTick 中的任务；执行微任务队列中的任务\n> node >= 11：node 在 setTimeout 执行后会手动清空微任务队列，用来保证计算结果和浏览器相近\n\n<a name=\"DFxcp\"></a>\n### node.js 中定时器和 process.nextTick 执行时机\n\n- setImmediate：触发一个异步回调，在事件循环的 check 阶段立即执行\n- setTimeout：触发一个异步回调，当计时器过期后，在事件循环的 timers 阶段执行，仅执行一次，可使用 clearTimeout 取消\n- setInterval：触发一个异步回调，每次计时器过期后，都会在事件循环的 timers 阶段执行一次回调，可使用 clearInterval 取消\n- process.nextTick：触发一个微任务异步回调，既可以在主线程 mainline 中执行，也可以在事件循环中的某一个阶段中执行\n<a name=\"TJa6Z\"></a>\n### node.js 中事件循环的案例\n```javascript\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n \nasync function async2() {\n    console.log('async2')\n}\n \nconsole.log('script start')\n \nsetTimeout(function () {\n    console.log('setTimeout0')\n}, 0)\n \nsetTimeout(function () {\n    console.log('setTimeout2')\n}, 300)\n \nsetImmediate(() => console.log('setImmediate'));\n \nprocess.nextTick(() => console.log('nextTick1'));\n \nasync1();\n \nprocess.nextTick(() => console.log('nextTick2'));\n \nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve();\n    console.log('promise2')\n}).then(function () {\n    console.log('promise3')\n})\n \nconsole.log('script end')\n```\n\n- 先找到同步任务，输出 script start\n- 遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中\n- 遇到第二个 setTimeout，300ms 后将里面的回调函数放到 timers 队列中\n- 遇到第一个 setImmediate，将里面的回调函数放到 check 队列中\n- 遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行\n- 执行 async1 函数，输出 async1 start\n- 执行 async2 函数，输出 async2，async2 后面的输出 async1 end 进入微任务队列，等待下一轮的事件循环\n- 遇到第二个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行\n- 遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2\n- then 里面的回调函数进入微任务队列\n- 遇到同步任务，输出 script end\n- 执行下一轮回调函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2\n- 然后执行微任务队列，依次输出 async1 end、promise3\n- 执行 timers 队列，依次输出 setTimeout0\n- 接着执行 check 队列，依次输出 setImmediate\n- 300ms 后，timer 队列存在任务，执行输出 setTimeout2\n\n执行结果如下：\n```shell\nscript start\nasync1 start\nasync2\npromise1\npromise2\nscript end\nnextTick1\nnextTick2\nasync1 end\npromise3\nsetTimeout0\nsetImmediate\nsetTimeout2\n```\n<a name=\"rIfN9\"></a>\n## 浏览器的渲染原理\n<a name=\"ihQFN\"></a>\n### 渲染流水线\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/732231/1700342640685-6007ba92-0714-49d8-9735-03e806f3041d.png#averageHue=%23fcfbf9&clientId=ucb9ee095-bbd4-4&from=paste&height=344&id=uaec3dc5e&originHeight=316&originWidth=932&originalType=binary&ratio=2&rotation=0&showTitle=false&size=50925&status=done&style=none&taskId=uaad5a4f3-fc3b-47d1-986f-3579e5599d2&title=&width=1016)\n<a name=\"Y9GAc\"></a>\n### 渲染完整过程\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/732231/1700342664434-b95f893d-5c25-46c6-803a-cf90a77ba8aa.png#averageHue=%23f4f4f3&clientId=ucb9ee095-bbd4-4&from=paste&height=454&id=u1a49aea3&originHeight=413&originWidth=903&originalType=binary&ratio=2&rotation=0&showTitle=false&size=52277&status=done&style=none&taskId=u1e0dcfe8-2e5b-4d0c-90ea-957256b9e39&title=&width=993.5)\n<a name=\"SByHk\"></a>\n### 浏览器如何对页面进行渲染\n当浏览器的网络线程收到 html 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程<br />整个渲染流程分为多个阶段，分别是：**「html 解析 parse」**、**「样式计算 style」**、**「布局 layout」**、**「分层 layer」**、**「绘制 paint」**、**「分块 tiling」**、**「光栅化 raster」**、**「画 draw」**。每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。这样整个渲染流程就形成了一套组织严密的生产流水线\n\n- 渲染的第一步是解析 html\n   - 解析过程中遇到 css 解析 css，遇到 js 执行 js。为了提高解析效率，浏览器在开始解析前，会启动一个**预解析的线程**，率先下载 html 中的**外部 css 文件**和**外部的 js 文件**\n   - 如果主线程解析到 link 位置，此时外部的 css 文件还没有下载解析好，**主线程不会等待**，继续解析后续的 html。这是因为下载和解析 css 的工作是在**预解析线程**中进行的。**这就是 css 不会阻塞 html 解析的根本原因**\n   - 如果主线程解析到 script 位置，会停止解析 html，转而等待 js 文件下载好，并将全局代码解析执行完成后，才能继续解析 html。这是因为 js 代码的执行过程**可能会修改当前的 dom 树**，所以 dom 树的生成**必须暂停**。**这就是 js 会阻塞 html 解析的根本原因**\n   - 第一步完成后，会得到 **dom 树**和 **cssom（css object model）树**，浏览器的**默认样式**、**内部样式**、**外部样式**、**行内样式**均会包含在 cssom 树中\n- 渲染的下一步是样式计算\n   - 主线程会遍历得到的 dom 树，依次为树中的每个节点计算出它最终的样式，称之为 `Computed Style`\n   - 在这一过程中，很多预设值会变成绝对值，比如 `red` 会变成 `rgb(255,0,0)`；相对单位会变成绝对单位，比如 `em` 会变成 `px`\n   - 这一步完成后，会**得到一颗带有样式的 dom 树**\n- 接下来是布局，布局完成后会得到布局树\n   - 布局阶段会依遍历 dom 树的每一个节点，**计算每个节点的几何信息**。\n      - 例如节点的宽高、相对**包含块**的位置\n   - 大部分时候，dom 树和布局树并非一一对应。\n      - 例如 `display: none`的节点没有几何信息，因此不会生成到布局树\n      - 又比如使用了伪元素选择器，虽然 dom 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中\n      - 还有**匿名行盒**、**匿名块盒**等等都会导致 dom 树和布局树无法一一对应\n- 下一步是分层\n   - 主线程会使用一套复杂的策略对整个布局树进行分层\n   - **分层的好处**：将来某一个层改变后，**仅仅只会对该层进行后续处理**，从而**提升效率**\n   - 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过使用 `will-change`属性更大程度的影响分层结果\n- 再下一步是绘制\n   - 主线程会为每个层单独产生**绘制指令集**，用于描述这一层的内容应该如何画出来\n- 交给**合成线程**分块\n   - 完成绘制后，主线程会将每个图层的绘制信息提交给**合成线程**，剩余工作将会由合成线程来完成\n   - 合成线程首先对**每个图层进行分块**，将其划分为更多的小区域\n   - 它会从**线程池**中拿去多个线程来完成分块工作\n- 分块完成后，进入**光栅化**阶段\n   - 合成线程会将块信息**交给 gpu 进程**，以极高的速度完成光栅化\n   - gpu 进程会开启多个线程来完成光栅化，并且**优先处理靠近视口区域**的块\n   - 光栅化的结果，就是一块一块的位图\n- 最后一个阶段就是画\n   - 合成线程拿到每个层、每个块的位图后，生成一个个**「指引 quad」**信息\n   - 指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到**旋转、缩放**等变形\n   - **变形发生在合成线程**，与**渲染主线程无关**，**这就是 transform 效率高的本质原因**\n   - 合成线程会把 quad 提交给 gpu 进程，由 gpu 进程产生系统调用，提交给 gpu 硬件，最终完成屏幕成像\n\n---\n\n包含块<br />行盒，块盒 <br />内容必须在行盒中<br />行盒和块盒不能相邻 匿名行盒 \n\n合成线程和渲染主线程在渲染进程里面，是放在沙盒里的，安全\n\n---\n\n<a name=\"WFMRQ\"></a>\n### 什么是 reflow - 回流\n\n- reflow 的本质就是重新计算**布局（layout）树**\n- 当进行了会影响**布局（layout）树**的操作后，需要重新计算布局树，会引发 layout\n- 为了避免连续的多次操作导致**布局（layout）树**反复计算，浏览器会**合并**这些操作，当 js 代码**全部完成**后再**进行统一计算**。所以，**改动属性**造成的 reflow 是**异步**完成的\n- 也同样因为如此，当 js 获取布局属性时，就可能造成**无法获取到最新的**布局信息\n- 浏览器在反复权衡下，最终决定获取属性时立即 reflow\n<a name=\"lT9JU\"></a>\n### 什么是 repaint - 重绘\n\n- repaint 的本质就是重新根据**分层信息**计算了**绘制指令**\n- 当改动了**可见样式**后，就需要**重新计算**，会引发 repaint\n- 由于**元素的布局信息**也属于**可见样式**，所以 reflow 一定会引起 repaint\n<a name=\"XMc3j\"></a>\n### 为什么 transform 效率高\n\n- 因为 transform 既不会影响**布局（layout**），也不会影响**绘制指令**，它影响的只是渲染流程的最后一个 - **draw 阶段**\n- 由于 **draw 阶段**在**合成线程**中，所以 transform 的变化**几乎不会影响渲染主线程**。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化\n<a name=\"i9uyF\"></a>\n## 位运算\n<a name=\"l9E0I\"></a>\n### 位运算符\n\n- 按位与 **&**\n   - a & b：只有当 a 和 b 中对应的位都是 1 时，结果位才是 1\n   - 用途：常用于位掩码\n- 按位或 **|**\n   - a | b：如果 a 和 b 中至少有一个对应位是 1，则结果位是 1\n   - 用途：设置位掩码\n- 按位异或 **^**\n   - a ^ b：当 a 和 b 中对应位不相同时，结果位是 1\n   - 用途：切换位掩码\n- 按位非 **~**\n   - ~a：反转 a 的所有位（1 变 0，0 变 1）\n   - 用途：常用于位掩码的反转\n- 左移 **<<**\n   - a << b：将 a 的二进制表示向左移动 b 位（从右侧补 0）\n   - 用途：相当于乘以 2 的 b 次幂\n- 有符号右移 **>>**\n   - a >> b：将 a 的二进制表示向右移动 b 位，保留符号位（正数前面补 0，负数前面补-）\n   - 用途：相当于除以 2 的 b 次幂，保持符号\n- 无符号右移 **>>>**\n   - a >>> b：将 a 的二进制表示向右移动 b 位，不保留符号位（前面补 0）\n   - 用途：对于正数和负数的右移操作，结果总是正数\n<a name=\"X9BfX\"></a>\n### 使用场景\n\n1. **设置和清除特定位**：使用 &、| 和 ~ 来设置、清除或切换特定位。这在处理位掩码或状态标志时非常有用\n   - 设置第 i 位：`num |= (1 << i)`\n   - 清除第 i 位：`num &= ~(1 << i)`\n   - 切换第 i 位：`num ^= (1 << i)`\n   - 检查第 i 位是否设置：`(num & (1 << i)) != 0`\n2. **权限控制**：位运算常用于实现权限控制系统，其中每个位代表一种权限，通过位运算来添加、移除和检查权限\n   - 假设每个位代表一个权限，可以用位运算符来控制权限的开启和关闭\n   - `permissions |= (1 << READ)` 可以开启读权限\n3. **两数交换不用额外变量**：使用 ^ 可以在不使用临时变量的情况下交换两个数\n```javascript\nlet a = 5, b = 9\na ^= b // output: 12，a = 12，b = 9\nb ^= a // output: 5，b = 5，a = 12\na ^= b // output: 9，a = 9，b = 5\n```\n\n4. **计算两数的和**：通过 ^ 和 & 操作，可以实现两个数的加法而不使用加号或减号\n```javascript\nwhile (b != 0) {\n    let carry = a & b;\n    a = a ^ b;\n    b = carry << 1;\n}\n```\n\n5. **求绝对值**：利用 >> 和 ^ 操作可以计算一个数的绝对值\n```javascript\nint abs(int x) {\n    int mask = x >> 31;\n    return (x ^ mask) - mask;\n}\n```\n\n6. **判断奇偶性**：使用 & 检查一个数的最低位，可以快速判断一个数是奇数还是偶数\n```javascript\n// 利用最低位判断数字奇偶性\nif (num & 1) {\n  // 奇数\n} else {\n// 偶数\n}\n```\n\n7. **乘除以 2 的幂**：使用 << 和 >> 操作可以实现乘除以 2 的幂\n8. **快速访问数组元素**：在处理像图像处理这样的大型数组时，位运算可以用于快速计算索引，提高效率\n   - 在图像处理中，可以用位运算来计算像素的位置：`let index = (row << shift) + column`\n   - 这里假设每行有 2 的幂个像素\n9. **单一位的状态切换**：使用 ^ 可以快速切换一个位的状态\n   - `flag ^= (1 << i)`\n   - 这可以快速切换第 i 位的状态\n10. **二进制反转或位反转**：对整数进行位反转，这在某些特定的数学运算和算法问题中非常有用\n   - 将一个数的二进制表示反转：例如，将 0b1101 变为 0b1011\n11. **求两数的最大公约数**：使用位运算结合递归或迭代方法可以高效求解最大公约数\n12. **求解子集问题**：在处理组合问题时，位运算可以用来枚举集合的所有子集\n```javascript\nfor (let subset = 0; subset < (1 << n); ++subset) {\n  // 处理子集，n 是集合中元素数量\n}\n```\n",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"JEo5n\"><span class=\"ne-text\">进程和线程</span></h2><h3 id=\"nBfC3\"><span class=\"ne-text\">进程</span></h3><ul class=\"ne-ul\"><li id=\"u4e17911c\" data-lake-index-type=\"0\"><span class=\"ne-text\">概念：进程是操作系统进行资源分配和管理的最小单位，是能够拥有系统资源的最小单位。一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值</span></li><li id=\"ua586dc9a\" data-lake-index-type=\"0\"><span class=\"ne-text\">理解：任何程序运行都需要有它自己专属的内存空间，可以把这块内存空间简单理解为进程。每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意</span></li></ul><h3 id=\"GsUdR\"><span class=\"ne-text\">线程</span></h3><ul class=\"ne-ul\"><li id=\"u9c80d41f\" data-lake-index-type=\"0\"><span class=\"ne-text\">概念：线程是进程中执行运算的最小单位</span></li><li id=\"ua9643d6c\" data-lake-index-type=\"0\"><span class=\"ne-text\">理解：在拥有进程后，就可以运行程序代码，而运行代码的 &quot;人&quot; 称之为线程。一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程也被称为</span><strong><span class=\"ne-text\">主线程</span></strong><span class=\"ne-text\">。如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以</span><strong><span class=\"ne-text\">一个进程中可以包含多个线程</span></strong></li></ul><h3 id=\"oBx5h\"><span class=\"ne-text\">进程和线程的区别</span></h3><ul class=\"ne-ul\"><li id=\"u2c73120a\" data-lake-index-type=\"0\"><span class=\"ne-text\">进程是计算机管理运行程序的一种方式，一个进程下可包含一个或者多个线程。线程可以理解为子进程</span></li><li id=\"u8b62dd98\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(32, 33, 34)\">一个线程只能属于一个进程，而一个进程可以包含多个线程</span></li><li id=\"u6dbc0d2d\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(32, 33, 34)\">线程无地址空间，它包括在进程的地址空间里</span></li><li id=\"u0b7ffd9e\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(32, 33, 34)\">线程的开销和代价比进程小</span></li></ul><h3 id=\"b3IF7\"><span class=\"ne-text\">浏览器有哪些进程和线程</span></h3><p id=\"u4253d197\" class=\"ne-p\"><strong><span class=\"ne-text\">浏览器是一个多进程多线程的应用程序</span></strong><span class=\"ne-text\">，其内部工作极其复杂，为了避免各工作间相互影响，同时减少连环崩溃的几率，当启动浏览器后，它将会自动启动多个进程。（另外，可以在浏览器的任务管理器中查看当前的所有进程）</span></p><p id=\"ub9e6b2d1\" class=\"ne-p\"><span class=\"ne-text\">最主要的进程如下：</span></p><ol class=\"ne-ol\"><li id=\"ue939426b\" data-lake-index-type=\"0\"><span class=\"ne-text\">浏览器进程：主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务</span></li><li id=\"u19c85b21\" data-lake-index-type=\"0\"><span class=\"ne-text\">网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务</span></li><li id=\"u134104bd\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">渲染进程</span></strong><span class=\"ne-text\">：渲染进程启动后，会开启一个</span><strong><span class=\"ne-text\">渲染主线程</span></strong><span class=\"ne-text\">，它负责执行 html、css、js 代码</span></li></ol><p id=\"u3f3ea18a\" class=\"ne-p\"><span class=\"ne-text\">默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响（未来可能会限制同一个域下共用一个渲染进程，具体需要参考 </span><a href=\"https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability\" data-href=\"https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">chrome 官网文档</span></a><span class=\"ne-text\">）</span></p><h3 id=\"NuMU7\"><span class=\"ne-text\">渲染主线程是如何工作的</span></h3><p id=\"u72b75f93\" class=\"ne-p\"><span class=\"ne-text\">渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于</span></p><ul class=\"ne-ul\"><li id=\"uc9eebfd9\" data-lake-index-type=\"0\"><span class=\"ne-text\">解析 html</span></li><li id=\"u7eb71df5\" data-lake-index-type=\"0\"><span class=\"ne-text\">解析 css</span></li><li id=\"u4d3a8453\" data-lake-index-type=\"0\"><span class=\"ne-text\">计算样式</span></li><li id=\"u87bf95d4\" data-lake-index-type=\"0\"><span class=\"ne-text\">布局</span></li><li id=\"u79a5b695\" data-lake-index-type=\"0\"><span class=\"ne-text\">处理图层</span></li><li id=\"u6c78d1ec\" data-lake-index-type=\"0\"><span class=\"ne-text\">每秒把页面画 60 次</span></li><li id=\"u85857a32\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行全局 js 代码</span></li><li id=\"udf2e97ab\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行时间处理函数</span></li><li id=\"u8c685902\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行计时器的回调函数</span></li><li id=\"u092deb75\" data-lake-index-type=\"0\"><span class=\"ne-text\">......</span></li></ul><h3 id=\"npC5D\"><span class=\"ne-text\">为什么 js 是单线程</span></h3><p id=\"u1d9b89c5\" class=\"ne-p\"><span class=\"ne-text\">因为多个线程同时操作 dom，会发生冲突，出现意料之外的情况。所以说，</span><strong><span class=\"ne-text\">单线程是异步产生的原因</span></strong></p><h3 id=\"krL6t\"><span class=\"ne-text\">渲染主线程的排队机制（事件循环 or 消息循环）</span></h3><p id=\"ud2697bb6\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/732231/1700256055361-d609be7e-7f21-43d7-88f5-f464da0c450c.png\" width=\"451.2\" id=\"u27c65aec\" class=\"ne-image\"></p><ol class=\"ne-ol\"><li id=\"u57df05c6\" data-lake-index-type=\"0\"><span class=\"ne-text\">最开始时，渲染主线程会进入一个</span><strong><span class=\"ne-text\">无限循环</span></strong></li><li id=\"ubbd5141d\" data-lake-index-type=\"0\"><span class=\"ne-text\">每一次循环会</span><strong><span class=\"ne-text\">检查消息队列</span></strong><span class=\"ne-text\">中是否有任务存在。如果有，就取出第一个任务来执行，执行完当前任务后，进入下一次循环；如果没有任务等待被执行，则进入休眠状态</span></li><li id=\"u332c0373\" data-lake-index-type=\"0\"><span class=\"ne-text\">其他所有线程（包括其他进程的线程）可以随时向消息队列中添加任务。新任务会被添加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续通过循环来拿取任务</span></li></ol><h2 id=\"o1x4y\"><span class=\"ne-text\">事件循环</span></h2><h3 id=\"EqdKK\"><span class=\"ne-text\">如何理解 js 的异步</span></h3><ol class=\"ne-ol\"><li id=\"ue821a135\" data-lake-index-type=\"0\"><span class=\"ne-text\">js 是一门</span><strong><span class=\"ne-text\">单线程</span></strong><span class=\"ne-text\">的语言，这是因为它运行在浏览器的</span><strong><span class=\"ne-text\">渲染主线程</span></strong><span class=\"ne-text\">中，而</span><strong><span class=\"ne-text\">渲染主线程只有一个</span></strong><span class=\"ne-text\">。同时渲染主线程承担着诸多的工作，页面渲染、js 执行都在其中运行。</span></li><li id=\"uffb27c21\" data-lake-index-type=\"0\"><span class=\"ne-text\">如果采用同步的方式，极有可能导致主线程产生阻塞，从而导致</span><strong><span class=\"ne-text\">消息队列（事件队列）</span></strong><span class=\"ne-text\">中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白消耗时间，另一方面会导致页面无法及时更新，给用户造成页面卡死的现象</span></li><li id=\"uf073ecef\" data-lake-index-type=\"0\"><span class=\"ne-text\">因此浏览器采取异步的方式来避免以上情况。具体做法是：当某些任务发生时，如</span><strong><span class=\"ne-text\">计时器、网络、事件监听</span></strong><span class=\"ne-text\">等，</span><strong><span class=\"ne-text\">主线程</span></strong><span class=\"ne-text\">将任务</span><strong><span class=\"ne-text\">交给其他线程</span></strong><span class=\"ne-text\">去处理，</span><strong><span class=\"ne-text\">自身立即结束任务的执行</span></strong><span class=\"ne-text\">，转而</span><strong><span class=\"ne-text\">执行后续的任务</span></strong><span class=\"ne-text\">。当其他线程完成时，将事先传递的</span><strong><span class=\"ne-text\">回调函数包装成任务</span></strong><span class=\"ne-text\">，加入到</span><strong><span class=\"ne-text\">消息队列（事件队列）的末尾排队</span></strong><span class=\"ne-text\">，</span><strong><span class=\"ne-text\">等待主线程调度执行</span></strong></li><li id=\"udd36f866\" data-lake-index-type=\"0\"><span class=\"ne-text\">在这种异步模式下，浏览器永不阻塞，从而最大幅度的保证了单线程的流畅运行</span></li></ol><h3 id=\"ohRDl\"><span class=\"ne-text\">浏览器的事件循环机制 event loop</span></h3><ul class=\"ne-ul\"><li id=\"u809095e6\" data-lake-index-type=\"0\"><span class=\"ne-text\">事件循环又叫做消息循环（chrome 里叫 message loop），是</span><strong><span class=\"ne-text\">浏览器渲染主线程的工作方式</span></strong><span class=\"ne-text\">（也是</span><strong><span class=\"ne-text\">异步的实现方式</span></strong><span class=\"ne-text\">）</span></li><li id=\"ub23ce813\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 chrome 的源码中，它会开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时机将任务加入到队列末尾即可</span></li><li id=\"u9011d5c5\" data-lake-index-type=\"0\"><span class=\"ne-text\">过去把消息队列简单分为宏任务队列和微任务队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式</span></li><li id=\"u0b44947e\" data-lake-index-type=\"0\"><span class=\"ne-text\">根据 w3c 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须拥有一个微任务队列，微任务队列的任务一定具有最高的优先级，从而优先调度执行</span></li></ul><h3 id=\"l0hIq\"><span class=\"ne-text\">js 中计时器是否能做到精准计时</span></h3><p id=\"uf46db2c3\" class=\"ne-p\"><span class=\"ne-text\">无法做到精准计时</span></p><ol class=\"ne-ol\"><li id=\"u48c8409d\" data-lake-index-type=\"0\"><span class=\"ne-text\">计算机硬件没有原子钟，无法做到精准计时</span></li><li id=\"u080eefe8\" data-lake-index-type=\"0\"><span class=\"ne-text\">操作系统的计时函数本身就存在少量偏差，由于 js 计时器最终调用的是操作系统的函数，因此也会携带这些偏差</span></li><li id=\"uccab18b3\" data-lake-index-type=\"0\"><span class=\"ne-text\">根据 w3c 标准，浏览器在实现计时器时，如果嵌套层级超过 5 层，从第 6 层开始会带有 4ms 的延迟时间，因此在计时时间 &lt; 4ms 时又带来了些许偏差</span></li><li id=\"u67a9a1d1\" data-lake-index-type=\"0\"><span class=\"ne-text\">受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</span></li></ol><h3 id=\"HlZmO\"><span class=\"ne-text\">执行栈和事件队列</span></h3><ul class=\"ne-ul\"><li id=\"u241b834b\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行栈：类似</span><strong><span class=\"ne-text\">函数调用栈</span></strong><span class=\"ne-text\">的运行容器，执行栈为空时，js 引擎会检查事件队列是否为空，如果不为空，那么将第一个任务压入执行栈中执行</span></li><li id=\"u367aaffe\" data-lake-index-type=\"0\"><span class=\"ne-text\">事件队列 or 消息队列：一个</span><strong><span class=\"ne-text\">存储着待执行任务</span></strong><span class=\"ne-text\">的队列，其中的任务</span><strong><span class=\"ne-text\">严格按照时间顺序</span></strong><span class=\"ne-text\">来执行，</span><strong><span class=\"ne-text\">队首的任务率先执行</span></strong><span class=\"ne-text\">，</span><strong><span class=\"ne-text\">队尾的任务最后执行</span></strong><span class=\"ne-text\">。同时每次仅执行一个任务</span></li></ul><h3 id=\"TeWGN\"><span class=\"ne-text\">任务或消息队列的优先级</span></h3><p id=\"u01b25436\" class=\"ne-p\"><span class=\"ne-text\">任务没有优先级，它在消息队列中先进先出。然而</span><strong><span class=\"ne-text\">消息队列是有优先级的</span></strong></p><p id=\"u17f4bbe6\" class=\"ne-p\"><span class=\"ne-text\">根据 w3c 的最新解释：</span></p><ul class=\"ne-ul\"><li id=\"u39278466\" data-lake-index-type=\"0\"><span class=\"ne-text\">每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</span></li><li id=\"u803f4cf2\" data-lake-index-type=\"0\"><span class=\"ne-text\">浏览器必须准备好一个微任务队列，</span><a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" data-href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">微任务队列中的任务优先于所有其他任务执行</span></a></li></ul><h3 id=\"IKSWL\"><span class=\"ne-text\">任务队列都有哪些</span></h3><p id=\"u04917572\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/732231/1700232559234-0777bb5b-1f74-4b49-abd1-194c8be16c1d.png\" width=\"981\" id=\"yMEIq\" class=\"ne-image\"></p><p id=\"u27cf6e9d\" class=\"ne-p\"><span class=\"ne-text\">在目前的 chrome 的实现中，至少包含了下面的队列：</span></p><ul class=\"ne-ul\"><li id=\"uf919ec60\" data-lake-index-type=\"0\"><span class=\"ne-text\">延时队列：用以存放</span><strong><span class=\"ne-text\">计时器到达后的回调任务</span></strong><span class=\"ne-text\">，优先级 - 中</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u3f4f41df\" data-lake-index-type=\"0\"><span class=\"ne-text\">setTimeout</span></li><li id=\"ua8b02786\" data-lake-index-type=\"0\"><span class=\"ne-text\">setInterval</span></li><li id=\"u671cada8\" data-lake-index-type=\"0\"><span class=\"ne-text\">setImmediate</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u236a9d80\" data-lake-index-type=\"0\"><span class=\"ne-text\">交互队列：用于存放</span><strong><span class=\"ne-text\">用户操作后产生的事件处理任务</span></strong><span class=\"ne-text\">，优先级 - 高</span></li><li id=\"ubfa9013f\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列：用以存放</span><strong><span class=\"ne-text\">需要最快被执行的任务</span></strong><span class=\"ne-text\">，优先级 - 最高</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ua02fc8fa\" data-lake-index-type=\"0\"><span class=\"ne-text\">promise 回调 - 必须有 resolve or reject 结果，同一块作用域内多个 resolve 中，期中一个执行完毕后其余的皆不再执行</span></li><li id=\"u43b56753\" data-lake-index-type=\"0\"><span class=\"ne-text\">node.js 的 process.nextTick</span></li><li id=\"u9d186ac1\" data-lake-index-type=\"0\"><span class=\"ne-text\">MutationObserver -  对 dom 变化进行监听</span></li></ul></ul><div class=\"ne-quote\"><p id=\"u7a7bb360\" class=\"ne-p\"><span class=\"ne-text\">浏览器认为与用户交互相关的任务优先级可能比延时任务的优先级更高</span></p></div><h3 id=\"cUQDd\"><span class=\"ne-text\">requestAnimationFrame 和 requestIdleCallback</span></h3><p id=\"u6946777b\" class=\"ne-p\"><span class=\"ne-text\">前者是在渲染前执行的，因为动画会更改 dom 结构，后者是用来处理计算量大但不紧急的事件，当队列中没有任务执行时，会清空它内部的回调，也可以传入 timeout 参数，强制 timeout 秒后执行，但是会阻塞其他代码的执行</span></p><hr id=\"fArB5\" class=\"ne-hr\"><h3 id=\"KLzYc\"><span class=\"ne-text\">⚠️</span><span class=\"ne-text\"> 旧 - 浏览器事件循环机制 event loop</span></h3><ul class=\"ne-ul\"><li id=\"u517f16a2\" data-lake-index-type=\"0\"><span class=\"ne-text\">js 是单线程执行的，在代码执行的过程中，通过将不同函数的</span><strong><span class=\"ne-text\">执行上下文</span></strong><span class=\"ne-text\">压入</span><strong><span class=\"ne-text\">执行栈</span></strong><span class=\"ne-text\">中来保证代码的有序执行</span></li><li id=\"u307a10c8\" data-lake-index-type=\"0\"><span class=\"ne-text\">最开始将整个 </span><strong><span class=\"ne-text\">script 脚本作为一个宏任务</span></strong><span class=\"ne-text\">执行，执行过程中</span><strong><span class=\"ne-text\">同步代码</span></strong><span class=\"ne-text\">直接执行</span></li><li id=\"u4f08934c\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行同步代码时，如果遇到了异步事件，js 引擎将不会一直等待其返回结果，而是将这个事件暂时挂起，继续执行</span><strong><span class=\"ne-text\">执行栈</span></strong><span class=\"ne-text\">中的其它任务</span></li><li id=\"u9eb0ea70\" data-lake-index-type=\"0\"><span class=\"ne-text\">在异步事件执行完毕后，判断任务类型，将其回调函数插入分别插入到</span><strong><span class=\"ne-text\">宏任务队列</span></strong><span class=\"ne-text\">或</span><strong><span class=\"ne-text\">微任务队列，宏任务队列和微任务队列都属于消息队列</span></strong></li><li id=\"u282fe776\" data-lake-index-type=\"0\"><span class=\"ne-text\">当执行栈中的任务执行完毕后，js 引擎会首先判断</span><strong><span class=\"ne-text\">微任务队列</span></strong><span class=\"ne-text\">中是否有任务可以执行，如果有就将微任务队列队首的事件压入</span><strong><span class=\"ne-text\">执行栈</span></strong><span class=\"ne-text\">中等待执行，直到微任务队列的所有任务全部执行完毕，之后执行宏任务队列中的任务</span></li><li id=\"u5296b32a\" data-lake-index-type=\"0\"><span class=\"ne-text\">首先执行浏览器的 ui 线程渲染工作，渲染阶段会收到以下因素的影响</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ub68aa294\" data-lake-index-type=\"0\"><span class=\"ne-text\">屏幕分辨率改变，如果页面性能太差，为了不丢帧，浏览器会选择降低帧率</span></li><li id=\"u4b8535c0\" data-lake-index-type=\"0\"><span class=\"ne-text\">浏览器判断本次渲染是否会造成视觉上的改变，比如背景色改变</span></li><li id=\"u954a3872\" data-lake-index-type=\"0\"><span class=\"ne-text\">map of animation frame callbacks 为空</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u87e40d33\" data-lake-index-type=\"0\"><span class=\"ne-text\">接着检查是否有 web worker 任务，有则执行</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u5349296d\" data-lake-index-type=\"0\"><span class=\"ne-text\">对需要渲染的文档，如果窗口发生了变化，就会调用 resize 事件（resize 自带节流）</span></li><li id=\"ude3cb905\" data-lake-index-type=\"0\"><span class=\"ne-text\">对需要渲染的文档，如果页面发生了滚动，就会调用 scroll 事件（scroll 自带节流）</span></li><li id=\"ufc87720c\" data-lake-index-type=\"0\"><span class=\"ne-text\">对需要渲染的文档，执行 requestAnimationFrame 回调</span></li><li id=\"uc4d04713\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 IntersectionObserver 回调，重新渲染页面</span></li><li id=\"u2ae43486\" data-lake-index-type=\"0\"><span class=\"ne-text\">最后会检查宏任务队列和微任务队列是否为空，如果为空会调用 idle 空闲周期算法，检测 requestIdleCallback 是否为空，如果不为空就会执行里面的回调</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u1f44d563\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行完</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">本轮宏任务</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">后，执行</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">下一轮宏任务</span></strong></li></ul><hr id=\"qBCfp\" class=\"ne-hr\"><h3 id=\"ASXwF\"><span class=\"ne-text\">node.js 中事件循环的 6 个阶段</span></h3><p id=\"u1b71a0ab\" class=\"ne-p\"><span class=\"ne-text\">下面为 node 执行的整个过程，如果执行了任何非阻塞的异步代码，则会进入事件循环：</span></p><p id=\"u4f1b1453\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646662274965-6259f561-8bd7-4251-9810-67df3477bbcf.png\" width=\"980\" id=\"u2d752270\" class=\"ne-image\"></p><p id=\"uf5cbc935\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u72cb75d5\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">定时器 timers</span></strong><span class=\"ne-text\">：本阶段执行已经被 setTimeout 和 setInterval 的调度回调函数</span></li><li id=\"u9a553fb8\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">待定回调 pending callbacks</span></strong><span class=\"ne-text\">：执行延迟到下一个循环迭代的 I/O 回调</span></li><li id=\"ue8787399\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">idle，prepare</span></strong><span class=\"ne-text\">：仅系统内部使用</span></li><li id=\"u102afb60\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">轮询 poll</span></strong><span class=\"ne-text\">：检索新的 I/O 事件；执行与 I/O 相关的回调(几乎所有情况下，除了 close callbacks，那些由定时器和 setImmediate 调度的之外)，其余情况 node 将在适当的时候在此阻塞</span></li><li id=\"u3fbd4751\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">检测 check</span></strong><span class=\"ne-text\">：setImmediate 回调函数在这里执行</span></li><li id=\"u064f2b47\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">关闭的回调函数 close callbacks</span></strong><span class=\"ne-text\">：一些关闭的回调函数。如：</span><code class=\"ne-code\"><span class=\"ne-text\">socket.on('close', ...)</span></code></li></ul><div class=\"ne-quote\"><p id=\"u98c2e509\" class=\"ne-p\"><span class=\"ne-text\">每个阶段都会有一个 FIFO 先进先出的回调队列，都会尽可能地执行完当前阶段中所有的回调，或到达了系统相关限制后，才会进入下一阶段</span></p></div><div class=\"ne-quote\"><p id=\"ua63c03f6\" class=\"ne-p\"><span class=\"ne-text\">poll 阶段执行微任务的时机：每一个回调执行时执行相应的微任务</span></p><p id=\"ufd1e7c43\" class=\"ne-p\"><span class=\"ne-text\">timers 和 check 阶段执行微任务的时机：在所有回调执行完毕后，统一执行相应的微任务</span></p></div><h3 id=\"bh0wY\"><span class=\"ne-text\">node.js 中的微任务</span></h3><ul class=\"ne-ul\"><li id=\"u387e038f\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.nextTick 注册的回调函数 - nextTick task queue</span></li><li id=\"u84f4bd32\" data-lake-index-type=\"0\"><span class=\"ne-text\">promise.then 注册的回调函数 - promise task queue</span></li></ul><p id=\"u7f89bab0\" class=\"ne-p\"><span class=\"ne-text\">node.js 在执行微任务时，优先执行 nextTick task queue 中的任务，执行完后接着执行 promise task queue 中的任务，所以若二者同时处于主线程或事件循环的相同阶段，process.nextTick 回调函数的优先级 &gt; promise.then 回调函数的优先级</span></p><h3 id=\"h2KYD\"><span class=\"ne-text\">node.js 的事件循环</span></h3><ul class=\"ne-ul\"><li id=\"u39ece818\" data-lake-index-type=\"0\"><span class=\"ne-text\">当 node.js 启动后，会初始化事件循环，处理已提供的输入脚本，同时可能会调用一些异步 api、调度定时器、process.nextTick，然后开始处理事件循环</span></li><li id=\"ubcbb737d\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行事件循环的每个阶段</span></li><li id=\"ucd8e7051\" data-lake-index-type=\"0\"><span class=\"ne-text\">在相应阶段的回调函数执行时或执行完毕后，执行微任务</span></li></ul><div class=\"ne-quote\"><p id=\"u09707d6a\" class=\"ne-p\"><span class=\"ne-text\">node &lt; 10：执行 1-6 阶段的任务；执行 nextTick 中的任务；执行微任务队列中的任务</span></p><p id=\"u44f7fe33\" class=\"ne-p\"><span class=\"ne-text\">node &gt;= 11：node 在 setTimeout 执行后会手动清空微任务队列，用来保证计算结果和浏览器相近</span></p></div><h3 id=\"DFxcp\"><span class=\"ne-text\">node.js 中定时器和 process.nextTick 执行时机</span></h3><ul class=\"ne-ul\"><li id=\"u31ee1ea7\" data-lake-index-type=\"0\"><span class=\"ne-text\">setImmediate：触发一个异步回调，在事件循环的 check 阶段立即执行</span></li><li id=\"ue89e8f06\" data-lake-index-type=\"0\"><span class=\"ne-text\">setTimeout：触发一个异步回调，当计时器过期后，在事件循环的 timers 阶段执行，仅执行一次，可使用 clearTimeout 取消</span></li><li id=\"u745fdec9\" data-lake-index-type=\"0\"><span class=\"ne-text\">setInterval：触发一个异步回调，每次计时器过期后，都会在事件循环的 timers 阶段执行一次回调，可使用 clearInterval 取消</span></li><li id=\"u3f75bd92\" data-lake-index-type=\"0\"><span class=\"ne-text\">process.nextTick：触发一个微任务异步回调，既可以在主线程 mainline 中执行，也可以在事件循环中的某一个阶段中执行</span></li></ul><h3 id=\"TJa6Z\"><span class=\"ne-text\">node.js 中事件循环的案例</span></h3><pre data-language=\"javascript\" id=\"ETy1X\" class=\"ne-codeblock language-javascript\"><code>async function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n \nasync function async2() {\n    console.log('async2')\n}\n \nconsole.log('script start')\n \nsetTimeout(function () {\n    console.log('setTimeout0')\n}, 0)\n \nsetTimeout(function () {\n    console.log('setTimeout2')\n}, 300)\n \nsetImmediate(() =&gt; console.log('setImmediate'));\n \nprocess.nextTick(() =&gt; console.log('nextTick1'));\n \nasync1();\n \nprocess.nextTick(() =&gt; console.log('nextTick2'));\n \nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve();\n    console.log('promise2')\n}).then(function () {\n    console.log('promise3')\n})\n \nconsole.log('script end')</code></pre><ul class=\"ne-ul\"><li id=\"u7a40a41e\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">先找到同步任务，输出 script start</span></li><li id=\"u20497a45\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</span></li><li id=\"uf7cca6e1\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第二个 setTimeout，300ms 后将里面的回调函数放到 timers 队列中</span></li><li id=\"uce150b27\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第一个 setImmediate，将里面的回调函数放到 check 队列中</span></li><li id=\"udb1c1194\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li id=\"ub4af3f8c\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 async1 函数，输出 async1 start</span></li><li id=\"u415792e2\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 async2 函数，输出 async2，async2 后面的输出 async1 end 进入微任务队列，等待下一轮的事件循环</span></li><li id=\"u5422cd44\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到第二个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li id=\"u84245938\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</span></li><li id=\"uaa34cf68\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">then 里面的回调函数进入微任务队列</span></li><li id=\"u89bb1c55\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">遇到同步任务，输出 script end</span></li><li id=\"u480356b6\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行下一轮回调函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</span></li><li id=\"u1f2d483f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">然后执行微任务队列，依次输出 async1 end、promise3</span></li><li id=\"uab245ab6\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">执行 timers 队列，依次输出 setTimeout0</span></li><li id=\"u87013448\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">接着执行 check 队列，依次输出 setImmediate</span></li><li id=\"u44172c50\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">300ms 后，timer 队列存在任务，执行输出 setTimeout2</span></li></ul><p id=\"u34cd94b0\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">执行结果如下：</span></p><pre data-language=\"shell\" id=\"gF2iX\" class=\"ne-codeblock language-shell\"><code>script start\nasync1 start\nasync2\npromise1\npromise2\nscript end\nnextTick1\nnextTick2\nasync1 end\npromise3\nsetTimeout0\nsetImmediate\nsetTimeout2</code></pre><h2 id=\"rIfN9\"><span class=\"ne-text\">浏览器的渲染原理</span></h2><h3 id=\"ihQFN\"><span class=\"ne-text\">渲染流水线</span></h3><p id=\"u02fadf54\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/732231/1700342640685-6007ba92-0714-49d8-9735-03e806f3041d.png\" width=\"1016\" id=\"uaec3dc5e\" class=\"ne-image\"></p><h3 id=\"Y9GAc\"><span class=\"ne-text\">渲染完整过程</span></h3><p id=\"ufba9c796\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2023/png/732231/1700342664434-b95f893d-5c25-46c6-803a-cf90a77ba8aa.png\" width=\"993.5\" id=\"u1a49aea3\" class=\"ne-image\"></p><h3 id=\"SByHk\"><span class=\"ne-text\">浏览器如何对页面进行渲染</span></h3><p id=\"ueef1381d\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">当浏览器的网络线程收到 html 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程</span></p><p id=\"u0a9e329f\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">整个渲染流程分为多个阶段，分别是：</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「html 解析 parse」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「样式计算 style」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「布局 layout」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「分层 layer」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「绘制 paint」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「分块 tiling」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「光栅化 raster」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「画 draw」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。这样整个渲染流程就形成了一套组织严密的生产流水线</span></p><ul class=\"ne-ul\"><li id=\"u10ce90e8\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">渲染的第一步是解析 html</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u8ea908ab\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">解析过程中遇到 css 解析 css，遇到 js 执行 js。为了提高解析效率，浏览器在开始解析前，会启动一个</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">预解析的线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，率先下载 html 中的</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">外部 css 文件</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">和</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">外部的 js 文件</span></strong></li><li id=\"u882a14ba\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">如果主线程解析到 link 位置，此时外部的 css 文件还没有下载解析好，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">主线程不会等待</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，继续解析后续的 html。这是因为下载和解析 css 的工作是在</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">预解析线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中进行的。</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">这就是 css 不会阻塞 html 解析的根本原因</span></strong></li><li id=\"u27857434\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">如果主线程解析到 script 位置，会停止解析 html，转而等待 js 文件下载好，并将全局代码解析执行完成后，才能继续解析 html。这是因为 js 代码的执行过程</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">可能会修改当前的 dom 树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，所以 dom 树的生成</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">必须暂停</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">这就是 js 会阻塞 html 解析的根本原因</span></strong></li><li id=\"u29280a92\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">第一步完成后，会得到 </span><strong><span class=\"ne-text\" style=\"font-size: 14px\">dom 树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">和 </span><strong><span class=\"ne-text\" style=\"font-size: 14px\">cssom（css object model）树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，浏览器的</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">默认样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">内部样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">外部样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">行内样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">均会包含在 cssom 树中</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u66472295\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">渲染的下一步是样式计算</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uace2c64f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">主线程会遍历得到的 dom 树，依次为树中的每个节点计算出它最终的样式，称之为 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">Computed Style</span></code></li><li id=\"u0e577988\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">在这一过程中，很多预设值会变成绝对值，比如 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">red</span></code><span class=\"ne-text\" style=\"font-size: 14px\"> 会变成 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">rgb(255,0,0)</span></code><span class=\"ne-text\" style=\"font-size: 14px\">；相对单位会变成绝对单位，比如 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">em</span></code><span class=\"ne-text\" style=\"font-size: 14px\"> 会变成 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">px</span></code></li><li id=\"ub08f1fa0\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">这一步完成后，会</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">得到一颗带有样式的 dom 树</span></strong></li></ul></ul><ul class=\"ne-ul\"><li id=\"ub660ddfa\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">接下来是布局，布局完成后会得到布局树</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uc4d04074\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">布局阶段会依遍历 dom 树的每一个节点，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">计算每个节点的几何信息</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u9f8df374\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">例如节点的宽高、相对</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">包含块</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">的位置</span></li></ul></ul></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u91a3e8d7\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">大部分时候，dom 树和布局树并非一一对应。</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u8347daee\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">例如 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">display: none</span></code><span class=\"ne-text\" style=\"font-size: 14px\">的节点没有几何信息，因此不会生成到布局树</span></li><li id=\"u11ec29a8\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">又比如使用了伪元素选择器，虽然 dom 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中</span></li><li id=\"u211bf85e\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">还有</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">匿名行盒</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">、</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">匿名块盒</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">等等都会导致 dom 树和布局树无法一一对应</span></li></ul></ul></ul><ul class=\"ne-ul\"><li id=\"u5c0d3d61\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">下一步是分层</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ua18841b6\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">主线程会使用一套复杂的策略对整个布局树进行分层</span></li><li id=\"u1140322f\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\" style=\"font-size: 14px\">分层的好处</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">：将来某一个层改变后，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">仅仅只会对该层进行后续处理</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，从而</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">提升效率</span></strong></li><li id=\"u1dea6151\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过使用 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 14px\">will-change</span></code><span class=\"ne-text\" style=\"font-size: 14px\">属性更大程度的影响分层结果</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u6c9cb511\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">再下一步是绘制</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u6af5f92d\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">主线程会为每个层单独产生</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">绘制指令集</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，用于描述这一层的内容应该如何画出来</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u50f21b6f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">交给</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">合成线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">分块</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ubb4a6772\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">完成绘制后，主线程会将每个图层的绘制信息提交给</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">合成线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，剩余工作将会由合成线程来完成</span></li><li id=\"u08f3b198\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程首先对</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">每个图层进行分块</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，将其划分为更多的小区域</span></li><li id=\"uf8b31626\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">它会从</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">线程池</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中拿去多个线程来完成分块工作</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u5353b8d8\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">分块完成后，进入</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">光栅化</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">阶段</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u0f4995f4\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程会将块信息</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">交给 gpu 进程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，以极高的速度完成光栅化</span></li><li id=\"u0e967914\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">gpu 进程会开启多个线程来完成光栅化，并且</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">优先处理靠近视口区域</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">的块</span></li><li id=\"ub33bc434\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">光栅化的结果，就是一块一块的位图</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"ub9bcc39a\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">最后一个阶段就是画</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ued6ef728\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程拿到每个层、每个块的位图后，生成一个个</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">「指引 quad」</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">信息</span></li><li id=\"u9c394ffe\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">旋转、缩放</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">等变形</span></li><li id=\"u86b29ca4\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\" style=\"font-size: 14px\">变形发生在合成线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，与</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">渲染主线程无关</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">这就是 transform 效率高的本质原因</span></strong></li><li id=\"u47c5dbb0\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程会把 quad 提交给 gpu 进程，由 gpu 进程产生系统调用，提交给 gpu 硬件，最终完成屏幕成像</span></li></ul></ul><hr id=\"FEfyn\" class=\"ne-hr\"><p id=\"u3ddf85f2\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">包含块</span></p><p id=\"u035b9176\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">行盒，块盒 </span></p><p id=\"ua70ccb70\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">内容必须在行盒中</span></p><p id=\"u5003c1d2\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">行盒和块盒不能相邻 匿名行盒 </span></p><p id=\"uf59320cd\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\"></span></p><p id=\"ua3d7f67b\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 14px\">合成线程和渲染主线程在渲染进程里面，是放在沙盒里的，安全</span></p><hr id=\"s5V3a\" class=\"ne-hr\"><h3 id=\"WFMRQ\"><span class=\"ne-text\">什么是 reflow - 回流</span></h3><ul class=\"ne-ul\"><li id=\"uc1a51ffe\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">reflow 的本质就是重新计算</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">布局（layout）树</span></strong></li><li id=\"u1e00f20f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">当进行了会影响</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">布局（layout）树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">的操作后，需要重新计算布局树，会引发 layout</span></li><li id=\"u61727091\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">为了避免连续的多次操作导致</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">布局（layout）树</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">反复计算，浏览器会</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">合并</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">这些操作，当 js 代码</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">全部完成</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">后再</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">进行统一计算</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。所以，</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">改动属性</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">造成的 reflow 是</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">异步</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">完成的</span></li><li id=\"u5e674d4f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">也同样因为如此，当 js 获取布局属性时，就可能造成</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">无法获取到最新的</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">布局信息</span></li><li id=\"uf81d091c\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">浏览器在反复权衡下，最终决定获取属性时立即 reflow</span></li></ul><h3 id=\"lT9JU\"><span class=\"ne-text\">什么是 repaint - 重绘</span></h3><ul class=\"ne-ul\"><li id=\"ua27927eb\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">repaint 的本质就是重新根据</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">分层信息</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">计算了</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">绘制指令</span></strong></li><li id=\"u7b924f4d\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">当改动了</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">可见样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">后，就需要</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">重新计算</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，会引发 repaint</span></li><li id=\"u88ff1c39\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">由于</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">元素的布局信息</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">也属于</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">可见样式</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，所以 reflow 一定会引起 repaint</span></li></ul><h3 id=\"XMc3j\"><span class=\"ne-text\">为什么 transform 效率高</span></h3><ul class=\"ne-ul\"><li id=\"uc5a59c9c\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">因为 transform 既不会影响</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">布局（layout</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">），也不会影响</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">绘制指令</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">，它影响的只是渲染流程的最后一个 - </span><strong><span class=\"ne-text\" style=\"font-size: 14px\">draw 阶段</span></strong></li><li id=\"u0d095d00\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 14px\">由于 </span><strong><span class=\"ne-text\" style=\"font-size: 14px\">draw 阶段</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">在</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">合成线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">中，所以 transform 的变化</span><strong><span class=\"ne-text\" style=\"font-size: 14px\">几乎不会影响渲染主线程</span></strong><span class=\"ne-text\" style=\"font-size: 14px\">。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化</span></li></ul><h2 id=\"i9uyF\"><span class=\"ne-text\">位运算</span></h2><h3 id=\"l9E0I\"><span class=\"ne-text\">位运算符</span></h3><ul class=\"ne-ul\"><li id=\"ue8107695\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位与 </span><strong><span class=\"ne-text\">&amp;</span></strong><span class=\"ne-text\"></span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u5d3019df\" data-lake-index-type=\"0\"><span class=\"ne-text\">a &amp; b：只有当 a 和 b 中对应的位都是 1 时，结果位才是 1</span></li><li id=\"ud787f28a\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：常用于位掩码</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u1c3ef920\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位或 </span><strong><span class=\"ne-text\">|</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ub0a7f439\" data-lake-index-type=\"0\"><span class=\"ne-text\">a | b：如果 a 和 b 中至少有一个对应位是 1，则结果位是 1</span></li><li id=\"u340deae5\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：设置位掩码</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u4277b90b\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位异或 </span><strong><span class=\"ne-text\">^</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u3a88eedc\" data-lake-index-type=\"0\"><span class=\"ne-text\">a ^ b：当 a 和 b 中对应位不相同时，结果位是 1</span></li><li id=\"u356c9bca\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：切换位掩码</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u2aecbbfd\" data-lake-index-type=\"0\"><span class=\"ne-text\">按位非 </span><strong><span class=\"ne-text\">~</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u850e3894\" data-lake-index-type=\"0\"><span class=\"ne-text\">~a：反转 a 的所有位（1 变 0，0 变 1）</span></li><li id=\"u1c4741ed\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：常用于位掩码的反转</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u675a8365\" data-lake-index-type=\"0\"><span class=\"ne-text\">左移 </span><strong><span class=\"ne-text\">&lt;&lt;</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u5f5046cb\" data-lake-index-type=\"0\"><span class=\"ne-text\">a &lt;&lt; b：将 a 的二进制表示向左移动 b 位（从右侧补 0）</span></li><li id=\"ueab672f2\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：相当于乘以 2 的 b 次幂</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"ub2b78ac1\" data-lake-index-type=\"0\"><span class=\"ne-text\">有符号右移 </span><strong><span class=\"ne-text\">&gt;&gt;</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uce3f6def\" data-lake-index-type=\"0\"><span class=\"ne-text\">a &gt;&gt; b：将 a 的二进制表示向右移动 b 位，保留符号位（正数前面补 0，负数前面补-）</span></li><li id=\"ufcb6e0f5\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：相当于除以 2 的 b 次幂，保持符号</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"uc2f024ef\" data-lake-index-type=\"0\"><span class=\"ne-text\">无符号右移 </span><strong><span class=\"ne-text\">&gt;&gt;&gt;</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u81ecdf48\" data-lake-index-type=\"0\"><span class=\"ne-text\">a &gt;&gt;&gt; b：将 a 的二进制表示向右移动 b 位，不保留符号位（前面补 0）</span></li><li id=\"udaedf8cf\" data-lake-index-type=\"0\"><span class=\"ne-text\">用途：对于正数和负数的右移操作，结果总是正数</span></li></ul></ul><h3 id=\"X9BfX\"><span class=\"ne-text\">使用场景</span></h3><ol class=\"ne-ol\"><li id=\"u7a68ee33\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">设置和清除特定位</span></strong><span class=\"ne-text\">：使用 &amp;、| 和 ~ 来设置、清除或切换特定位。这在处理位掩码或状态标志时非常有用</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uab6b884c\" data-lake-index-type=\"0\"><span class=\"ne-text\">设置第 i 位：</span><code class=\"ne-code\"><span class=\"ne-text\">num |= (1 &lt;&lt; i)</span></code></li><li id=\"u5398f91d\" data-lake-index-type=\"0\"><span class=\"ne-text\">清除第 i 位：</span><code class=\"ne-code\"><span class=\"ne-text\">num &amp;= ~(1 &lt;&lt; i)</span></code></li><li id=\"u2fe5883a\" data-lake-index-type=\"0\"><span class=\"ne-text\">切换第 i 位：</span><code class=\"ne-code\"><span class=\"ne-text\">num ^= (1 &lt;&lt; i)</span></code></li><li id=\"u3733a173\" data-lake-index-type=\"0\"><span class=\"ne-text\">检查第 i 位是否设置：</span><code class=\"ne-code\"><span class=\"ne-text\">(num &amp; (1 &lt;&lt; i)) != 0</span></code></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u9d15a845\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">权限控制</span></strong><span class=\"ne-text\">：位运算常用于实现权限控制系统，其中每个位代表一种权限，通过位运算来添加、移除和检查权限</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u083b3dc0\" data-lake-index-type=\"0\"><span class=\"ne-text\">假设每个位代表一个权限，可以用位运算符来控制权限的开启和关闭</span></li><li id=\"ubf921bb5\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">permissions |= (1 &lt;&lt; READ)</span></code><span class=\"ne-text\"> 可以开启读权限</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u2efb5358\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">两数交换不用额外变量</span></strong><span class=\"ne-text\">：使用 ^ 可以在不使用临时变量的情况下交换两个数</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"gqKRM\" class=\"ne-codeblock language-javascript\"><code>let a = 5, b = 9\na ^= b // output: 12，a = 12，b = 9\nb ^= a // output: 5，b = 5，a = 12\na ^= b // output: 9，a = 9，b = 5</code></pre></span><ol start=\"4\" class=\"ne-ol\"><li id=\"u4e5ac8f8\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">计算两数的和</span></strong><span class=\"ne-text\">：通过 ^ 和 &amp; 操作，可以实现两个数的加法而不使用加号或减号</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"mQe04\" class=\"ne-codeblock language-javascript\"><code>while (b != 0) {\n    let carry = a &amp; b;\n    a = a ^ b;\n    b = carry &lt;&lt; 1;\n}</code></pre></span><ol start=\"5\" class=\"ne-ol\"><li id=\"u75c8a793\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">求绝对值</span></strong><span class=\"ne-text\">：利用 &gt;&gt; 和 ^ 操作可以计算一个数的绝对值</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"wQ8Oe\" class=\"ne-codeblock language-javascript\"><code>int abs(int x) {\n    int mask = x &gt;&gt; 31;\n    return (x ^ mask) - mask;\n}</code></pre></span><ol start=\"6\" class=\"ne-ol\"><li id=\"ue5395103\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">判断奇偶性</span></strong><span class=\"ne-text\">：使用 &amp; 检查一个数的最低位，可以快速判断一个数是奇数还是偶数</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"n8lHZ\" class=\"ne-codeblock language-javascript\"><code>// 利用最低位判断数字奇偶性\nif (num &amp; 1) {\n  // 奇数\n} else {\n// 偶数\n}</code></pre></span><ol start=\"7\" class=\"ne-ol\"><li id=\"ub44f12e0\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">乘除以 2 的幂</span></strong><span class=\"ne-text\">：使用 &lt;&lt; 和 &gt;&gt; 操作可以实现乘除以 2 的幂</span></li><li id=\"ud569ea7b\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">快速访问数组元素</span></strong><span class=\"ne-text\">：在处理像图像处理这样的大型数组时，位运算可以用于快速计算索引，提高效率</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ua31a2372\" data-lake-index-type=\"0\"><span class=\"ne-text\">在图像处理中，可以用位运算来计算像素的位置：</span><code class=\"ne-code\"><span class=\"ne-text\">let index = (row &lt;&lt; shift) + column</span></code></li><li id=\"udde1ca0f\" data-lake-index-type=\"0\"><span class=\"ne-text\">这里假设每行有 2 的幂个像素</span></li></ul></ul><ol start=\"9\" class=\"ne-ol\"><li id=\"uc245873a\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">单一位的状态切换</span></strong><span class=\"ne-text\">：使用 ^ 可以快速切换一个位的状态</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u0e54a91b\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">flag ^= (1 &lt;&lt; i)</span></code></li><li id=\"u0ab8bc65\" data-lake-index-type=\"0\"><span class=\"ne-text\">这可以快速切换第 i 位的状态</span></li></ul></ul><ol start=\"10\" class=\"ne-ol\"><li id=\"u227e51a4\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">二进制反转或位反转</span></strong><span class=\"ne-text\">：对整数进行位反转，这在某些特定的数学运算和算法问题中非常有用</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u8577dbaa\" data-lake-index-type=\"0\"><span class=\"ne-text\">将一个数的二进制表示反转：例如，将 0b1101 变为 0b1011</span></li></ul></ul><ol start=\"11\" class=\"ne-ol\"><li id=\"ua13881ab\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">求两数的最大公约数</span></strong><span class=\"ne-text\">：使用位运算结合递归或迭代方法可以高效求解最大公约数</span></li><li id=\"u06c7645f\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">求解子集问题</span></strong><span class=\"ne-text\">：在处理组合问题时，位运算可以用来枚举集合的所有子集</span></li></ol><span style=\"margin-left: 2em\"><pre data-language=\"javascript\" id=\"l76jf\" class=\"ne-codeblock language-javascript\"><code>for (let subset = 0; subset &lt; (1 &lt;&lt; n); ++subset) {\n  // 处理子集，n 是集合中元素数量\n}</code></pre></span></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"viewport\" content=\"adapt\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"paragraphSpacing\" content=\"relax\" /><h2 data-lake-id=\"JEo5n\" id=\"JEo5n\"><span data-lake-id=\"u7d8866c2\" id=\"u7d8866c2\">进程和线程</span></h2><h3 data-lake-id=\"nBfC3\" id=\"nBfC3\"><span data-lake-id=\"u0e064515\" id=\"u0e064515\">进程</span></h3><ul list=\"ub052d37f\"><li fid=\"u9d77fa92\" data-lake-id=\"u4e17911c\" id=\"u4e17911c\"><span data-lake-id=\"u7c7ef76f\" id=\"u7c7ef76f\">概念：进程是操作系统进行资源分配和管理的最小单位，是能够拥有系统资源的最小单位。一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值</span></li><li fid=\"u9d77fa92\" data-lake-id=\"ua586dc9a\" id=\"ua586dc9a\"><span data-lake-id=\"u5115efae\" id=\"u5115efae\">理解：任何程序运行都需要有它自己专属的内存空间，可以把这块内存空间简单理解为进程。每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意</span></li></ul><h3 data-lake-id=\"GsUdR\" id=\"GsUdR\"><span data-lake-id=\"u7226bc0e\" id=\"u7226bc0e\">线程</span></h3><ul list=\"uf8184b19\"><li fid=\"u722efa47\" data-lake-id=\"u9c80d41f\" id=\"u9c80d41f\"><span data-lake-id=\"uc0546571\" id=\"uc0546571\">概念：线程是进程中执行运算的最小单位</span></li><li fid=\"u722efa47\" data-lake-id=\"ua9643d6c\" id=\"ua9643d6c\"><span data-lake-id=\"u38a8454a\" id=\"u38a8454a\">理解：在拥有进程后，就可以运行程序代码，而运行代码的 &quot;人&quot; 称之为线程。一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程也被称为</span><strong><span data-lake-id=\"u58b3d898\" id=\"u58b3d898\">主线程</span></strong><span data-lake-id=\"ud9f3d980\" id=\"ud9f3d980\">。如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以</span><strong><span data-lake-id=\"uefbd2b60\" id=\"uefbd2b60\">一个进程中可以包含多个线程</span></strong></li></ul><h3 data-lake-id=\"oBx5h\" id=\"oBx5h\"><span data-lake-id=\"u27f7b6ca\" id=\"u27f7b6ca\">进程和线程的区别</span></h3><ul list=\"u00e58bec\"><li fid=\"ua572f1c2\" data-lake-id=\"u2c73120a\" id=\"u2c73120a\"><span data-lake-id=\"uee5e2f91\" id=\"uee5e2f91\">进程是计算机管理运行程序的一种方式，一个进程下可包含一个或者多个线程。线程可以理解为子进程</span></li><li fid=\"ua572f1c2\" data-lake-id=\"u8b62dd98\" id=\"u8b62dd98\"><span data-lake-id=\"u253eca56\" id=\"u253eca56\" style=\"color: rgb(32, 33, 34)\">一个线程只能属于一个进程，而一个进程可以包含多个线程</span></li><li fid=\"ua572f1c2\" data-lake-id=\"u6dbc0d2d\" id=\"u6dbc0d2d\"><span data-lake-id=\"u1c004722\" id=\"u1c004722\" style=\"color: rgb(32, 33, 34)\">线程无地址空间，它包括在进程的地址空间里</span></li><li fid=\"ua572f1c2\" data-lake-id=\"u0b7ffd9e\" id=\"u0b7ffd9e\"><span data-lake-id=\"u1b4f8f35\" id=\"u1b4f8f35\" style=\"color: rgb(32, 33, 34)\">线程的开销和代价比进程小</span></li></ul><h3 data-lake-id=\"b3IF7\" id=\"b3IF7\"><span data-lake-id=\"u210c737c\" id=\"u210c737c\">浏览器有哪些进程和线程</span></h3><p data-lake-id=\"u4253d197\" id=\"u4253d197\"><strong><span data-lake-id=\"u631fb2e7\" id=\"u631fb2e7\">浏览器是一个多进程多线程的应用程序</span></strong><span data-lake-id=\"ub5aa2ca1\" id=\"ub5aa2ca1\">，其内部工作极其复杂，为了避免各工作间相互影响，同时减少连环崩溃的几率，当启动浏览器后，它将会自动启动多个进程。（另外，可以在浏览器的任务管理器中查看当前的所有进程）</span></p><p data-lake-id=\"ub9e6b2d1\" id=\"ub9e6b2d1\"><span data-lake-id=\"ub5b8bdcb\" id=\"ub5b8bdcb\">最主要的进程如下：</span></p><ol list=\"u84aed78c\"><li fid=\"u58953088\" data-lake-id=\"ue939426b\" id=\"ue939426b\"><span data-lake-id=\"u97ec26a0\" id=\"u97ec26a0\">浏览器进程：主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务</span></li><li fid=\"u58953088\" data-lake-id=\"u19c85b21\" id=\"u19c85b21\"><span data-lake-id=\"uc65f19c3\" id=\"uc65f19c3\">网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务</span></li><li fid=\"u58953088\" data-lake-id=\"u134104bd\" id=\"u134104bd\"><strong><span data-lake-id=\"ue5da7a0d\" id=\"ue5da7a0d\">渲染进程</span></strong><span data-lake-id=\"u0a9bc6c7\" id=\"u0a9bc6c7\">：渲染进程启动后，会开启一个</span><strong><span data-lake-id=\"u50d849c1\" id=\"u50d849c1\">渲染主线程</span></strong><span data-lake-id=\"u1e66df70\" id=\"u1e66df70\">，它负责执行 html、css、js 代码</span></li></ol><p data-lake-id=\"u3f3ea18a\" id=\"u3f3ea18a\"><span data-lake-id=\"ua8ce7d01\" id=\"ua8ce7d01\">默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响（未来可能会限制同一个域下共用一个渲染进程，具体需要参考 </span><a href=\"https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability\" target=\"_blank\" data-lake-id=\"ud726aaab\" id=\"ud726aaab\"><span data-lake-id=\"u7d163bc7\" id=\"u7d163bc7\">chrome 官网文档</span></a><span data-lake-id=\"uc98b02de\" id=\"uc98b02de\">）</span></p><h3 data-lake-id=\"NuMU7\" id=\"NuMU7\"><span data-lake-id=\"u69a2a716\" id=\"u69a2a716\">渲染主线程是如何工作的</span></h3><p data-lake-id=\"u72b75f93\" id=\"u72b75f93\"><span data-lake-id=\"u59b0f22e\" id=\"u59b0f22e\">渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于</span></p><ul list=\"u4da76dc1\"><li fid=\"ud3737b49\" data-lake-id=\"uc9eebfd9\" id=\"uc9eebfd9\"><span data-lake-id=\"u5c3e58f9\" id=\"u5c3e58f9\">解析 html</span></li><li fid=\"ud3737b49\" data-lake-id=\"u7eb71df5\" id=\"u7eb71df5\"><span data-lake-id=\"ua2401d5c\" id=\"ua2401d5c\">解析 css</span></li><li fid=\"ud3737b49\" data-lake-id=\"u4d3a8453\" id=\"u4d3a8453\"><span data-lake-id=\"u911602e4\" id=\"u911602e4\">计算样式</span></li><li fid=\"ud3737b49\" data-lake-id=\"u87bf95d4\" id=\"u87bf95d4\"><span data-lake-id=\"u6b9ef32f\" id=\"u6b9ef32f\">布局</span></li><li fid=\"ud3737b49\" data-lake-id=\"u79a5b695\" id=\"u79a5b695\"><span data-lake-id=\"uc77d98a0\" id=\"uc77d98a0\">处理图层</span></li><li fid=\"ud3737b49\" data-lake-id=\"u6c78d1ec\" id=\"u6c78d1ec\"><span data-lake-id=\"u22cbc3a4\" id=\"u22cbc3a4\">每秒把页面画 60 次</span></li><li fid=\"ud3737b49\" data-lake-id=\"u85857a32\" id=\"u85857a32\"><span data-lake-id=\"u5cf6ebb6\" id=\"u5cf6ebb6\">执行全局 js 代码</span></li><li fid=\"ud3737b49\" data-lake-id=\"udf2e97ab\" id=\"udf2e97ab\"><span data-lake-id=\"uc8529ab8\" id=\"uc8529ab8\">执行时间处理函数</span></li><li fid=\"ud3737b49\" data-lake-id=\"u8c685902\" id=\"u8c685902\"><span data-lake-id=\"u4a06a7d5\" id=\"u4a06a7d5\">执行计时器的回调函数</span></li><li fid=\"ud3737b49\" data-lake-id=\"u092deb75\" id=\"u092deb75\"><span data-lake-id=\"uf6a38ab5\" id=\"uf6a38ab5\">......</span></li></ul><h3 data-lake-id=\"npC5D\" id=\"npC5D\"><span data-lake-id=\"ud91bd95a\" id=\"ud91bd95a\">为什么 js 是单线程</span></h3><p data-lake-id=\"u1d9b89c5\" id=\"u1d9b89c5\"><span data-lake-id=\"u28231f72\" id=\"u28231f72\">因为多个线程同时操作 dom，会发生冲突，出现意料之外的情况。所以说，</span><strong><span data-lake-id=\"uba6fd2b6\" id=\"uba6fd2b6\">单线程是异步产生的原因</span></strong></p><h3 data-lake-id=\"krL6t\" id=\"krL6t\"><span data-lake-id=\"ucf8a38cd\" id=\"ucf8a38cd\">渲染主线程的排队机制（事件循环 or 消息循环）</span></h3><p data-lake-id=\"ud2697bb6\" id=\"ud2697bb6\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2023%2Fpng%2F732231%2F1700256055361-d609be7e-7f21-43d7-88f5-f464da0c450c.png%22%2C%22taskId%22%3A%22u8a63b048-eb85-4d08-b2a3-b98e9021903%22%2C%22clientId%22%3A%22udc20a255-187f-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A451.2%2C%22height%22%3A228%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A79407%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A1128%2C%22originHeight%22%3A570%2C%22ratio%22%3A2.5%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%20%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%20%E4%BB%BB%E5%8A%A1%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%E4%BB%BB%E5%8A%A1%20%E4%BB%BB%E5%8A%A1%20%E4%BB%BB%E5%8A%A1%20%E4%BB%BB%E5%8A%A1%20QUEUE%20MESSAGE%20%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%20%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A318%2C%22y%22%3A12%2C%22width%22%3A197%2C%22height%22%3A29%2C%22text%22%3A%22%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%22%7D%2C%7B%22x%22%3A95%2C%22y%22%3A87%2C%22width%22%3A142%2C%22height%22%3A29%2C%22text%22%3A%22%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%22%7D%2C%7B%22x%22%3A367%2C%22y%22%3A90%2C%22width%22%3A48%2C%22height%22%3A25%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A1%22%7D%2C%7B%22x%22%3A110%2C%22y%22%3A249%2C%22width%22%3A113%2C%22height%22%3A28%2C%22text%22%3A%22%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%22%7D%2C%7B%22x%22%3A366%2C%22y%22%3A258%2C%22width%22%3A49%2C%22height%22%3A25%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A1%22%7D%2C%7B%22x%22%3A519%2C%22y%22%3A259%2C%22width%22%3A48%2C%22height%22%3A25%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A1%22%7D%2C%7B%22x%22%3A813%2C%22y%22%3A259%2C%22width%22%3A48%2C%22height%22%3A25%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A1%22%7D%2C%7B%22x%22%3A667%2C%22y%22%3A260%2C%22width%22%3A47%2C%22height%22%3A22%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A1%22%7D%2C%7B%22x%22%3A193%2C%22y%22%3A288%2C%22width%22%3A84%2C%22height%22%3A22%2C%22text%22%3A%22QUEUE%22%7D%2C%7B%22x%22%3A55%2C%22y%22%3A290%2C%22width%22%3A120%2C%22height%22%3A21%2C%22text%22%3A%22MESSAGE%22%7D%2C%7B%22x%22%3A650%2C%22y%22%3A487%2C%22width%22%3A114%2C%22height%22%3A29%2C%22text%22%3A%22%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%22%7D%2C%7B%22x%22%3A406%2C%22y%22%3A488%2C%22width%22%3A114%2C%22height%22%3A29%2C%22text%22%3A%22%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f7f6f4%22%2C%22id%22%3A%22u27c65aec%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><ol list=\"u4743bfc5\"><li fid=\"u8a278a0c\" data-lake-id=\"u57df05c6\" id=\"u57df05c6\"><span data-lake-id=\"uf64089f7\" id=\"uf64089f7\">最开始时，渲染主线程会进入一个</span><strong><span data-lake-id=\"u3d43f0c8\" id=\"u3d43f0c8\">无限循环</span></strong></li><li fid=\"u8a278a0c\" data-lake-id=\"ubbd5141d\" id=\"ubbd5141d\"><span data-lake-id=\"uc21e27b7\" id=\"uc21e27b7\">每一次循环会</span><strong><span data-lake-id=\"ue2ea4660\" id=\"ue2ea4660\">检查消息队列</span></strong><span data-lake-id=\"u9fd3caec\" id=\"u9fd3caec\">中是否有任务存在。如果有，就取出第一个任务来执行，执行完当前任务后，进入下一次循环；如果没有任务等待被执行，则进入休眠状态</span></li><li fid=\"u8a278a0c\" data-lake-id=\"u332c0373\" id=\"u332c0373\"><span data-lake-id=\"u07ca66a9\" id=\"u07ca66a9\">其他所有线程（包括其他进程的线程）可以随时向消息队列中添加任务。新任务会被添加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续通过循环来拿取任务</span></li></ol><h2 data-lake-id=\"o1x4y\" id=\"o1x4y\"><span data-lake-id=\"u22feecda\" id=\"u22feecda\">事件循环</span></h2><h3 data-lake-id=\"EqdKK\" id=\"EqdKK\"><span data-lake-id=\"u14661c57\" id=\"u14661c57\">如何理解 js 的异步</span></h3><ol list=\"u386878da\"><li fid=\"u5dadb225\" data-lake-id=\"ue821a135\" id=\"ue821a135\"><span data-lake-id=\"ub80a4900\" id=\"ub80a4900\">js 是一门</span><strong><span data-lake-id=\"u6c9541c8\" id=\"u6c9541c8\">单线程</span></strong><span data-lake-id=\"u5130986e\" id=\"u5130986e\">的语言，这是因为它运行在浏览器的</span><strong><span data-lake-id=\"ud05efd8d\" id=\"ud05efd8d\">渲染主线程</span></strong><span data-lake-id=\"ua2a05e5c\" id=\"ua2a05e5c\">中，而</span><strong><span data-lake-id=\"u88a7c724\" id=\"u88a7c724\">渲染主线程只有一个</span></strong><span data-lake-id=\"ub18273a1\" id=\"ub18273a1\">。同时渲染主线程承担着诸多的工作，页面渲染、js 执行都在其中运行。</span></li><li fid=\"u5dadb225\" data-lake-id=\"uffb27c21\" id=\"uffb27c21\"><span data-lake-id=\"u48d1a09b\" id=\"u48d1a09b\">如果采用同步的方式，极有可能导致主线程产生阻塞，从而导致</span><strong><span data-lake-id=\"u57f2a168\" id=\"u57f2a168\">消息队列（事件队列）</span></strong><span data-lake-id=\"u186db451\" id=\"u186db451\">中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白消耗时间，另一方面会导致页面无法及时更新，给用户造成页面卡死的现象</span></li><li fid=\"u5dadb225\" data-lake-id=\"uf073ecef\" id=\"uf073ecef\"><span data-lake-id=\"u84d42957\" id=\"u84d42957\">因此浏览器采取异步的方式来避免以上情况。具体做法是：当某些任务发生时，如</span><strong><span data-lake-id=\"u59ceb35e\" id=\"u59ceb35e\">计时器、网络、事件监听</span></strong><span data-lake-id=\"uc9456221\" id=\"uc9456221\">等，</span><strong><span data-lake-id=\"uabcbb171\" id=\"uabcbb171\">主线程</span></strong><span data-lake-id=\"u04201fa1\" id=\"u04201fa1\">将任务</span><strong><span data-lake-id=\"u60d72abb\" id=\"u60d72abb\">交给其他线程</span></strong><span data-lake-id=\"ue4b98fc8\" id=\"ue4b98fc8\">去处理，</span><strong><span data-lake-id=\"ua6680fb3\" id=\"ua6680fb3\">自身立即结束任务的执行</span></strong><span data-lake-id=\"ue3a1427f\" id=\"ue3a1427f\">，转而</span><strong><span data-lake-id=\"uf14b2790\" id=\"uf14b2790\">执行后续的任务</span></strong><span data-lake-id=\"u0e758ce9\" id=\"u0e758ce9\">。当其他线程完成时，将事先传递的</span><strong><span data-lake-id=\"uba0c07ce\" id=\"uba0c07ce\">回调函数包装成任务</span></strong><span data-lake-id=\"u114beed0\" id=\"u114beed0\">，加入到</span><strong><span data-lake-id=\"u517d2f10\" id=\"u517d2f10\">消息队列（事件队列）的末尾排队</span></strong><span data-lake-id=\"ucfa6bf31\" id=\"ucfa6bf31\">，</span><strong><span data-lake-id=\"uc580ea28\" id=\"uc580ea28\">等待主线程调度执行</span></strong></li><li fid=\"u5dadb225\" data-lake-id=\"udd36f866\" id=\"udd36f866\"><span data-lake-id=\"u32e278f1\" id=\"u32e278f1\">在这种异步模式下，浏览器永不阻塞，从而最大幅度的保证了单线程的流畅运行</span></li></ol><h3 data-lake-id=\"ohRDl\" id=\"ohRDl\"><span data-lake-id=\"uc5145b6a\" id=\"uc5145b6a\">浏览器的事件循环机制 event loop</span></h3><ul list=\"ud6fc0e86\"><li fid=\"u92dec848\" data-lake-id=\"u809095e6\" id=\"u809095e6\"><span data-lake-id=\"u0459fcbd\" id=\"u0459fcbd\">事件循环又叫做消息循环（chrome 里叫 message loop），是</span><strong><span data-lake-id=\"ud9fc67ab\" id=\"ud9fc67ab\">浏览器渲染主线程的工作方式</span></strong><span data-lake-id=\"u0f01a1cc\" id=\"u0f01a1cc\">（也是</span><strong><span data-lake-id=\"uf9e2dab0\" id=\"uf9e2dab0\">异步的实现方式</span></strong><span data-lake-id=\"u38f85660\" id=\"u38f85660\">）</span></li><li fid=\"u92dec848\" data-lake-id=\"ub23ce813\" id=\"ub23ce813\"><span data-lake-id=\"ucd2f3ca4\" id=\"ucd2f3ca4\">在 chrome 的源码中，它会开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时机将任务加入到队列末尾即可</span></li><li fid=\"u92dec848\" data-lake-id=\"u9011d5c5\" id=\"u9011d5c5\"><span data-lake-id=\"uaaaca69c\" id=\"uaaaca69c\">过去把消息队列简单分为宏任务队列和微任务队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式</span></li><li fid=\"u92dec848\" data-lake-id=\"u0b44947e\" id=\"u0b44947e\"><span data-lake-id=\"u7a177ad7\" id=\"u7a177ad7\">根据 w3c 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须拥有一个微任务队列，微任务队列的任务一定具有最高的优先级，从而优先调度执行</span></li></ul><h3 data-lake-id=\"l0hIq\" id=\"l0hIq\"><span data-lake-id=\"u9fafbd21\" id=\"u9fafbd21\">js 中计时器是否能做到精准计时</span></h3><p data-lake-id=\"uf46db2c3\" id=\"uf46db2c3\"><span data-lake-id=\"ud78cea40\" id=\"ud78cea40\">无法做到精准计时</span></p><ol list=\"u57106c5e\"><li fid=\"u574dac71\" data-lake-id=\"u48c8409d\" id=\"u48c8409d\"><span data-lake-id=\"uba69cae6\" id=\"uba69cae6\">计算机硬件没有原子钟，无法做到精准计时</span></li><li fid=\"u574dac71\" data-lake-id=\"u080eefe8\" id=\"u080eefe8\"><span data-lake-id=\"ua6d25a66\" id=\"ua6d25a66\">操作系统的计时函数本身就存在少量偏差，由于 js 计时器最终调用的是操作系统的函数，因此也会携带这些偏差</span></li><li fid=\"u574dac71\" data-lake-id=\"uccab18b3\" id=\"uccab18b3\"><span data-lake-id=\"uc1b910b2\" id=\"uc1b910b2\">根据 w3c 标准，浏览器在实现计时器时，如果嵌套层级超过 5 层，从第 6 层开始会带有 4ms 的延迟时间，因此在计时时间 &lt; 4ms 时又带来了些许偏差</span></li><li fid=\"u574dac71\" data-lake-id=\"u67a9a1d1\" id=\"u67a9a1d1\"><span data-lake-id=\"u136037f6\" id=\"u136037f6\">受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</span></li></ol><h3 data-lake-id=\"HlZmO\" id=\"HlZmO\"><span data-lake-id=\"ub029a492\" id=\"ub029a492\">执行栈和事件队列</span></h3><ul list=\"u11c0efee\"><li fid=\"u772c2126\" data-lake-id=\"u241b834b\" id=\"u241b834b\"><span data-lake-id=\"u9a0b69b5\" id=\"u9a0b69b5\">执行栈：类似</span><strong><span data-lake-id=\"ua5a9379a\" id=\"ua5a9379a\">函数调用栈</span></strong><span data-lake-id=\"ua1f3061e\" id=\"ua1f3061e\">的运行容器，执行栈为空时，js 引擎会检查事件队列是否为空，如果不为空，那么将第一个任务压入执行栈中执行</span></li><li fid=\"u772c2126\" data-lake-id=\"u367aaffe\" id=\"u367aaffe\"><span data-lake-id=\"uc5270d29\" id=\"uc5270d29\">事件队列 or 消息队列：一个</span><strong><span data-lake-id=\"u78ef9e0a\" id=\"u78ef9e0a\">存储着待执行任务</span></strong><span data-lake-id=\"u7cb6791a\" id=\"u7cb6791a\">的队列，其中的任务</span><strong><span data-lake-id=\"ua5835f34\" id=\"ua5835f34\">严格按照时间顺序</span></strong><span data-lake-id=\"u3edcf86f\" id=\"u3edcf86f\">来执行，</span><strong><span data-lake-id=\"u301beab1\" id=\"u301beab1\">队首的任务率先执行</span></strong><span data-lake-id=\"u2352f9ea\" id=\"u2352f9ea\">，</span><strong><span data-lake-id=\"u946617aa\" id=\"u946617aa\">队尾的任务最后执行</span></strong><span data-lake-id=\"u09dea476\" id=\"u09dea476\">。同时每次仅执行一个任务</span></li></ul><h3 data-lake-id=\"TeWGN\" id=\"TeWGN\"><span data-lake-id=\"uc4083664\" id=\"uc4083664\">任务或消息队列的优先级</span></h3><p data-lake-id=\"u01b25436\" id=\"u01b25436\"><span data-lake-id=\"ua115a636\" id=\"ua115a636\">任务没有优先级，它在消息队列中先进先出。然而</span><strong><span data-lake-id=\"u58fc976e\" id=\"u58fc976e\">消息队列是有优先级的</span></strong></p><p data-lake-id=\"u17f4bbe6\" id=\"u17f4bbe6\"><span data-lake-id=\"ue2e9e16e\" id=\"ue2e9e16e\">根据 w3c 的最新解释：</span></p><ul list=\"ufa8183c2\"><li fid=\"u2a2955ec\" data-lake-id=\"u39278466\" id=\"u39278466\"><span data-lake-id=\"uafa15057\" id=\"uafa15057\">每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</span></li><li fid=\"u2a2955ec\" data-lake-id=\"u803f4cf2\" id=\"u803f4cf2\"><span data-lake-id=\"uc62130a0\" id=\"uc62130a0\">浏览器必须准备好一个微任务队列，</span><a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" target=\"_blank\" data-lake-id=\"u85bc4132\" id=\"u85bc4132\"><span data-lake-id=\"u9612a0ea\" id=\"u9612a0ea\">微任务队列中的任务优先于所有其他任务执行</span></a></li></ul><h3 data-lake-id=\"IKSWL\" id=\"IKSWL\"><span data-lake-id=\"u0bc7e5c8\" id=\"u0bc7e5c8\">任务队列都有哪些</span></h3><p data-lake-id=\"u04917572\" id=\"u04917572\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2023%2Fpng%2F732231%2F1700232559234-0777bb5b-1f74-4b49-abd1-194c8be16c1d.png%22%2C%22taskId%22%3A%22u43c0b990-60bd-4445-9a2a-1bd44e35f06%22%2C%22clientId%22%3A%22u82c408e8-81eb-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A981%2C%22height%22%3A604%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A181774%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A981%2C%22originHeight%22%3A604%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%20%E5%BE%AE%E9%98%9F%E5%88%97%20144115%20FN3%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20%E4%BA%A4%E4%BA%92%E9%98%9F%E5%88%97%20%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A86%2C%22y%22%3A112%2C%22width%22%3A126%2C%22height%22%3A27%2C%22text%22%3A%22%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%22%7D%2C%7B%22x%22%3A117%2C%22y%22%3A223%2C%22width%22%3A76%2C%22height%22%3A25%2C%22text%22%3A%22%E5%BE%AE%E9%98%9F%E5%88%97%22%7D%2C%7B%22x%22%3A930%2C%22y%22%3A318%2C%22width%22%3A51%2C%22height%22%3A16%2C%22text%22%3A%22144115%22%7D%2C%7B%22x%22%3A359%2C%22y%22%3A320%2C%22width%22%3A38%2C%22height%22%3A20%2C%22text%22%3A%22FN3%22%7D%2C%7B%22x%22%3A104%2C%22y%22%3A326%2C%22width%22%3A100%2C%22height%22%3A26%2C%22text%22%3A%22%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%22%7D%2C%7B%22x%22%3A105%2C%22y%22%3A424%2C%22width%22%3A99%2C%22height%22%3A26%2C%22text%22%3A%22%E4%BA%A4%E4%BA%92%E9%98%9F%E5%88%97%22%7D%2C%7B%22x%22%3A314%2C%22y%22%3A542%2C%22width%22%3A102%2C%22height%22%3A27%2C%22text%22%3A%22%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f2d2cb%22%2C%22id%22%3A%22yMEIq%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u27cf6e9d\" id=\"u27cf6e9d\"><span data-lake-id=\"u53c369d2\" id=\"u53c369d2\">在目前的 chrome 的实现中，至少包含了下面的队列：</span></p><ul list=\"ufb7f58bb\"><li fid=\"u71ad4664\" data-lake-id=\"uf919ec60\" id=\"uf919ec60\"><span data-lake-id=\"u06a7a964\" id=\"u06a7a964\">延时队列：用以存放</span><strong><span data-lake-id=\"u02272679\" id=\"u02272679\">计时器到达后的回调任务</span></strong><span data-lake-id=\"u5111090a\" id=\"u5111090a\">，优先级 - 中</span></li></ul><ul list=\"ufb7f58bb\" data-lake-indent=\"1\"><li fid=\"u71ad4664\" data-lake-id=\"u3f4f41df\" id=\"u3f4f41df\"><span data-lake-id=\"u78ca27b3\" id=\"u78ca27b3\">setTimeout</span></li><li fid=\"u71ad4664\" data-lake-id=\"ua8b02786\" id=\"ua8b02786\"><span data-lake-id=\"udf92ac14\" id=\"udf92ac14\">setInterval</span></li><li fid=\"u71ad4664\" data-lake-id=\"u671cada8\" id=\"u671cada8\"><span data-lake-id=\"u951ae593\" id=\"u951ae593\">setImmediate</span></li></ul><ul list=\"ufb7f58bb\" start=\"2\"><li fid=\"u71ad4664\" data-lake-id=\"u236a9d80\" id=\"u236a9d80\"><span data-lake-id=\"u9a5b98e3\" id=\"u9a5b98e3\">交互队列：用于存放</span><strong><span data-lake-id=\"u35c7f46e\" id=\"u35c7f46e\">用户操作后产生的事件处理任务</span></strong><span data-lake-id=\"u5d1b2f62\" id=\"u5d1b2f62\">，优先级 - 高</span></li><li fid=\"u71ad4664\" data-lake-id=\"ubfa9013f\" id=\"ubfa9013f\"><span data-lake-id=\"u831ed356\" id=\"u831ed356\">微任务队列：用以存放</span><strong><span data-lake-id=\"u1a287601\" id=\"u1a287601\">需要最快被执行的任务</span></strong><span data-lake-id=\"u5ee31dee\" id=\"u5ee31dee\">，优先级 - 最高</span></li></ul><ul list=\"ufb7f58bb\" data-lake-indent=\"1\"><li fid=\"u71ad4664\" data-lake-id=\"ua02fc8fa\" id=\"ua02fc8fa\"><span data-lake-id=\"uc59f4aba\" id=\"uc59f4aba\">promise 回调 - 必须有 resolve or reject 结果，同一块作用域内多个 resolve 中，期中一个执行完毕后其余的皆不再执行</span></li><li fid=\"u71ad4664\" data-lake-id=\"u43b56753\" id=\"u43b56753\"><span data-lake-id=\"u3b8ba64b\" id=\"u3b8ba64b\">node.js 的 process.nextTick</span></li><li fid=\"u71ad4664\" data-lake-id=\"u9d186ac1\" id=\"u9d186ac1\"><span data-lake-id=\"u113d284b\" id=\"u113d284b\">MutationObserver -  对 dom 变化进行监听</span></li></ul><blockquote data-lake-id=\"u954efe59\" id=\"u954efe59\"><p data-lake-id=\"u7a7bb360\" id=\"u7a7bb360\"><span data-lake-id=\"u8f41a9d2\" id=\"u8f41a9d2\">浏览器认为与用户交互相关的任务优先级可能比延时任务的优先级更高</span></p></blockquote><h3 data-lake-id=\"cUQDd\" id=\"cUQDd\"><span data-lake-id=\"u3cbabcb6\" id=\"u3cbabcb6\">requestAnimationFrame 和 requestIdleCallback</span></h3><p data-lake-id=\"u6946777b\" id=\"u6946777b\"><span data-lake-id=\"u26734fdc\" id=\"u26734fdc\">前者是在渲染前执行的，因为动画会更改 dom 结构，后者是用来处理计算量大但不紧急的事件，当队列中没有任务执行时，会清空它内部的回调，也可以传入 timeout 参数，强制 timeout 秒后执行，但是会阻塞其他代码的执行</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22fArB5%22%7D\"></card><h3 data-lake-id=\"KLzYc\" id=\"KLzYc\"><span data-lake-id=\"u53f1bd66\" id=\"u53f1bd66\">⚠️</span><span data-lake-id=\"u577c7203\" id=\"u577c7203\"> 旧 - 浏览器事件循环机制 event loop</span></h3><ul list=\"u7a87fbca\"><li fid=\"u6689264d\" data-lake-id=\"u517f16a2\" id=\"u517f16a2\"><span data-lake-id=\"uc413fff4\" id=\"uc413fff4\">js 是单线程执行的，在代码执行的过程中，通过将不同函数的</span><strong><span data-lake-id=\"ud9839b6e\" id=\"ud9839b6e\">执行上下文</span></strong><span data-lake-id=\"u538127e8\" id=\"u538127e8\">压入</span><strong><span data-lake-id=\"u1f2e0e13\" id=\"u1f2e0e13\">执行栈</span></strong><span data-lake-id=\"ufcceb231\" id=\"ufcceb231\">中来保证代码的有序执行</span></li><li fid=\"u6689264d\" data-lake-id=\"u307a10c8\" id=\"u307a10c8\"><span data-lake-id=\"uf3e3d256\" id=\"uf3e3d256\">最开始将整个 </span><strong><span data-lake-id=\"u3be600c6\" id=\"u3be600c6\">script 脚本作为一个宏任务</span></strong><span data-lake-id=\"u5f70d617\" id=\"u5f70d617\">执行，执行过程中</span><strong><span data-lake-id=\"u67f89482\" id=\"u67f89482\">同步代码</span></strong><span data-lake-id=\"ueb01dc9b\" id=\"ueb01dc9b\">直接执行</span></li><li fid=\"u6689264d\" data-lake-id=\"u4f08934c\" id=\"u4f08934c\"><span data-lake-id=\"u4d4af828\" id=\"u4d4af828\">执行同步代码时，如果遇到了异步事件，js 引擎将不会一直等待其返回结果，而是将这个事件暂时挂起，继续执行</span><strong><span data-lake-id=\"u60baafb4\" id=\"u60baafb4\">执行栈</span></strong><span data-lake-id=\"u3533f983\" id=\"u3533f983\">中的其它任务</span></li><li fid=\"u6689264d\" data-lake-id=\"u9eb0ea70\" id=\"u9eb0ea70\"><span data-lake-id=\"u4fbce55e\" id=\"u4fbce55e\">在异步事件执行完毕后，判断任务类型，将其回调函数插入分别插入到</span><strong><span data-lake-id=\"u55db6e9a\" id=\"u55db6e9a\">宏任务队列</span></strong><span data-lake-id=\"u2754bff5\" id=\"u2754bff5\">或</span><strong><span data-lake-id=\"u9adc0daf\" id=\"u9adc0daf\">微任务队列，宏任务队列和微任务队列都属于消息队列</span></strong></li><li fid=\"u6689264d\" data-lake-id=\"u282fe776\" id=\"u282fe776\"><span data-lake-id=\"ubf147e2e\" id=\"ubf147e2e\">当执行栈中的任务执行完毕后，js 引擎会首先判断</span><strong><span data-lake-id=\"u5ee955ef\" id=\"u5ee955ef\">微任务队列</span></strong><span data-lake-id=\"uf123e434\" id=\"uf123e434\">中是否有任务可以执行，如果有就将微任务队列队首的事件压入</span><strong><span data-lake-id=\"uebe5b678\" id=\"uebe5b678\">执行栈</span></strong><span data-lake-id=\"ua7d7bcc8\" id=\"ua7d7bcc8\">中等待执行，直到微任务队列的所有任务全部执行完毕，之后执行宏任务队列中的任务</span></li><li fid=\"u6689264d\" data-lake-id=\"u5296b32a\" id=\"u5296b32a\"><span data-lake-id=\"u258bfc86\" id=\"u258bfc86\">首先执行浏览器的 ui 线程渲染工作，渲染阶段会收到以下因素的影响</span></li></ul><ul list=\"u7a87fbca\" data-lake-indent=\"1\"><li fid=\"u4ec89819\" data-lake-id=\"ub68aa294\" id=\"ub68aa294\"><span data-lake-id=\"ue05a318f\" id=\"ue05a318f\">屏幕分辨率改变，如果页面性能太差，为了不丢帧，浏览器会选择降低帧率</span></li><li fid=\"u4ec89819\" data-lake-id=\"u4b8535c0\" id=\"u4b8535c0\"><span data-lake-id=\"u544d8de0\" id=\"u544d8de0\">浏览器判断本次渲染是否会造成视觉上的改变，比如背景色改变</span></li><li fid=\"u4ec89819\" data-lake-id=\"u954a3872\" id=\"u954a3872\"><span data-lake-id=\"u7628923b\" id=\"u7628923b\">map of animation frame callbacks 为空</span></li></ul><ul list=\"u7a87fbca\" start=\"7\"><li fid=\"u6689264d\" data-lake-id=\"u87e40d33\" id=\"u87e40d33\"><span data-lake-id=\"u1c8d8ffb\" id=\"u1c8d8ffb\">接着检查是否有 web worker 任务，有则执行</span></li></ul><ul list=\"u7a87fbca\" data-lake-indent=\"1\"><li fid=\"u4ec89819\" data-lake-id=\"u5349296d\" id=\"u5349296d\"><span data-lake-id=\"u4bbe0aab\" id=\"u4bbe0aab\">对需要渲染的文档，如果窗口发生了变化，就会调用 resize 事件（resize 自带节流）</span></li><li fid=\"u4ec89819\" data-lake-id=\"ude3cb905\" id=\"ude3cb905\"><span data-lake-id=\"u2b12bae4\" id=\"u2b12bae4\">对需要渲染的文档，如果页面发生了滚动，就会调用 scroll 事件（scroll 自带节流）</span></li><li fid=\"u4ec89819\" data-lake-id=\"ufc87720c\" id=\"ufc87720c\"><span data-lake-id=\"ud589f8af\" id=\"ud589f8af\">对需要渲染的文档，执行 requestAnimationFrame 回调</span></li><li fid=\"u4ec89819\" data-lake-id=\"uc4d04713\" id=\"uc4d04713\"><span data-lake-id=\"uc4ccb3ed\" id=\"uc4ccb3ed\">调用 IntersectionObserver 回调，重新渲染页面</span></li><li fid=\"u4ec89819\" data-lake-id=\"u2ae43486\" id=\"u2ae43486\"><span data-lake-id=\"u689025f1\" id=\"u689025f1\">最后会检查宏任务队列和微任务队列是否为空，如果为空会调用 idle 空闲周期算法，检测 requestIdleCallback 是否为空，如果不为空就会执行里面的回调</span></li></ul><ul list=\"u7a87fbca\" start=\"8\"><li fid=\"u6689264d\" data-lake-id=\"u1f44d563\" id=\"u1f44d563\"><span data-lake-id=\"ued4f0f97\" id=\"ued4f0f97\" class=\"lake-fontsize-11\">执行完</span><strong><span data-lake-id=\"u8b63b630\" id=\"u8b63b630\" class=\"lake-fontsize-11\">本轮宏任务</span></strong><span data-lake-id=\"uf894a601\" id=\"uf894a601\" class=\"lake-fontsize-11\">后，执行</span><strong><span data-lake-id=\"ud9262dcd\" id=\"ud9262dcd\" class=\"lake-fontsize-11\">下一轮宏任务</span></strong></li></ul><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22qBCfp%22%7D\"></card><h3 data-lake-id=\"ASXwF\" id=\"ASXwF\"><span data-lake-id=\"u2fde101e\" id=\"u2fde101e\">node.js 中事件循环的 6 个阶段</span></h3><p data-lake-id=\"u1b71a0ab\" id=\"u1b71a0ab\"><span data-lake-id=\"u2d86c4a2\" id=\"u2d86c4a2\">下面为 node 执行的整个过程，如果执行了任何非阻塞的异步代码，则会进入事件循环：</span></p><p data-lake-id=\"u4f1b1453\" id=\"u4f1b1453\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646662274965-6259f561-8bd7-4251-9810-67df3477bbcf.png%22%2C%22taskId%22%3A%22uc7f19d61-bd9e-44f6-adb0-4e441a2adbd%22%2C%22clientId%22%3A%22u5d023ea2-a4d9-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A980%2C%22height%22%3A556%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A180079%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A1960%2C%22originHeight%22%3A1112%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22NODE%20PENDING%20START%20TIMERS%20CALLBACKS%20MICROTASKS%20YES%20IDLE%2FPREPARE%20ACTIVE%20HANDLERS%20MAINLINE%20OR%20EVENT%20LOOP%20REQUESTS%20MICROTASKS%20MICROTASKS%20POLL%20NO%20NOTE%3ATHE%20TIMING%20OF%20THE%20CLOSE%20EXECUTION%20OF%20MICROTASKS%20CHECK%20HERE%20IS%20DIFFERENT%20FROM%20OTHERS%20CALLBACKS%20NODE%20END%20MICROTASKS%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A100.13535%2C%22y%22%3A61.772163%2C%22width%22%3A95.04871999999999%2C%22height%22%3A31.632431000000004%2C%22text%22%3A%22NODE%22%7D%2C%7B%22x%22%3A1265.4126%2C%22y%22%3A101.629585%2C%22width%22%3A140.7425999999998%2C%22height%22%3A36.936284999999984%2C%22text%22%3A%22PENDING%22%7D%2C%7B%22x%22%3A107.49211%2C%22y%22%3A115.21987%2C%22width%22%3A81.09487999999999%2C%22height%22%3A29.338710000000006%2C%22text%22%3A%22START%22%7D%2C%7B%22x%22%3A853.31934%2C%22y%22%3A125.65624%2C%22width%22%3A115.54509999999993%2C%22height%22%3A34.73559%2C%22text%22%3A%22TIMERS%22%7D%2C%7B%22x%22%3A1260.17%2C%22y%22%3A150.97543%2C%22width%22%3A150.37599999999998%2C%22height%22%3A34.23116000000002%2C%22text%22%3A%22CALLBACKS%22%7D%2C%7B%22x%22%3A831.6851%2C%22y%22%3A224.3897%2C%22width%22%3A158.6988%2C%22height%22%3A25.090100000000007%2C%22text%22%3A%22MICROTASKS%22%7D%2C%7B%22x%22%3A637.6718%2C%22y%22%3A277.9678%2C%22width%22%3A61.72140000000002%2C%22height%22%3A37.16805999999997%2C%22text%22%3A%22YES%22%7D%2C%7B%22x%22%3A1632.9617%2C%22y%22%3A352.89813%2C%22width%22%3A213.07219999999984%2C%22height%22%3A41.30717000000004%2C%22text%22%3A%22IDLE%2FPREPARE%22%7D%2C%7B%22x%22%3A558.51324%2C%22y%22%3A441.79303%2C%22width%22%3A74.36446000000001%2C%22height%22%3A23.752319999999997%2C%22text%22%3A%22ACTIVE%22%7D%2C%7B%22x%22%3A544.23553%2C%22y%22%3A475.55356%2C%22width%22%3A98.57426999999996%2C%22height%22%3A22.552489999999977%2C%22text%22%3A%22HANDLERS%22%7D%2C%7B%22x%22%3A73.71015%2C%22y%22%3A483.3756%2C%22width%22%3A147.39239%2C%22height%22%3A31.36599999999993%2C%22text%22%3A%22MAINLINE%22%7D%2C%7B%22x%22%3A577.933%2C%22y%22%3A512.9687%2C%22width%22%3A37.18443000000002%2C%22height%22%3A18.375%2C%22text%22%3A%22OR%22%7D%2C%7B%22x%22%3A1013.4062%2C%22y%22%3A540.8466%2C%22width%22%3A289.93230000000005%2C%22height%22%3A50.00570000000005%2C%22text%22%3A%22EVENT%20LOOP%22%7D%2C%7B%22x%22%3A542.0549%2C%22y%22%3A540.9865%2C%22width%22%3A103.53200000000004%2C%22height%22%3A23.8836%2C%22text%22%3A%22REQUESTS%22%7D%2C%7B%22x%22%3A68.47498%2C%22y%22%3A578.38257%2C%22width%22%3A158.34172%2C%22height%22%3A24.02773000000002%2C%22text%22%3A%22MICROTASKS%22%7D%2C%7B%22x%22%3A1850.2899%2C%22y%22%3A653.4574%2C%22width%22%3A27.527700000000095%2C%22height%22%3A145.64549999999997%2C%22text%22%3A%22MICROTASKS%22%7D%2C%7B%22x%22%3A1689.692%2C%22y%22%3A706.7841%2C%22width%22%3A64.93229999999994%2C%22height%22%3A32.97163999999998%2C%22text%22%3A%22POLL%22%7D%2C%7B%22x%22%3A426.15613%2C%22y%22%3A766.3127%2C%22width%22%3A55.61901999999998%2C%22height%22%3A31.51445000000001%2C%22text%22%3A%22NO%22%7D%2C%7B%22x%22%3A1613.3322%2C%22y%22%3A869.2507%2C%22width%22%3A264.3088%2C%22height%22%3A27.213300000000004%2C%22text%22%3A%22NOTE%3ATHE%20TIMING%20OF%20THE%22%7D%2C%7B%22x%22%3A861.90375%2C%22y%22%3A894.37787%2C%22width%22%3A94.73169000000007%2C%22height%22%3A39.62373000000002%2C%22text%22%3A%22CLOSE%22%7D%2C%7B%22x%22%3A1615.8507%2C%22y%22%3A903.93304%2C%22width%22%3A270.2772%2C%22height%22%3A21.895819999999958%2C%22text%22%3A%22EXECUTION%20OF%20MICROTASKS%22%7D%2C%7B%22x%22%3A1301.0377%2C%22y%22%3A924.56396%2C%22width%22%3A102.21769999999992%2C%22height%22%3A38.22203999999999%2C%22text%22%3A%22CHECK%22%7D%2C%7B%22x%22%3A1614.6619%2C%22y%22%3A934.76807%2C%22width%22%3A317.7111%2C%22height%22%3A25.66763000000003%2C%22text%22%3A%22HERE%20IS%20DIFFERENT%20FROM%20OTHERS%22%7D%2C%7B%22x%22%3A831.71906%2C%22y%22%3A943.4289%2C%22width%22%3A154.62634000000003%2C%22height%22%3A39.81920000000002%2C%22text%22%3A%22CALLBACKS%22%7D%2C%7B%22x%22%3A106.12054%2C%22y%22%3A949.29193%2C%22width%22%3A89.75146000000001%2C%22height%22%3A32.225040000000035%2C%22text%22%3A%22NODE%22%7D%2C%7B%22x%22%3A118.86394%2C%22y%22%3A1004.1138%2C%22width%22%3A64.96486%2C%22height%22%3A26.802500000000123%2C%22text%22%3A%22END%22%7D%2C%7B%22x%22%3A1272.4097%2C%22y%22%3A1025.9928%2C%22width%22%3A158.5748000000001%2C%22height%22%3A25.942000000000007%2C%22text%22%3A%22MICROTASKS%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f9f2e5%22%2C%22id%22%3A%22u2d752270%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"uf5cbc935\" id=\"uf5cbc935\"><br></p><ul list=\"u4d54e764\"><li fid=\"u9f8fc63f\" data-lake-id=\"u72cb75d5\" id=\"u72cb75d5\"><strong><span data-lake-id=\"u5bab2eff\" id=\"u5bab2eff\">定时器 timers</span></strong><span data-lake-id=\"u0983ec38\" id=\"u0983ec38\">：本阶段执行已经被 setTimeout 和 setInterval 的调度回调函数</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"u9a553fb8\" id=\"u9a553fb8\"><strong><span data-lake-id=\"u28b286b4\" id=\"u28b286b4\">待定回调 pending callbacks</span></strong><span data-lake-id=\"ub33ef0fb\" id=\"ub33ef0fb\">：执行延迟到下一个循环迭代的 I/O 回调</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"ue8787399\" id=\"ue8787399\"><strong><span data-lake-id=\"ud3e585e0\" id=\"ud3e585e0\">idle，prepare</span></strong><span data-lake-id=\"u2182cd44\" id=\"u2182cd44\">：仅系统内部使用</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"u102afb60\" id=\"u102afb60\"><strong><span data-lake-id=\"ub83fe0c7\" id=\"ub83fe0c7\">轮询 poll</span></strong><span data-lake-id=\"u03a2d54b\" id=\"u03a2d54b\">：检索新的 I/O 事件；执行与 I/O 相关的回调(几乎所有情况下，除了 close callbacks，那些由定时器和 setImmediate 调度的之外)，其余情况 node 将在适当的时候在此阻塞</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"u3fbd4751\" id=\"u3fbd4751\"><strong><span data-lake-id=\"u06f9f322\" id=\"u06f9f322\">检测 check</span></strong><span data-lake-id=\"u45f4fb09\" id=\"u45f4fb09\">：setImmediate 回调函数在这里执行</span></li><li fid=\"u9f8fc63f\" data-lake-id=\"u064f2b47\" id=\"u064f2b47\"><strong><span data-lake-id=\"u5315ec27\" id=\"u5315ec27\">关闭的回调函数 close callbacks</span></strong><span data-lake-id=\"u6d7f2ad5\" id=\"u6d7f2ad5\">：一些关闭的回调函数。如：</span><code data-lake-id=\"u1c572aae\" id=\"u1c572aae\"><span data-lake-id=\"u5e5155fd\" id=\"u5e5155fd\">socket.on('close', ...)</span></code></li></ul><blockquote data-lake-id=\"u204dec7e\" id=\"u204dec7e\"><p data-lake-id=\"u98c2e509\" id=\"u98c2e509\"><span data-lake-id=\"uc549d68d\" id=\"uc549d68d\">每个阶段都会有一个 FIFO 先进先出的回调队列，都会尽可能地执行完当前阶段中所有的回调，或到达了系统相关限制后，才会进入下一阶段</span></p></blockquote><blockquote data-lake-id=\"ub28a5c97\" id=\"ub28a5c97\"><p data-lake-id=\"ua63c03f6\" id=\"ua63c03f6\"><span data-lake-id=\"ufcb1bff1\" id=\"ufcb1bff1\">poll 阶段执行微任务的时机：每一个回调执行时执行相应的微任务</span></p><p data-lake-id=\"ufd1e7c43\" id=\"ufd1e7c43\"><span data-lake-id=\"u816bddb2\" id=\"u816bddb2\">timers 和 check 阶段执行微任务的时机：在所有回调执行完毕后，统一执行相应的微任务</span></p></blockquote><h3 data-lake-id=\"bh0wY\" id=\"bh0wY\"><span data-lake-id=\"u31cc643c\" id=\"u31cc643c\">node.js 中的微任务</span></h3><ul list=\"u0bc5a248\"><li fid=\"u7b09bb05\" data-lake-id=\"u387e038f\" id=\"u387e038f\"><span data-lake-id=\"ua7c8fc12\" id=\"ua7c8fc12\">process.nextTick 注册的回调函数 - nextTick task queue</span></li><li fid=\"u7b09bb05\" data-lake-id=\"u84f4bd32\" id=\"u84f4bd32\"><span data-lake-id=\"udd9772a7\" id=\"udd9772a7\">promise.then 注册的回调函数 - promise task queue</span></li></ul><p data-lake-id=\"u7f89bab0\" id=\"u7f89bab0\"><span data-lake-id=\"ud8960eb7\" id=\"ud8960eb7\">node.js 在执行微任务时，优先执行 nextTick task queue 中的任务，执行完后接着执行 promise task queue 中的任务，所以若二者同时处于主线程或事件循环的相同阶段，process.nextTick 回调函数的优先级 &gt; promise.then 回调函数的优先级</span></p><h3 data-lake-id=\"h2KYD\" id=\"h2KYD\"><span data-lake-id=\"uc37ff87a\" id=\"uc37ff87a\" class=\"lake-fontsize-11\">node.js 的事件循环</span></h3><ul list=\"ud0e33eb6\"><li fid=\"u58bc6292\" data-lake-id=\"u39ece818\" id=\"u39ece818\"><span data-lake-id=\"u3e170848\" id=\"u3e170848\">当 node.js 启动后，会初始化事件循环，处理已提供的输入脚本，同时可能会调用一些异步 api、调度定时器、process.nextTick，然后开始处理事件循环</span></li><li fid=\"u58bc6292\" data-lake-id=\"ubcbb737d\" id=\"ubcbb737d\"><span data-lake-id=\"u75157f39\" id=\"u75157f39\">执行事件循环的每个阶段</span></li><li fid=\"u58bc6292\" data-lake-id=\"ucd8e7051\" id=\"ucd8e7051\"><span data-lake-id=\"ua647dbfb\" id=\"ua647dbfb\">在相应阶段的回调函数执行时或执行完毕后，执行微任务</span></li></ul><blockquote data-lake-id=\"u74a06531\" id=\"u74a06531\"><p data-lake-id=\"u09707d6a\" id=\"u09707d6a\"><span data-lake-id=\"ud317a820\" id=\"ud317a820\">node &lt; 10：执行 1-6 阶段的任务；执行 nextTick 中的任务；执行微任务队列中的任务</span></p><p data-lake-id=\"u44f7fe33\" id=\"u44f7fe33\"><span data-lake-id=\"uc09bd3db\" id=\"uc09bd3db\">node &gt;= 11：node 在 setTimeout 执行后会手动清空微任务队列，用来保证计算结果和浏览器相近</span></p></blockquote><h3 data-lake-id=\"DFxcp\" id=\"DFxcp\"><span data-lake-id=\"u3126c44b\" id=\"u3126c44b\">node.js 中定时器和 process.nextTick 执行时机</span></h3><ul list=\"u930c71fd\"><li fid=\"udc681544\" data-lake-id=\"u31ee1ea7\" id=\"u31ee1ea7\"><span data-lake-id=\"u75ba2585\" id=\"u75ba2585\">setImmediate：触发一个异步回调，在事件循环的 check 阶段立即执行</span></li><li fid=\"udc681544\" data-lake-id=\"ue89e8f06\" id=\"ue89e8f06\"><span data-lake-id=\"ua7cefad7\" id=\"ua7cefad7\">setTimeout：触发一个异步回调，当计时器过期后，在事件循环的 timers 阶段执行，仅执行一次，可使用 clearTimeout 取消</span></li><li fid=\"udc681544\" data-lake-id=\"u745fdec9\" id=\"u745fdec9\"><span data-lake-id=\"u6e4872f2\" id=\"u6e4872f2\">setInterval：触发一个异步回调，每次计时器过期后，都会在事件循环的 timers 阶段执行一次回调，可使用 clearInterval 取消</span></li><li fid=\"udc681544\" data-lake-id=\"u3f75bd92\" id=\"u3f75bd92\"><span data-lake-id=\"u36ec52f3\" id=\"u36ec52f3\">process.nextTick：触发一个微任务异步回调，既可以在主线程 mainline 中执行，也可以在事件循环中的某一个阶段中执行</span></li></ul><h3 data-lake-id=\"TJa6Z\" id=\"TJa6Z\"><span data-lake-id=\"u1671ee9c\" id=\"u1671ee9c\">node.js 中事件循环的案例</span></h3><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22async%20function%20async1()%20%7B%5Cn%20%20%20%20console.log('async1%20start')%5Cn%20%20%20%20await%20async2()%5Cn%20%20%20%20console.log('async1%20end')%5Cn%7D%5Cn%20%5Cnasync%20function%20async2()%20%7B%5Cn%20%20%20%20console.log('async2')%5Cn%7D%5Cn%20%5Cnconsole.log('script%20start')%5Cn%20%5CnsetTimeout(function%20()%20%7B%5Cn%20%20%20%20console.log('setTimeout0')%5Cn%7D%2C%200)%5Cn%20%5CnsetTimeout(function%20()%20%7B%5Cn%20%20%20%20console.log('setTimeout2')%5Cn%7D%2C%20300)%5Cn%20%5CnsetImmediate(()%20%3D%3E%20console.log('setImmediate'))%3B%5Cn%20%5Cnprocess.nextTick(()%20%3D%3E%20console.log('nextTick1'))%3B%5Cn%20%5Cnasync1()%3B%5Cn%20%5Cnprocess.nextTick(()%20%3D%3E%20console.log('nextTick2'))%3B%5Cn%20%5Cnnew%20Promise(function%20(resolve)%20%7B%5Cn%20%20%20%20console.log('promise1')%5Cn%20%20%20%20resolve()%3B%5Cn%20%20%20%20console.log('promise2')%5Cn%7D).then(function%20()%20%7B%5Cn%20%20%20%20console.log('promise3')%5Cn%7D)%5Cn%20%5Cnconsole.log('script%20end')%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22ETy1X%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><ul list=\"u3dcd149c\"><li fid=\"u5ab13f46\" data-lake-id=\"u7a40a41e\" id=\"u7a40a41e\"><span data-lake-id=\"uf838717f\" id=\"uf838717f\" class=\"lake-fontsize-11\">先找到同步任务，输出 script start</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u20497a45\" id=\"u20497a45\"><span data-lake-id=\"uc630e9c4\" id=\"uc630e9c4\" class=\"lake-fontsize-11\">遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</span></li><li fid=\"u5ab13f46\" data-lake-id=\"uf7cca6e1\" id=\"uf7cca6e1\"><span data-lake-id=\"u0f80a9fa\" id=\"u0f80a9fa\" class=\"lake-fontsize-11\">遇到第二个 setTimeout，300ms 后将里面的回调函数放到 timers 队列中</span></li><li fid=\"u5ab13f46\" data-lake-id=\"uce150b27\" id=\"uce150b27\"><span data-lake-id=\"u1f264b3d\" id=\"u1f264b3d\" class=\"lake-fontsize-11\">遇到第一个 setImmediate，将里面的回调函数放到 check 队列中</span></li><li fid=\"u5ab13f46\" data-lake-id=\"udb1c1194\" id=\"udb1c1194\"><span data-lake-id=\"u1d66bb3f\" id=\"u1d66bb3f\" class=\"lake-fontsize-11\">遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li fid=\"u5ab13f46\" data-lake-id=\"ub4af3f8c\" id=\"ub4af3f8c\"><span data-lake-id=\"u024840ae\" id=\"u024840ae\" class=\"lake-fontsize-11\">执行 async1 函数，输出 async1 start</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u415792e2\" id=\"u415792e2\"><span data-lake-id=\"u25097e68\" id=\"u25097e68\" class=\"lake-fontsize-11\">执行 async2 函数，输出 async2，async2 后面的输出 async1 end 进入微任务队列，等待下一轮的事件循环</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u5422cd44\" id=\"u5422cd44\"><span data-lake-id=\"u9d8a4e58\" id=\"u9d8a4e58\" class=\"lake-fontsize-11\">遇到第二个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u84245938\" id=\"u84245938\"><span data-lake-id=\"u7dde9685\" id=\"u7dde9685\" class=\"lake-fontsize-11\">遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</span></li><li fid=\"u5ab13f46\" data-lake-id=\"uaa34cf68\" id=\"uaa34cf68\"><span data-lake-id=\"u6d590bae\" id=\"u6d590bae\" class=\"lake-fontsize-11\">then 里面的回调函数进入微任务队列</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u89bb1c55\" id=\"u89bb1c55\"><span data-lake-id=\"ufb51ea4f\" id=\"ufb51ea4f\" class=\"lake-fontsize-11\">遇到同步任务，输出 script end</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u480356b6\" id=\"u480356b6\"><span data-lake-id=\"u9dd69001\" id=\"u9dd69001\" class=\"lake-fontsize-11\">执行下一轮回调函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u1f2d483f\" id=\"u1f2d483f\"><span data-lake-id=\"u8900207e\" id=\"u8900207e\" class=\"lake-fontsize-11\">然后执行微任务队列，依次输出 async1 end、promise3</span></li><li fid=\"u5ab13f46\" data-lake-id=\"uab245ab6\" id=\"uab245ab6\"><span data-lake-id=\"u90429afa\" id=\"u90429afa\" class=\"lake-fontsize-11\">执行 timers 队列，依次输出 setTimeout0</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u87013448\" id=\"u87013448\"><span data-lake-id=\"uc4b6d73f\" id=\"uc4b6d73f\" class=\"lake-fontsize-11\">接着执行 check 队列，依次输出 setImmediate</span></li><li fid=\"u5ab13f46\" data-lake-id=\"u44172c50\" id=\"u44172c50\"><span data-lake-id=\"uc952fe3e\" id=\"uc952fe3e\" class=\"lake-fontsize-11\">300ms 后，timer 队列存在任务，执行输出 setTimeout2</span></li></ul><p data-lake-id=\"u34cd94b0\" id=\"u34cd94b0\"><span data-lake-id=\"ufa7631be\" id=\"ufa7631be\" class=\"lake-fontsize-11\">执行结果如下：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22shell%22%2C%22code%22%3A%22script%20start%5Cnasync1%20start%5Cnasync2%5Cnpromise1%5Cnpromise2%5Cnscript%20end%5CnnextTick1%5CnnextTick2%5Cnasync1%20end%5Cnpromise3%5CnsetTimeout0%5CnsetImmediate%5CnsetTimeout2%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22gF2iX%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h2 data-lake-id=\"rIfN9\" id=\"rIfN9\"><span data-lake-id=\"uabf31d5c\" id=\"uabf31d5c\">浏览器的渲染原理</span></h2><h3 data-lake-id=\"ihQFN\" id=\"ihQFN\"><span data-lake-id=\"ucbc43322\" id=\"ucbc43322\">渲染流水线</span></h3><p data-lake-id=\"u02fadf54\" id=\"u02fadf54\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2023%2Fpng%2F732231%2F1700342640685-6007ba92-0714-49d8-9735-03e806f3041d.png%22%2C%22taskId%22%3A%22uaad5a4f3-fc3b-47d1-986f-3579e5599d2%22%2C%22clientId%22%3A%22ucb9ee095-bbd4-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A1016%2C%22height%22%3A344%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A50925%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A932%2C%22originHeight%22%3A316%2C%22ratio%22%3A2%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97%20%E5%B8%83%E5%B1%80%20%E8%A7%A3%E6%9E%90HTML%20HTML%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E7%BB%98%E5%88%B6%20%E5%88%86%E5%9D%97%20%E5%88%86%E5%B1%82%20%E5%85%89%E6%A0%85%E5%8C%96%20%E7%94%BB%20%E5%83%8F%E7%B4%A0%E4%BF%A1%E6%81%AF%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A473%2C%22y%22%3A76%2C%22width%22%3A70%2C%22height%22%3A20%2C%22text%22%3A%22%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97%22%7D%2C%7B%22x%22%3A759%2C%22y%22%3A77%2C%22width%22%3A34%2C%22height%22%3A18%2C%22text%22%3A%22%E5%B8%83%E5%B1%80%22%7D%2C%7B%22x%22%3A221%2C%22y%22%3A77%2C%22width%22%3A87%2C%22height%22%3A17%2C%22text%22%3A%22%E8%A7%A3%E6%9E%90HTML%22%7D%2C%7B%22x%22%3A41%2C%22y%22%3A78%2C%22width%22%3A102%2C%22height%22%3A18%2C%22text%22%3A%22HTML%E5%AD%97%E7%AC%A6%E4%B8%B2%22%7D%2C%7B%22x%22%3A489%2C%22y%22%3A169%2C%22width%22%3A36%2C%22height%22%3A19%2C%22text%22%3A%22%E7%BB%98%E5%88%B6%22%7D%2C%7B%22x%22%3A248%2C%22y%22%3A169%2C%22width%22%3A34%2C%22height%22%3A18%2C%22text%22%3A%22%E5%88%86%E5%9D%97%22%7D%2C%7B%22x%22%3A760%2C%22y%22%3A170%2C%22width%22%3A34%2C%22height%22%3A18%2C%22text%22%3A%22%E5%88%86%E5%B1%82%22%7D%2C%7B%22x%22%3A237%2C%22y%22%3A261%2C%22width%22%3A53%2C%22height%22%3A19%2C%22text%22%3A%22%E5%85%89%E6%A0%85%E5%8C%96%22%7D%2C%7B%22x%22%3A498%2C%22y%22%3A261%2C%22width%22%3A21%2C%22height%22%3A20%2C%22text%22%3A%22%E7%94%BB%22%7D%2C%7B%22x%22%3A625%2C%22y%22%3A262%2C%22width%22%3A68%2C%22height%22%3A19%2C%22text%22%3A%22%E5%83%8F%E7%B4%A0%E4%BF%A1%E6%81%AF%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23fcfbf9%22%2C%22id%22%3A%22uaec3dc5e%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h3 data-lake-id=\"Y9GAc\" id=\"Y9GAc\"><span data-lake-id=\"u50720442\" id=\"u50720442\">渲染完整过程</span></h3><p data-lake-id=\"ufba9c796\" id=\"ufba9c796\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2023%2Fpng%2F732231%2F1700342664434-b95f893d-5c25-46c6-803a-cf90a77ba8aa.png%22%2C%22taskId%22%3A%22u1e0dcfe8-2e5b-4d0c-90ea-957256b9e39%22%2C%22clientId%22%3A%22ucb9ee095-bbd4-4%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A993.5%2C%22height%22%3A454%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A52277%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A903%2C%22originHeight%22%3A413%2C%22ratio%22%3A2%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%20LAYOUT%20LAYER%20STYLE%20PAINT%20PARSE%20TILING%20%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B%20DRAW%20RASTER%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A34%2C%22y%22%3A64%2C%22width%22%3A87%2C%22height%22%3A17%2C%22text%22%3A%22%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%22%7D%2C%7B%22x%22%3A302%2C%22y%22%3A65%2C%22width%22%3A61%2C%22height%22%3A16%2C%22text%22%3A%22LAYOUT%22%7D%2C%7B%22x%22%3A384%2C%22y%22%3A65%2C%22width%22%3A52%2C%22height%22%3A17%2C%22text%22%3A%22LAYER%22%7D%2C%7B%22x%22%3A232%2C%22y%22%3A66%2C%22width%22%3A51%2C%22height%22%3A16%2C%22text%22%3A%22STYLE%22%7D%2C%7B%22x%22%3A461%2C%22y%22%3A65%2C%22width%22%3A53%2C%22height%22%3A18%2C%22text%22%3A%22PAINT%22%7D%2C%7B%22x%22%3A158%2C%22y%22%3A67%2C%22width%22%3A53%2C%22height%22%3A13%2C%22text%22%3A%22PARSE%22%7D%2C%7B%22x%22%3A538%2C%22y%22%3A168%2C%22width%22%3A61%2C%22height%22%3A19%2C%22text%22%3A%22TILING%22%7D%2C%7B%22x%22%3A43%2C%22y%22%3A168%2C%22width%22%3A69%2C%22height%22%3A18%2C%22text%22%3A%22%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B%22%7D%2C%7B%22x%22%3A718%2C%22y%22%3A171%2C%22width%22%3A41%2C%22height%22%3A14%2C%22text%22%3A%22DRAW%22%7D%2C%7B%22x%22%3A623%2C%22y%22%3A172%2C%22width%22%3A60%2C%22height%22%3A14%2C%22text%22%3A%22RASTER%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f4f4f3%22%2C%22id%22%3A%22u1a49aea3%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h3 data-lake-id=\"SByHk\" id=\"SByHk\"><span data-lake-id=\"u36829ffe\" id=\"u36829ffe\" class=\"lake-fontsize-11\">浏览器如何对页面进行渲染</span></h3><p data-lake-id=\"ueef1381d\" id=\"ueef1381d\"><span data-lake-id=\"u792f43ab\" id=\"u792f43ab\" class=\"lake-fontsize-11\">当浏览器的网络线程收到 html 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程</span></p><p data-lake-id=\"u0a9e329f\" id=\"u0a9e329f\"><span data-lake-id=\"ud0a153ec\" id=\"ud0a153ec\" class=\"lake-fontsize-11\">整个渲染流程分为多个阶段，分别是：</span><strong><span data-lake-id=\"u5e347d99\" id=\"u5e347d99\" class=\"lake-fontsize-11\">「html 解析 parse」</span></strong><span data-lake-id=\"u948e22eb\" id=\"u948e22eb\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"u389b5485\" id=\"u389b5485\" class=\"lake-fontsize-11\">「样式计算 style」</span></strong><span data-lake-id=\"u4caf16ea\" id=\"u4caf16ea\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"u316e3c5b\" id=\"u316e3c5b\" class=\"lake-fontsize-11\">「布局 layout」</span></strong><span data-lake-id=\"u1646af4f\" id=\"u1646af4f\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"u904be539\" id=\"u904be539\" class=\"lake-fontsize-11\">「分层 layer」</span></strong><span data-lake-id=\"uc267984b\" id=\"uc267984b\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"u783bae83\" id=\"u783bae83\" class=\"lake-fontsize-11\">「绘制 paint」</span></strong><span data-lake-id=\"u4798a168\" id=\"u4798a168\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"u0aac8336\" id=\"u0aac8336\" class=\"lake-fontsize-11\">「分块 tiling」</span></strong><span data-lake-id=\"u7bf5016c\" id=\"u7bf5016c\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"u1c511a5a\" id=\"u1c511a5a\" class=\"lake-fontsize-11\">「光栅化 raster」</span></strong><span data-lake-id=\"u5ae123d9\" id=\"u5ae123d9\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"ua7b86dc6\" id=\"ua7b86dc6\" class=\"lake-fontsize-11\">「画 draw」</span></strong><span data-lake-id=\"u41ef6489\" id=\"u41ef6489\" class=\"lake-fontsize-11\">。每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。这样整个渲染流程就形成了一套组织严密的生产流水线</span></p><ul list=\"u8e277575\"><li fid=\"u038a5def\" data-lake-id=\"u10ce90e8\" id=\"u10ce90e8\"><span data-lake-id=\"ub29beebe\" id=\"ub29beebe\" class=\"lake-fontsize-11\">渲染的第一步是解析 html</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"1\"><li fid=\"u038a5def\" data-lake-id=\"u8ea908ab\" id=\"u8ea908ab\"><span data-lake-id=\"u39091048\" id=\"u39091048\" class=\"lake-fontsize-11\">解析过程中遇到 css 解析 css，遇到 js 执行 js。为了提高解析效率，浏览器在开始解析前，会启动一个</span><strong><span data-lake-id=\"u1dda72f0\" id=\"u1dda72f0\" class=\"lake-fontsize-11\">预解析的线程</span></strong><span data-lake-id=\"u8ed4e0c0\" id=\"u8ed4e0c0\" class=\"lake-fontsize-11\">，率先下载 html 中的</span><strong><span data-lake-id=\"u3a3a0737\" id=\"u3a3a0737\" class=\"lake-fontsize-11\">外部 css 文件</span></strong><span data-lake-id=\"u617a744e\" id=\"u617a744e\" class=\"lake-fontsize-11\">和</span><strong><span data-lake-id=\"u28a95f7b\" id=\"u28a95f7b\" class=\"lake-fontsize-11\">外部的 js 文件</span></strong></li><li fid=\"u038a5def\" data-lake-id=\"u882a14ba\" id=\"u882a14ba\"><span data-lake-id=\"u7bfb4453\" id=\"u7bfb4453\" class=\"lake-fontsize-11\">如果主线程解析到 link 位置，此时外部的 css 文件还没有下载解析好，</span><strong><span data-lake-id=\"ueecbf9b1\" id=\"ueecbf9b1\" class=\"lake-fontsize-11\">主线程不会等待</span></strong><span data-lake-id=\"ua831f6fe\" id=\"ua831f6fe\" class=\"lake-fontsize-11\">，继续解析后续的 html。这是因为下载和解析 css 的工作是在</span><strong><span data-lake-id=\"u7181b7f7\" id=\"u7181b7f7\" class=\"lake-fontsize-11\">预解析线程</span></strong><span data-lake-id=\"u84a6625c\" id=\"u84a6625c\" class=\"lake-fontsize-11\">中进行的。</span><strong><span data-lake-id=\"u35905e11\" id=\"u35905e11\" class=\"lake-fontsize-11\">这就是 css 不会阻塞 html 解析的根本原因</span></strong></li><li fid=\"u038a5def\" data-lake-id=\"u27857434\" id=\"u27857434\"><span data-lake-id=\"u1efc180d\" id=\"u1efc180d\" class=\"lake-fontsize-11\">如果主线程解析到 script 位置，会停止解析 html，转而等待 js 文件下载好，并将全局代码解析执行完成后，才能继续解析 html。这是因为 js 代码的执行过程</span><strong><span data-lake-id=\"u6e439dfc\" id=\"u6e439dfc\" class=\"lake-fontsize-11\">可能会修改当前的 dom 树</span></strong><span data-lake-id=\"ub7b4b52d\" id=\"ub7b4b52d\" class=\"lake-fontsize-11\">，所以 dom 树的生成</span><strong><span data-lake-id=\"u3b81eb40\" id=\"u3b81eb40\" class=\"lake-fontsize-11\">必须暂停</span></strong><span data-lake-id=\"udbf8e8f9\" id=\"udbf8e8f9\" class=\"lake-fontsize-11\">。</span><strong><span data-lake-id=\"uf94f8ec2\" id=\"uf94f8ec2\" class=\"lake-fontsize-11\">这就是 js 会阻塞 html 解析的根本原因</span></strong></li><li fid=\"u038a5def\" data-lake-id=\"u29280a92\" id=\"u29280a92\"><span data-lake-id=\"u140e1b92\" id=\"u140e1b92\" class=\"lake-fontsize-11\">第一步完成后，会得到 </span><strong><span data-lake-id=\"uf8dedf36\" id=\"uf8dedf36\" class=\"lake-fontsize-11\">dom 树</span></strong><span data-lake-id=\"u9bf67c0d\" id=\"u9bf67c0d\" class=\"lake-fontsize-11\">和 </span><strong><span data-lake-id=\"u192ad51a\" id=\"u192ad51a\" class=\"lake-fontsize-11\">cssom（css object model）树</span></strong><span data-lake-id=\"u3d73b868\" id=\"u3d73b868\" class=\"lake-fontsize-11\">，浏览器的</span><strong><span data-lake-id=\"u47cc631a\" id=\"u47cc631a\" class=\"lake-fontsize-11\">默认样式</span></strong><span data-lake-id=\"u7816fafb\" id=\"u7816fafb\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"u97fdec28\" id=\"u97fdec28\" class=\"lake-fontsize-11\">内部样式</span></strong><span data-lake-id=\"uf919aa2a\" id=\"uf919aa2a\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"u03ad1916\" id=\"u03ad1916\" class=\"lake-fontsize-11\">外部样式</span></strong><span data-lake-id=\"u51bda044\" id=\"u51bda044\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"u8860360e\" id=\"u8860360e\" class=\"lake-fontsize-11\">行内样式</span></strong><span data-lake-id=\"u12eaa6ad\" id=\"u12eaa6ad\" class=\"lake-fontsize-11\">均会包含在 cssom 树中</span></li></ul><ul list=\"u8e277575\" start=\"2\"><li fid=\"u038a5def\" data-lake-id=\"u66472295\" id=\"u66472295\"><span data-lake-id=\"u532555a9\" id=\"u532555a9\" class=\"lake-fontsize-11\">渲染的下一步是样式计算</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"1\"><li fid=\"u038a5def\" data-lake-id=\"uace2c64f\" id=\"uace2c64f\"><span data-lake-id=\"u82bb3b9c\" id=\"u82bb3b9c\" class=\"lake-fontsize-11\">主线程会遍历得到的 dom 树，依次为树中的每个节点计算出它最终的样式，称之为 </span><code data-lake-id=\"uafaf3ff3\" id=\"uafaf3ff3\"><span data-lake-id=\"u3561c4bc\" id=\"u3561c4bc\" class=\"lake-fontsize-11\">Computed Style</span></code></li><li fid=\"u038a5def\" data-lake-id=\"u0e577988\" id=\"u0e577988\"><span data-lake-id=\"u39b41e74\" id=\"u39b41e74\" class=\"lake-fontsize-11\">在这一过程中，很多预设值会变成绝对值，比如 </span><code data-lake-id=\"u62bde07c\" id=\"u62bde07c\"><span data-lake-id=\"uc781ad61\" id=\"uc781ad61\" class=\"lake-fontsize-11\">red</span></code><span data-lake-id=\"u2266c97b\" id=\"u2266c97b\" class=\"lake-fontsize-11\"> 会变成 </span><code data-lake-id=\"u9783c9f1\" id=\"u9783c9f1\"><span data-lake-id=\"u4fe5e566\" id=\"u4fe5e566\" class=\"lake-fontsize-11\">rgb(255,0,0)</span></code><span data-lake-id=\"ud9f196f3\" id=\"ud9f196f3\" class=\"lake-fontsize-11\">；相对单位会变成绝对单位，比如 </span><code data-lake-id=\"u6b79507e\" id=\"u6b79507e\"><span data-lake-id=\"uecfed8dc\" id=\"uecfed8dc\" class=\"lake-fontsize-11\">em</span></code><span data-lake-id=\"u5e3fd06d\" id=\"u5e3fd06d\" class=\"lake-fontsize-11\"> 会变成 </span><code data-lake-id=\"udddd7ca4\" id=\"udddd7ca4\"><span data-lake-id=\"u0ac83ecb\" id=\"u0ac83ecb\" class=\"lake-fontsize-11\">px</span></code></li><li fid=\"u038a5def\" data-lake-id=\"ub08f1fa0\" id=\"ub08f1fa0\"><span data-lake-id=\"ucc73e9a9\" id=\"ucc73e9a9\" class=\"lake-fontsize-11\">这一步完成后，会</span><strong><span data-lake-id=\"u12c9ba4d\" id=\"u12c9ba4d\" class=\"lake-fontsize-11\">得到一颗带有样式的 dom 树</span></strong></li></ul><ul list=\"u8e277575\" start=\"3\"><li fid=\"u038a5def\" data-lake-id=\"ub660ddfa\" id=\"ub660ddfa\"><span data-lake-id=\"u59c33bfa\" id=\"u59c33bfa\" class=\"lake-fontsize-11\">接下来是布局，布局完成后会得到布局树</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"1\"><li fid=\"u038a5def\" data-lake-id=\"uc4d04074\" id=\"uc4d04074\"><span data-lake-id=\"uae07317f\" id=\"uae07317f\" class=\"lake-fontsize-11\">布局阶段会依遍历 dom 树的每一个节点，</span><strong><span data-lake-id=\"u0a25fd9a\" id=\"u0a25fd9a\" class=\"lake-fontsize-11\">计算每个节点的几何信息</span></strong><span data-lake-id=\"u985dd8a5\" id=\"u985dd8a5\" class=\"lake-fontsize-11\">。</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"2\"><li fid=\"u038a5def\" data-lake-id=\"u9f8df374\" id=\"u9f8df374\"><span data-lake-id=\"ubd3b7f99\" id=\"ubd3b7f99\" class=\"lake-fontsize-11\">例如节点的宽高、相对</span><strong><span data-lake-id=\"u26d3f3ec\" id=\"u26d3f3ec\" class=\"lake-fontsize-11\">包含块</span></strong><span data-lake-id=\"u37bd93d7\" id=\"u37bd93d7\" class=\"lake-fontsize-11\">的位置</span></li></ul><ul list=\"u8e277575\" start=\"2\" data-lake-indent=\"1\"><li fid=\"u038a5def\" data-lake-id=\"u91a3e8d7\" id=\"u91a3e8d7\"><span data-lake-id=\"u310b85c1\" id=\"u310b85c1\" class=\"lake-fontsize-11\">大部分时候，dom 树和布局树并非一一对应。</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"2\"><li fid=\"u038a5def\" data-lake-id=\"u8347daee\" id=\"u8347daee\"><span data-lake-id=\"u9f544a06\" id=\"u9f544a06\" class=\"lake-fontsize-11\">例如 </span><code data-lake-id=\"ucf1d758d\" id=\"ucf1d758d\"><span data-lake-id=\"u93cd2349\" id=\"u93cd2349\" class=\"lake-fontsize-11\">display: none</span></code><span data-lake-id=\"ucabe7a56\" id=\"ucabe7a56\" class=\"lake-fontsize-11\">的节点没有几何信息，因此不会生成到布局树</span></li><li fid=\"u038a5def\" data-lake-id=\"u11ec29a8\" id=\"u11ec29a8\"><span data-lake-id=\"uff00fa66\" id=\"uff00fa66\" class=\"lake-fontsize-11\">又比如使用了伪元素选择器，虽然 dom 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中</span></li><li fid=\"u038a5def\" data-lake-id=\"u211bf85e\" id=\"u211bf85e\"><span data-lake-id=\"ua6cdbbe8\" id=\"ua6cdbbe8\" class=\"lake-fontsize-11\">还有</span><strong><span data-lake-id=\"u57140214\" id=\"u57140214\" class=\"lake-fontsize-11\">匿名行盒</span></strong><span data-lake-id=\"u7d1e045e\" id=\"u7d1e045e\" class=\"lake-fontsize-11\">、</span><strong><span data-lake-id=\"ue81739bf\" id=\"ue81739bf\" class=\"lake-fontsize-11\">匿名块盒</span></strong><span data-lake-id=\"u9124b33d\" id=\"u9124b33d\" class=\"lake-fontsize-11\">等等都会导致 dom 树和布局树无法一一对应</span></li></ul><ul list=\"u8e277575\" start=\"4\"><li fid=\"u038a5def\" data-lake-id=\"u5c0d3d61\" id=\"u5c0d3d61\"><span data-lake-id=\"ud4c246f8\" id=\"ud4c246f8\" class=\"lake-fontsize-11\">下一步是分层</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"1\"><li fid=\"u038a5def\" data-lake-id=\"ua18841b6\" id=\"ua18841b6\"><span data-lake-id=\"u86bbe002\" id=\"u86bbe002\" class=\"lake-fontsize-11\">主线程会使用一套复杂的策略对整个布局树进行分层</span></li><li fid=\"u038a5def\" data-lake-id=\"u1140322f\" id=\"u1140322f\"><strong><span data-lake-id=\"u6bc083e6\" id=\"u6bc083e6\" class=\"lake-fontsize-11\">分层的好处</span></strong><span data-lake-id=\"u901ff0b3\" id=\"u901ff0b3\" class=\"lake-fontsize-11\">：将来某一个层改变后，</span><strong><span data-lake-id=\"uc93046c6\" id=\"uc93046c6\" class=\"lake-fontsize-11\">仅仅只会对该层进行后续处理</span></strong><span data-lake-id=\"u1acf8292\" id=\"u1acf8292\" class=\"lake-fontsize-11\">，从而</span><strong><span data-lake-id=\"u55c3ecd7\" id=\"u55c3ecd7\" class=\"lake-fontsize-11\">提升效率</span></strong></li><li fid=\"u038a5def\" data-lake-id=\"u1dea6151\" id=\"u1dea6151\"><span data-lake-id=\"uafe42b19\" id=\"uafe42b19\" class=\"lake-fontsize-11\">滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过使用 </span><code data-lake-id=\"u6e70359b\" id=\"u6e70359b\"><span data-lake-id=\"u2f707361\" id=\"u2f707361\" class=\"lake-fontsize-11\">will-change</span></code><span data-lake-id=\"u1d871553\" id=\"u1d871553\" class=\"lake-fontsize-11\">属性更大程度的影响分层结果</span></li></ul><ul list=\"u8e277575\" start=\"5\"><li fid=\"u038a5def\" data-lake-id=\"u6c9cb511\" id=\"u6c9cb511\"><span data-lake-id=\"ud674965a\" id=\"ud674965a\" class=\"lake-fontsize-11\">再下一步是绘制</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"1\"><li fid=\"u038a5def\" data-lake-id=\"u6af5f92d\" id=\"u6af5f92d\"><span data-lake-id=\"u2c0244fd\" id=\"u2c0244fd\" class=\"lake-fontsize-11\">主线程会为每个层单独产生</span><strong><span data-lake-id=\"ud583eec2\" id=\"ud583eec2\" class=\"lake-fontsize-11\">绘制指令集</span></strong><span data-lake-id=\"u6ce2d0b8\" id=\"u6ce2d0b8\" class=\"lake-fontsize-11\">，用于描述这一层的内容应该如何画出来</span></li></ul><ul list=\"u8e277575\" start=\"6\"><li fid=\"u038a5def\" data-lake-id=\"u50f21b6f\" id=\"u50f21b6f\"><span data-lake-id=\"u33286579\" id=\"u33286579\" class=\"lake-fontsize-11\">交给</span><strong><span data-lake-id=\"udfca967e\" id=\"udfca967e\" class=\"lake-fontsize-11\">合成线程</span></strong><span data-lake-id=\"u685bb197\" id=\"u685bb197\" class=\"lake-fontsize-11\">分块</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"1\"><li fid=\"u038a5def\" data-lake-id=\"ubb4a6772\" id=\"ubb4a6772\"><span data-lake-id=\"u058f80e4\" id=\"u058f80e4\" class=\"lake-fontsize-11\">完成绘制后，主线程会将每个图层的绘制信息提交给</span><strong><span data-lake-id=\"u76d4f170\" id=\"u76d4f170\" class=\"lake-fontsize-11\">合成线程</span></strong><span data-lake-id=\"u0fd0b4bc\" id=\"u0fd0b4bc\" class=\"lake-fontsize-11\">，剩余工作将会由合成线程来完成</span></li><li fid=\"u038a5def\" data-lake-id=\"u08f3b198\" id=\"u08f3b198\"><span data-lake-id=\"uc185df79\" id=\"uc185df79\" class=\"lake-fontsize-11\">合成线程首先对</span><strong><span data-lake-id=\"u2e81b2d6\" id=\"u2e81b2d6\" class=\"lake-fontsize-11\">每个图层进行分块</span></strong><span data-lake-id=\"uc29f8c2d\" id=\"uc29f8c2d\" class=\"lake-fontsize-11\">，将其划分为更多的小区域</span></li><li fid=\"u038a5def\" data-lake-id=\"uf8b31626\" id=\"uf8b31626\"><span data-lake-id=\"u408f43ad\" id=\"u408f43ad\" class=\"lake-fontsize-11\">它会从</span><strong><span data-lake-id=\"u260f0f7b\" id=\"u260f0f7b\" class=\"lake-fontsize-11\">线程池</span></strong><span data-lake-id=\"u454b34a3\" id=\"u454b34a3\" class=\"lake-fontsize-11\">中拿去多个线程来完成分块工作</span></li></ul><ul list=\"u8e277575\" start=\"7\"><li fid=\"u038a5def\" data-lake-id=\"u5353b8d8\" id=\"u5353b8d8\"><span data-lake-id=\"ud426f8e9\" id=\"ud426f8e9\" class=\"lake-fontsize-11\">分块完成后，进入</span><strong><span data-lake-id=\"uf590b656\" id=\"uf590b656\" class=\"lake-fontsize-11\">光栅化</span></strong><span data-lake-id=\"uf70af17f\" id=\"uf70af17f\" class=\"lake-fontsize-11\">阶段</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"1\"><li fid=\"u038a5def\" data-lake-id=\"u0f4995f4\" id=\"u0f4995f4\"><span data-lake-id=\"u2bd49067\" id=\"u2bd49067\" class=\"lake-fontsize-11\">合成线程会将块信息</span><strong><span data-lake-id=\"udd876bba\" id=\"udd876bba\" class=\"lake-fontsize-11\">交给 gpu 进程</span></strong><span data-lake-id=\"u0e800627\" id=\"u0e800627\" class=\"lake-fontsize-11\">，以极高的速度完成光栅化</span></li><li fid=\"u038a5def\" data-lake-id=\"u0e967914\" id=\"u0e967914\"><span data-lake-id=\"ueca33d65\" id=\"ueca33d65\" class=\"lake-fontsize-11\">gpu 进程会开启多个线程来完成光栅化，并且</span><strong><span data-lake-id=\"ua0a45847\" id=\"ua0a45847\" class=\"lake-fontsize-11\">优先处理靠近视口区域</span></strong><span data-lake-id=\"u99e501da\" id=\"u99e501da\" class=\"lake-fontsize-11\">的块</span></li><li fid=\"u038a5def\" data-lake-id=\"ub33bc434\" id=\"ub33bc434\"><span data-lake-id=\"uf21254c5\" id=\"uf21254c5\" class=\"lake-fontsize-11\">光栅化的结果，就是一块一块的位图</span></li></ul><ul list=\"u8e277575\" start=\"8\"><li fid=\"u038a5def\" data-lake-id=\"ub9bcc39a\" id=\"ub9bcc39a\"><span data-lake-id=\"u9e92b770\" id=\"u9e92b770\" class=\"lake-fontsize-11\">最后一个阶段就是画</span></li></ul><ul list=\"u8e277575\" data-lake-indent=\"1\"><li fid=\"u038a5def\" data-lake-id=\"ued6ef728\" id=\"ued6ef728\"><span data-lake-id=\"u06160ced\" id=\"u06160ced\" class=\"lake-fontsize-11\">合成线程拿到每个层、每个块的位图后，生成一个个</span><strong><span data-lake-id=\"uea638dd1\" id=\"uea638dd1\" class=\"lake-fontsize-11\">「指引 quad」</span></strong><span data-lake-id=\"u988a3e71\" id=\"u988a3e71\" class=\"lake-fontsize-11\">信息</span></li><li fid=\"u038a5def\" data-lake-id=\"u9c394ffe\" id=\"u9c394ffe\"><span data-lake-id=\"uc576e869\" id=\"uc576e869\" class=\"lake-fontsize-11\">指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到</span><strong><span data-lake-id=\"u8c5a4da4\" id=\"u8c5a4da4\" class=\"lake-fontsize-11\">旋转、缩放</span></strong><span data-lake-id=\"u5faa48a0\" id=\"u5faa48a0\" class=\"lake-fontsize-11\">等变形</span></li><li fid=\"u038a5def\" data-lake-id=\"u86b29ca4\" id=\"u86b29ca4\"><strong><span data-lake-id=\"u22afffe2\" id=\"u22afffe2\" class=\"lake-fontsize-11\">变形发生在合成线程</span></strong><span data-lake-id=\"u591996c4\" id=\"u591996c4\" class=\"lake-fontsize-11\">，与</span><strong><span data-lake-id=\"ua43cc3ff\" id=\"ua43cc3ff\" class=\"lake-fontsize-11\">渲染主线程无关</span></strong><span data-lake-id=\"ue33c70b9\" id=\"ue33c70b9\" class=\"lake-fontsize-11\">，</span><strong><span data-lake-id=\"u67fb7b6e\" id=\"u67fb7b6e\" class=\"lake-fontsize-11\">这就是 transform 效率高的本质原因</span></strong></li><li fid=\"u038a5def\" data-lake-id=\"u47c5dbb0\" id=\"u47c5dbb0\"><span data-lake-id=\"ub7e940b3\" id=\"ub7e940b3\" class=\"lake-fontsize-11\">合成线程会把 quad 提交给 gpu 进程，由 gpu 进程产生系统调用，提交给 gpu 硬件，最终完成屏幕成像</span></li></ul><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22FEfyn%22%7D\"></card><p data-lake-id=\"u3ddf85f2\" id=\"u3ddf85f2\"><span data-lake-id=\"u2ad6df0d\" id=\"u2ad6df0d\" class=\"lake-fontsize-11\">包含块</span></p><p data-lake-id=\"u035b9176\" id=\"u035b9176\"><span data-lake-id=\"ude792d11\" id=\"ude792d11\" class=\"lake-fontsize-11\">行盒，块盒 </span></p><p data-lake-id=\"ua70ccb70\" id=\"ua70ccb70\"><span data-lake-id=\"u6e401e30\" id=\"u6e401e30\" class=\"lake-fontsize-11\">内容必须在行盒中</span></p><p data-lake-id=\"u5003c1d2\" id=\"u5003c1d2\"><span data-lake-id=\"u3a79d6aa\" id=\"u3a79d6aa\" class=\"lake-fontsize-11\">行盒和块盒不能相邻 匿名行盒 </span></p><p data-lake-id=\"uf59320cd\" id=\"uf59320cd\"><span data-lake-id=\"u526a28d3\" id=\"u526a28d3\" class=\"lake-fontsize-11\">​</span><br></p><p data-lake-id=\"ua3d7f67b\" id=\"ua3d7f67b\"><span data-lake-id=\"u30747bda\" id=\"u30747bda\" class=\"lake-fontsize-11\">合成线程和渲染主线程在渲染进程里面，是放在沙盒里的，安全</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22s5V3a%22%7D\"></card><h3 data-lake-id=\"WFMRQ\" id=\"WFMRQ\"><span data-lake-id=\"ua1825fb6\" id=\"ua1825fb6\">什么是 reflow - 回流</span></h3><ul list=\"u46a84c37\"><li fid=\"u87a404a4\" data-lake-id=\"uc1a51ffe\" id=\"uc1a51ffe\"><span data-lake-id=\"u8cbfeed1\" id=\"u8cbfeed1\" class=\"lake-fontsize-11\">reflow 的本质就是重新计算</span><strong><span data-lake-id=\"u152e6259\" id=\"u152e6259\" class=\"lake-fontsize-11\">布局（layout）树</span></strong></li><li fid=\"u87a404a4\" data-lake-id=\"u1e00f20f\" id=\"u1e00f20f\"><span data-lake-id=\"u28212ec9\" id=\"u28212ec9\" class=\"lake-fontsize-11\">当进行了会影响</span><strong><span data-lake-id=\"u6b171091\" id=\"u6b171091\" class=\"lake-fontsize-11\">布局（layout）树</span></strong><span data-lake-id=\"u88b35d72\" id=\"u88b35d72\" class=\"lake-fontsize-11\">的操作后，需要重新计算布局树，会引发 layout</span></li><li fid=\"u87a404a4\" data-lake-id=\"u61727091\" id=\"u61727091\"><span data-lake-id=\"u1d0b19c3\" id=\"u1d0b19c3\" class=\"lake-fontsize-11\">为了避免连续的多次操作导致</span><strong><span data-lake-id=\"uf6da088f\" id=\"uf6da088f\" class=\"lake-fontsize-11\">布局（layout）树</span></strong><span data-lake-id=\"u0dc853f0\" id=\"u0dc853f0\" class=\"lake-fontsize-11\">反复计算，浏览器会</span><strong><span data-lake-id=\"u17fc7ddf\" id=\"u17fc7ddf\" class=\"lake-fontsize-11\">合并</span></strong><span data-lake-id=\"u231fc6f9\" id=\"u231fc6f9\" class=\"lake-fontsize-11\">这些操作，当 js 代码</span><strong><span data-lake-id=\"u82089352\" id=\"u82089352\" class=\"lake-fontsize-11\">全部完成</span></strong><span data-lake-id=\"u3d778857\" id=\"u3d778857\" class=\"lake-fontsize-11\">后再</span><strong><span data-lake-id=\"u61ac42aa\" id=\"u61ac42aa\" class=\"lake-fontsize-11\">进行统一计算</span></strong><span data-lake-id=\"uc8d76210\" id=\"uc8d76210\" class=\"lake-fontsize-11\">。所以，</span><strong><span data-lake-id=\"u0b118d86\" id=\"u0b118d86\" class=\"lake-fontsize-11\">改动属性</span></strong><span data-lake-id=\"u6f9ff951\" id=\"u6f9ff951\" class=\"lake-fontsize-11\">造成的 reflow 是</span><strong><span data-lake-id=\"u3297b4bd\" id=\"u3297b4bd\" class=\"lake-fontsize-11\">异步</span></strong><span data-lake-id=\"u068ec748\" id=\"u068ec748\" class=\"lake-fontsize-11\">完成的</span></li><li fid=\"u87a404a4\" data-lake-id=\"u5e674d4f\" id=\"u5e674d4f\"><span data-lake-id=\"uf1827ba9\" id=\"uf1827ba9\" class=\"lake-fontsize-11\">也同样因为如此，当 js 获取布局属性时，就可能造成</span><strong><span data-lake-id=\"u8fc4482c\" id=\"u8fc4482c\" class=\"lake-fontsize-11\">无法获取到最新的</span></strong><span data-lake-id=\"uc39e376e\" id=\"uc39e376e\" class=\"lake-fontsize-11\">布局信息</span></li><li fid=\"u87a404a4\" data-lake-id=\"uf81d091c\" id=\"uf81d091c\"><span data-lake-id=\"uf61b1d3d\" id=\"uf61b1d3d\" class=\"lake-fontsize-11\">浏览器在反复权衡下，最终决定获取属性时立即 reflow</span></li></ul><h3 data-lake-id=\"lT9JU\" id=\"lT9JU\"><span data-lake-id=\"u05f12d7f\" id=\"u05f12d7f\">什么是 repaint - 重绘</span></h3><ul list=\"u93e78d84\"><li fid=\"u762bdd72\" data-lake-id=\"ua27927eb\" id=\"ua27927eb\"><span data-lake-id=\"ubd81e584\" id=\"ubd81e584\" class=\"lake-fontsize-11\">repaint 的本质就是重新根据</span><strong><span data-lake-id=\"u124cadba\" id=\"u124cadba\" class=\"lake-fontsize-11\">分层信息</span></strong><span data-lake-id=\"ud2e5126e\" id=\"ud2e5126e\" class=\"lake-fontsize-11\">计算了</span><strong><span data-lake-id=\"ud6273f4b\" id=\"ud6273f4b\" class=\"lake-fontsize-11\">绘制指令</span></strong></li><li fid=\"u762bdd72\" data-lake-id=\"u7b924f4d\" id=\"u7b924f4d\"><span data-lake-id=\"u9ec02b30\" id=\"u9ec02b30\" class=\"lake-fontsize-11\">当改动了</span><strong><span data-lake-id=\"u3e2b20d7\" id=\"u3e2b20d7\" class=\"lake-fontsize-11\">可见样式</span></strong><span data-lake-id=\"u2d276fdc\" id=\"u2d276fdc\" class=\"lake-fontsize-11\">后，就需要</span><strong><span data-lake-id=\"u295f4cd0\" id=\"u295f4cd0\" class=\"lake-fontsize-11\">重新计算</span></strong><span data-lake-id=\"u22b0552e\" id=\"u22b0552e\" class=\"lake-fontsize-11\">，会引发 repaint</span></li><li fid=\"u762bdd72\" data-lake-id=\"u88ff1c39\" id=\"u88ff1c39\"><span data-lake-id=\"u73a04d45\" id=\"u73a04d45\" class=\"lake-fontsize-11\">由于</span><strong><span data-lake-id=\"uc7526f36\" id=\"uc7526f36\" class=\"lake-fontsize-11\">元素的布局信息</span></strong><span data-lake-id=\"ueca18f35\" id=\"ueca18f35\" class=\"lake-fontsize-11\">也属于</span><strong><span data-lake-id=\"uc590b315\" id=\"uc590b315\" class=\"lake-fontsize-11\">可见样式</span></strong><span data-lake-id=\"ua2c61fb3\" id=\"ua2c61fb3\" class=\"lake-fontsize-11\">，所以 reflow 一定会引起 repaint</span></li></ul><h3 data-lake-id=\"XMc3j\" id=\"XMc3j\"><span data-lake-id=\"ua77d3c13\" id=\"ua77d3c13\">为什么 transform 效率高</span></h3><ul list=\"u254c4684\"><li fid=\"u66d9e056\" data-lake-id=\"uc5a59c9c\" id=\"uc5a59c9c\"><span data-lake-id=\"uf998b26e\" id=\"uf998b26e\" class=\"lake-fontsize-11\">因为 transform 既不会影响</span><strong><span data-lake-id=\"u02dde20a\" id=\"u02dde20a\" class=\"lake-fontsize-11\">布局（layout</span></strong><span data-lake-id=\"u60e1ebab\" id=\"u60e1ebab\" class=\"lake-fontsize-11\">），也不会影响</span><strong><span data-lake-id=\"uc42bf9d4\" id=\"uc42bf9d4\" class=\"lake-fontsize-11\">绘制指令</span></strong><span data-lake-id=\"u79225499\" id=\"u79225499\" class=\"lake-fontsize-11\">，它影响的只是渲染流程的最后一个 - </span><strong><span data-lake-id=\"ud3ce088b\" id=\"ud3ce088b\" class=\"lake-fontsize-11\">draw 阶段</span></strong></li><li fid=\"u66d9e056\" data-lake-id=\"u0d095d00\" id=\"u0d095d00\"><span data-lake-id=\"u7058d76d\" id=\"u7058d76d\" class=\"lake-fontsize-11\">由于 </span><strong><span data-lake-id=\"uf9be2b7f\" id=\"uf9be2b7f\" class=\"lake-fontsize-11\">draw 阶段</span></strong><span data-lake-id=\"u4c003e74\" id=\"u4c003e74\" class=\"lake-fontsize-11\">在</span><strong><span data-lake-id=\"uda57cabd\" id=\"uda57cabd\" class=\"lake-fontsize-11\">合成线程</span></strong><span data-lake-id=\"u7189c157\" id=\"u7189c157\" class=\"lake-fontsize-11\">中，所以 transform 的变化</span><strong><span data-lake-id=\"ufaf39233\" id=\"ufaf39233\" class=\"lake-fontsize-11\">几乎不会影响渲染主线程</span></strong><span data-lake-id=\"u388b97cf\" id=\"u388b97cf\" class=\"lake-fontsize-11\">。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化</span></li></ul><h2 data-lake-id=\"i9uyF\" id=\"i9uyF\"><span data-lake-id=\"u5bb09bf6\" id=\"u5bb09bf6\">位运算</span></h2><h3 data-lake-id=\"l9E0I\" id=\"l9E0I\"><span data-lake-id=\"u65db399c\" id=\"u65db399c\">位运算符</span></h3><ul list=\"uf06e2ad4\"><li fid=\"u78ee43fc\" data-lake-id=\"ue8107695\" id=\"ue8107695\"><span data-lake-id=\"u62eb5904\" id=\"u62eb5904\">按位与 </span><strong><span data-lake-id=\"ucb5bb9c6\" id=\"ucb5bb9c6\">&amp;</span></strong><span data-lake-id=\"u89a94233\" id=\"u89a94233\">​</span></li></ul><ul list=\"uf06e2ad4\" data-lake-indent=\"1\"><li fid=\"u78ee43fc\" data-lake-id=\"u5d3019df\" id=\"u5d3019df\"><span data-lake-id=\"u0974ea3b\" id=\"u0974ea3b\">a &amp; b：只有当 a 和 b 中对应的位都是 1 时，结果位才是 1</span></li><li fid=\"u78ee43fc\" data-lake-id=\"ud787f28a\" id=\"ud787f28a\"><span data-lake-id=\"u9c5f6aaa\" id=\"u9c5f6aaa\">用途：常用于位掩码</span></li></ul><ul list=\"uf06e2ad4\" start=\"2\"><li fid=\"u78ee43fc\" data-lake-id=\"u1c3ef920\" id=\"u1c3ef920\"><span data-lake-id=\"u3dff6986\" id=\"u3dff6986\">按位或 </span><strong><span data-lake-id=\"ue91b0ea9\" id=\"ue91b0ea9\">|</span></strong></li></ul><ul list=\"uf06e2ad4\" data-lake-indent=\"1\"><li fid=\"u78ee43fc\" data-lake-id=\"ub0a7f439\" id=\"ub0a7f439\"><span data-lake-id=\"u97fc5147\" id=\"u97fc5147\">a | b：如果 a 和 b 中至少有一个对应位是 1，则结果位是 1</span></li><li fid=\"u78ee43fc\" data-lake-id=\"u340deae5\" id=\"u340deae5\"><span data-lake-id=\"u79c7ea71\" id=\"u79c7ea71\">用途：设置位掩码</span></li></ul><ul list=\"uf06e2ad4\" start=\"3\"><li fid=\"u78ee43fc\" data-lake-id=\"u4277b90b\" id=\"u4277b90b\"><span data-lake-id=\"uf75adece\" id=\"uf75adece\">按位异或 </span><strong><span data-lake-id=\"u476ffeed\" id=\"u476ffeed\">^</span></strong></li></ul><ul list=\"uf06e2ad4\" data-lake-indent=\"1\"><li fid=\"u78ee43fc\" data-lake-id=\"u3a88eedc\" id=\"u3a88eedc\"><span data-lake-id=\"uf015cacb\" id=\"uf015cacb\">a ^ b：当 a 和 b 中对应位不相同时，结果位是 1</span></li><li fid=\"u78ee43fc\" data-lake-id=\"u356c9bca\" id=\"u356c9bca\"><span data-lake-id=\"u66e6e481\" id=\"u66e6e481\">用途：切换位掩码</span></li></ul><ul list=\"uf06e2ad4\" start=\"4\"><li fid=\"u78ee43fc\" data-lake-id=\"u2aecbbfd\" id=\"u2aecbbfd\"><span data-lake-id=\"ud72cb232\" id=\"ud72cb232\">按位非 </span><strong><span data-lake-id=\"u407b0657\" id=\"u407b0657\">~</span></strong></li></ul><ul list=\"uf06e2ad4\" data-lake-indent=\"1\"><li fid=\"u78ee43fc\" data-lake-id=\"u850e3894\" id=\"u850e3894\"><span data-lake-id=\"u1f0180c6\" id=\"u1f0180c6\">~a：反转 a 的所有位（1 变 0，0 变 1）</span></li><li fid=\"u78ee43fc\" data-lake-id=\"u1c4741ed\" id=\"u1c4741ed\"><span data-lake-id=\"uc05289de\" id=\"uc05289de\">用途：常用于位掩码的反转</span></li></ul><ul list=\"uf06e2ad4\" start=\"5\"><li fid=\"u78ee43fc\" data-lake-id=\"u675a8365\" id=\"u675a8365\"><span data-lake-id=\"ufea5ed4d\" id=\"ufea5ed4d\">左移 </span><strong><span data-lake-id=\"u9f7ee544\" id=\"u9f7ee544\">&lt;&lt;</span></strong></li></ul><ul list=\"uf06e2ad4\" data-lake-indent=\"1\"><li fid=\"u78ee43fc\" data-lake-id=\"u5f5046cb\" id=\"u5f5046cb\"><span data-lake-id=\"ucba64e80\" id=\"ucba64e80\">a &lt;&lt; b：将 a 的二进制表示向左移动 b 位（从右侧补 0）</span></li><li fid=\"u78ee43fc\" data-lake-id=\"ueab672f2\" id=\"ueab672f2\"><span data-lake-id=\"uf0e86cb7\" id=\"uf0e86cb7\">用途：相当于乘以 2 的 b 次幂</span></li></ul><ul list=\"uf06e2ad4\" start=\"6\"><li fid=\"u78ee43fc\" data-lake-id=\"ub2b78ac1\" id=\"ub2b78ac1\"><span data-lake-id=\"u03a90ea3\" id=\"u03a90ea3\">有符号右移 </span><strong><span data-lake-id=\"uf20b5b4d\" id=\"uf20b5b4d\">&gt;&gt;</span></strong></li></ul><ul list=\"uf06e2ad4\" data-lake-indent=\"1\"><li fid=\"u78ee43fc\" data-lake-id=\"uce3f6def\" id=\"uce3f6def\"><span data-lake-id=\"u64825a9c\" id=\"u64825a9c\">a &gt;&gt; b：将 a 的二进制表示向右移动 b 位，保留符号位（正数前面补 0，负数前面补-）</span></li><li fid=\"u78ee43fc\" data-lake-id=\"ufcb6e0f5\" id=\"ufcb6e0f5\"><span data-lake-id=\"ua0d2706a\" id=\"ua0d2706a\">用途：相当于除以 2 的 b 次幂，保持符号</span></li></ul><ul list=\"uf06e2ad4\" start=\"7\"><li fid=\"u78ee43fc\" data-lake-id=\"uc2f024ef\" id=\"uc2f024ef\"><span data-lake-id=\"u57cbf492\" id=\"u57cbf492\">无符号右移 </span><strong><span data-lake-id=\"u3e18bd54\" id=\"u3e18bd54\">&gt;&gt;&gt;</span></strong></li></ul><ul list=\"uf06e2ad4\" data-lake-indent=\"1\"><li fid=\"u78ee43fc\" data-lake-id=\"u81ecdf48\" id=\"u81ecdf48\"><span data-lake-id=\"u13f2be10\" id=\"u13f2be10\">a &gt;&gt;&gt; b：将 a 的二进制表示向右移动 b 位，不保留符号位（前面补 0）</span></li><li fid=\"u78ee43fc\" data-lake-id=\"udaedf8cf\" id=\"udaedf8cf\"><span data-lake-id=\"u1bee943c\" id=\"u1bee943c\">用途：对于正数和负数的右移操作，结果总是正数</span></li></ul><h3 data-lake-id=\"X9BfX\" id=\"X9BfX\"><span data-lake-id=\"ud2cbdf47\" id=\"ud2cbdf47\">使用场景</span></h3><ol list=\"u07246918\"><li fid=\"u6b5453c1\" data-lake-id=\"u7a68ee33\" id=\"u7a68ee33\"><strong><span data-lake-id=\"u183cd12d\" id=\"u183cd12d\">设置和清除特定位</span></strong><span data-lake-id=\"u6ebb9952\" id=\"u6ebb9952\">：使用 &amp;、| 和 ~ 来设置、清除或切换特定位。这在处理位掩码或状态标志时非常有用</span></li></ol><ul list=\"ued7eddb6\" data-lake-indent=\"1\"><li fid=\"u02a1fffa\" data-lake-id=\"uab6b884c\" id=\"uab6b884c\"><span data-lake-id=\"u9d5a7839\" id=\"u9d5a7839\">设置第 i 位：</span><code data-lake-id=\"u343f4d96\" id=\"u343f4d96\"><span data-lake-id=\"udff828e1\" id=\"udff828e1\">num |= (1 &lt;&lt; i)</span></code></li><li fid=\"u02a1fffa\" data-lake-id=\"u5398f91d\" id=\"u5398f91d\"><span data-lake-id=\"u5ceec408\" id=\"u5ceec408\">清除第 i 位：</span><code data-lake-id=\"u613e76ee\" id=\"u613e76ee\"><span data-lake-id=\"uf5b90115\" id=\"uf5b90115\">num &amp;= ~(1 &lt;&lt; i)</span></code></li><li fid=\"u02a1fffa\" data-lake-id=\"u2fe5883a\" id=\"u2fe5883a\"><span data-lake-id=\"ub2c329d2\" id=\"ub2c329d2\">切换第 i 位：</span><code data-lake-id=\"u7aafb464\" id=\"u7aafb464\"><span data-lake-id=\"ueb756472\" id=\"ueb756472\">num ^= (1 &lt;&lt; i)</span></code></li><li fid=\"u02a1fffa\" data-lake-id=\"u3733a173\" id=\"u3733a173\"><span data-lake-id=\"u28fdd5fe\" id=\"u28fdd5fe\">检查第 i 位是否设置：</span><code data-lake-id=\"u3f77da10\" id=\"u3f77da10\"><span data-lake-id=\"ueeba164e\" id=\"ueeba164e\">(num &amp; (1 &lt;&lt; i)) != 0</span></code></li></ul><ol list=\"u07246918\" start=\"2\"><li fid=\"u6b5453c1\" data-lake-id=\"u9d15a845\" id=\"u9d15a845\"><strong><span data-lake-id=\"uab68fe28\" id=\"uab68fe28\">权限控制</span></strong><span data-lake-id=\"u1a89b4d5\" id=\"u1a89b4d5\">：位运算常用于实现权限控制系统，其中每个位代表一种权限，通过位运算来添加、移除和检查权限</span></li></ol><ul list=\"ucce76923\" data-lake-indent=\"1\"><li fid=\"uab699aea\" data-lake-id=\"u083b3dc0\" id=\"u083b3dc0\"><span data-lake-id=\"u0857e6bb\" id=\"u0857e6bb\">假设每个位代表一个权限，可以用位运算符来控制权限的开启和关闭</span></li><li fid=\"uab699aea\" data-lake-id=\"ubf921bb5\" id=\"ubf921bb5\"><code data-lake-id=\"u47324338\" id=\"u47324338\"><span data-lake-id=\"ufac9a796\" id=\"ufac9a796\">permissions |= (1 &lt;&lt; READ)</span></code><span data-lake-id=\"ucabf91a1\" id=\"ucabf91a1\"> 可以开启读权限</span></li></ul><ol list=\"u07246918\" start=\"3\"><li fid=\"u6b5453c1\" data-lake-id=\"u2efb5358\" id=\"u2efb5358\"><strong><span data-lake-id=\"u3650b68e\" id=\"u3650b68e\">两数交换不用额外变量</span></strong><span data-lake-id=\"u146c5c5b\" id=\"u146c5c5b\">：使用 ^ 可以在不使用临时变量的情况下交换两个数</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20a%20%3D%205%2C%20b%20%3D%209%5Cna%20%5E%3D%20b%20%2F%2F%20output%3A%2012%EF%BC%8Ca%20%3D%2012%EF%BC%8Cb%20%3D%209%5Cnb%20%5E%3D%20a%20%2F%2F%20output%3A%205%EF%BC%8Cb%20%3D%205%EF%BC%8Ca%20%3D%2012%5Cna%20%5E%3D%20b%20%2F%2F%20output%3A%209%EF%BC%8Ca%20%3D%209%EF%BC%8Cb%20%3D%205%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22__widthMode%22%3A%22normal%22%2C%22id%22%3A%22gqKRM%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22widthMode%22%3A%22normal%22%7D\" hindent=\"2em\"></card><ol list=\"u07246918\" start=\"4\"><li fid=\"u6b5453c1\" data-lake-id=\"u4e5ac8f8\" id=\"u4e5ac8f8\"><strong><span data-lake-id=\"ua71383ef\" id=\"ua71383ef\">计算两数的和</span></strong><span data-lake-id=\"u0ab610bf\" id=\"u0ab610bf\">：通过 ^ 和 &amp; 操作，可以实现两个数的加法而不使用加号或减号</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22while%20(b%20!%3D%200)%20%7B%5Cn%20%20%20%20let%20carry%20%3D%20a%20%26%20b%3B%5Cn%20%20%20%20a%20%3D%20a%20%5E%20b%3B%5Cn%20%20%20%20b%20%3D%20carry%20%3C%3C%201%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22__widthMode%22%3A%22normal%22%2C%22id%22%3A%22mQe04%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22widthMode%22%3A%22normal%22%7D\" hindent=\"2em\"></card><ol list=\"u07246918\" start=\"5\"><li fid=\"u6b5453c1\" data-lake-id=\"u75c8a793\" id=\"u75c8a793\"><strong><span data-lake-id=\"ua204b95a\" id=\"ua204b95a\">求绝对值</span></strong><span data-lake-id=\"udaa0ef0a\" id=\"udaa0ef0a\">：利用 &gt;&gt; 和 ^ 操作可以计算一个数的绝对值</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22int%20abs(int%20x)%20%7B%5Cn%20%20%20%20int%20mask%20%3D%20x%20%3E%3E%2031%3B%5Cn%20%20%20%20return%20(x%20%5E%20mask)%20-%20mask%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22__widthMode%22%3A%22normal%22%2C%22id%22%3A%22wQ8Oe%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22widthMode%22%3A%22normal%22%7D\" hindent=\"2em\"></card><ol list=\"u07246918\" start=\"6\"><li fid=\"u6b5453c1\" data-lake-id=\"ue5395103\" id=\"ue5395103\"><strong><span data-lake-id=\"ud639e328\" id=\"ud639e328\">判断奇偶性</span></strong><span data-lake-id=\"u5beee1aa\" id=\"u5beee1aa\">：使用 &amp; 检查一个数的最低位，可以快速判断一个数是奇数还是偶数</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%88%A9%E7%94%A8%E6%9C%80%E4%BD%8E%E4%BD%8D%E5%88%A4%E6%96%AD%E6%95%B0%E5%AD%97%E5%A5%87%E5%81%B6%E6%80%A7%5Cnif%20(num%20%26%201)%20%7B%5Cn%20%20%2F%2F%20%E5%A5%87%E6%95%B0%5Cn%7D%20else%20%7B%5Cn%2F%2F%20%E5%81%B6%E6%95%B0%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22__widthMode%22%3A%22normal%22%2C%22id%22%3A%22n8lHZ%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22widthMode%22%3A%22normal%22%7D\" hindent=\"2em\"></card><ol list=\"u07246918\" start=\"7\"><li fid=\"u6b5453c1\" data-lake-id=\"ub44f12e0\" id=\"ub44f12e0\"><strong><span data-lake-id=\"u0eb058b3\" id=\"u0eb058b3\">乘除以 2 的幂</span></strong><span data-lake-id=\"u7450b3ea\" id=\"u7450b3ea\">：使用 &lt;&lt; 和 &gt;&gt; 操作可以实现乘除以 2 的幂</span></li><li fid=\"u6b5453c1\" data-lake-id=\"ud569ea7b\" id=\"ud569ea7b\"><strong><span data-lake-id=\"ub44f07ae\" id=\"ub44f07ae\">快速访问数组元素</span></strong><span data-lake-id=\"u8f62d4e6\" id=\"u8f62d4e6\">：在处理像图像处理这样的大型数组时，位运算可以用于快速计算索引，提高效率</span></li></ol><ul list=\"u70fd5671\" data-lake-indent=\"1\"><li fid=\"u34f0e26a\" data-lake-id=\"ua31a2372\" id=\"ua31a2372\"><span data-lake-id=\"u0d523b87\" id=\"u0d523b87\">在图像处理中，可以用位运算来计算像素的位置：</span><code data-lake-id=\"u6f0c8946\" id=\"u6f0c8946\"><span data-lake-id=\"u1997690d\" id=\"u1997690d\">let index = (row &lt;&lt; shift) + column</span></code></li><li fid=\"u34f0e26a\" data-lake-id=\"udde1ca0f\" id=\"udde1ca0f\"><span data-lake-id=\"u763c5a5f\" id=\"u763c5a5f\">这里假设每行有 2 的幂个像素</span></li></ul><ol list=\"u07246918\" start=\"9\"><li fid=\"u6b5453c1\" data-lake-id=\"uc245873a\" id=\"uc245873a\"><strong><span data-lake-id=\"ub77fa427\" id=\"ub77fa427\">单一位的状态切换</span></strong><span data-lake-id=\"u6593e239\" id=\"u6593e239\">：使用 ^ 可以快速切换一个位的状态</span></li></ol><ul list=\"udf348518\" data-lake-indent=\"1\"><li fid=\"u9b4a8a81\" data-lake-id=\"u0e54a91b\" id=\"u0e54a91b\"><code data-lake-id=\"ue6fbeb28\" id=\"ue6fbeb28\"><span data-lake-id=\"u9e22ee0d\" id=\"u9e22ee0d\">flag ^= (1 &lt;&lt; i)</span></code></li><li fid=\"u9b4a8a81\" data-lake-id=\"u0ab8bc65\" id=\"u0ab8bc65\"><span data-lake-id=\"u3a8f0850\" id=\"u3a8f0850\">这可以快速切换第 i 位的状态</span></li></ul><ol list=\"u07246918\" start=\"10\"><li fid=\"u6b5453c1\" data-lake-id=\"u227e51a4\" id=\"u227e51a4\"><strong><span data-lake-id=\"u7048ea79\" id=\"u7048ea79\">二进制反转或位反转</span></strong><span data-lake-id=\"ud1250b60\" id=\"ud1250b60\">：对整数进行位反转，这在某些特定的数学运算和算法问题中非常有用</span></li></ol><ul list=\"u7cf91c4c\" data-lake-indent=\"1\"><li fid=\"u46430e71\" data-lake-id=\"u8577dbaa\" id=\"u8577dbaa\"><span data-lake-id=\"u25f0a3e0\" id=\"u25f0a3e0\">将一个数的二进制表示反转：例如，将 0b1101 变为 0b1011</span></li></ul><ol list=\"u07246918\" start=\"11\"><li fid=\"u6b5453c1\" data-lake-id=\"ua13881ab\" id=\"ua13881ab\"><strong><span data-lake-id=\"u307bb469\" id=\"u307bb469\">求两数的最大公约数</span></strong><span data-lake-id=\"ueb7d97bb\" id=\"ueb7d97bb\">：使用位运算结合递归或迭代方法可以高效求解最大公约数</span></li><li fid=\"u6b5453c1\" data-lake-id=\"u06c7645f\" id=\"u06c7645f\"><strong><span data-lake-id=\"u20c782c9\" id=\"u20c782c9\">求解子集问题</span></strong><span data-lake-id=\"u1e8c0804\" id=\"u1e8c0804\">：在处理组合问题时，位运算可以用来枚举集合的所有子集</span></li></ol><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22for%20(let%20subset%20%3D%200%3B%20subset%20%3C%20(1%20%3C%3C%20n)%3B%20%2B%2Bsubset)%20%7B%5Cn%20%20%2F%2F%20%E5%A4%84%E7%90%86%E5%AD%90%E9%9B%86%EF%BC%8Cn%20%E6%98%AF%E9%9B%86%E5%90%88%E4%B8%AD%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22l76jf%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\" hindent=\"2em\"></card>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 7135,
  "created_at": "2023-11-15T13:45:35.000Z",
  "updated_at": "2023-11-19T14:24:41.000Z",
  "content_updated_at": "2023-11-19T14:24:40.000Z",
  "published_at": "2023-11-19T14:24:40.000Z",
  "first_published_at": "2023-11-15T13:45:56.574Z",
  "book": {
    "id": 44240028,
    "type": "Book",
    "slug": "mgn4ot",
    "name": "八股文 new",
    "user_id": 732231,
    "description": null,
    "toc_yml": "- type: META\n  count: 8\n  display_level: 1\n  tail_type: UPDATED_AT\n  base_version_id: 374208521\n  published: true\n  max_level: 0\n  last_updated_at: 2023-11-23T18:48:48.915Z\n  version_id: 374208543\n- type: DOC\n  title: javascript\n  uuid: sleELbMYL4LTKL4R\n  url: gzo4vg97gz8ff9ot\n  prev_uuid: ''\n  sibling_uuid: 6a5B8crWkAOej4tV\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147068436\n  level: 0\n  id: 147068436\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: css3\n  uuid: 6a5B8crWkAOej4tV\n  url: wp44gz2g4tg4sk9g\n  prev_uuid: sleELbMYL4LTKL4R\n  sibling_uuid: FCVDShhUlU_WqK1H\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147175066\n  level: 0\n  id: 147175066\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: html5\n  uuid: FCVDShhUlU_WqK1H\n  url: yz1azuhe9ix48gwg\n  prev_uuid: 6a5B8crWkAOej4tV\n  sibling_uuid: Tb6IbVp21drHFTAj\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147175048\n  level: 0\n  id: 147175048\n  open_window: 1\n  visible: 0\n- type: DOC\n  title: 计算机网络\n  uuid: Tb6IbVp21drHFTAj\n  url: lwd683w54d01mim4\n  prev_uuid: FCVDShhUlU_WqK1H\n  sibling_uuid: r18kP_ktN9mrOLct\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147174671\n  level: 0\n  id: 147174671\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 框架\n  uuid: r18kP_ktN9mrOLct\n  url: yc22k58ygncdgg57\n  prev_uuid: Tb6IbVp21drHFTAj\n  sibling_uuid: WavF2oVmJr8aZldK\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147174982\n  level: 0\n  id: 147174982\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 构建工具\n  uuid: WavF2oVmJr8aZldK\n  url: cowx8k8iee1d5qbi\n  prev_uuid: r18kP_ktN9mrOLct\n  sibling_uuid: vYGSh-0Zc4YY2hxY\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147174940\n  level: 0\n  id: 147174940\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 小程序\n  uuid: vYGSh-0Zc4YY2hxY\n  url: wrg4cl7gm7oe6kt4\n  prev_uuid: WavF2oVmJr8aZldK\n  sibling_uuid: 0Kr44lJnepSt160L\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147175096\n  level: 0\n  id: 147175096\n  open_window: 1\n  visible: 0\n- type: DOC\n  title: node.js\n  uuid: 0Kr44lJnepSt160L\n  url: vbtgnccfrn23ecl6\n  prev_uuid: vYGSh-0Zc4YY2hxY\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147175110\n  level: 0\n  id: 147175110\n  open_window: 1\n  visible: 1\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 8,
    "likes_count": 0,
    "watches_count": 0,
    "content_updated_at": "2023-11-23T18:48:48.941Z",
    "created_at": "2023-11-15T10:47:20.000Z",
    "updated_at": "2023-11-23T18:48:49.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-22T20:13:30.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/mgn4ot",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 2126313424,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}