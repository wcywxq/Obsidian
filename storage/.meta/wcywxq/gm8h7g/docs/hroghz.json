{
  "id": 11435969,
  "slug": "hroghz",
  "title": "队列 queue",
  "description": "链接队列与栈不同，它遵从先进先出（FIFO——First In First Out）原则，新添加的元素排在队列的尾部，元素只能从队列头部移除。我们在前一篇文章中描述了如何用 JavaScript 来实现栈这种数据结构，这里我们对应地来实现队列。function Queue() {     le...",
  "cover": "",
  "user_id": 732231,
  "book_id": 24854102,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><p id=\"ud86b4603\" class=\"ne-p\"><a href=\"https://www.cnblogs.com/jaxu/p/11268862.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11268862.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">链接</span></a></p><p id=\"uc22df259\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u3a286c75\" class=\"ne-p\"><span class=\"ne-text\">队列与栈不同，它遵从先进先出（FIFO——First In First Out）原则，新添加的元素排在队列的尾部，元素只能从队列头部移除。<br />我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">前一篇文章</span></a><span class=\"ne-text\">中描述了如何用 JavaScript 来实现栈这种数据结构，这里我们对应地来实现队列。</span></p><p id=\"u90fd6c7c\" class=\"ne-p\"><span class=\"ne-text\"></span></p><pre data-language=\"javascript\" id=\"c01b2b7e\" class=\"ne-codeblock language-javascript\">function Queue() {\n    let items = []\n\n    // 向队列添加元素（一个或多个）\n    this.enqueue = function (element) {\n        if (element instanceof Array) items = items.concat(element)\n        else items.push(element)\n    }\n\n    // 从队列移除元素\n    this.dequeue = function () {\n        return items.shift()\n    }\n\n    // 返回队列中的第一个元素\n    this.front = function () {\n        return items[0]\n    }\n\n    // 判断队列是否为空\n    this.isEmpty = function () {\n        return items.length === 0\n    }\n\n    // 返回队列的长度\n    this.size = function () {\n        return items.length\n    }\n\n    // 清空队列\n    this.clear = function () {\n        items = []\n    }\n\n    // 打印队列内的所有元素\n    this.print = function () {\n        console.log(items.toString())\n    }\n}</pre><p id=\"u0fc3aa4e\" class=\"ne-p\"><br></p><p id=\"u09c338f2\" class=\"ne-p\"><span class=\"ne-text\">与栈的实现方式类似，唯一不同的是从队列移除元素时取的是队列头部的元素（最先添加的），而栈则是取的顶部元素（最后添加的）。下面是一些测试用例及返回结果：</span></p><p id=\"u1aeb6d71\" class=\"ne-p\"><span class=\"ne-text\"></span></p><pre data-language=\"javascript\" id=\"dc9c198c\" class=\"ne-codeblock language-javascript\">let queue = new Queue()\nconsole.log(queue.isEmpty()) // true\n\nqueue.enqueue(&quot;John&quot;)\nqueue.enqueue([&quot;Jack&quot;, &quot;Camila&quot;])\nqueue.print() // John,Jack,Camila\nconsole.log(queue.size()) // 3\nconsole.log(queue.isEmpty()) // false\nconsole.log(queue.front()) // John\n\nconsole.log(queue.dequeue()) // John\nqueue.print() // Jack,Camila\n\nqueue.clear()\nqueue.print() //</pre><p id=\"u65f5dd92\" class=\"ne-p\"><br></p><p id=\"ua03a4426\" class=\"ne-p\"><span class=\"ne-text\">注意，我们允许批量向队列中添加元素，为此我们需要判断 enqueue 方法的参数类型，如果参数是数组，则用 concat()函数连接两个数组，如果参数不是数组，则直接用 push()函数将元素添加到队列中。<br />与栈的实现方式一样，这里我们也同样给出用 ES6 的 WeakMap 类来实现的队列版本。</span></p><p id=\"u4b16d777\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"cd33377b\" class=\"ne-codeblock language-javascript\">let Queue = (function () {\n    const items = new WeakMap()\n\n    class Queue {\n        constructor() {\n            items.set(this, [])\n        }\n\n        enqueue(element) {\n            let q = items.get(this)\n            if (element instanceof Array) items.set(this, q.concat(element))\n            else q.push(element)\n        }\n\n        dequeue() {\n            let q = items.get(this)\n            return q.shift()\n        }\n\n        front() {\n            return items.get(this)[0]\n        }\n\n        isEmpty() {\n            return items.get(this).length === 0\n        }\n\n        size() {\n            return items.get(this).length\n        }\n\n        clear() {\n            items.set(this, [])\n        }\n\n        print() {\n            console.log(items.get(this).toString())\n        }\n    }\n\n    return Queue\n})()</pre><p id=\"uaf80eac8\" class=\"ne-p\"><br></p><p id=\"ub73f7cdc\" class=\"ne-p\"><span class=\"ne-text\">这两个版本的执行结果是一样的，它们的区别我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">前一篇文章</span></a><span class=\"ne-text\">中已经提及过了，这里不再赘述。</span></p><p id=\"u124a3d4d\" class=\"ne-p\"><span class=\"ne-text\"></span></p><h3 id=\"0ca1785b\"><span class=\"ne-text\">优先队列</span></h3><p id=\"u0c340174\" class=\"ne-p\"><br></p><p id=\"ufa7635a2\" class=\"ne-p\"><span class=\"ne-text\">所谓优先队列，顾名思义，就是说插入到队列中的元素可以根据优先级设置先后顺序。优先级越高位置越靠前，优先级越低位置越靠后。假设优先级用数字来表示，如果数字越小表示的优先级越高，形成的队列就称之为最小优先队列，反之则称之为最大优先队列。下面是实现的代码：</span></p><p id=\"uae616ef3\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"481071f9\" class=\"ne-codeblock language-javascript\">function PriorityQueue() {\n    let items = []\n\n    // 向队列添加元素（一个或多个）\n    // 参数obj的数据格式：{element, priority}\n    this.enqueue = function (obj) {\n        if (obj instanceof Array) {\n            for (let i = 0, ci; (ci = obj[i]); i++) {\n                this.enqueue(ci)\n            }\n        } else {\n            let added = false\n            for (let i = 0, ci; (ci = items[i]); i++) {\n                // 最小优先级，即将priority值小的元素插入到队列的前面\n                if (obj.priority &lt; ci.priority) {\n                    items.splice(i, 0, obj)\n                    added = true\n                    break\n                }\n            }\n\n            // 如果元素没有插入到队列中，则默认加到队列的尾部\n            if (!added) items.push(obj)\n        }\n    }\n\n    // 从队列移除元素\n    this.dequeue = function () {\n        return items.shift()\n    }\n\n    // 返回队列中的第一个元素\n    this.front = function () {\n        return items[0]\n    }\n\n    // 判断队列是否为空\n    this.isEmpty = function () {\n        return items.length === 0\n    }\n\n    // 返回队列的长度\n    this.size = function () {\n        return items.length\n    }\n\n    // 清空队列\n    this.clear = function () {\n        items = []\n    }\n\n    // 打印队列内的所有元素\n    this.print = function () {\n        items.forEach(function (item) {\n            console.log(`${item.element} - ${item.priority}`)\n        })\n    }\n}</pre><p id=\"u9f741f26\" class=\"ne-p\"><br></p><p id=\"u4138cd75\" class=\"ne-p\"><span class=\"ne-text\">可以看到，唯一有区别的只有 enqueue 方法。我们规定所有添加到优先队列的元素都必须满足{element, priority}这种 JSON 格式，以保证队列中的每一个元素都有一个 priority 属性来表示优先级。如果要添加的元素的优先级和队列中已有元素的优先级相同，仍然遵循队列的先进先出原则。如果队列中所有元素的优先级比要添加的元素的优先级都高，则将元素添加到队列的末尾。我们将 print()方法也做了一些调整，以方便查看输出结果。</span></p><p id=\"u2cbdfd2c\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3cb9e8f1\" class=\"ne-codeblock language-javascript\">let queue = new PriorityQueue()\nconsole.log(queue.isEmpty()) // true\n\nqueue.enqueue({ element: &quot;John&quot;, priority: 2 })\nqueue.enqueue([\n    { element: &quot;Jack&quot;, priority: 1 },\n    { element: &quot;Camila&quot;, priority: 1 }\n])\nqueue.print() // Jack,Camila,John</pre><p id=\"ua63c6f03\" class=\"ne-p\"><br></p><p id=\"u97d9df77\" class=\"ne-p\"><span class=\"ne-text\">由于 John 的优先级比其它两个低，所以它被排在了最后面。虽然 Jack 和 Camila 的优先级相同，但是 Jack 是在 Camila 之前先插入到队列中的，所以 Jack 排在了 Camila 之前，这也符合了我们的预期。</span></p><p id=\"u8b28332c\" class=\"ne-p\"><br></p><h3 id=\"9032418d\"><span class=\"ne-text\">循环队列</span></h3><p id=\"uee48ad15\" class=\"ne-p\"><br></p><p id=\"u51b48524\" class=\"ne-p\"><span class=\"ne-text\">我们用一个小游戏“击鼓传花”来说明循环队列在实际中的应用。</span></p><p id=\"u7f0c0eab\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0e361af1\" class=\"ne-codeblock language-javascript\">function hotPotato(nameList, num) {\n    let queue = new Queue()\n\n    for (let i = 0, ci; (ci = nameList[i]); i++) {\n        queue.enqueue(ci)\n    }\n\n    let eliminated = &quot;&quot;\n    while (queue.size() &gt; 1) {\n        for (let i = 0; i &lt; num; i++) {\n            queue.enqueue(queue.dequeue())\n        }\n        eliminated = queue.dequeue()\n        console.log(`${eliminated} has been eliminated.`)\n    }\n\n    return queue.dequeue()\n}\n\nlet names = [&quot;John&quot;, &quot;Jack&quot;, &quot;Camila&quot;, &quot;Ingrid&quot;, &quot;Carl&quot;]\nlet winner = hotPotato(names, 7)\nconsole.log(`The winner is: ${winner}`)</pre><p id=\"u7c263c89\" class=\"ne-p\"><br></p><p id=\"uafde652f\" class=\"ne-p\"><span class=\"ne-text\">在这个游戏中，我们传入由五个名字组成的数组，用来表示参加游戏的五个人，数字 7 表示每一轮要传递的次数。在每一个过程中，我们从队列头部取出一个元素加到队列的尾部，当次数用完的时候，将队列头部的元素取出来，作为这一轮中被淘汰的人。让我们来看一下具体的执行过程，一开始队列中的顺序是 John, Jack, Camila, Ingrid, Carl，然后传递 7 次：<br /><br />1. Jack, Camila, Ingrid, Carl, John<br />2. Camila, Ingrid, Carl, John, Jack<br />3. Ingrid, Carl, John, Jack, Camila<br />4. Carl, John, Jack, Camila, Ingrid<br />5. John, Jack, Camila, Ingrid, Carl<br />6. Jack, Camila, Ingrid, Carl, John<br />7. Camila, Ingrid, Carl, John, Jack</span></p><p id=\"u16265625\" class=\"ne-p\"><span class=\"ne-text\"><br />之后从队列中取出的是 Camila。反复执行上述过程，直到队列中的元素只剩一个，这个就是最后的赢家！<br /><br />下面是完整的执行结果：</span></p><p id=\"ufb1c5601\" class=\"ne-p\"><br></p><pre data-language=\"shell\" id=\"e2e74b06\" class=\"ne-codeblock language-shell\">Camila has been eliminated.\nJack has been eliminated.\nCarl has been eliminated.\nIngrid has been eliminated.\nThe winner is: John</pre></div>",
  "body": "[链接](https://www.cnblogs.com/jaxu/p/11268862.html)\n\n队列与栈不同，它遵从先进先出（FIFO——First In First Out）原则，新添加的元素排在队列的尾部，元素只能从队列头部移除。<br />我们在[前一篇文章](https://www.cnblogs.com/jaxu/p/11264017.html)中描述了如何用 JavaScript 来实现栈这种数据结构，这里我们对应地来实现队列。\n\n```javascript\nfunction Queue() {\n    let items = []\n\n    // 向队列添加元素（一个或多个）\n    this.enqueue = function (element) {\n        if (element instanceof Array) items = items.concat(element)\n        else items.push(element)\n    }\n\n    // 从队列移除元素\n    this.dequeue = function () {\n        return items.shift()\n    }\n\n    // 返回队列中的第一个元素\n    this.front = function () {\n        return items[0]\n    }\n\n    // 判断队列是否为空\n    this.isEmpty = function () {\n        return items.length === 0\n    }\n\n    // 返回队列的长度\n    this.size = function () {\n        return items.length\n    }\n\n    // 清空队列\n    this.clear = function () {\n        items = []\n    }\n\n    // 打印队列内的所有元素\n    this.print = function () {\n        console.log(items.toString())\n    }\n}\n```\n\n与栈的实现方式类似，唯一不同的是从队列移除元素时取的是队列头部的元素（最先添加的），而栈则是取的顶部元素（最后添加的）。下面是一些测试用例及返回结果：\n\n```javascript\nlet queue = new Queue()\nconsole.log(queue.isEmpty()) // true\n\nqueue.enqueue(\"John\")\nqueue.enqueue([\"Jack\", \"Camila\"])\nqueue.print() // John,Jack,Camila\nconsole.log(queue.size()) // 3\nconsole.log(queue.isEmpty()) // false\nconsole.log(queue.front()) // John\n\nconsole.log(queue.dequeue()) // John\nqueue.print() // Jack,Camila\n\nqueue.clear()\nqueue.print() //\n```\n\n注意，我们允许批量向队列中添加元素，为此我们需要判断 enqueue 方法的参数类型，如果参数是数组，则用 concat()函数连接两个数组，如果参数不是数组，则直接用 push()函数将元素添加到队列中。<br />与栈的实现方式一样，这里我们也同样给出用 ES6 的 WeakMap 类来实现的队列版本。\n\n```javascript\nlet Queue = (function () {\n    const items = new WeakMap()\n\n    class Queue {\n        constructor() {\n            items.set(this, [])\n        }\n\n        enqueue(element) {\n            let q = items.get(this)\n            if (element instanceof Array) items.set(this, q.concat(element))\n            else q.push(element)\n        }\n\n        dequeue() {\n            let q = items.get(this)\n            return q.shift()\n        }\n\n        front() {\n            return items.get(this)[0]\n        }\n\n        isEmpty() {\n            return items.get(this).length === 0\n        }\n\n        size() {\n            return items.get(this).length\n        }\n\n        clear() {\n            items.set(this, [])\n        }\n\n        print() {\n            console.log(items.get(this).toString())\n        }\n    }\n\n    return Queue\n})()\n```\n\n这两个版本的执行结果是一样的，它们的区别我们在[前一篇文章](https://www.cnblogs.com/jaxu/p/11264017.html)中已经提及过了，这里不再赘述。\n\n<a name=\"0ca1785b\"></a>\n### 优先队列\n\n所谓优先队列，顾名思义，就是说插入到队列中的元素可以根据优先级设置先后顺序。优先级越高位置越靠前，优先级越低位置越靠后。假设优先级用数字来表示，如果数字越小表示的优先级越高，形成的队列就称之为最小优先队列，反之则称之为最大优先队列。下面是实现的代码：\n\n```javascript\nfunction PriorityQueue() {\n    let items = []\n\n    // 向队列添加元素（一个或多个）\n    // 参数obj的数据格式：{element, priority}\n    this.enqueue = function (obj) {\n        if (obj instanceof Array) {\n            for (let i = 0, ci; (ci = obj[i]); i++) {\n                this.enqueue(ci)\n            }\n        } else {\n            let added = false\n            for (let i = 0, ci; (ci = items[i]); i++) {\n                // 最小优先级，即将priority值小的元素插入到队列的前面\n                if (obj.priority < ci.priority) {\n                    items.splice(i, 0, obj)\n                    added = true\n                    break\n                }\n            }\n\n            // 如果元素没有插入到队列中，则默认加到队列的尾部\n            if (!added) items.push(obj)\n        }\n    }\n\n    // 从队列移除元素\n    this.dequeue = function () {\n        return items.shift()\n    }\n\n    // 返回队列中的第一个元素\n    this.front = function () {\n        return items[0]\n    }\n\n    // 判断队列是否为空\n    this.isEmpty = function () {\n        return items.length === 0\n    }\n\n    // 返回队列的长度\n    this.size = function () {\n        return items.length\n    }\n\n    // 清空队列\n    this.clear = function () {\n        items = []\n    }\n\n    // 打印队列内的所有元素\n    this.print = function () {\n        items.forEach(function (item) {\n            console.log(`${item.element} - ${item.priority}`)\n        })\n    }\n}\n```\n\n可以看到，唯一有区别的只有 enqueue 方法。我们规定所有添加到优先队列的元素都必须满足{element, priority}这种 JSON 格式，以保证队列中的每一个元素都有一个 priority 属性来表示优先级。如果要添加的元素的优先级和队列中已有元素的优先级相同，仍然遵循队列的先进先出原则。如果队列中所有元素的优先级比要添加的元素的优先级都高，则将元素添加到队列的末尾。我们将 print()方法也做了一些调整，以方便查看输出结果。\n\n```javascript\nlet queue = new PriorityQueue()\nconsole.log(queue.isEmpty()) // true\n\nqueue.enqueue({ element: \"John\", priority: 2 })\nqueue.enqueue([\n    { element: \"Jack\", priority: 1 },\n    { element: \"Camila\", priority: 1 }\n])\nqueue.print() // Jack,Camila,John\n```\n\n由于 John 的优先级比其它两个低，所以它被排在了最后面。虽然 Jack 和 Camila 的优先级相同，但是 Jack 是在 Camila 之前先插入到队列中的，所以 Jack 排在了 Camila 之前，这也符合了我们的预期。\n\n<a name=\"9032418d\"></a>\n### 循环队列\n\n我们用一个小游戏“击鼓传花”来说明循环队列在实际中的应用。\n\n```javascript\nfunction hotPotato(nameList, num) {\n    let queue = new Queue()\n\n    for (let i = 0, ci; (ci = nameList[i]); i++) {\n        queue.enqueue(ci)\n    }\n\n    let eliminated = \"\"\n    while (queue.size() > 1) {\n        for (let i = 0; i < num; i++) {\n            queue.enqueue(queue.dequeue())\n        }\n        eliminated = queue.dequeue()\n        console.log(`${eliminated} has been eliminated.`)\n    }\n\n    return queue.dequeue()\n}\n\nlet names = [\"John\", \"Jack\", \"Camila\", \"Ingrid\", \"Carl\"]\nlet winner = hotPotato(names, 7)\nconsole.log(`The winner is: ${winner}`)\n```\n\n在这个游戏中，我们传入由五个名字组成的数组，用来表示参加游戏的五个人，数字 7 表示每一轮要传递的次数。在每一个过程中，我们从队列头部取出一个元素加到队列的尾部，当次数用完的时候，将队列头部的元素取出来，作为这一轮中被淘汰的人。让我们来看一下具体的执行过程，一开始队列中的顺序是 John, Jack, Camila, Ingrid, Carl，然后传递 7 次：\n\n1. Jack, Camila, Ingrid, Carl, John<br />2. Camila, Ingrid, Carl, John, Jack<br />3. Ingrid, Carl, John, Jack, Camila<br />4. Carl, John, Jack, Camila, Ingrid<br />5. John, Jack, Camila, Ingrid, Carl<br />6. Jack, Camila, Ingrid, Carl, John<br />7. Camila, Ingrid, Carl, John, Jack\n\n之后从队列中取出的是 Camila。反复执行上述过程，直到队列中的元素只剩一个，这个就是最后的赢家！\n\n下面是完整的执行结果：\n\n```shell\nCamila has been eliminated.\nJack has been eliminated.\nCarl has been eliminated.\nIngrid has been eliminated.\nThe winner is: John\n```\n",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><p id=\"ud86b4603\" class=\"ne-p\"><a href=\"https://www.cnblogs.com/jaxu/p/11268862.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11268862.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">链接</span></a></p><p id=\"uc22df259\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u3a286c75\" class=\"ne-p\"><span class=\"ne-text\">队列与栈不同，它遵从先进先出（FIFO——First In First Out）原则，新添加的元素排在队列的尾部，元素只能从队列头部移除。<br />我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">前一篇文章</span></a><span class=\"ne-text\">中描述了如何用 JavaScript 来实现栈这种数据结构，这里我们对应地来实现队列。</span></p><p id=\"u90fd6c7c\" class=\"ne-p\"><span class=\"ne-text\"></span></p><pre data-language=\"javascript\" id=\"c01b2b7e\" class=\"ne-codeblock language-javascript\">function Queue() {\n    let items = []\n\n    // 向队列添加元素（一个或多个）\n    this.enqueue = function (element) {\n        if (element instanceof Array) items = items.concat(element)\n        else items.push(element)\n    }\n\n    // 从队列移除元素\n    this.dequeue = function () {\n        return items.shift()\n    }\n\n    // 返回队列中的第一个元素\n    this.front = function () {\n        return items[0]\n    }\n\n    // 判断队列是否为空\n    this.isEmpty = function () {\n        return items.length === 0\n    }\n\n    // 返回队列的长度\n    this.size = function () {\n        return items.length\n    }\n\n    // 清空队列\n    this.clear = function () {\n        items = []\n    }\n\n    // 打印队列内的所有元素\n    this.print = function () {\n        console.log(items.toString())\n    }\n}</pre><p id=\"u0fc3aa4e\" class=\"ne-p\"><br></p><p id=\"u09c338f2\" class=\"ne-p\"><span class=\"ne-text\">与栈的实现方式类似，唯一不同的是从队列移除元素时取的是队列头部的元素（最先添加的），而栈则是取的顶部元素（最后添加的）。下面是一些测试用例及返回结果：</span></p><p id=\"u1aeb6d71\" class=\"ne-p\"><span class=\"ne-text\"></span></p><pre data-language=\"javascript\" id=\"dc9c198c\" class=\"ne-codeblock language-javascript\">let queue = new Queue()\nconsole.log(queue.isEmpty()) // true\n\nqueue.enqueue(&quot;John&quot;)\nqueue.enqueue([&quot;Jack&quot;, &quot;Camila&quot;])\nqueue.print() // John,Jack,Camila\nconsole.log(queue.size()) // 3\nconsole.log(queue.isEmpty()) // false\nconsole.log(queue.front()) // John\n\nconsole.log(queue.dequeue()) // John\nqueue.print() // Jack,Camila\n\nqueue.clear()\nqueue.print() //</pre><p id=\"u65f5dd92\" class=\"ne-p\"><br></p><p id=\"ua03a4426\" class=\"ne-p\"><span class=\"ne-text\">注意，我们允许批量向队列中添加元素，为此我们需要判断 enqueue 方法的参数类型，如果参数是数组，则用 concat()函数连接两个数组，如果参数不是数组，则直接用 push()函数将元素添加到队列中。<br />与栈的实现方式一样，这里我们也同样给出用 ES6 的 WeakMap 类来实现的队列版本。</span></p><p id=\"u4b16d777\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"cd33377b\" class=\"ne-codeblock language-javascript\">let Queue = (function () {\n    const items = new WeakMap()\n\n    class Queue {\n        constructor() {\n            items.set(this, [])\n        }\n\n        enqueue(element) {\n            let q = items.get(this)\n            if (element instanceof Array) items.set(this, q.concat(element))\n            else q.push(element)\n        }\n\n        dequeue() {\n            let q = items.get(this)\n            return q.shift()\n        }\n\n        front() {\n            return items.get(this)[0]\n        }\n\n        isEmpty() {\n            return items.get(this).length === 0\n        }\n\n        size() {\n            return items.get(this).length\n        }\n\n        clear() {\n            items.set(this, [])\n        }\n\n        print() {\n            console.log(items.get(this).toString())\n        }\n    }\n\n    return Queue\n})()</pre><p id=\"uaf80eac8\" class=\"ne-p\"><br></p><p id=\"ub73f7cdc\" class=\"ne-p\"><span class=\"ne-text\">这两个版本的执行结果是一样的，它们的区别我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">前一篇文章</span></a><span class=\"ne-text\">中已经提及过了，这里不再赘述。</span></p><p id=\"u124a3d4d\" class=\"ne-p\"><span class=\"ne-text\"></span></p><h3 id=\"0ca1785b\"><span class=\"ne-text\">优先队列</span></h3><p id=\"u0c340174\" class=\"ne-p\"><br></p><p id=\"ufa7635a2\" class=\"ne-p\"><span class=\"ne-text\">所谓优先队列，顾名思义，就是说插入到队列中的元素可以根据优先级设置先后顺序。优先级越高位置越靠前，优先级越低位置越靠后。假设优先级用数字来表示，如果数字越小表示的优先级越高，形成的队列就称之为最小优先队列，反之则称之为最大优先队列。下面是实现的代码：</span></p><p id=\"uae616ef3\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"481071f9\" class=\"ne-codeblock language-javascript\">function PriorityQueue() {\n    let items = []\n\n    // 向队列添加元素（一个或多个）\n    // 参数obj的数据格式：{element, priority}\n    this.enqueue = function (obj) {\n        if (obj instanceof Array) {\n            for (let i = 0, ci; (ci = obj[i]); i++) {\n                this.enqueue(ci)\n            }\n        } else {\n            let added = false\n            for (let i = 0, ci; (ci = items[i]); i++) {\n                // 最小优先级，即将priority值小的元素插入到队列的前面\n                if (obj.priority &lt; ci.priority) {\n                    items.splice(i, 0, obj)\n                    added = true\n                    break\n                }\n            }\n\n            // 如果元素没有插入到队列中，则默认加到队列的尾部\n            if (!added) items.push(obj)\n        }\n    }\n\n    // 从队列移除元素\n    this.dequeue = function () {\n        return items.shift()\n    }\n\n    // 返回队列中的第一个元素\n    this.front = function () {\n        return items[0]\n    }\n\n    // 判断队列是否为空\n    this.isEmpty = function () {\n        return items.length === 0\n    }\n\n    // 返回队列的长度\n    this.size = function () {\n        return items.length\n    }\n\n    // 清空队列\n    this.clear = function () {\n        items = []\n    }\n\n    // 打印队列内的所有元素\n    this.print = function () {\n        items.forEach(function (item) {\n            console.log(`${item.element} - ${item.priority}`)\n        })\n    }\n}</pre><p id=\"u9f741f26\" class=\"ne-p\"><br></p><p id=\"u4138cd75\" class=\"ne-p\"><span class=\"ne-text\">可以看到，唯一有区别的只有 enqueue 方法。我们规定所有添加到优先队列的元素都必须满足{element, priority}这种 JSON 格式，以保证队列中的每一个元素都有一个 priority 属性来表示优先级。如果要添加的元素的优先级和队列中已有元素的优先级相同，仍然遵循队列的先进先出原则。如果队列中所有元素的优先级比要添加的元素的优先级都高，则将元素添加到队列的末尾。我们将 print()方法也做了一些调整，以方便查看输出结果。</span></p><p id=\"u2cbdfd2c\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3cb9e8f1\" class=\"ne-codeblock language-javascript\">let queue = new PriorityQueue()\nconsole.log(queue.isEmpty()) // true\n\nqueue.enqueue({ element: &quot;John&quot;, priority: 2 })\nqueue.enqueue([\n    { element: &quot;Jack&quot;, priority: 1 },\n    { element: &quot;Camila&quot;, priority: 1 }\n])\nqueue.print() // Jack,Camila,John</pre><p id=\"ua63c6f03\" class=\"ne-p\"><br></p><p id=\"u97d9df77\" class=\"ne-p\"><span class=\"ne-text\">由于 John 的优先级比其它两个低，所以它被排在了最后面。虽然 Jack 和 Camila 的优先级相同，但是 Jack 是在 Camila 之前先插入到队列中的，所以 Jack 排在了 Camila 之前，这也符合了我们的预期。</span></p><p id=\"u8b28332c\" class=\"ne-p\"><br></p><h3 id=\"9032418d\"><span class=\"ne-text\">循环队列</span></h3><p id=\"uee48ad15\" class=\"ne-p\"><br></p><p id=\"u51b48524\" class=\"ne-p\"><span class=\"ne-text\">我们用一个小游戏“击鼓传花”来说明循环队列在实际中的应用。</span></p><p id=\"u7f0c0eab\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0e361af1\" class=\"ne-codeblock language-javascript\">function hotPotato(nameList, num) {\n    let queue = new Queue()\n\n    for (let i = 0, ci; (ci = nameList[i]); i++) {\n        queue.enqueue(ci)\n    }\n\n    let eliminated = &quot;&quot;\n    while (queue.size() &gt; 1) {\n        for (let i = 0; i &lt; num; i++) {\n            queue.enqueue(queue.dequeue())\n        }\n        eliminated = queue.dequeue()\n        console.log(`${eliminated} has been eliminated.`)\n    }\n\n    return queue.dequeue()\n}\n\nlet names = [&quot;John&quot;, &quot;Jack&quot;, &quot;Camila&quot;, &quot;Ingrid&quot;, &quot;Carl&quot;]\nlet winner = hotPotato(names, 7)\nconsole.log(`The winner is: ${winner}`)</pre><p id=\"u7c263c89\" class=\"ne-p\"><br></p><p id=\"uafde652f\" class=\"ne-p\"><span class=\"ne-text\">在这个游戏中，我们传入由五个名字组成的数组，用来表示参加游戏的五个人，数字 7 表示每一轮要传递的次数。在每一个过程中，我们从队列头部取出一个元素加到队列的尾部，当次数用完的时候，将队列头部的元素取出来，作为这一轮中被淘汰的人。让我们来看一下具体的执行过程，一开始队列中的顺序是 John, Jack, Camila, Ingrid, Carl，然后传递 7 次：<br /><br />1. Jack, Camila, Ingrid, Carl, John<br />2. Camila, Ingrid, Carl, John, Jack<br />3. Ingrid, Carl, John, Jack, Camila<br />4. Carl, John, Jack, Camila, Ingrid<br />5. John, Jack, Camila, Ingrid, Carl<br />6. Jack, Camila, Ingrid, Carl, John<br />7. Camila, Ingrid, Carl, John, Jack</span></p><p id=\"u16265625\" class=\"ne-p\"><span class=\"ne-text\"><br />之后从队列中取出的是 Camila。反复执行上述过程，直到队列中的元素只剩一个，这个就是最后的赢家！<br /><br />下面是完整的执行结果：</span></p><p id=\"ufb1c5601\" class=\"ne-p\"><br></p><pre data-language=\"shell\" id=\"e2e74b06\" class=\"ne-codeblock language-shell\">Camila has been eliminated.\nJack has been eliminated.\nCarl has been eliminated.\nIngrid has been eliminated.\nThe winner is: John</pre></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"traditional\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"ud86b4603\" id=\"ud86b4603\"><a href=\"https://www.cnblogs.com/jaxu/p/11268862.html\" target=\"_blank\" data-lake-id=\"ucfe25774\" id=\"ucfe25774\"><span data-lake-id=\"uc6b3b258\" id=\"uc6b3b258\">链接</span></a></p><p data-lake-id=\"uc22df259\" id=\"uc22df259\"><span data-lake-id=\"u439e8563\" id=\"u439e8563\">​</span><br></p><p data-lake-id=\"u3a286c75\" id=\"u3a286c75\"><span data-lake-id=\"u666e42f2\" id=\"u666e42f2\">队列与栈不同，它遵从先进先出（FIFO——First In First Out）原则，新添加的元素排在队列的尾部，元素只能从队列头部移除。<br />我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" data-lake-id=\"u190ea75e\" id=\"u190ea75e\"><span data-lake-id=\"u71c19464\" id=\"u71c19464\">前一篇文章</span></a><span data-lake-id=\"u9613fa4d\" id=\"u9613fa4d\">中描述了如何用 JavaScript 来实现栈这种数据结构，这里我们对应地来实现队列。</span></p><p data-lake-id=\"u90fd6c7c\" id=\"u90fd6c7c\"><span data-lake-id=\"u2c491b23\" id=\"u2c491b23\">​</span><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20Queue()%20%7B%5Cn%20%20%20%20let%20items%20%3D%20%5B%5D%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%90%91%E9%98%9F%E5%88%97%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%EF%BC%89%5Cn%20%20%20%20this.enqueue%20%3D%20function%20(element)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(element%20instanceof%20Array)%20items%20%3D%20items.concat(element)%5Cn%20%20%20%20%20%20%20%20else%20items.push(element)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E4%BB%8E%E9%98%9F%E5%88%97%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%5Cn%20%20%20%20this.dequeue%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20items.shift()%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%5Cn%20%20%20%20this.front%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20items%5B0%5D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%5Cn%20%20%20%20this.isEmpty%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20items.length%20%3D%3D%3D%200%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%5Cn%20%20%20%20this.size%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20items.length%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E6%B8%85%E7%A9%BA%E9%98%9F%E5%88%97%5Cn%20%20%20%20this.clear%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20items%20%3D%20%5B%5D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%5Cn%20%20%20%20this.print%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20console.log(items.toString())%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22c01b2b7e%22%7D\"></card><p data-lake-id=\"u0fc3aa4e\" id=\"u0fc3aa4e\"><br></p><p data-lake-id=\"u09c338f2\" id=\"u09c338f2\"><span data-lake-id=\"u05287f40\" id=\"u05287f40\">与栈的实现方式类似，唯一不同的是从队列移除元素时取的是队列头部的元素（最先添加的），而栈则是取的顶部元素（最后添加的）。下面是一些测试用例及返回结果：</span></p><p data-lake-id=\"u1aeb6d71\" id=\"u1aeb6d71\"><span data-lake-id=\"uca68d187\" id=\"uca68d187\">​</span><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20queue%20%3D%20new%20Queue()%5Cnconsole.log(queue.isEmpty())%20%2F%2F%20true%5Cn%5Cnqueue.enqueue(%5C%22John%5C%22)%5Cnqueue.enqueue(%5B%5C%22Jack%5C%22%2C%20%5C%22Camila%5C%22%5D)%5Cnqueue.print()%20%2F%2F%20John%2CJack%2CCamila%5Cnconsole.log(queue.size())%20%2F%2F%203%5Cnconsole.log(queue.isEmpty())%20%2F%2F%20false%5Cnconsole.log(queue.front())%20%2F%2F%20John%5Cn%5Cnconsole.log(queue.dequeue())%20%2F%2F%20John%5Cnqueue.print()%20%2F%2F%20Jack%2CCamila%5Cn%5Cnqueue.clear()%5Cnqueue.print()%20%2F%2F%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22dc9c198c%22%7D\"></card><p data-lake-id=\"u65f5dd92\" id=\"u65f5dd92\"><br></p><p data-lake-id=\"ua03a4426\" id=\"ua03a4426\"><span data-lake-id=\"ud015e3a1\" id=\"ud015e3a1\">注意，我们允许批量向队列中添加元素，为此我们需要判断 enqueue 方法的参数类型，如果参数是数组，则用 concat()函数连接两个数组，如果参数不是数组，则直接用 push()函数将元素添加到队列中。<br />与栈的实现方式一样，这里我们也同样给出用 ES6 的 WeakMap 类来实现的队列版本。</span></p><p data-lake-id=\"u4b16d777\" id=\"u4b16d777\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20Queue%20%3D%20(function%20()%20%7B%5Cn%20%20%20%20const%20items%20%3D%20new%20WeakMap()%5Cn%5Cn%20%20%20%20class%20Queue%20%7B%5Cn%20%20%20%20%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20items.set(this%2C%20%5B%5D)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20enqueue(element)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20q%20%3D%20items.get(this)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(element%20instanceof%20Array)%20items.set(this%2C%20q.concat(element))%5Cn%20%20%20%20%20%20%20%20%20%20%20%20else%20q.push(element)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20dequeue()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20q%20%3D%20items.get(this)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20q.shift()%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20front()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20items.get(this)%5B0%5D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20isEmpty()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20items.get(this).length%20%3D%3D%3D%200%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20size()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20items.get(this).length%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20clear()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20items.set(this%2C%20%5B%5D)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20print()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20console.log(items.get(this).toString())%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20return%20Queue%5Cn%7D)()%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22cd33377b%22%7D\"></card><p data-lake-id=\"uaf80eac8\" id=\"uaf80eac8\"><br></p><p data-lake-id=\"ub73f7cdc\" id=\"ub73f7cdc\"><span data-lake-id=\"u7102e050\" id=\"u7102e050\">这两个版本的执行结果是一样的，它们的区别我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" data-lake-id=\"ue6b7757a\" id=\"ue6b7757a\"><span data-lake-id=\"u5af253b5\" id=\"u5af253b5\">前一篇文章</span></a><span data-lake-id=\"ua85280ad\" id=\"ua85280ad\">中已经提及过了，这里不再赘述。</span></p><p data-lake-id=\"u124a3d4d\" id=\"u124a3d4d\"><span data-lake-id=\"u5b5bc5f5\" id=\"u5b5bc5f5\">​</span><br></p><h3 data-lake-id=\"0ca1785b\" id=\"0ca1785b\"><span data-lake-id=\"u7c8be820\" id=\"u7c8be820\">优先队列</span></h3><p data-lake-id=\"u0c340174\" id=\"u0c340174\"><br></p><p data-lake-id=\"ufa7635a2\" id=\"ufa7635a2\"><span data-lake-id=\"uf0001b83\" id=\"uf0001b83\">所谓优先队列，顾名思义，就是说插入到队列中的元素可以根据优先级设置先后顺序。优先级越高位置越靠前，优先级越低位置越靠后。假设优先级用数字来表示，如果数字越小表示的优先级越高，形成的队列就称之为最小优先队列，反之则称之为最大优先队列。下面是实现的代码：</span></p><p data-lake-id=\"uae616ef3\" id=\"uae616ef3\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20PriorityQueue()%20%7B%5Cn%20%20%20%20let%20items%20%3D%20%5B%5D%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%90%91%E9%98%9F%E5%88%97%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%EF%BC%89%5Cn%20%20%20%20%2F%2F%20%E5%8F%82%E6%95%B0obj%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%9A%7Belement%2C%20priority%7D%5Cn%20%20%20%20this.enqueue%20%3D%20function%20(obj)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(obj%20instanceof%20Array)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20for%20(let%20i%20%3D%200%2C%20ci%3B%20(ci%20%3D%20obj%5Bi%5D)%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.enqueue(ci)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20added%20%3D%20false%5Cn%20%20%20%20%20%20%20%20%20%20%20%20for%20(let%20i%20%3D%200%2C%20ci%3B%20(ci%20%3D%20items%5Bi%5D)%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E6%9C%80%E5%B0%8F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%8C%E5%8D%B3%E5%B0%86priority%E5%80%BC%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E5%88%B0%E9%98%9F%E5%88%97%E7%9A%84%E5%89%8D%E9%9D%A2%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(obj.priority%20%3C%20ci.priority)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20items.splice(i%2C%200%2C%20obj)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20added%20%3D%20true%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20break%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E6%B2%A1%E6%9C%89%E6%8F%92%E5%85%A5%E5%88%B0%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%88%99%E9%BB%98%E8%AE%A4%E5%8A%A0%E5%88%B0%E9%98%9F%E5%88%97%E7%9A%84%E5%B0%BE%E9%83%A8%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(!added)%20items.push(obj)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E4%BB%8E%E9%98%9F%E5%88%97%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%5Cn%20%20%20%20this.dequeue%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20items.shift()%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%5Cn%20%20%20%20this.front%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20items%5B0%5D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%5Cn%20%20%20%20this.isEmpty%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20items.length%20%3D%3D%3D%200%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%5Cn%20%20%20%20this.size%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20items.length%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E6%B8%85%E7%A9%BA%E9%98%9F%E5%88%97%5Cn%20%20%20%20this.clear%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20items%20%3D%20%5B%5D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%5Cn%20%20%20%20this.print%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20items.forEach(function%20(item)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20console.log(%60%24%7Bitem.element%7D%20-%20%24%7Bitem.priority%7D%60)%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22481071f9%22%7D\"></card><p data-lake-id=\"u9f741f26\" id=\"u9f741f26\"><br></p><p data-lake-id=\"u4138cd75\" id=\"u4138cd75\"><span data-lake-id=\"u16a61ebe\" id=\"u16a61ebe\">可以看到，唯一有区别的只有 enqueue 方法。我们规定所有添加到优先队列的元素都必须满足{element, priority}这种 JSON 格式，以保证队列中的每一个元素都有一个 priority 属性来表示优先级。如果要添加的元素的优先级和队列中已有元素的优先级相同，仍然遵循队列的先进先出原则。如果队列中所有元素的优先级比要添加的元素的优先级都高，则将元素添加到队列的末尾。我们将 print()方法也做了一些调整，以方便查看输出结果。</span></p><p data-lake-id=\"u2cbdfd2c\" id=\"u2cbdfd2c\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20queue%20%3D%20new%20PriorityQueue()%5Cnconsole.log(queue.isEmpty())%20%2F%2F%20true%5Cn%5Cnqueue.enqueue(%7B%20element%3A%20%5C%22John%5C%22%2C%20priority%3A%202%20%7D)%5Cnqueue.enqueue(%5B%5Cn%20%20%20%20%7B%20element%3A%20%5C%22Jack%5C%22%2C%20priority%3A%201%20%7D%2C%5Cn%20%20%20%20%7B%20element%3A%20%5C%22Camila%5C%22%2C%20priority%3A%201%20%7D%5Cn%5D)%5Cnqueue.print()%20%2F%2F%20Jack%2CCamila%2CJohn%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%223cb9e8f1%22%7D\"></card><p data-lake-id=\"ua63c6f03\" id=\"ua63c6f03\"><br></p><p data-lake-id=\"u97d9df77\" id=\"u97d9df77\"><span data-lake-id=\"u0f9c238b\" id=\"u0f9c238b\">由于 John 的优先级比其它两个低，所以它被排在了最后面。虽然 Jack 和 Camila 的优先级相同，但是 Jack 是在 Camila 之前先插入到队列中的，所以 Jack 排在了 Camila 之前，这也符合了我们的预期。</span></p><p data-lake-id=\"u8b28332c\" id=\"u8b28332c\"><br></p><h3 data-lake-id=\"9032418d\" id=\"9032418d\"><span data-lake-id=\"u73d8e39a\" id=\"u73d8e39a\">循环队列</span></h3><p data-lake-id=\"uee48ad15\" id=\"uee48ad15\"><br></p><p data-lake-id=\"u51b48524\" id=\"u51b48524\"><span data-lake-id=\"u8275553f\" id=\"u8275553f\">我们用一个小游戏“击鼓传花”来说明循环队列在实际中的应用。</span></p><p data-lake-id=\"u7f0c0eab\" id=\"u7f0c0eab\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20hotPotato(nameList%2C%20num)%20%7B%5Cn%20%20%20%20let%20queue%20%3D%20new%20Queue()%5Cn%5Cn%20%20%20%20for%20(let%20i%20%3D%200%2C%20ci%3B%20(ci%20%3D%20nameList%5Bi%5D)%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20queue.enqueue(ci)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20let%20eliminated%20%3D%20%5C%22%5C%22%5Cn%20%20%20%20while%20(queue.size()%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20num%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20queue.enqueue(queue.dequeue())%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20eliminated%20%3D%20queue.dequeue()%5Cn%20%20%20%20%20%20%20%20console.log(%60%24%7Beliminated%7D%20has%20been%20eliminated.%60)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20return%20queue.dequeue()%5Cn%7D%5Cn%5Cnlet%20names%20%3D%20%5B%5C%22John%5C%22%2C%20%5C%22Jack%5C%22%2C%20%5C%22Camila%5C%22%2C%20%5C%22Ingrid%5C%22%2C%20%5C%22Carl%5C%22%5D%5Cnlet%20winner%20%3D%20hotPotato(names%2C%207)%5Cnconsole.log(%60The%20winner%20is%3A%20%24%7Bwinner%7D%60)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%220e361af1%22%7D\"></card><p data-lake-id=\"u7c263c89\" id=\"u7c263c89\"><br></p><p data-lake-id=\"uafde652f\" id=\"uafde652f\"><span data-lake-id=\"u48dc28fc\" id=\"u48dc28fc\">在这个游戏中，我们传入由五个名字组成的数组，用来表示参加游戏的五个人，数字 7 表示每一轮要传递的次数。在每一个过程中，我们从队列头部取出一个元素加到队列的尾部，当次数用完的时候，将队列头部的元素取出来，作为这一轮中被淘汰的人。让我们来看一下具体的执行过程，一开始队列中的顺序是 John, Jack, Camila, Ingrid, Carl，然后传递 7 次：<br /><br />1. Jack, Camila, Ingrid, Carl, John<br />2. Camila, Ingrid, Carl, John, Jack<br />3. Ingrid, Carl, John, Jack, Camila<br />4. Carl, John, Jack, Camila, Ingrid<br />5. John, Jack, Camila, Ingrid, Carl<br />6. Jack, Camila, Ingrid, Carl, John<br />7. Camila, Ingrid, Carl, John, Jack</span></p><p data-lake-id=\"u16265625\" id=\"u16265625\"><span data-lake-id=\"ua8ab8cfa\" id=\"ua8ab8cfa\"><br />之后从队列中取出的是 Camila。反复执行上述过程，直到队列中的元素只剩一个，这个就是最后的赢家！<br /><br />下面是完整的执行结果：</span></p><p data-lake-id=\"ufb1c5601\" id=\"ufb1c5601\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22shell%22%2C%22code%22%3A%22Camila%20has%20been%20eliminated.%5CnJack%20has%20been%20eliminated.%5CnCarl%20has%20been%20eliminated.%5CnIngrid%20has%20been%20eliminated.%5CnThe%20winner%20is%3A%20John%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22e2e74b06%22%7D\"></card>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 1606,
  "created_at": "2020-08-09T08:03:52.000Z",
  "updated_at": "2023-11-19T17:55:04.000Z",
  "content_updated_at": "2022-03-04T04:18:02.000Z",
  "published_at": "2022-03-04T04:18:02.000Z",
  "first_published_at": "2020-08-09T08:03:52.000Z",
  "book": {
    "id": 24854102,
    "type": "Book",
    "slug": "gm8h7g",
    "name": "算法 algorithm",
    "user_id": 732231,
    "description": "算法基础、leetCode",
    "toc_yml": "- type: META\n  count: 17\n  display_level: all\n  tail_type: UPDATED_AT\n  base_version_id: 372567226\n  published: true\n  max_level: 1\n  last_updated_at: 2023-11-19T18:02:44.264Z\n  version_id: 372567245\n- type: TITLE\n  title: 算法刷题索引\n  uuid: 9iuletCnX8AA1DWl\n  url: ''\n  prev_uuid: ''\n  sibling_uuid: BMR7y68MzsRsLpq6\n  child_uuid: 4IS2N309UG8zzeKG\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: LeetCode 热题 🔥 100\n  uuid: 4IS2N309UG8zzeKG\n  url: im0vt7\n  prev_uuid: 9iuletCnX8AA1DWl\n  sibling_uuid: uioHkKsczkPGgdyr\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67808056\n  level: 1\n  id: 67808056\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 剑指 offer 第二版\n  uuid: uioHkKsczkPGgdyr\n  url: dotw59\n  prev_uuid: 4IS2N309UG8zzeKG\n  sibling_uuid: syezq9xwx3badLKu\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810801\n  level: 1\n  id: 67810801\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: LeetCode 精选 TOP 面试题\n  uuid: syezq9xwx3badLKu\n  url: brcxx5\n  prev_uuid: uioHkKsczkPGgdyr\n  sibling_uuid: PKQxO_4GM33AkW__\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810529\n  level: 1\n  id: 67810529\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 剑指 offer 专项突击版\n  uuid: PKQxO_4GM33AkW__\n  url: mff6ll\n  prev_uuid: syezq9xwx3badLKu\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810920\n  level: 1\n  id: 67810920\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 数据结构\n  uuid: BMR7y68MzsRsLpq6\n  url: ''\n  prev_uuid: 9iuletCnX8AA1DWl\n  sibling_uuid: zvwUUlHnEeEhPJ9v\n  child_uuid: E-fia709YBhQtJrt\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 对象 object\n  uuid: E-fia709YBhQtJrt\n  url: aogq4f\n  prev_uuid: BMR7y68MzsRsLpq6\n  sibling_uuid: D7LcTHUXkpP6SYG4\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432408\n  level: 1\n  id: 11432408\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 数组 array\n  uuid: D7LcTHUXkpP6SYG4\n  url: oq0mk5\n  prev_uuid: E-fia709YBhQtJrt\n  sibling_uuid: LwftOZYaPeqjwhdS\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432407\n  level: 1\n  id: 11432407\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字符串 string\n  uuid: LwftOZYaPeqjwhdS\n  url: sih9mc\n  prev_uuid: D7LcTHUXkpP6SYG4\n  sibling_uuid: dj5FuaOaHSda1AbK\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432412\n  level: 1\n  id: 11432412\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 栈 stack\n  uuid: dj5FuaOaHSda1AbK\n  url: xi2mh9\n  prev_uuid: LwftOZYaPeqjwhdS\n  sibling_uuid: IOag-iKKv87hGhdm\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435979\n  level: 1\n  id: 11435979\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 队列 queue\n  uuid: IOag-iKKv87hGhdm\n  url: hroghz\n  prev_uuid: dj5FuaOaHSda1AbK\n  sibling_uuid: 778WMx0aXLZVUl9p\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435969\n  level: 1\n  id: 11435969\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 链表 Linkist\n  uuid: 778WMx0aXLZVUl9p\n  url: mo7sde\n  prev_uuid: IOag-iKKv87hGhdm\n  sibling_uuid: j9b8vxS9kTz8xa3x\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435962\n  level: 1\n  id: 11435962\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 树 tree\n  uuid: j9b8vxS9kTz8xa3x\n  url: glas5w\n  prev_uuid: 778WMx0aXLZVUl9p\n  sibling_uuid: QARpKzPBR5puFByT\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435974\n  level: 1\n  id: 11435974\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 图 graph\n  uuid: QARpKzPBR5puFByT\n  url: dgduok\n  prev_uuid: j9b8vxS9kTz8xa3x\n  sibling_uuid: kKoPgVQTytiILSgY\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435966\n  level: 1\n  id: 11435966\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 集合 set\n  uuid: kKoPgVQTytiILSgY\n  url: ub10iw\n  prev_uuid: QARpKzPBR5puFByT\n  sibling_uuid: R7qhLVPS4xKQZLD7\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435960\n  level: 1\n  id: 11435960\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字典和散列表 dictionary & hash table\n  uuid: R7qhLVPS4xKQZLD7\n  url: aq5vbp\n  prev_uuid: kKoPgVQTytiILSgY\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435958\n  level: 1\n  id: 11435958\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 动态规划\n  uuid: zvwUUlHnEeEhPJ9v\n  url: mnfkhynksc1h459r\n  prev_uuid: BMR7y68MzsRsLpq6\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147451432\n  level: 0\n  id: 147451432\n  open_window: 1\n  visible: 0\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 16,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-19T18:02:44.299Z",
    "created_at": "2022-02-21T07:49:26.000Z",
    "updated_at": "2023-11-19T18:02:44.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-23T19:11:28.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/gm8h7g",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-23T19:11:28.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 848996256,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-23T19:11:28.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}