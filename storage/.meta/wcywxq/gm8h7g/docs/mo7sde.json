{
  "id": 11435962,
  "slug": "mo7sde",
  "title": "链表 Linkist",
  "description": "链表用来存储有序的元素集合，与数组不同，链表中的元素并非保存在连续的存储空间内，每个元素由一个存储元素本身的节点和一个指向下一个元素的指针构成。当要移动或删除元素时，只需要修改相应元素上的指针就可以了。对链表元素的操作要比对数组元素的操作效率更高。下面是链表数据结构的示意图上面链表中每一个元素...",
  "cover": "https://cdn.nlark.com/yuque/0/2020/png/732231/1608704346914-b3d8a713-634d-45fe-ad2c-e040f9985485.png",
  "user_id": 732231,
  "book_id": 24854102,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><p id=\"8b9b28b86315b765178b080bc38ae357\" class=\"ne-p\"><span class=\"ne-text\">链表用来存储有序的元素集合，与数组不同，链表中的元素并非保存在连续的存储空间内，每个元素由一个存储元素本身的节点和一个指向下一个元素的指针构成。当要移动或删除元素时，只需要修改相应元素上的指针就可以了。对链表元素的操作要比对数组元素的操作效率更高。下面是链表数据结构的示意图</span></p><p id=\"72463c7b18450670c3a6f51a033e7705_p_4\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704346914-b3d8a713-634d-45fe-ad2c-e040f9985485.png\" width=\"687\" id=\"VpKv4\" class=\"ne-image\"></p><p id=\"7467903a77e4c43e92d4f196903d0bbe_p_5\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"e4dd054a65272350f615a79c1a64f043_li_4\" data-lake-index-type=\"0\"><span class=\"ne-text\">上面链表中每一个元素只有一个 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针，用来指向下一个节点，这样的链表称之为单向链表，我们只能从链表的头部开始遍历整个链表，任何一个节点只能找到它的下一个节点，而不能找到它的上一个节点。双向链表中的每一个元素拥有两个指针，一个用来指向下一个节点，一个用来指向上一个节点。在双向链表中，除了可以像单向链表一样从头部开始遍历之外，还可以从尾部进行遍历。下面是双向链表的数据结构示意图：</span></li></ul><p id=\"0ece3fcfc6cfe87dcd2fbef555e7fa0e\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704367520-532d5db4-3fde-4ac4-8de5-4fd3e1d287e1.png\" width=\"811\" id=\"OZJLc\" class=\"ne-image\"></p><h2 id=\"72786a69\"><span class=\"ne-text\">单向链表</span></h2><p id=\"92c8228235b93f7cc9ced6ac90fca3a6_p_8\" class=\"ne-p\"><br></p><h3 id=\"f411d0f1\"><span class=\"ne-text\">说明</span></h3><p id=\"eadc4ec477465f1f239730d987d394b1_p_9\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"4e0f7020a8c91a492857b08e9cc58082_p_10\" class=\"ne-p\"><span class=\"ne-text\">要实现链表数据结构，关键在于保存 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 元素（即链表的头元素）以及每一个元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针，有这两部分我们就可以很方便地遍历链表从而操作所有的元素。可以把链表想象成一条锁链，锁链中的每一个节点都是相互连接的，我们只要找到锁链的头，整条锁链就都可以找到了。让我们来看一下具体的实现方式。</span></p></div><p id=\"828bea0262f636b25c97fbef525aed20_p_11\" class=\"ne-p\"><br></p><h3 id=\"52b36576\"><span class=\"ne-text\">步骤</span></h3><p id=\"09a2b5671cf447a1a3529d71c89cf9e1_p_12\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"dd1e0b174e1d660e60418c341a173d86_li_5\" data-lake-index-type=\"0\"><span class=\"ne-text\">首先我们需要一个辅助类，用来描述链表中的节点。这个类很简单，只需要两个属性，一个用来保存节点的值，一个用来保存指向下一个节点的指针。</span></li></ul><p id=\"2369fafe89fae403079018df6f36b51b_p_13\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d857bee2\" class=\"ne-codeblock language-javascript\"><code>function ListNode(element) {\n  this.element = element;\n  this.next = null;\n}</code></pre><p id=\"7cf79ceeaaf91ef14264b4c55c1c8c1d_p_14\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"80545d0bc091d3aa67a632280c9c644f_li_6\" data-lake-index-type=\"0\"><span class=\"ne-text\">下面是链表类的基本骨架</span></li></ul><p id=\"c53070088aadb43ef468f61fca8ca22a_p_15\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"27d7fcec\" class=\"ne-codeblock language-javascript\"><code>class LinkList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n  }\n  // 向链表中添加节点\n  append(element) {\n    var node = new ListNode(element);\n    if (this.head === null) {\n      this.head = node;\n    } else {\n      var current = this.getElementAt(this.length - 1);\n      current.next = node;\n    }\n    this.length++;\n  }\n  // 在链表的指定位置插入节点\n  insert(position, element) {\n    if (position &lt; 0 || position &gt; this.length - 1) {\n      return false;\n    }\n    var node = new ListNode(element);\n    if (position === 0) {\n      node.next = this.head;\n      this.head = node;\n    } else {\n      var previous = this.getElementAt(position - 1);\n      node.next = previous.next;\n      previous.next = node;\n    }\n    this.length++;\n    return true;\n  }\n  // 删除链表中指定位置的元素，并返回这个元素的值\n  removeAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) {\n      return null;\n    }\n    var current = this.head;\n    if (position === 0) {\n      this.head = current.next;\n    } else {\n      var previous = this.getElementAt(position - 1);\n      current = previous.next;\n      previous.next = current.next;\n    }\n    this.length--;\n    return current.element;\n  }\n  // 删除链表中对应的元素\n  remove(element) {\n    var index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n  // 在链表中查找给定元素的索引\n  indexOf(element) {\n    var current = this.head;\n    for (var i = 0; i &lt; this.length; i++) {\n      if (current.element === element) {\n        return i;\n      }\n      current = current.next;\n    }\n    return -1;\n  }\n  // 返回链表中索引所对应的元素\n  getElementAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) {\n      return null;\n    }\n    var current = this.head;\n    for (var i = 0; i &lt; position; i++) {\n      current = current.next;\n    }\n    return current;\n  }\n  // 判断链表是否为空\n  isEmpty() {\n    // return this.head === null;\n    return this.length === 0;\n  }\n  // 返回链表的长度\n  size() {\n    return this.length;\n  }\n  // 返回头节点\n  getHead() {\n    return this.head;\n  }\n  // 清空链表\n  clear() {\n    this.head = null;\n    this.length = 0;\n  }\n  // 辅助方法，按指定格式输出链表中的所有元素，方便测试验证结果\n  toString() {\n    var current = this.head;\n    var s = '';\n\n    while (current) {\n      var next = current.next;\n      next = next ? next.element : 'null';\n      s += `[element: ${current.element}, next: ${next}] `;\n      current = current.next;\n    }\n\n    return s;\n  }\n}</code></pre><p id=\"42752743bc6d3f9f6c928fb47989b8c2_p_16\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"a012eaef546925b976a236f8bd3f64e7_li_7\" data-lake-index-type=\"0\"><span class=\"ne-text\">让我们从查找链表元素的方法 </span><code class=\"ne-code\"><span class=\"ne-text\">getElementAt()</span></code><span class=\"ne-text\"> 开始，因为后面我们会多次用到它。</span></li></ul><p id=\"c5eaf555cee01ec836fc749258c6179d_p_17\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"63f782ef\" class=\"ne-codeblock language-javascript\"><code>getElementAt(position) {\n  if (position &lt; 0 || position &gt; this.length - 1) {\n    return null;\n  }\n  var current = this.head;\n  for (var i = 0; i &lt; position; i++) {\n    current = current.next;\n  }\n  return current;\n}</code></pre><p id=\"3f8949dd5527f0c9624c3fd3faefb76f_p_18\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"c6ec48e23d522d65bf625dd7fc70dcaf_p_19\" class=\"ne-p\"><span class=\"ne-text\">首先判断参数 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 的边界值，如果值超出了索引的范围（小于 </span><code class=\"ne-code\"><span class=\"ne-text\">0</span></code><span class=\"ne-text\"> 或者大于</span><code class=\"ne-code\"><span class=\"ne-text\">length - 1</span></code><span class=\"ne-text\">），则返回 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">。我们从链表的 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 开始，遍历整个链表直到找到对应索引位置的节点，然后返回这个节点。是不是很简单？和所有有序数据集合一样，链表的索引默认从 </span><code class=\"ne-code\"><span class=\"ne-text\">0</span></code><span class=\"ne-text\"> 开始，只要找到了链表的头（所以我们必须在 </span><code class=\"ne-code\"><span class=\"ne-text\">LinkList</span></code><span class=\"ne-text\"> 类中保存 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 值），然后就可以遍历找到索引所在位置的元素。</span></p></div><p id=\"db841a6e995b001085603629a3ace379_p_20\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"2d66a6505ab279bb08b85117369010b7_li_8\" data-lake-index-type=\"0\"><span class=\"ne-text\">有了 </span><code class=\"ne-code\"><span class=\"ne-text\">getElementAt()</span></code><span class=\"ne-text\"> 方法，接下来我们就可以很方便地实现 </span><code class=\"ne-code\"><span class=\"ne-text\">append()</span></code><span class=\"ne-text\"> 方法，用来在链表的尾部添加新节点。</span></li></ul><p id=\"54d418504a63791b75a5f497078fa24a_p_21\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"fe0473b5\" class=\"ne-codeblock language-javascript\"><code>append(element) {\n  var node = new ListNode(element);\n  // 如果当前链表为空，则将 head 指向 node\n  if (this.head === null) {\n    this.head = node;\n  } else {\n    // 否则，找到链表尾部的元素，然后添加新元素\n    var current = this.getElementAt(this.length - 1);\n    current.next = node;\n  }\n  this.length++;\n}</code></pre><p id=\"37928cd1f32681ee4810a9ab9d3c1104_p_22\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"0d2b77f2199ac7265917a3f688cdcc8b_p_23\" class=\"ne-p\"><span class=\"ne-text\">如果链表的 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">（这种情况表示链表为空），则直接将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 指向新添加的元素。否则，通过 </span><code class=\"ne-code\"><span class=\"ne-text\">getElementAt()</span></code><span class=\"ne-text\"> 方法找到链表的最后一个节点，将该节点的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向新添加的元素。新添加的元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针默认为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">，链表最后一个元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 值为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">。将节点挂到链表上之后，不要忘记将链表的长度加 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code><span class=\"ne-text\">，我们需要通过</span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 属性来记录链表的长度。</span></p></div><p id=\"1f3b4b4a4867a8b756c196b38558d0c4_p_24\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"b0ece2beb942cca306a5d6e038dbff74_li_9\" data-lake-index-type=\"0\"><span class=\"ne-text\">接下来我们要实现 </span><code class=\"ne-code\"><span class=\"ne-text\">insert()</span></code><span class=\"ne-text\"> 方法，可以在链表的任意位置添加节点。</span></li></ul><p id=\"3afe72986fc83f6913935faccbcf69b2_p_25\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0fadeda0\" class=\"ne-codeblock language-javascript\"><code>insert(position, element) {\n  // position 不能超过边界值\n  if (position &lt; 0 || position &gt; this.length - 1) {\n    return false;\n  }\n\n  var node = new ListNode(element);\n\n  if (position === 0) {\n    node.next = this.head;\n    this.head = node;\n  } else {\n    var previous = this.getElementAt(position - 1);\n    node.next = previous.next;\n    previous.next = node;    \n  }\n  this.length++;\n  return true;\n}</code></pre><p id=\"b57de0a6a045efefe71d109094be9ddc_p_26\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"fa9fe669f446436952510d0b04f9a327_p_27\" class=\"ne-p\"><span class=\"ne-text\">首先也是要判断参数 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 的边界值，不能越界。当 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 的值为 </span><code class=\"ne-code\"><span class=\"ne-text\">0</span></code><span class=\"ne-text\"> 时，表示要在链表的头部插入新节点，对应的操作如下图所示。将新插入节点的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向现在的 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\">，然后更新 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 的值为新插入的节点。</span></p></div><p id=\"c2f989dd0f058d43258fb7a314f90ca4\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704395087-c23664dd-c205-44d5-9e63-870bf14ec0b1.png\" width=\"687\" id=\"ZmDav\" class=\"ne-image\"></p><p id=\"d657ac1e4c3211af4f7dcea889518735_p_30\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"16010a0caa57e486c6540ca460620ade_p_31\" class=\"ne-p\"><span class=\"ne-text\">如果要插入的节点在链表的中间或者尾部，对应的操作如下图。假设链表长度为 </span><code class=\"ne-code\"><span class=\"ne-text\">3</span></code><span class=\"ne-text\">，要在位置 </span><code class=\"ne-code\"><span class=\"ne-text\">2</span></code><span class=\"ne-text\"> 插入新节点，我们首先找到位置 </span><code class=\"ne-code\"><span class=\"ne-text\">2</span></code><span class=\"ne-text\"> 的前一个节点 </span><code class=\"ne-code\"><span class=\"ne-text\">previous node</span></code><span class=\"ne-text\">，将新节点 </span><code class=\"ne-code\"><span class=\"ne-text\">new node</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向 </span><code class=\"ne-code\"><span class=\"ne-text\">previous node</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 所对应的节点，然后再将</span><code class=\"ne-code\"><span class=\"ne-text\">previous node</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向 </span><code class=\"ne-code\"><span class=\"ne-text\">new node</span></code><span class=\"ne-text\">，这样就把新节点挂到链表中了。考虑一下，当插入的节点在链表的尾部，这种情况也是适用的。而如果链表为空，即链表的 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">，则参数 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 会超出边界条件，从而 </span><code class=\"ne-code\"><span class=\"ne-text\">insert()</span></code><span class=\"ne-text\"> 方法会直接返回 </span><code class=\"ne-code\"><span class=\"ne-text\">false</span></code><span class=\"ne-text\">。</span></p></div><p id=\"39abba9494ef6da94608fbd0e487aa60_p_34\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704419032-051f8ebf-b913-43a0-8473-afb6535e64f9.png\" width=\"687\" id=\"JgFG3\" class=\"ne-image\"></p><div class=\"ne-quote\"><p id=\"ae75bb4df811b53ac3c664c56d8c1fa3_p_35\" class=\"ne-p\"><span class=\"ne-text\">最后，别忘了更新 </span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 属性的值，将链表的长度加 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code><span class=\"ne-text\">。</span></p></div><p id=\"6f8f966688575a1f666bafa122494f73_p_36\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"97dcf5372a3cedc8fc0514642c0cbfa4_li_10\" data-lake-index-type=\"0\"><span class=\"ne-text\">按照相同的方式，我们可以很容易地写出 </span><code class=\"ne-code\"><span class=\"ne-text\">removeAt()</span></code><span class=\"ne-text\"> 方法，用来删除链表中指定位置的节点。</span></li></ul><p id=\"ab57135091a86c42cc63ec67ac068a45_p_37\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"267e369c\" class=\"ne-codeblock language-javascript\"><code>removeAt(position) {\n  // position 不能超出边界值\n  if (position &lt; 0 || position &gt; this.length - 1) {\n    return null;\n  }\n  var current = this.head;\n  if (position === 0) {\n    this.head = current.next;\n  } else {\n    var previous = this.getElementAt(position - 1);\n    current = previous.next;\n    previous.next = current.next;\n  }\n  this.length--;\n  return current.element;\n}</code></pre><p id=\"82f45866a429f6224b2e92c65bfda254_p_38\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"3f3fd98cb4e8eab62e88d532e3d7b0c3_p_39\" class=\"ne-p\"><span class=\"ne-text\">下面两张示意图说明了从链表头部和其它位置删除节点的情况。</span></p></div><p id=\"fb18d8c69d5615182defd0ad2553d6e4\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705111553-9ff6c07c-5b98-408d-952e-625082c91c70.png\" width=\"687\" id=\"MhjJL\" class=\"ne-image\"></p><p id=\"aebb7af96a9ee3c9b7a669f28fef1d7e_p_42\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705120449-8a4c3bff-e7e3-4338-883f-c230e291392b.png\" width=\"687\" id=\"R7Y5r\" class=\"ne-image\"></p><p id=\"157b805d005afe38c7c2d5198b31ee6e_p_44\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"1e5528b26a18d968e53320129af8e26f_p_45\" class=\"ne-p\"><span class=\"ne-text\">如果要删除的节点为链表的头部，只需要将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 移到下一个节点即可。如果当前链表只有一个节点，那么下一个节点为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">，此时将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 指向下一个节点等同于将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 设置成 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">，删除之后链表为空。如果要删除的节点在链表的中间部分，我们需要找出 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 所在位置的前一个节点，将它的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 所在位置的下一个节点。总之，删除节点只需要修改相应节点的指针，使断开位置左右相邻的节点重新连接上。被删除的节点由于再也没有其它部分的引用而被丢弃在内存中，等待垃圾回收器来清除。</span></p></div><p id=\"e81b6efc8e2153cf8aa53e3b04d7f22c_p_46\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"d836f2fb214ecaed8dec32fa40e17e5f_p_47\" class=\"ne-p\"><span class=\"ne-text\">最后，别忘了将链表的长度减 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code><span class=\"ne-text\">。</span></p></div><p id=\"aa95668f5a65b03373d1b0b3f9f8d3a6_p_48\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"090d05326053a60eb487c6f1a8adb0fd_li_11\" data-lake-index-type=\"0\"><span class=\"ne-text\">下面我们来看看 </span><code class=\"ne-code\"><span class=\"ne-text\">indexOf()</span></code><span class=\"ne-text\"> 方法，该方法返回给定元素在链表中的索引位置。</span></li></ul><p id=\"233f53790c0b9d757f931748dd4d9e1e_p_49\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"78f94abd\" class=\"ne-codeblock language-javascript\"><code>indexOf(element) {\n  var current = this.head;\n\n  for (var i = 0; i &lt; this.length; i++) {\n    if (current.element === element) {\n      return i;\n    }\n    current = current.next;\n  }\n\n  return -1;\n}</code></pre><p id=\"4108a5bc411c7547dc6876b612b07f81_p_50\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"d3d16a640dc72a5f6ecfe699df4eb251_p_51\" class=\"ne-p\"><span class=\"ne-text\">我们从链表的头部开始遍历，直到找到和给定元素相同的元素，然后返回对应的索引号。如果没有找到对应的元素，则返回 </span><code class=\"ne-code\"><span class=\"ne-text\">-1</span></code><span class=\"ne-text\">。</span></p></div><p id=\"bc2359f7bb1e32241fa27f528e60a125_p_52\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"9c9801a1b5710689441aea5114c5451d_li_12\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">isEmpty()</span></code><span class=\"ne-text\"> 方法中，我们可以根据 </span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 是否为 </span><code class=\"ne-code\"><span class=\"ne-text\">0</span></code><span class=\"ne-text\"> 来判断链表是否为空，当然也可以根据 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 是否为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\"> 来进行判断，前提是所有涉及到链表节点添加和移除的方法都要正确地更新 </span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\">。</span><code class=\"ne-code\"><span class=\"ne-text\">toString()</span></code><span class=\"ne-text\"> 方法只是为了方便测试而编写的，我们来看看几个测试用例：</span></li></ul><p id=\"0c6a7643ebb3931744a90899eb00ce0b_p_53\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"caa0199a\" class=\"ne-codeblock language-javascript\"><code>var linkList = new LinkList();\nlinkList.append(10);\nlinkList.append(15);\nlinkList.append(20);\nconsole.log(linkList.toString());\n\nlinkList.insert(0, 9);\nlinkList.insert(2, 11);\nlinkList.insert(5, 25);\nconsole.log(linkList.toString());\n\nconsole.log(linkList.removeAt(0));\nconsole.log(linkList.removeAt(1));\nconsole.log(linkList.removeAt(3));\nconsole.log(linkList.toString());\n\nconsole.log(linkList.indexOf(20));\n\nlinkList.remove(20);\n\nconsole.log(linkList.toString());\n\nlinkList.clear();\nconsole.log(linkList.size());</code></pre><p id=\"a74a1ae9e5a12e5ca252284043884853_p_55\" class=\"ne-p\"><br></p><p id=\"c7813883a63e45a345fd6584f3605108\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705261819-5917b870-8756-4de9-8e66-be0548d56213.png\" width=\"1306\" id=\"ivo2u\" class=\"ne-image\"></p><p id=\"a6e7204180aba568d27cc7b95d0717fd_p_56\" class=\"ne-p\"><br></p><h2 id=\"b5fb11e9\"><span class=\"ne-text\">双向链表</span></h2><p id=\"67592880a847e874a0da3af4d564ef1f_p_57\" class=\"ne-p\"><br></p><h3 id=\"52b36576-1\"><span class=\"ne-text\">步骤</span></h3><p id=\"e3c9bad72638009a374744280c63ecc6_p_58\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"71dfa86733f47d82c73b38a06d62e761_p_59\" class=\"ne-p\"><span class=\"ne-text\">由于双向链表具有单向链表的所有特性，因此我们的双向链表类可以继承自前面的单向链表类，不过辅助类 </span><code class=\"ne-code\"><span class=\"ne-text\">Node</span></code><span class=\"ne-text\"> 需要添加一个 </span><code class=\"ne-code\"><span class=\"ne-text\">prev</span></code><span class=\"ne-text\"> 属性，用来指向前一个节点。</span></p></div><p id=\"daa3e859dfee1b8825cb9c219dcb2526_p_60\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d581a74e\" class=\"ne-codeblock language-javascript\"><code>function Node(element) {\n  this.element = element;\n  this.next = null;\n  this.prev = null;\n}</code></pre><p id=\"d89d8c6a729313c0d25f9b1742c0d590_p_61\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"4c0fde53ab52bab59735979a46c369e6_li_13\" data-lake-index-type=\"0\"><span class=\"ne-text\">下面是继承自 </span><code class=\"ne-code\"><span class=\"ne-text\">LinkList</span></code><span class=\"ne-text\"> 类的双向链表类的基本骨架</span></li></ul><p id=\"9b034733f43578c770243b15c945bc07_p_62\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ada9a947\" class=\"ne-codeblock language-javascript\"><code>class DoubleLinkList extends LinkList {\n  constructor() {\n    super();\n    this.tail = null; // 尾节点\n  }\n}</code></pre><p id=\"87e34965e50e2c8e31ce44a85667e8dd_p_63\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"e7deef6eec135673422c81bcb1e849fa_li_14\" data-lake-index-type=\"0\"><span class=\"ne-text\">先来看看 </span><code class=\"ne-code\"><span class=\"ne-text\">append()</span></code><span class=\"ne-text\"> 方法的实现。当链表为空时，除了要将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 指向当前添加的节点外，还要将 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\"> 也指向当前要添加的节点。当链表不为空时，直接将 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指向当前要添加的节点 </span><code class=\"ne-code\"><span class=\"ne-text\">node</span></code><span class=\"ne-text\">，然后修改 </span><code class=\"ne-code\"><span class=\"ne-text\">node</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">prev</span></code><span class=\"ne-text\"> 指向旧的 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\">，最后修改 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\"> 为新添加的节点。我们不需要从头开始遍历整个链表，而通过 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\"> 可以直接找到链表的尾部，这一点比单向链表的操作要更方便。最后将 </span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 的值加 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code><span class=\"ne-text\">，修改链表的长度。</span></li></ul><p id=\"b3add770127d8c2a5064673aa8a9731f_p_64\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"82b5988d\" class=\"ne-codeblock language-javascript\"><code>append(element) {\n  var node = new Node(element);\n\n  // 如果链表为空，则将 head 和 tail 都指向当前添加的节点\n  if (this.head === null) {\n    this.head = node;\n    this.tail = node;\n  } else {\n    // 否则，将当前节点添加到链表的尾部\n    this.tail.next = node;\n    node.prev = this.tail;\n    this.tail = node;\n  }\n  this.length++;\n}</code></pre><p id=\"2a81d6eed31dfd1dc3c193bbdb75c1a1_p_65\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"fb612dbf2bb2e66d056a6eaabc751c4a_li_15\" data-lake-index-type=\"0\"><span class=\"ne-text\">由于双向链表可以从链表的尾部往前遍历，所以我们修改了 </span><code class=\"ne-code\"><span class=\"ne-text\">getElementAt()</span></code><span class=\"ne-text\"> 方法，对基类中单向链表的方法进行了改写。当要查找的元素的索引号大于链表长度的一半时，从链表的尾部开始遍历。</span></li></ul><p id=\"cf44cb59378505901ec625cdc88d7d91_p_66\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"92923481\" class=\"ne-codeblock language-javascript\"><code>getELementAt(position) {\n  if (position &lt; 0 || position &gt; this.length - 1) return null;\n  // 从后向前遍历\n  if (position &gt; Math.floor(this.length / 2)) {\n    var current = this.tail;\n    for (var i = this.length - 1; i &gt; position; i--) {\n      current = current.prev;\n    }\n    return current;\n  } else {\n    return super.getELementAt(position);\n  }\n}</code></pre><p id=\"152302cc03cd3433e252fd8fbe4bade7_p_67\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"4d870fc948e9f1e7f3f99b3638b5d172_p_68\" class=\"ne-p\"><span class=\"ne-text\">有两种遍历方式，从前往后遍历调用的是基类单向链表里的方法，从后往前遍历需要用到节点的 </span><code class=\"ne-code\"><span class=\"ne-text\">prev</span></code><span class=\"ne-text\"> 指针，用来查找前一个节点。</span></p></div><p id=\"956e0d4312e941b77cd57ec35c294aff_p_69\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"1c6b2cbaa20f2b95f254bde42dfcc6be_li_16\" data-lake-index-type=\"0\"><span class=\"ne-text\">我们同时还需要修改 </span><code class=\"ne-code\"><span class=\"ne-text\">insert()</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">removeAt()</span></code><span class=\"ne-text\"> 这两个方法。记住，与单向链表唯一的区别就是要同时维护 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\">，以及每一个节点上的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">prev</span></code><span class=\"ne-text\"> 指针。</span></li></ul><p id=\"67523e0fa28fe87849ce38cd391e3347_p_70\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"e965d6f7\" class=\"ne-codeblock language-javascript\"><code>insert(position, element) {\n  if (position &lt; 0 || position &gt; this.length - 1) return false;\n\n  // 插入到尾部\n  if (position === this.length) {\n    this.append(element);\n  } else {\n    var node = new ListNode(element);\n    // 插入到头部\n    if (position === 0) {\n      if (this.head === null) {\n        this.head = node;\n        this.tail = node;\n      } else {\n        node.next = this.head;\n        this.head.prev = node;\n        this.head = node;\n      }\n    } else {\n      // 插入到中间位置\n      var current = this.getElementAt(position);\n      var previous = current.prev;\n      node.next = current;\n      node.prev = previous;\n      previous.next = node;\n      current.prev = node;\n    }\n  }\n  this.length++;\n  return true;\n}\n\nremoveAt(position) {\n  if (position &lt; 0 || position &gt; this.length - 1) return null;\n\n  var current = this.head;\n  var previous;\n\n  // 移除头部元素\n  if (position === 0) {\n    this.head = current.next;\n    this.head.prev = null;\n    if (this.length === 1) {\n      this.tail = null;\n    }\n  } else if (position === this.length - 1) {\n    // 移除尾部元素\n    current = this.tail;\n    this.tail = current.prev;\n    this.tail.next = null;\n  } else {\n    // 移除中间元素\n    current = this.getELementAt(position);\n    previous = current.prev;\n    previous.next = current.next;\n    current.next.prev = previous;\n  }\n  this.length--;\n  return current.element;\n}</code></pre><p id=\"b7f5c253c3fb3956b40638fc0613cbf9_p_71\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"1e25a43370983bdf041a1d8097c0bd11_li_17\" data-lake-index-type=\"0\"><span class=\"ne-text\">操作过程中需要判断一些特殊情况，例如链表的头和尾，以及当前链表是否为空等等，否则程序可能会在某些特殊情况下导致越界和报错。下面是一个完整的双向链表类的代码</span></li></ul><p id=\"200b796b4b1f5a36aa12caae6b6fa3d8_p_72\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"4cc9d200\" class=\"ne-codeblock language-javascript\"><code>class DoubleLinkList extends LinkList {\n  constructor() {\n    super();\n    this.tail = null;\n  }\n  append(element) {\n    var node = new ListNode(element);\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n    } else {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    }\n    this.length++;\n  }\n  getElementAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) return null;\n    if (position &gt; Math.floor(this.length / 2)) {\n      var current = this.tail;\n      for (var i = this.length - 1; i &gt; position; i--) {\n        current = current.prev;\n      }\n      return current;\n    } else {\n      super.getElementAt(position);\n    }\n  }\n  insert(position, element) {\n    if (position &lt; 0 || position &gt; this.length - 1) return false;\n\n    if (position === this.length) {\n      this.append(element);\n    } else {\n      var node = new ListNode(element);\n      if (position === 0) {\n        if (this.head === null) {\n          this.head = node;\n          this.tail = node;\n        } else {\n          node.next = this.head;\n          this.head.prev = node;\n          this.head = node;\n        }\n      } else {\n        var current = this.getElementAt(position);\n        var previous = current.prev;\n        node.next = current;\n        node.prev = previous;\n        previous.next = node;\n        current.prev = node;\n      }\n    }\n    this.length++;\n    return true;\n  }\n  removeAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) return null;\n    var current = this.head;\n    var previous;\n    if (position === 0) {\n      this.head = current.next;\n      this.head.prev = null;\n      if (this.length === 1) {\n        this.tail = null; \n      }\n    } else if (position === this.length - 1) {\n      current = this.tail;\n      this.tail = current.prev;\n      this.tail.next = null;\n    } else {\n      current = this.getElementAt(position);\n      previous = current.prev;\n      previous.next = current.next;\n      current.next.prev = previous;\n    }\n    this.length--;\n    return current.element;\n  }\n  getTail() {\n    return this.tail;\n  }\n  clear() {\n    super.clear();\n    this.tail = null;\n  }\n  toString() {\n    var current = this.head;\n    var s = '';\n\n    while (current) {\n      var next = current.next;\n      var previous = current.prev;\n      next = next ? next.element : 'null';\n      previous = previous ? previous.element : 'null';\n      s += `[element: ${current.element}, prev: ${previous}, next: ${next}]`;\n      current = current.next;\n    }\n\n    return s;\n  }\n}</code></pre><p id=\"7e9db6e1dddd1090f9cbf7742b89f0d6_p_73\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"472e55dbf4deef5e801a1aea0c8b6d12_li_18\" data-lake-index-type=\"0\"><span class=\"ne-text\">我们重写了 </span><code class=\"ne-code\"><span class=\"ne-text\">toString()</span></code><span class=\"ne-text\"> 方法以方便更加清楚地查看测试结果。下面是一些测试用例：</span></li></ul><p id=\"d36608d2dcf9f070081537010b5adfb3_p_74\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"25634705\" class=\"ne-codeblock language-javascript\"><code>let doubleLinkList = new DoubleLinkList();\ndoubleLinkList.append(10);\ndoubleLinkList.append(15);\ndoubleLinkList.append(20);\ndoubleLinkList.append(25);\ndoubleLinkList.append(30);\nconsole.log(doubleLinkList.toString());\nconsole.log(doubleLinkList.getElementAt(1).element);\nconsole.log(doubleLinkList.getElementAt(2).element);\nconsole.log(doubleLinkList.getElementAt(3).element);\n\ndoubleLinkList.insert(0, 9);\ndoubleLinkList.insert(4, 24);\ndoubleLinkList.insert(7, 35);\nconsole.log(doubleLinkList.toString());\n\nconsole.log(doubleLinkList.removeAt(0));\nconsole.log(doubleLinkList.removeAt(1));\nconsole.log(doubleLinkList.removeAt(5));\nconsole.log(doubleLinkList.toString());</code></pre><p id=\"cee026a6997be2fe2ca3b5d6e2ce2bf0_p_75\" class=\"ne-p\"><br></p><p id=\"28a7c119a7b8708c8cfc9833004e4e86_p_76\" class=\"ne-p\"><span class=\"ne-text\">-　对应的结果如下</span></p><p id=\"9fc1a1e32cf7c324fef5888bc3009382_p_77\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"aff9010a\" class=\"ne-codeblock language-javascript\"><code>[element: 10, prev: null, next: 15] [element: 15, prev: 10, next: 20] [element: 20, prev: 15, next: 25] [element: 25, prev: 20, next: 30] [element: 30, prev: 25, next: null] \n20\n[element: 9, prev: null, next: 10] [element: 10, prev: 9, next: 15] [element: 15, prev: 10, next: 20] [element: 20, prev: 15, next: 24] [element: 24, prev: 20, next: 25] [element: 25, prev: 24, next: 30] [element: 30, prev: 25, next: 35] [element: 35, prev: 30, next: null] \n15\n[element: 10, prev: null, next: 20] [element: 20, prev: 10, next: 24] [element: 24, prev: 20, next: 25] [element: 25, prev: 24, next: 35] [element: 35, prev: 25, next: null]</code></pre><p id=\"f585fed1cef9af7641b65ac1c4919258_p_78\" class=\"ne-p\"><br></p><h2 id=\"e99bcd83\"><span class=\"ne-text\">循环链表</span></h2><p id=\"f855fcce122120d1233c03106e601338_p_79\" class=\"ne-p\"><br></p><h3 id=\"61a3ec66\"><span class=\"ne-text\">介绍</span></h3><p id=\"cacc5e28cdefa24e262c83e0ab2a3ade_p_80\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"9ba304ef5ef40b56856fd834e2552ea3_p_81\" class=\"ne-p\"><span class=\"ne-text\">顾名思义，循环链表的尾部指向它自己的头部。循环链表可以有单向循环链表，也可以有双向循环链表。下面是单向循环链表和双向循环链表的数据结构示意图</span></p></div><p id=\"1a51c9f1188a20d8f4ddd78fcfd5029c\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705287564-4531cdeb-9452-4e71-a303-44e9c7c6e029.png\" width=\"813\" id=\"jcuvb\" class=\"ne-image\"></p><p id=\"470257ffbff08ad0eedbc557452f8c66_p_84\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"e58586690da8f83c90d1fcda883aeab1_p_85\" class=\"ne-p\"><span class=\"ne-text\">在实现循环链表时，需要确保最后一个元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\">。下面是单向循环链表的完整代码</span></p></div><p id=\"c07d4a2054239914d4a014d7d64fcf23_p_86\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0e5a6b7f\" class=\"ne-codeblock language-javascript\"><code>class CircularLinkList extends LinkList {\n  constructor() {\n    super();\n  }\n  append(element) {\n    let node = new ListNode(element);\n    if (this.head === null) this.head = node;\n    else {\n      let current = this.getElementAt(this.length - 1);\n      current.next = node;\n    }\n    // 将新添加的元素的 next 指向 head\n    node.next = this.head;\n    this.length++;\n  }\n  insert(element, position) {\n    if (position &lt; 0 || position &gt; this.length - 1) return false;\n    let node = new ListNode(element);\n    if (position === 0) {\n      node.next = this.head;\n      let current = this.getElementAt(this.length - 1);\n      current.next = node;\n      this.head = node;\n    } else {\n      var previous = this.getElementAt(position - 1);\n      node.next = previous.next;\n      previous.next = node;\n    }\n    this.length++;\n    return true;\n  }\n  removeAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) return null;\n    let current = this.head;\n    if (position === 0) this.head = current.next;\n    else {\n      let previous = this.getElementAt(position - 1);\n      current = previous.next;\n      previous.next = current.next;\n    }\n    this.length--;\n    if (this.length &gt; 1) {\n      let last = this.getElementAt(this.length - 1);\n      last.next = this.head;\n    }\n    return current.element;\n  }\n  toString() {\n    let current = this.head;\n    let s = '';\n    for (let i = 0; i &lt; this.length; i++) {\n      let next = current.next;\n      next = next ? next.element : 'null';\n      s += `[element: ${current.element}, next: ${next}]`;\n      current = current.next;\n    }\n  }\n}</code></pre><p id=\"bd67236b6b40e1ddeba66aa4c905c5af_p_87\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"d37c3e02383ce61ac96e1a5ffe252903_li_19\" data-lake-index-type=\"0\"><span class=\"ne-text\">单向循环链表的测试用例</span></li></ul><p id=\"ac4c0d2013d04adfac6d2e9459525ac0_p_88\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"dd66533a\" class=\"ne-codeblock language-javascript\"><code>let circularLinkList = new CircularLinkList();\ncircularLinkList.append(10);\ncircularLinkList.append(15);\ncircularLinkList.append(20);\n\nconsole.log(circularLinkList.toString());\n\ncircularLinkList.insert(0, 9);\ncircularLinkList.insert(3, 25);\nconsole.log(circularLinkList.toString());\n\nconsole.log(circularLinkList.removeAt(0));\nconsole.log(circularLinkList.toString());</code></pre><p id=\"ab51a4ad9cb9ee48199bb5c9fc6715a2_p_89\" class=\"ne-p\"><br></p><p id=\"98cc90e5a061e870651ed34f20c695df_p_90\" class=\"ne-p\"><span class=\"ne-text\">-　对应的结果如下</span></p><p id=\"55b4793bc7d98162a0d6addc99b469ec\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705316856-b6b81605-b48c-462c-adc6-57b21fecd1bf.png\" width=\"1086\" id=\"ODmE6\" class=\"ne-image\"></p></div>",
  "body": "链表用来存储有序的元素集合，与数组不同，链表中的元素并非保存在连续的存储空间内，每个元素由一个存储元素本身的节点和一个指向下一个元素的指针构成。当要移动或删除元素时，只需要修改相应元素上的指针就可以了。对链表元素的操作要比对数组元素的操作效率更高。下面是链表数据结构的示意图<br />![linkList.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704346914-b3d8a713-634d-45fe-ad2c-e040f9985485.png#averageHue=%23ededed&height=118&id=VpKv4&originHeight=118&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6139&status=done&style=none&title=&width=687)\n\n- 上面链表中每一个元素只有一个 `next` 指针，用来指向下一个节点，这样的链表称之为单向链表，我们只能从链表的头部开始遍历整个链表，任何一个节点只能找到它的下一个节点，而不能找到它的上一个节点。双向链表中的每一个元素拥有两个指针，一个用来指向下一个节点，一个用来指向上一个节点。在双向链表中，除了可以像单向链表一样从头部开始遍历之外，还可以从尾部进行遍历。下面是双向链表的数据结构示意图：\n\n![doubleLinkList.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704367520-532d5db4-3fde-4ac4-8de5-4fd3e1d287e1.png#averageHue=%23ececec&height=123&id=OZJLc&originHeight=123&originWidth=811&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8281&status=done&style=none&title=&width=811)\n<a name=\"72786a69\"></a>\n## 单向链表\n\n<a name=\"f411d0f1\"></a>\n### 说明\n\n> 要实现链表数据结构，关键在于保存 `head` 元素（即链表的头元素）以及每一个元素的 `next` 指针，有这两部分我们就可以很方便地遍历链表从而操作所有的元素。可以把链表想象成一条锁链，锁链中的每一个节点都是相互连接的，我们只要找到锁链的头，整条锁链就都可以找到了。让我们来看一下具体的实现方式。\n\n\n<a name=\"52b36576\"></a>\n### 步骤\n\n- 首先我们需要一个辅助类，用来描述链表中的节点。这个类很简单，只需要两个属性，一个用来保存节点的值，一个用来保存指向下一个节点的指针。\n\n```javascript\nfunction ListNode(element) {\n  this.element = element;\n  this.next = null;\n}\n```\n\n- 下面是链表类的基本骨架\n\n```javascript\nclass LinkList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n  }\n  // 向链表中添加节点\n  append(element) {\n    var node = new ListNode(element);\n    if (this.head === null) {\n      this.head = node;\n    } else {\n      var current = this.getElementAt(this.length - 1);\n      current.next = node;\n    }\n    this.length++;\n  }\n  // 在链表的指定位置插入节点\n  insert(position, element) {\n    if (position < 0 || position > this.length - 1) {\n      return false;\n    }\n    var node = new ListNode(element);\n    if (position === 0) {\n      node.next = this.head;\n      this.head = node;\n    } else {\n      var previous = this.getElementAt(position - 1);\n      node.next = previous.next;\n      previous.next = node;\n    }\n    this.length++;\n    return true;\n  }\n  // 删除链表中指定位置的元素，并返回这个元素的值\n  removeAt(position) {\n    if (position < 0 || position > this.length - 1) {\n      return null;\n    }\n    var current = this.head;\n    if (position === 0) {\n      this.head = current.next;\n    } else {\n      var previous = this.getElementAt(position - 1);\n      current = previous.next;\n      previous.next = current.next;\n    }\n    this.length--;\n    return current.element;\n  }\n  // 删除链表中对应的元素\n  remove(element) {\n    var index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n  // 在链表中查找给定元素的索引\n  indexOf(element) {\n    var current = this.head;\n    for (var i = 0; i < this.length; i++) {\n      if (current.element === element) {\n        return i;\n      }\n      current = current.next;\n    }\n    return -1;\n  }\n  // 返回链表中索引所对应的元素\n  getElementAt(position) {\n    if (position < 0 || position > this.length - 1) {\n      return null;\n    }\n    var current = this.head;\n    for (var i = 0; i < position; i++) {\n      current = current.next;\n    }\n    return current;\n  }\n  // 判断链表是否为空\n  isEmpty() {\n    // return this.head === null;\n    return this.length === 0;\n  }\n  // 返回链表的长度\n  size() {\n    return this.length;\n  }\n  // 返回头节点\n  getHead() {\n    return this.head;\n  }\n  // 清空链表\n  clear() {\n    this.head = null;\n    this.length = 0;\n  }\n  // 辅助方法，按指定格式输出链表中的所有元素，方便测试验证结果\n  toString() {\n    var current = this.head;\n    var s = '';\n\n    while (current) {\n      var next = current.next;\n      next = next ? next.element : 'null';\n      s += `[element: ${current.element}, next: ${next}] `;\n      current = current.next;\n    }\n\n    return s;\n  }\n}\n```\n\n- 让我们从查找链表元素的方法 `getElementAt()` 开始，因为后面我们会多次用到它。\n\n```javascript\ngetElementAt(position) {\n  if (position < 0 || position > this.length - 1) {\n    return null;\n  }\n  var current = this.head;\n  for (var i = 0; i < position; i++) {\n    current = current.next;\n  }\n  return current;\n}\n```\n\n> 首先判断参数 `position` 的边界值，如果值超出了索引的范围（小于 `0` 或者大于`length - 1`），则返回 `null`。我们从链表的 `head` 开始，遍历整个链表直到找到对应索引位置的节点，然后返回这个节点。是不是很简单？和所有有序数据集合一样，链表的索引默认从 `0` 开始，只要找到了链表的头（所以我们必须在 `LinkList` 类中保存 `head` 值），然后就可以遍历找到索引所在位置的元素。\n\n\n- 有了 `getElementAt()` 方法，接下来我们就可以很方便地实现 `append()` 方法，用来在链表的尾部添加新节点。\n\n```javascript\nappend(element) {\n  var node = new ListNode(element);\n  // 如果当前链表为空，则将 head 指向 node\n  if (this.head === null) {\n    this.head = node;\n  } else {\n    // 否则，找到链表尾部的元素，然后添加新元素\n    var current = this.getElementAt(this.length - 1);\n    current.next = node;\n  }\n  this.length++;\n}\n```\n\n> 如果链表的 `head` 为 `null`（这种情况表示链表为空），则直接将 `head` 指向新添加的元素。否则，通过 `getElementAt()` 方法找到链表的最后一个节点，将该节点的 `next` 指针指向新添加的元素。新添加的元素的 `next` 指针默认为 `null`，链表最后一个元素的 `next` 值为 `null`。将节点挂到链表上之后，不要忘记将链表的长度加 `1`，我们需要通过`length` 属性来记录链表的长度。\n\n\n- 接下来我们要实现 `insert()` 方法，可以在链表的任意位置添加节点。\n\n```javascript\ninsert(position, element) {\n  // position 不能超过边界值\n  if (position < 0 || position > this.length - 1) {\n    return false;\n  }\n\n  var node = new ListNode(element);\n\n  if (position === 0) {\n    node.next = this.head;\n    this.head = node;\n  } else {\n    var previous = this.getElementAt(position - 1);\n    node.next = previous.next;\n    previous.next = node;    \n  }\n  this.length++;\n  return true;\n}\n```\n\n> 首先也是要判断参数 `position` 的边界值，不能越界。当 `position` 的值为 `0` 时，表示要在链表的头部插入新节点，对应的操作如下图所示。将新插入节点的 `next` 指针指向现在的 `head`，然后更新 `head` 的值为新插入的节点。\n\n![linkList_insert1.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704395087-c23664dd-c205-44d5-9e63-870bf14ec0b1.png#averageHue=%23f1f1f1&height=205&id=ZmDav&originHeight=205&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11778&status=done&style=none&title=&width=687)\n\n> 如果要插入的节点在链表的中间或者尾部，对应的操作如下图。假设链表长度为 `3`，要在位置 `2` 插入新节点，我们首先找到位置 `2` 的前一个节点 `previous node`，将新节点 `new node` 的 `next` 指针指向 `previous node` 的 `next` 所对应的节点，然后再将`previous node` 的 `next` 指针指向 `new node`，这样就把新节点挂到链表中了。考虑一下，当插入的节点在链表的尾部，这种情况也是适用的。而如果链表为空，即链表的 `head` 为 `null`，则参数 `position` 会超出边界条件，从而 `insert()` 方法会直接返回 `false`。\n\n![linkList_insert2.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704419032-051f8ebf-b913-43a0-8473-afb6535e64f9.png#averageHue=%23f1f1f1&height=205&id=JgFG3&originHeight=205&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12178&status=done&style=none&title=&width=687)\n> 最后，别忘了更新 `length` 属性的值，将链表的长度加 `1`。\n\n\n- 按照相同的方式，我们可以很容易地写出 `removeAt()` 方法，用来删除链表中指定位置的节点。\n\n```javascript\nremoveAt(position) {\n  // position 不能超出边界值\n  if (position < 0 || position > this.length - 1) {\n    return null;\n  }\n  var current = this.head;\n  if (position === 0) {\n    this.head = current.next;\n  } else {\n    var previous = this.getElementAt(position - 1);\n    current = previous.next;\n    previous.next = current.next;\n  }\n  this.length--;\n  return current.element;\n}\n```\n\n> 下面两张示意图说明了从链表头部和其它位置删除节点的情况。\n\n![linkList_removeAt1.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608705111553-9ff6c07c-5b98-408d-952e-625082c91c70.png#averageHue=%23f2f2f2&height=205&id=MhjJL&originHeight=205&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10618&status=done&style=none&title=&width=687)<br />![linkList_removeAt2.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608705120449-8a4c3bff-e7e3-4338-883f-c230e291392b.png#averageHue=%23f2f2f2&height=205&id=R7Y5r&originHeight=205&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8551&status=done&style=none&title=&width=687)\n\n> 如果要删除的节点为链表的头部，只需要将 `head` 移到下一个节点即可。如果当前链表只有一个节点，那么下一个节点为 `null`，此时将 `head` 指向下一个节点等同于将 `head` 设置成 `null`，删除之后链表为空。如果要删除的节点在链表的中间部分，我们需要找出 `position` 所在位置的前一个节点，将它的 `next` 指针指向 `position` 所在位置的下一个节点。总之，删除节点只需要修改相应节点的指针，使断开位置左右相邻的节点重新连接上。被删除的节点由于再也没有其它部分的引用而被丢弃在内存中，等待垃圾回收器来清除。\n\n\n> 最后，别忘了将链表的长度减 `1`。\n\n\n- 下面我们来看看 `indexOf()` 方法，该方法返回给定元素在链表中的索引位置。\n\n```javascript\nindexOf(element) {\n  var current = this.head;\n\n  for (var i = 0; i < this.length; i++) {\n    if (current.element === element) {\n      return i;\n    }\n    current = current.next;\n  }\n\n  return -1;\n}\n```\n\n> 我们从链表的头部开始遍历，直到找到和给定元素相同的元素，然后返回对应的索引号。如果没有找到对应的元素，则返回 `-1`。\n\n\n- 在 `isEmpty()` 方法中，我们可以根据 `length` 是否为 `0` 来判断链表是否为空，当然也可以根据 `head` 是否为 `null` 来进行判断，前提是所有涉及到链表节点添加和移除的方法都要正确地更新 `length` 和 `head`。`toString()` 方法只是为了方便测试而编写的，我们来看看几个测试用例：\n\n```javascript\nvar linkList = new LinkList();\nlinkList.append(10);\nlinkList.append(15);\nlinkList.append(20);\nconsole.log(linkList.toString());\n\nlinkList.insert(0, 9);\nlinkList.insert(2, 11);\nlinkList.insert(5, 25);\nconsole.log(linkList.toString());\n\nconsole.log(linkList.removeAt(0));\nconsole.log(linkList.removeAt(1));\nconsole.log(linkList.removeAt(3));\nconsole.log(linkList.toString());\n\nconsole.log(linkList.indexOf(20));\n\nlinkList.remove(20);\n\nconsole.log(linkList.toString());\n\nlinkList.clear();\nconsole.log(linkList.size());\n```\n\n![linkList_test.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608705261819-5917b870-8756-4de9-8e66-be0548d56213.png#averageHue=%232b2b24&height=171&id=ivo2u&originHeight=171&originWidth=1306&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14507&status=done&style=none&title=&width=1306)\n\n<a name=\"b5fb11e9\"></a>\n## 双向链表\n\n<a name=\"52b36576-1\"></a>\n### 步骤\n\n> 由于双向链表具有单向链表的所有特性，因此我们的双向链表类可以继承自前面的单向链表类，不过辅助类 `Node` 需要添加一个 `prev` 属性，用来指向前一个节点。\n\n\n```javascript\nfunction Node(element) {\n  this.element = element;\n  this.next = null;\n  this.prev = null;\n}\n```\n\n- 下面是继承自 `LinkList` 类的双向链表类的基本骨架\n\n```javascript\nclass DoubleLinkList extends LinkList {\n  constructor() {\n    super();\n    this.tail = null; // 尾节点\n  }\n}\n```\n\n- 先来看看 `append()` 方法的实现。当链表为空时，除了要将 `head` 指向当前添加的节点外，还要将 `tail` 也指向当前要添加的节点。当链表不为空时，直接将 `tail` 的 `next` 指向当前要添加的节点 `node`，然后修改 `node` 的 `prev` 指向旧的 `tail`，最后修改 `tail` 为新添加的节点。我们不需要从头开始遍历整个链表，而通过 `tail` 可以直接找到链表的尾部，这一点比单向链表的操作要更方便。最后将 `length` 的值加 `1`，修改链表的长度。\n\n```javascript\nappend(element) {\n  var node = new Node(element);\n\n  // 如果链表为空，则将 head 和 tail 都指向当前添加的节点\n  if (this.head === null) {\n    this.head = node;\n    this.tail = node;\n  } else {\n    // 否则，将当前节点添加到链表的尾部\n    this.tail.next = node;\n    node.prev = this.tail;\n    this.tail = node;\n  }\n  this.length++;\n}\n```\n\n- 由于双向链表可以从链表的尾部往前遍历，所以我们修改了 `getElementAt()` 方法，对基类中单向链表的方法进行了改写。当要查找的元素的索引号大于链表长度的一半时，从链表的尾部开始遍历。\n\n```javascript\ngetELementAt(position) {\n  if (position < 0 || position > this.length - 1) return null;\n  // 从后向前遍历\n  if (position > Math.floor(this.length / 2)) {\n    var current = this.tail;\n    for (var i = this.length - 1; i > position; i--) {\n      current = current.prev;\n    }\n    return current;\n  } else {\n    return super.getELementAt(position);\n  }\n}\n```\n\n> 有两种遍历方式，从前往后遍历调用的是基类单向链表里的方法，从后往前遍历需要用到节点的 `prev` 指针，用来查找前一个节点。\n\n\n- 我们同时还需要修改 `insert()` 和 `removeAt()` 这两个方法。记住，与单向链表唯一的区别就是要同时维护 `head` 和 `tail`，以及每一个节点上的 `next` 和 `prev` 指针。\n\n```javascript\ninsert(position, element) {\n  if (position < 0 || position > this.length - 1) return false;\n\n  // 插入到尾部\n  if (position === this.length) {\n    this.append(element);\n  } else {\n    var node = new ListNode(element);\n    // 插入到头部\n    if (position === 0) {\n      if (this.head === null) {\n        this.head = node;\n        this.tail = node;\n      } else {\n        node.next = this.head;\n        this.head.prev = node;\n        this.head = node;\n      }\n    } else {\n      // 插入到中间位置\n      var current = this.getElementAt(position);\n      var previous = current.prev;\n      node.next = current;\n      node.prev = previous;\n      previous.next = node;\n      current.prev = node;\n    }\n  }\n  this.length++;\n  return true;\n}\n\nremoveAt(position) {\n  if (position < 0 || position > this.length - 1) return null;\n\n  var current = this.head;\n  var previous;\n\n  // 移除头部元素\n  if (position === 0) {\n    this.head = current.next;\n    this.head.prev = null;\n    if (this.length === 1) {\n      this.tail = null;\n    }\n  } else if (position === this.length - 1) {\n    // 移除尾部元素\n    current = this.tail;\n    this.tail = current.prev;\n    this.tail.next = null;\n  } else {\n    // 移除中间元素\n    current = this.getELementAt(position);\n    previous = current.prev;\n    previous.next = current.next;\n    current.next.prev = previous;\n  }\n  this.length--;\n  return current.element;\n}\n```\n\n- 操作过程中需要判断一些特殊情况，例如链表的头和尾，以及当前链表是否为空等等，否则程序可能会在某些特殊情况下导致越界和报错。下面是一个完整的双向链表类的代码\n\n```javascript\nclass DoubleLinkList extends LinkList {\n  constructor() {\n    super();\n    this.tail = null;\n  }\n  append(element) {\n    var node = new ListNode(element);\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n    } else {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    }\n    this.length++;\n  }\n  getElementAt(position) {\n    if (position < 0 || position > this.length - 1) return null;\n    if (position > Math.floor(this.length / 2)) {\n      var current = this.tail;\n      for (var i = this.length - 1; i > position; i--) {\n        current = current.prev;\n      }\n      return current;\n    } else {\n      super.getElementAt(position);\n    }\n  }\n  insert(position, element) {\n    if (position < 0 || position > this.length - 1) return false;\n\n    if (position === this.length) {\n      this.append(element);\n    } else {\n      var node = new ListNode(element);\n      if (position === 0) {\n        if (this.head === null) {\n          this.head = node;\n          this.tail = node;\n        } else {\n          node.next = this.head;\n          this.head.prev = node;\n          this.head = node;\n        }\n      } else {\n        var current = this.getElementAt(position);\n        var previous = current.prev;\n        node.next = current;\n        node.prev = previous;\n        previous.next = node;\n        current.prev = node;\n      }\n    }\n    this.length++;\n    return true;\n  }\n  removeAt(position) {\n    if (position < 0 || position > this.length - 1) return null;\n    var current = this.head;\n    var previous;\n    if (position === 0) {\n      this.head = current.next;\n      this.head.prev = null;\n      if (this.length === 1) {\n        this.tail = null; \n      }\n    } else if (position === this.length - 1) {\n      current = this.tail;\n      this.tail = current.prev;\n      this.tail.next = null;\n    } else {\n      current = this.getElementAt(position);\n      previous = current.prev;\n      previous.next = current.next;\n      current.next.prev = previous;\n    }\n    this.length--;\n    return current.element;\n  }\n  getTail() {\n    return this.tail;\n  }\n  clear() {\n    super.clear();\n    this.tail = null;\n  }\n  toString() {\n    var current = this.head;\n    var s = '';\n\n    while (current) {\n      var next = current.next;\n      var previous = current.prev;\n      next = next ? next.element : 'null';\n      previous = previous ? previous.element : 'null';\n      s += `[element: ${current.element}, prev: ${previous}, next: ${next}]`;\n      current = current.next;\n    }\n\n    return s;\n  }\n}\n```\n\n- 我们重写了 `toString()` 方法以方便更加清楚地查看测试结果。下面是一些测试用例：\n\n```javascript\nlet doubleLinkList = new DoubleLinkList();\ndoubleLinkList.append(10);\ndoubleLinkList.append(15);\ndoubleLinkList.append(20);\ndoubleLinkList.append(25);\ndoubleLinkList.append(30);\nconsole.log(doubleLinkList.toString());\nconsole.log(doubleLinkList.getElementAt(1).element);\nconsole.log(doubleLinkList.getElementAt(2).element);\nconsole.log(doubleLinkList.getElementAt(3).element);\n\ndoubleLinkList.insert(0, 9);\ndoubleLinkList.insert(4, 24);\ndoubleLinkList.insert(7, 35);\nconsole.log(doubleLinkList.toString());\n\nconsole.log(doubleLinkList.removeAt(0));\nconsole.log(doubleLinkList.removeAt(1));\nconsole.log(doubleLinkList.removeAt(5));\nconsole.log(doubleLinkList.toString());\n```\n\n-　对应的结果如下\n\n```javascript\n[element: 10, prev: null, next: 15] [element: 15, prev: 10, next: 20] [element: 20, prev: 15, next: 25] [element: 25, prev: 20, next: 30] [element: 30, prev: 25, next: null] \n20\n[element: 9, prev: null, next: 10] [element: 10, prev: 9, next: 15] [element: 15, prev: 10, next: 20] [element: 20, prev: 15, next: 24] [element: 24, prev: 20, next: 25] [element: 25, prev: 24, next: 30] [element: 30, prev: 25, next: 35] [element: 35, prev: 30, next: null] \n15\n[element: 10, prev: null, next: 20] [element: 20, prev: 10, next: 24] [element: 24, prev: 20, next: 25] [element: 25, prev: 24, next: 35] [element: 35, prev: 25, next: null]\n```\n\n<a name=\"e99bcd83\"></a>\n## 循环链表\n\n<a name=\"61a3ec66\"></a>\n### 介绍\n\n> 顾名思义，循环链表的尾部指向它自己的头部。循环链表可以有单向循环链表，也可以有双向循环链表。下面是单向循环链表和双向循环链表的数据结构示意图\n\n![linkList_around.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608705287564-4531cdeb-9452-4e71-a303-44e9c7c6e029.png#averageHue=%23d1d1d1&height=299&id=jcuvb&originHeight=299&originWidth=813&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13882&status=done&style=none&title=&width=813)\n\n> 在实现循环链表时，需要确保最后一个元素的 `next` 指针指向 `head`。下面是单向循环链表的完整代码\n\n\n```javascript\nclass CircularLinkList extends LinkList {\n  constructor() {\n    super();\n  }\n  append(element) {\n    let node = new ListNode(element);\n    if (this.head === null) this.head = node;\n    else {\n      let current = this.getElementAt(this.length - 1);\n      current.next = node;\n    }\n    // 将新添加的元素的 next 指向 head\n    node.next = this.head;\n    this.length++;\n  }\n  insert(element, position) {\n    if (position < 0 || position > this.length - 1) return false;\n    let node = new ListNode(element);\n    if (position === 0) {\n      node.next = this.head;\n      let current = this.getElementAt(this.length - 1);\n      current.next = node;\n      this.head = node;\n    } else {\n      var previous = this.getElementAt(position - 1);\n      node.next = previous.next;\n      previous.next = node;\n    }\n    this.length++;\n    return true;\n  }\n  removeAt(position) {\n    if (position < 0 || position > this.length - 1) return null;\n    let current = this.head;\n    if (position === 0) this.head = current.next;\n    else {\n      let previous = this.getElementAt(position - 1);\n      current = previous.next;\n      previous.next = current.next;\n    }\n    this.length--;\n    if (this.length > 1) {\n      let last = this.getElementAt(this.length - 1);\n      last.next = this.head;\n    }\n    return current.element;\n  }\n  toString() {\n    let current = this.head;\n    let s = '';\n    for (let i = 0; i < this.length; i++) {\n      let next = current.next;\n      next = next ? next.element : 'null';\n      s += `[element: ${current.element}, next: ${next}]`;\n      current = current.next;\n    }\n  }\n}\n```\n\n- 单向循环链表的测试用例\n\n```javascript\nlet circularLinkList = new CircularLinkList();\ncircularLinkList.append(10);\ncircularLinkList.append(15);\ncircularLinkList.append(20);\n\nconsole.log(circularLinkList.toString());\n\ncircularLinkList.insert(0, 9);\ncircularLinkList.insert(3, 25);\nconsole.log(circularLinkList.toString());\n\nconsole.log(circularLinkList.removeAt(0));\nconsole.log(circularLinkList.toString());\n```\n\n-　对应的结果如下<br />![linList_around_result.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608705316856-b6b81605-b48c-462c-adc6-57b21fecd1bf.png#averageHue=%232e2e26&height=87&id=ODmE6&originHeight=87&originWidth=1086&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9699&status=done&style=none&title=&width=1086)\n",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><p id=\"8b9b28b86315b765178b080bc38ae357\" class=\"ne-p\"><span class=\"ne-text\">链表用来存储有序的元素集合，与数组不同，链表中的元素并非保存在连续的存储空间内，每个元素由一个存储元素本身的节点和一个指向下一个元素的指针构成。当要移动或删除元素时，只需要修改相应元素上的指针就可以了。对链表元素的操作要比对数组元素的操作效率更高。下面是链表数据结构的示意图</span></p><p id=\"72463c7b18450670c3a6f51a033e7705_p_4\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704346914-b3d8a713-634d-45fe-ad2c-e040f9985485.png\" width=\"687\" id=\"VpKv4\" class=\"ne-image\"></p><p id=\"7467903a77e4c43e92d4f196903d0bbe_p_5\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"e4dd054a65272350f615a79c1a64f043_li_4\" data-lake-index-type=\"0\"><span class=\"ne-text\">上面链表中每一个元素只有一个 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针，用来指向下一个节点，这样的链表称之为单向链表，我们只能从链表的头部开始遍历整个链表，任何一个节点只能找到它的下一个节点，而不能找到它的上一个节点。双向链表中的每一个元素拥有两个指针，一个用来指向下一个节点，一个用来指向上一个节点。在双向链表中，除了可以像单向链表一样从头部开始遍历之外，还可以从尾部进行遍历。下面是双向链表的数据结构示意图：</span></li></ul><p id=\"0ece3fcfc6cfe87dcd2fbef555e7fa0e\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704367520-532d5db4-3fde-4ac4-8de5-4fd3e1d287e1.png\" width=\"811\" id=\"OZJLc\" class=\"ne-image\"></p><h2 id=\"72786a69\"><span class=\"ne-text\">单向链表</span></h2><p id=\"92c8228235b93f7cc9ced6ac90fca3a6_p_8\" class=\"ne-p\"><br></p><h3 id=\"f411d0f1\"><span class=\"ne-text\">说明</span></h3><p id=\"eadc4ec477465f1f239730d987d394b1_p_9\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"4e0f7020a8c91a492857b08e9cc58082_p_10\" class=\"ne-p\"><span class=\"ne-text\">要实现链表数据结构，关键在于保存 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 元素（即链表的头元素）以及每一个元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针，有这两部分我们就可以很方便地遍历链表从而操作所有的元素。可以把链表想象成一条锁链，锁链中的每一个节点都是相互连接的，我们只要找到锁链的头，整条锁链就都可以找到了。让我们来看一下具体的实现方式。</span></p></div><p id=\"828bea0262f636b25c97fbef525aed20_p_11\" class=\"ne-p\"><br></p><h3 id=\"52b36576\"><span class=\"ne-text\">步骤</span></h3><p id=\"09a2b5671cf447a1a3529d71c89cf9e1_p_12\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"dd1e0b174e1d660e60418c341a173d86_li_5\" data-lake-index-type=\"0\"><span class=\"ne-text\">首先我们需要一个辅助类，用来描述链表中的节点。这个类很简单，只需要两个属性，一个用来保存节点的值，一个用来保存指向下一个节点的指针。</span></li></ul><p id=\"2369fafe89fae403079018df6f36b51b_p_13\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d857bee2\" class=\"ne-codeblock language-javascript\"><code>function ListNode(element) {\n  this.element = element;\n  this.next = null;\n}</code></pre><p id=\"7cf79ceeaaf91ef14264b4c55c1c8c1d_p_14\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"80545d0bc091d3aa67a632280c9c644f_li_6\" data-lake-index-type=\"0\"><span class=\"ne-text\">下面是链表类的基本骨架</span></li></ul><p id=\"c53070088aadb43ef468f61fca8ca22a_p_15\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"27d7fcec\" class=\"ne-codeblock language-javascript\"><code>class LinkList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n  }\n  // 向链表中添加节点\n  append(element) {\n    var node = new ListNode(element);\n    if (this.head === null) {\n      this.head = node;\n    } else {\n      var current = this.getElementAt(this.length - 1);\n      current.next = node;\n    }\n    this.length++;\n  }\n  // 在链表的指定位置插入节点\n  insert(position, element) {\n    if (position &lt; 0 || position &gt; this.length - 1) {\n      return false;\n    }\n    var node = new ListNode(element);\n    if (position === 0) {\n      node.next = this.head;\n      this.head = node;\n    } else {\n      var previous = this.getElementAt(position - 1);\n      node.next = previous.next;\n      previous.next = node;\n    }\n    this.length++;\n    return true;\n  }\n  // 删除链表中指定位置的元素，并返回这个元素的值\n  removeAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) {\n      return null;\n    }\n    var current = this.head;\n    if (position === 0) {\n      this.head = current.next;\n    } else {\n      var previous = this.getElementAt(position - 1);\n      current = previous.next;\n      previous.next = current.next;\n    }\n    this.length--;\n    return current.element;\n  }\n  // 删除链表中对应的元素\n  remove(element) {\n    var index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n  // 在链表中查找给定元素的索引\n  indexOf(element) {\n    var current = this.head;\n    for (var i = 0; i &lt; this.length; i++) {\n      if (current.element === element) {\n        return i;\n      }\n      current = current.next;\n    }\n    return -1;\n  }\n  // 返回链表中索引所对应的元素\n  getElementAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) {\n      return null;\n    }\n    var current = this.head;\n    for (var i = 0; i &lt; position; i++) {\n      current = current.next;\n    }\n    return current;\n  }\n  // 判断链表是否为空\n  isEmpty() {\n    // return this.head === null;\n    return this.length === 0;\n  }\n  // 返回链表的长度\n  size() {\n    return this.length;\n  }\n  // 返回头节点\n  getHead() {\n    return this.head;\n  }\n  // 清空链表\n  clear() {\n    this.head = null;\n    this.length = 0;\n  }\n  // 辅助方法，按指定格式输出链表中的所有元素，方便测试验证结果\n  toString() {\n    var current = this.head;\n    var s = '';\n\n    while (current) {\n      var next = current.next;\n      next = next ? next.element : 'null';\n      s += `[element: ${current.element}, next: ${next}] `;\n      current = current.next;\n    }\n\n    return s;\n  }\n}</code></pre><p id=\"42752743bc6d3f9f6c928fb47989b8c2_p_16\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"a012eaef546925b976a236f8bd3f64e7_li_7\" data-lake-index-type=\"0\"><span class=\"ne-text\">让我们从查找链表元素的方法 </span><code class=\"ne-code\"><span class=\"ne-text\">getElementAt()</span></code><span class=\"ne-text\"> 开始，因为后面我们会多次用到它。</span></li></ul><p id=\"c5eaf555cee01ec836fc749258c6179d_p_17\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"63f782ef\" class=\"ne-codeblock language-javascript\"><code>getElementAt(position) {\n  if (position &lt; 0 || position &gt; this.length - 1) {\n    return null;\n  }\n  var current = this.head;\n  for (var i = 0; i &lt; position; i++) {\n    current = current.next;\n  }\n  return current;\n}</code></pre><p id=\"3f8949dd5527f0c9624c3fd3faefb76f_p_18\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"c6ec48e23d522d65bf625dd7fc70dcaf_p_19\" class=\"ne-p\"><span class=\"ne-text\">首先判断参数 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 的边界值，如果值超出了索引的范围（小于 </span><code class=\"ne-code\"><span class=\"ne-text\">0</span></code><span class=\"ne-text\"> 或者大于</span><code class=\"ne-code\"><span class=\"ne-text\">length - 1</span></code><span class=\"ne-text\">），则返回 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">。我们从链表的 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 开始，遍历整个链表直到找到对应索引位置的节点，然后返回这个节点。是不是很简单？和所有有序数据集合一样，链表的索引默认从 </span><code class=\"ne-code\"><span class=\"ne-text\">0</span></code><span class=\"ne-text\"> 开始，只要找到了链表的头（所以我们必须在 </span><code class=\"ne-code\"><span class=\"ne-text\">LinkList</span></code><span class=\"ne-text\"> 类中保存 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 值），然后就可以遍历找到索引所在位置的元素。</span></p></div><p id=\"db841a6e995b001085603629a3ace379_p_20\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"2d66a6505ab279bb08b85117369010b7_li_8\" data-lake-index-type=\"0\"><span class=\"ne-text\">有了 </span><code class=\"ne-code\"><span class=\"ne-text\">getElementAt()</span></code><span class=\"ne-text\"> 方法，接下来我们就可以很方便地实现 </span><code class=\"ne-code\"><span class=\"ne-text\">append()</span></code><span class=\"ne-text\"> 方法，用来在链表的尾部添加新节点。</span></li></ul><p id=\"54d418504a63791b75a5f497078fa24a_p_21\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"fe0473b5\" class=\"ne-codeblock language-javascript\"><code>append(element) {\n  var node = new ListNode(element);\n  // 如果当前链表为空，则将 head 指向 node\n  if (this.head === null) {\n    this.head = node;\n  } else {\n    // 否则，找到链表尾部的元素，然后添加新元素\n    var current = this.getElementAt(this.length - 1);\n    current.next = node;\n  }\n  this.length++;\n}</code></pre><p id=\"37928cd1f32681ee4810a9ab9d3c1104_p_22\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"0d2b77f2199ac7265917a3f688cdcc8b_p_23\" class=\"ne-p\"><span class=\"ne-text\">如果链表的 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">（这种情况表示链表为空），则直接将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 指向新添加的元素。否则，通过 </span><code class=\"ne-code\"><span class=\"ne-text\">getElementAt()</span></code><span class=\"ne-text\"> 方法找到链表的最后一个节点，将该节点的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向新添加的元素。新添加的元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针默认为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">，链表最后一个元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 值为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">。将节点挂到链表上之后，不要忘记将链表的长度加 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code><span class=\"ne-text\">，我们需要通过</span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 属性来记录链表的长度。</span></p></div><p id=\"1f3b4b4a4867a8b756c196b38558d0c4_p_24\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"b0ece2beb942cca306a5d6e038dbff74_li_9\" data-lake-index-type=\"0\"><span class=\"ne-text\">接下来我们要实现 </span><code class=\"ne-code\"><span class=\"ne-text\">insert()</span></code><span class=\"ne-text\"> 方法，可以在链表的任意位置添加节点。</span></li></ul><p id=\"3afe72986fc83f6913935faccbcf69b2_p_25\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0fadeda0\" class=\"ne-codeblock language-javascript\"><code>insert(position, element) {\n  // position 不能超过边界值\n  if (position &lt; 0 || position &gt; this.length - 1) {\n    return false;\n  }\n\n  var node = new ListNode(element);\n\n  if (position === 0) {\n    node.next = this.head;\n    this.head = node;\n  } else {\n    var previous = this.getElementAt(position - 1);\n    node.next = previous.next;\n    previous.next = node;    \n  }\n  this.length++;\n  return true;\n}</code></pre><p id=\"b57de0a6a045efefe71d109094be9ddc_p_26\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"fa9fe669f446436952510d0b04f9a327_p_27\" class=\"ne-p\"><span class=\"ne-text\">首先也是要判断参数 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 的边界值，不能越界。当 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 的值为 </span><code class=\"ne-code\"><span class=\"ne-text\">0</span></code><span class=\"ne-text\"> 时，表示要在链表的头部插入新节点，对应的操作如下图所示。将新插入节点的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向现在的 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\">，然后更新 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 的值为新插入的节点。</span></p></div><p id=\"c2f989dd0f058d43258fb7a314f90ca4\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704395087-c23664dd-c205-44d5-9e63-870bf14ec0b1.png\" width=\"687\" id=\"ZmDav\" class=\"ne-image\"></p><p id=\"d657ac1e4c3211af4f7dcea889518735_p_30\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"16010a0caa57e486c6540ca460620ade_p_31\" class=\"ne-p\"><span class=\"ne-text\">如果要插入的节点在链表的中间或者尾部，对应的操作如下图。假设链表长度为 </span><code class=\"ne-code\"><span class=\"ne-text\">3</span></code><span class=\"ne-text\">，要在位置 </span><code class=\"ne-code\"><span class=\"ne-text\">2</span></code><span class=\"ne-text\"> 插入新节点，我们首先找到位置 </span><code class=\"ne-code\"><span class=\"ne-text\">2</span></code><span class=\"ne-text\"> 的前一个节点 </span><code class=\"ne-code\"><span class=\"ne-text\">previous node</span></code><span class=\"ne-text\">，将新节点 </span><code class=\"ne-code\"><span class=\"ne-text\">new node</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向 </span><code class=\"ne-code\"><span class=\"ne-text\">previous node</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 所对应的节点，然后再将</span><code class=\"ne-code\"><span class=\"ne-text\">previous node</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向 </span><code class=\"ne-code\"><span class=\"ne-text\">new node</span></code><span class=\"ne-text\">，这样就把新节点挂到链表中了。考虑一下，当插入的节点在链表的尾部，这种情况也是适用的。而如果链表为空，即链表的 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">，则参数 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 会超出边界条件，从而 </span><code class=\"ne-code\"><span class=\"ne-text\">insert()</span></code><span class=\"ne-text\"> 方法会直接返回 </span><code class=\"ne-code\"><span class=\"ne-text\">false</span></code><span class=\"ne-text\">。</span></p></div><p id=\"39abba9494ef6da94608fbd0e487aa60_p_34\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704419032-051f8ebf-b913-43a0-8473-afb6535e64f9.png\" width=\"687\" id=\"JgFG3\" class=\"ne-image\"></p><div class=\"ne-quote\"><p id=\"ae75bb4df811b53ac3c664c56d8c1fa3_p_35\" class=\"ne-p\"><span class=\"ne-text\">最后，别忘了更新 </span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 属性的值，将链表的长度加 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code><span class=\"ne-text\">。</span></p></div><p id=\"6f8f966688575a1f666bafa122494f73_p_36\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"97dcf5372a3cedc8fc0514642c0cbfa4_li_10\" data-lake-index-type=\"0\"><span class=\"ne-text\">按照相同的方式，我们可以很容易地写出 </span><code class=\"ne-code\"><span class=\"ne-text\">removeAt()</span></code><span class=\"ne-text\"> 方法，用来删除链表中指定位置的节点。</span></li></ul><p id=\"ab57135091a86c42cc63ec67ac068a45_p_37\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"267e369c\" class=\"ne-codeblock language-javascript\"><code>removeAt(position) {\n  // position 不能超出边界值\n  if (position &lt; 0 || position &gt; this.length - 1) {\n    return null;\n  }\n  var current = this.head;\n  if (position === 0) {\n    this.head = current.next;\n  } else {\n    var previous = this.getElementAt(position - 1);\n    current = previous.next;\n    previous.next = current.next;\n  }\n  this.length--;\n  return current.element;\n}</code></pre><p id=\"82f45866a429f6224b2e92c65bfda254_p_38\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"3f3fd98cb4e8eab62e88d532e3d7b0c3_p_39\" class=\"ne-p\"><span class=\"ne-text\">下面两张示意图说明了从链表头部和其它位置删除节点的情况。</span></p></div><p id=\"fb18d8c69d5615182defd0ad2553d6e4\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705111553-9ff6c07c-5b98-408d-952e-625082c91c70.png\" width=\"687\" id=\"MhjJL\" class=\"ne-image\"></p><p id=\"aebb7af96a9ee3c9b7a669f28fef1d7e_p_42\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705120449-8a4c3bff-e7e3-4338-883f-c230e291392b.png\" width=\"687\" id=\"R7Y5r\" class=\"ne-image\"></p><p id=\"157b805d005afe38c7c2d5198b31ee6e_p_44\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"1e5528b26a18d968e53320129af8e26f_p_45\" class=\"ne-p\"><span class=\"ne-text\">如果要删除的节点为链表的头部，只需要将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 移到下一个节点即可。如果当前链表只有一个节点，那么下一个节点为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">，此时将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 指向下一个节点等同于将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 设置成 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">，删除之后链表为空。如果要删除的节点在链表的中间部分，我们需要找出 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 所在位置的前一个节点，将它的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向 </span><code class=\"ne-code\"><span class=\"ne-text\">position</span></code><span class=\"ne-text\"> 所在位置的下一个节点。总之，删除节点只需要修改相应节点的指针，使断开位置左右相邻的节点重新连接上。被删除的节点由于再也没有其它部分的引用而被丢弃在内存中，等待垃圾回收器来清除。</span></p></div><p id=\"e81b6efc8e2153cf8aa53e3b04d7f22c_p_46\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"d836f2fb214ecaed8dec32fa40e17e5f_p_47\" class=\"ne-p\"><span class=\"ne-text\">最后，别忘了将链表的长度减 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code><span class=\"ne-text\">。</span></p></div><p id=\"aa95668f5a65b03373d1b0b3f9f8d3a6_p_48\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"090d05326053a60eb487c6f1a8adb0fd_li_11\" data-lake-index-type=\"0\"><span class=\"ne-text\">下面我们来看看 </span><code class=\"ne-code\"><span class=\"ne-text\">indexOf()</span></code><span class=\"ne-text\"> 方法，该方法返回给定元素在链表中的索引位置。</span></li></ul><p id=\"233f53790c0b9d757f931748dd4d9e1e_p_49\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"78f94abd\" class=\"ne-codeblock language-javascript\"><code>indexOf(element) {\n  var current = this.head;\n\n  for (var i = 0; i &lt; this.length; i++) {\n    if (current.element === element) {\n      return i;\n    }\n    current = current.next;\n  }\n\n  return -1;\n}</code></pre><p id=\"4108a5bc411c7547dc6876b612b07f81_p_50\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"d3d16a640dc72a5f6ecfe699df4eb251_p_51\" class=\"ne-p\"><span class=\"ne-text\">我们从链表的头部开始遍历，直到找到和给定元素相同的元素，然后返回对应的索引号。如果没有找到对应的元素，则返回 </span><code class=\"ne-code\"><span class=\"ne-text\">-1</span></code><span class=\"ne-text\">。</span></p></div><p id=\"bc2359f7bb1e32241fa27f528e60a125_p_52\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"9c9801a1b5710689441aea5114c5451d_li_12\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">isEmpty()</span></code><span class=\"ne-text\"> 方法中，我们可以根据 </span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 是否为 </span><code class=\"ne-code\"><span class=\"ne-text\">0</span></code><span class=\"ne-text\"> 来判断链表是否为空，当然也可以根据 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 是否为 </span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\"> 来进行判断，前提是所有涉及到链表节点添加和移除的方法都要正确地更新 </span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\">。</span><code class=\"ne-code\"><span class=\"ne-text\">toString()</span></code><span class=\"ne-text\"> 方法只是为了方便测试而编写的，我们来看看几个测试用例：</span></li></ul><p id=\"0c6a7643ebb3931744a90899eb00ce0b_p_53\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"caa0199a\" class=\"ne-codeblock language-javascript\"><code>var linkList = new LinkList();\nlinkList.append(10);\nlinkList.append(15);\nlinkList.append(20);\nconsole.log(linkList.toString());\n\nlinkList.insert(0, 9);\nlinkList.insert(2, 11);\nlinkList.insert(5, 25);\nconsole.log(linkList.toString());\n\nconsole.log(linkList.removeAt(0));\nconsole.log(linkList.removeAt(1));\nconsole.log(linkList.removeAt(3));\nconsole.log(linkList.toString());\n\nconsole.log(linkList.indexOf(20));\n\nlinkList.remove(20);\n\nconsole.log(linkList.toString());\n\nlinkList.clear();\nconsole.log(linkList.size());</code></pre><p id=\"a74a1ae9e5a12e5ca252284043884853_p_55\" class=\"ne-p\"><br></p><p id=\"c7813883a63e45a345fd6584f3605108\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705261819-5917b870-8756-4de9-8e66-be0548d56213.png\" width=\"1306\" id=\"ivo2u\" class=\"ne-image\"></p><p id=\"a6e7204180aba568d27cc7b95d0717fd_p_56\" class=\"ne-p\"><br></p><h2 id=\"b5fb11e9\"><span class=\"ne-text\">双向链表</span></h2><p id=\"67592880a847e874a0da3af4d564ef1f_p_57\" class=\"ne-p\"><br></p><h3 id=\"52b36576-1\"><span class=\"ne-text\">步骤</span></h3><p id=\"e3c9bad72638009a374744280c63ecc6_p_58\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"71dfa86733f47d82c73b38a06d62e761_p_59\" class=\"ne-p\"><span class=\"ne-text\">由于双向链表具有单向链表的所有特性，因此我们的双向链表类可以继承自前面的单向链表类，不过辅助类 </span><code class=\"ne-code\"><span class=\"ne-text\">Node</span></code><span class=\"ne-text\"> 需要添加一个 </span><code class=\"ne-code\"><span class=\"ne-text\">prev</span></code><span class=\"ne-text\"> 属性，用来指向前一个节点。</span></p></div><p id=\"daa3e859dfee1b8825cb9c219dcb2526_p_60\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d581a74e\" class=\"ne-codeblock language-javascript\"><code>function Node(element) {\n  this.element = element;\n  this.next = null;\n  this.prev = null;\n}</code></pre><p id=\"d89d8c6a729313c0d25f9b1742c0d590_p_61\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"4c0fde53ab52bab59735979a46c369e6_li_13\" data-lake-index-type=\"0\"><span class=\"ne-text\">下面是继承自 </span><code class=\"ne-code\"><span class=\"ne-text\">LinkList</span></code><span class=\"ne-text\"> 类的双向链表类的基本骨架</span></li></ul><p id=\"9b034733f43578c770243b15c945bc07_p_62\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ada9a947\" class=\"ne-codeblock language-javascript\"><code>class DoubleLinkList extends LinkList {\n  constructor() {\n    super();\n    this.tail = null; // 尾节点\n  }\n}</code></pre><p id=\"87e34965e50e2c8e31ce44a85667e8dd_p_63\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"e7deef6eec135673422c81bcb1e849fa_li_14\" data-lake-index-type=\"0\"><span class=\"ne-text\">先来看看 </span><code class=\"ne-code\"><span class=\"ne-text\">append()</span></code><span class=\"ne-text\"> 方法的实现。当链表为空时，除了要将 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 指向当前添加的节点外，还要将 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\"> 也指向当前要添加的节点。当链表不为空时，直接将 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指向当前要添加的节点 </span><code class=\"ne-code\"><span class=\"ne-text\">node</span></code><span class=\"ne-text\">，然后修改 </span><code class=\"ne-code\"><span class=\"ne-text\">node</span></code><span class=\"ne-text\"> 的 </span><code class=\"ne-code\"><span class=\"ne-text\">prev</span></code><span class=\"ne-text\"> 指向旧的 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\">，最后修改 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\"> 为新添加的节点。我们不需要从头开始遍历整个链表，而通过 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\"> 可以直接找到链表的尾部，这一点比单向链表的操作要更方便。最后将 </span><code class=\"ne-code\"><span class=\"ne-text\">length</span></code><span class=\"ne-text\"> 的值加 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code><span class=\"ne-text\">，修改链表的长度。</span></li></ul><p id=\"b3add770127d8c2a5064673aa8a9731f_p_64\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"82b5988d\" class=\"ne-codeblock language-javascript\"><code>append(element) {\n  var node = new Node(element);\n\n  // 如果链表为空，则将 head 和 tail 都指向当前添加的节点\n  if (this.head === null) {\n    this.head = node;\n    this.tail = node;\n  } else {\n    // 否则，将当前节点添加到链表的尾部\n    this.tail.next = node;\n    node.prev = this.tail;\n    this.tail = node;\n  }\n  this.length++;\n}</code></pre><p id=\"2a81d6eed31dfd1dc3c193bbdb75c1a1_p_65\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"fb612dbf2bb2e66d056a6eaabc751c4a_li_15\" data-lake-index-type=\"0\"><span class=\"ne-text\">由于双向链表可以从链表的尾部往前遍历，所以我们修改了 </span><code class=\"ne-code\"><span class=\"ne-text\">getElementAt()</span></code><span class=\"ne-text\"> 方法，对基类中单向链表的方法进行了改写。当要查找的元素的索引号大于链表长度的一半时，从链表的尾部开始遍历。</span></li></ul><p id=\"cf44cb59378505901ec625cdc88d7d91_p_66\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"92923481\" class=\"ne-codeblock language-javascript\"><code>getELementAt(position) {\n  if (position &lt; 0 || position &gt; this.length - 1) return null;\n  // 从后向前遍历\n  if (position &gt; Math.floor(this.length / 2)) {\n    var current = this.tail;\n    for (var i = this.length - 1; i &gt; position; i--) {\n      current = current.prev;\n    }\n    return current;\n  } else {\n    return super.getELementAt(position);\n  }\n}</code></pre><p id=\"152302cc03cd3433e252fd8fbe4bade7_p_67\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"4d870fc948e9f1e7f3f99b3638b5d172_p_68\" class=\"ne-p\"><span class=\"ne-text\">有两种遍历方式，从前往后遍历调用的是基类单向链表里的方法，从后往前遍历需要用到节点的 </span><code class=\"ne-code\"><span class=\"ne-text\">prev</span></code><span class=\"ne-text\"> 指针，用来查找前一个节点。</span></p></div><p id=\"956e0d4312e941b77cd57ec35c294aff_p_69\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"1c6b2cbaa20f2b95f254bde42dfcc6be_li_16\" data-lake-index-type=\"0\"><span class=\"ne-text\">我们同时还需要修改 </span><code class=\"ne-code\"><span class=\"ne-text\">insert()</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">removeAt()</span></code><span class=\"ne-text\"> 这两个方法。记住，与单向链表唯一的区别就是要同时维护 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">tail</span></code><span class=\"ne-text\">，以及每一个节点上的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 和 </span><code class=\"ne-code\"><span class=\"ne-text\">prev</span></code><span class=\"ne-text\"> 指针。</span></li></ul><p id=\"67523e0fa28fe87849ce38cd391e3347_p_70\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"e965d6f7\" class=\"ne-codeblock language-javascript\"><code>insert(position, element) {\n  if (position &lt; 0 || position &gt; this.length - 1) return false;\n\n  // 插入到尾部\n  if (position === this.length) {\n    this.append(element);\n  } else {\n    var node = new ListNode(element);\n    // 插入到头部\n    if (position === 0) {\n      if (this.head === null) {\n        this.head = node;\n        this.tail = node;\n      } else {\n        node.next = this.head;\n        this.head.prev = node;\n        this.head = node;\n      }\n    } else {\n      // 插入到中间位置\n      var current = this.getElementAt(position);\n      var previous = current.prev;\n      node.next = current;\n      node.prev = previous;\n      previous.next = node;\n      current.prev = node;\n    }\n  }\n  this.length++;\n  return true;\n}\n\nremoveAt(position) {\n  if (position &lt; 0 || position &gt; this.length - 1) return null;\n\n  var current = this.head;\n  var previous;\n\n  // 移除头部元素\n  if (position === 0) {\n    this.head = current.next;\n    this.head.prev = null;\n    if (this.length === 1) {\n      this.tail = null;\n    }\n  } else if (position === this.length - 1) {\n    // 移除尾部元素\n    current = this.tail;\n    this.tail = current.prev;\n    this.tail.next = null;\n  } else {\n    // 移除中间元素\n    current = this.getELementAt(position);\n    previous = current.prev;\n    previous.next = current.next;\n    current.next.prev = previous;\n  }\n  this.length--;\n  return current.element;\n}</code></pre><p id=\"b7f5c253c3fb3956b40638fc0613cbf9_p_71\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"1e25a43370983bdf041a1d8097c0bd11_li_17\" data-lake-index-type=\"0\"><span class=\"ne-text\">操作过程中需要判断一些特殊情况，例如链表的头和尾，以及当前链表是否为空等等，否则程序可能会在某些特殊情况下导致越界和报错。下面是一个完整的双向链表类的代码</span></li></ul><p id=\"200b796b4b1f5a36aa12caae6b6fa3d8_p_72\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"4cc9d200\" class=\"ne-codeblock language-javascript\"><code>class DoubleLinkList extends LinkList {\n  constructor() {\n    super();\n    this.tail = null;\n  }\n  append(element) {\n    var node = new ListNode(element);\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n    } else {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    }\n    this.length++;\n  }\n  getElementAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) return null;\n    if (position &gt; Math.floor(this.length / 2)) {\n      var current = this.tail;\n      for (var i = this.length - 1; i &gt; position; i--) {\n        current = current.prev;\n      }\n      return current;\n    } else {\n      super.getElementAt(position);\n    }\n  }\n  insert(position, element) {\n    if (position &lt; 0 || position &gt; this.length - 1) return false;\n\n    if (position === this.length) {\n      this.append(element);\n    } else {\n      var node = new ListNode(element);\n      if (position === 0) {\n        if (this.head === null) {\n          this.head = node;\n          this.tail = node;\n        } else {\n          node.next = this.head;\n          this.head.prev = node;\n          this.head = node;\n        }\n      } else {\n        var current = this.getElementAt(position);\n        var previous = current.prev;\n        node.next = current;\n        node.prev = previous;\n        previous.next = node;\n        current.prev = node;\n      }\n    }\n    this.length++;\n    return true;\n  }\n  removeAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) return null;\n    var current = this.head;\n    var previous;\n    if (position === 0) {\n      this.head = current.next;\n      this.head.prev = null;\n      if (this.length === 1) {\n        this.tail = null; \n      }\n    } else if (position === this.length - 1) {\n      current = this.tail;\n      this.tail = current.prev;\n      this.tail.next = null;\n    } else {\n      current = this.getElementAt(position);\n      previous = current.prev;\n      previous.next = current.next;\n      current.next.prev = previous;\n    }\n    this.length--;\n    return current.element;\n  }\n  getTail() {\n    return this.tail;\n  }\n  clear() {\n    super.clear();\n    this.tail = null;\n  }\n  toString() {\n    var current = this.head;\n    var s = '';\n\n    while (current) {\n      var next = current.next;\n      var previous = current.prev;\n      next = next ? next.element : 'null';\n      previous = previous ? previous.element : 'null';\n      s += `[element: ${current.element}, prev: ${previous}, next: ${next}]`;\n      current = current.next;\n    }\n\n    return s;\n  }\n}</code></pre><p id=\"7e9db6e1dddd1090f9cbf7742b89f0d6_p_73\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"472e55dbf4deef5e801a1aea0c8b6d12_li_18\" data-lake-index-type=\"0\"><span class=\"ne-text\">我们重写了 </span><code class=\"ne-code\"><span class=\"ne-text\">toString()</span></code><span class=\"ne-text\"> 方法以方便更加清楚地查看测试结果。下面是一些测试用例：</span></li></ul><p id=\"d36608d2dcf9f070081537010b5adfb3_p_74\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"25634705\" class=\"ne-codeblock language-javascript\"><code>let doubleLinkList = new DoubleLinkList();\ndoubleLinkList.append(10);\ndoubleLinkList.append(15);\ndoubleLinkList.append(20);\ndoubleLinkList.append(25);\ndoubleLinkList.append(30);\nconsole.log(doubleLinkList.toString());\nconsole.log(doubleLinkList.getElementAt(1).element);\nconsole.log(doubleLinkList.getElementAt(2).element);\nconsole.log(doubleLinkList.getElementAt(3).element);\n\ndoubleLinkList.insert(0, 9);\ndoubleLinkList.insert(4, 24);\ndoubleLinkList.insert(7, 35);\nconsole.log(doubleLinkList.toString());\n\nconsole.log(doubleLinkList.removeAt(0));\nconsole.log(doubleLinkList.removeAt(1));\nconsole.log(doubleLinkList.removeAt(5));\nconsole.log(doubleLinkList.toString());</code></pre><p id=\"cee026a6997be2fe2ca3b5d6e2ce2bf0_p_75\" class=\"ne-p\"><br></p><p id=\"28a7c119a7b8708c8cfc9833004e4e86_p_76\" class=\"ne-p\"><span class=\"ne-text\">-　对应的结果如下</span></p><p id=\"9fc1a1e32cf7c324fef5888bc3009382_p_77\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"aff9010a\" class=\"ne-codeblock language-javascript\"><code>[element: 10, prev: null, next: 15] [element: 15, prev: 10, next: 20] [element: 20, prev: 15, next: 25] [element: 25, prev: 20, next: 30] [element: 30, prev: 25, next: null] \n20\n[element: 9, prev: null, next: 10] [element: 10, prev: 9, next: 15] [element: 15, prev: 10, next: 20] [element: 20, prev: 15, next: 24] [element: 24, prev: 20, next: 25] [element: 25, prev: 24, next: 30] [element: 30, prev: 25, next: 35] [element: 35, prev: 30, next: null] \n15\n[element: 10, prev: null, next: 20] [element: 20, prev: 10, next: 24] [element: 24, prev: 20, next: 25] [element: 25, prev: 24, next: 35] [element: 35, prev: 25, next: null]</code></pre><p id=\"f585fed1cef9af7641b65ac1c4919258_p_78\" class=\"ne-p\"><br></p><h2 id=\"e99bcd83\"><span class=\"ne-text\">循环链表</span></h2><p id=\"f855fcce122120d1233c03106e601338_p_79\" class=\"ne-p\"><br></p><h3 id=\"61a3ec66\"><span class=\"ne-text\">介绍</span></h3><p id=\"cacc5e28cdefa24e262c83e0ab2a3ade_p_80\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"9ba304ef5ef40b56856fd834e2552ea3_p_81\" class=\"ne-p\"><span class=\"ne-text\">顾名思义，循环链表的尾部指向它自己的头部。循环链表可以有单向循环链表，也可以有双向循环链表。下面是单向循环链表和双向循环链表的数据结构示意图</span></p></div><p id=\"1a51c9f1188a20d8f4ddd78fcfd5029c\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705287564-4531cdeb-9452-4e71-a303-44e9c7c6e029.png\" width=\"813\" id=\"jcuvb\" class=\"ne-image\"></p><p id=\"470257ffbff08ad0eedbc557452f8c66_p_84\" class=\"ne-p\"><br></p><div class=\"ne-quote\"><p id=\"e58586690da8f83c90d1fcda883aeab1_p_85\" class=\"ne-p\"><span class=\"ne-text\">在实现循环链表时，需要确保最后一个元素的 </span><code class=\"ne-code\"><span class=\"ne-text\">next</span></code><span class=\"ne-text\"> 指针指向 </span><code class=\"ne-code\"><span class=\"ne-text\">head</span></code><span class=\"ne-text\">。下面是单向循环链表的完整代码</span></p></div><p id=\"c07d4a2054239914d4a014d7d64fcf23_p_86\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0e5a6b7f\" class=\"ne-codeblock language-javascript\"><code>class CircularLinkList extends LinkList {\n  constructor() {\n    super();\n  }\n  append(element) {\n    let node = new ListNode(element);\n    if (this.head === null) this.head = node;\n    else {\n      let current = this.getElementAt(this.length - 1);\n      current.next = node;\n    }\n    // 将新添加的元素的 next 指向 head\n    node.next = this.head;\n    this.length++;\n  }\n  insert(element, position) {\n    if (position &lt; 0 || position &gt; this.length - 1) return false;\n    let node = new ListNode(element);\n    if (position === 0) {\n      node.next = this.head;\n      let current = this.getElementAt(this.length - 1);\n      current.next = node;\n      this.head = node;\n    } else {\n      var previous = this.getElementAt(position - 1);\n      node.next = previous.next;\n      previous.next = node;\n    }\n    this.length++;\n    return true;\n  }\n  removeAt(position) {\n    if (position &lt; 0 || position &gt; this.length - 1) return null;\n    let current = this.head;\n    if (position === 0) this.head = current.next;\n    else {\n      let previous = this.getElementAt(position - 1);\n      current = previous.next;\n      previous.next = current.next;\n    }\n    this.length--;\n    if (this.length &gt; 1) {\n      let last = this.getElementAt(this.length - 1);\n      last.next = this.head;\n    }\n    return current.element;\n  }\n  toString() {\n    let current = this.head;\n    let s = '';\n    for (let i = 0; i &lt; this.length; i++) {\n      let next = current.next;\n      next = next ? next.element : 'null';\n      s += `[element: ${current.element}, next: ${next}]`;\n      current = current.next;\n    }\n  }\n}</code></pre><p id=\"bd67236b6b40e1ddeba66aa4c905c5af_p_87\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"d37c3e02383ce61ac96e1a5ffe252903_li_19\" data-lake-index-type=\"0\"><span class=\"ne-text\">单向循环链表的测试用例</span></li></ul><p id=\"ac4c0d2013d04adfac6d2e9459525ac0_p_88\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"dd66533a\" class=\"ne-codeblock language-javascript\"><code>let circularLinkList = new CircularLinkList();\ncircularLinkList.append(10);\ncircularLinkList.append(15);\ncircularLinkList.append(20);\n\nconsole.log(circularLinkList.toString());\n\ncircularLinkList.insert(0, 9);\ncircularLinkList.insert(3, 25);\nconsole.log(circularLinkList.toString());\n\nconsole.log(circularLinkList.removeAt(0));\nconsole.log(circularLinkList.toString());</code></pre><p id=\"ab51a4ad9cb9ee48199bb5c9fc6715a2_p_89\" class=\"ne-p\"><br></p><p id=\"98cc90e5a061e870651ed34f20c695df_p_90\" class=\"ne-p\"><span class=\"ne-text\">-　对应的结果如下</span></p><p id=\"55b4793bc7d98162a0d6addc99b469ec\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608705316856-b6b81605-b48c-462c-adc6-57b21fecd1bf.png\" width=\"1086\" id=\"ODmE6\" class=\"ne-image\"></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"8b9b28b86315b765178b080bc38ae357\" id=\"8b9b28b86315b765178b080bc38ae357\"><span data-lake-id=\"u1e203b79\" id=\"u1e203b79\">链表用来存储有序的元素集合，与数组不同，链表中的元素并非保存在连续的存储空间内，每个元素由一个存储元素本身的节点和一个指向下一个元素的指针构成。当要移动或删除元素时，只需要修改相应元素上的指针就可以了。对链表元素的操作要比对数组元素的操作效率更高。下面是链表数据结构的示意图</span></p><p data-lake-id=\"72463c7b18450670c3a6f51a033e7705_p_4\" id=\"72463c7b18450670c3a6f51a033e7705_p_4\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F732231%2F1608704346914-b3d8a713-634d-45fe-ad2c-e040f9985485.png%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A687%2C%22height%22%3A118%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22linkList.png%22%2C%22size%22%3A6139%2C%22originWidth%22%3A687%2C%22originHeight%22%3A118%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22node%20node%20node%20head%20null%20item%20next%20item%20item%20next%20next%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A325.4304%2C%22y%22%3A17.897448%2C%22width%22%3A33.984669999999994%2C%22height%22%3A10.836105%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A484.48447%2C%22y%22%3A18.001892%2C%22width%22%3A34.03823%2C%22height%22%3A10.748891999999998%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A142.67078%2C%22y%22%3A18.00601%2C%22width%22%3A34.2996%2C%22height%22%3A10.730972000000001%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A19.501797%2C%22y%22%3A62.61197%2C%22width%22%3A32.834720000000004%2C%22height%22%3A11.47587%2C%22text%22%3A%22head%22%7D%2C%7B%22x%22%3A614.1746%2C%22y%22%3A62.05746%2C%22width%22%3A25.682639999999992%2C%22height%22%3A11.791515999999994%2C%22text%22%3A%22null%22%7D%2C%7B%22x%22%3A301.60226%2C%22y%22%3A63.282963%2C%22width%22%3A29.740700000000004%2C%22height%22%3A10.746896999999997%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A351.94284%2C%22y%22%3A63.050396%2C%22width%22%3A32.52726000000001%2C%22height%22%3A11.186153999999995%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A464.82816%2C%22y%22%3A63.39839%2C%22width%22%3A29.81583999999998%2C%22height%22%3A10.538760000000003%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A123.67248%2C%22y%22%3A63.399525%2C%22width%22%3A29.782809999999998%2C%22height%22%3A10.378455000000002%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A516.35345%2C%22y%22%3A63.880917%2C%22width%22%3A29.968450000000075%2C%22height%22%3A10.060043000000007%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A175.31587%2C%22y%22%3A63.72276%2C%22width%22%3A30.030370000000005%2C%22height%22%3A10.179065000000001%2C%22text%22%3A%22next%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23ededed%22%2C%22id%22%3A%22VpKv4%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"7467903a77e4c43e92d4f196903d0bbe_p_5\" id=\"7467903a77e4c43e92d4f196903d0bbe_p_5\"><br></p><ul list=\"u5c787682\"><li fid=\"u513e64b4\" data-lake-id=\"e4dd054a65272350f615a79c1a64f043_li_4\" id=\"e4dd054a65272350f615a79c1a64f043_li_4\"><span data-lake-id=\"u25ba0357\" id=\"u25ba0357\">上面链表中每一个元素只有一个 </span><code data-lake-id=\"uab4e0de7\" id=\"uab4e0de7\"><span data-lake-id=\"u932f5c1f\" id=\"u932f5c1f\">next</span></code><span data-lake-id=\"u9c58d38d\" id=\"u9c58d38d\"> 指针，用来指向下一个节点，这样的链表称之为单向链表，我们只能从链表的头部开始遍历整个链表，任何一个节点只能找到它的下一个节点，而不能找到它的上一个节点。双向链表中的每一个元素拥有两个指针，一个用来指向下一个节点，一个用来指向上一个节点。在双向链表中，除了可以像单向链表一样从头部开始遍历之外，还可以从尾部进行遍历。下面是双向链表的数据结构示意图：</span></li></ul><p data-lake-id=\"0ece3fcfc6cfe87dcd2fbef555e7fa0e\" id=\"0ece3fcfc6cfe87dcd2fbef555e7fa0e\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F732231%2F1608704367520-532d5db4-3fde-4ac4-8de5-4fd3e1d287e1.png%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A811%2C%22height%22%3A123%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22doubleLinkList.png%22%2C%22size%22%3A8281%2C%22originWidth%22%3A811%2C%22originHeight%22%3A123%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22node%20node%20node%20tail%20head%20item%20item%20item%20next%20next%20prev%20prev%20prey%20next%20null%20null%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A170.20656%2C%22y%22%3A14.674535%2C%22width%22%3A34.880060000000014%2C%22height%22%3A11.356715%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A382.07288%2C%22y%22%3A15.268947%2C%22width%22%3A33.126059999999995%2C%22height%22%3A10.591666%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A591.5659%2C%22y%22%3A15.686101%2C%22width%22%3A32.53742999999997%2C%22height%22%3A9.837381999999998%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A753.8316%2C%22y%22%3A42.911106%2C%22width%22%3A20.339699999999993%2C%22height%22%3A12.422224%2C%22text%22%3A%22tail%22%7D%2C%7B%22x%22%3A22.467066%2C%22y%22%3A44.562656%2C%22width%22%3A31.453354%2C%22height%22%3A10.727904000000002%2C%22text%22%3A%22head%22%7D%2C%7B%22x%22%3A382.6753%2C%22y%22%3A56.793335%2C%22width%22%3A30.44920000000002%2C%22height%22%3A11.187235000000001%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A592.8106%2C%22y%22%3A57.02057%2C%22width%22%3A29.280399999999986%2C%22height%22%3A10.576804000000003%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A172.53896%2C%22y%22%3A57.240322%2C%22width%22%3A29.62926999999999%2C%22height%22%3A10.789358%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A223.88536%2C%22y%22%3A57.475246%2C%22width%22%3A30.24149%2C%22height%22%3A9.858090000000004%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A435.2218%2C%22y%22%3A57.428806%2C%22width%22%3A30.41586000000001%2C%22height%22%3A10.652244000000003%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A332.65308%2C%22y%22%3A58%2C%22width%22%3A29.739100000000008%2C%22height%22%3A10.345860000000002%2C%22text%22%3A%22prev%22%7D%2C%7B%22x%22%3A122.021515%2C%22y%22%3A58.223362%2C%22width%22%3A29.76225500000001%2C%22height%22%3A10.028137999999991%2C%22text%22%3A%22prev%22%7D%2C%7B%22x%22%3A542.0778%2C%22y%22%3A58%2C%22width%22%3A28.75389999999993%2C%22height%22%3A10.337395%2C%22text%22%3A%22prey%22%7D%2C%7B%22x%22%3A643.5192%2C%22y%22%3A58.45305%2C%22width%22%3A31.117000000000075%2C%22height%22%3A9.075510000000001%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A750.56366%2C%22y%22%3A66.55175%2C%22width%22%3A24.22393999999997%2C%22height%22%3A12.048190000000005%2C%22text%22%3A%22null%22%7D%2C%7B%22x%22%3A25.909506%2C%22y%22%3A76.15972%2C%22width%22%3A24.641384000000002%2C%22height%22%3A12.585730000000012%2C%22text%22%3A%22null%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23ececec%22%2C%22id%22%3A%22OZJLc%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h2 data-lake-id=\"72786a69\" id=\"72786a69\"><span data-lake-id=\"ub666b6a5\" id=\"ub666b6a5\">单向链表</span></h2><p data-lake-id=\"92c8228235b93f7cc9ced6ac90fca3a6_p_8\" id=\"92c8228235b93f7cc9ced6ac90fca3a6_p_8\"><br></p><h3 data-lake-id=\"f411d0f1\" id=\"f411d0f1\"><span data-lake-id=\"u67c9a419\" id=\"u67c9a419\">说明</span></h3><p data-lake-id=\"eadc4ec477465f1f239730d987d394b1_p_9\" id=\"eadc4ec477465f1f239730d987d394b1_p_9\"><br></p><blockquote data-lake-id=\"u15b8e58d\" id=\"u15b8e58d\"><p data-lake-id=\"4e0f7020a8c91a492857b08e9cc58082_p_10\" id=\"4e0f7020a8c91a492857b08e9cc58082_p_10\"><span data-lake-id=\"u330bb6b3\" id=\"u330bb6b3\">要实现链表数据结构，关键在于保存 </span><code data-lake-id=\"ub9e479bd\" id=\"ub9e479bd\"><span data-lake-id=\"u90b9807f\" id=\"u90b9807f\">head</span></code><span data-lake-id=\"ua89c2f90\" id=\"ua89c2f90\"> 元素（即链表的头元素）以及每一个元素的 </span><code data-lake-id=\"u7d5c60cb\" id=\"u7d5c60cb\"><span data-lake-id=\"ufaf9955c\" id=\"ufaf9955c\">next</span></code><span data-lake-id=\"u22e5cb9c\" id=\"u22e5cb9c\"> 指针，有这两部分我们就可以很方便地遍历链表从而操作所有的元素。可以把链表想象成一条锁链，锁链中的每一个节点都是相互连接的，我们只要找到锁链的头，整条锁链就都可以找到了。让我们来看一下具体的实现方式。</span></p></blockquote><p data-lake-id=\"828bea0262f636b25c97fbef525aed20_p_11\" id=\"828bea0262f636b25c97fbef525aed20_p_11\"><br></p><h3 data-lake-id=\"52b36576\" id=\"52b36576\"><span data-lake-id=\"u32cdd5b8\" id=\"u32cdd5b8\">步骤</span></h3><p data-lake-id=\"09a2b5671cf447a1a3529d71c89cf9e1_p_12\" id=\"09a2b5671cf447a1a3529d71c89cf9e1_p_12\"><br></p><ul list=\"u3b9e84eb\"><li fid=\"u7a917a1c\" data-lake-id=\"dd1e0b174e1d660e60418c341a173d86_li_5\" id=\"dd1e0b174e1d660e60418c341a173d86_li_5\"><span data-lake-id=\"u1e8825bf\" id=\"u1e8825bf\">首先我们需要一个辅助类，用来描述链表中的节点。这个类很简单，只需要两个属性，一个用来保存节点的值，一个用来保存指向下一个节点的指针。</span></li></ul><p data-lake-id=\"2369fafe89fae403079018df6f36b51b_p_13\" id=\"2369fafe89fae403079018df6f36b51b_p_13\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20ListNode(element)%20%7B%5Cn%20%20this.element%20%3D%20element%3B%5Cn%20%20this.next%20%3D%20null%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22d857bee2%22%7D\"></card><p data-lake-id=\"7cf79ceeaaf91ef14264b4c55c1c8c1d_p_14\" id=\"7cf79ceeaaf91ef14264b4c55c1c8c1d_p_14\"><br></p><ul list=\"u2b9a6411\"><li fid=\"u53308a3e\" data-lake-id=\"80545d0bc091d3aa67a632280c9c644f_li_6\" id=\"80545d0bc091d3aa67a632280c9c644f_li_6\"><span data-lake-id=\"u894ad591\" id=\"u894ad591\">下面是链表类的基本骨架</span></li></ul><p data-lake-id=\"c53070088aadb43ef468f61fca8ca22a_p_15\" id=\"c53070088aadb43ef468f61fca8ca22a_p_15\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20LinkList%20%7B%5Cn%20%20constructor()%20%7B%5Cn%20%20%20%20this.length%20%3D%200%3B%5Cn%20%20%20%20this.head%20%3D%20null%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%5Cn%20%20append(element)%20%7B%5Cn%20%20%20%20var%20node%20%3D%20new%20ListNode(element)%3B%5Cn%20%20%20%20if%20(this.head%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20var%20current%20%3D%20this.getElementAt(this.length%20-%201)%3B%5Cn%20%20%20%20%20%20current.next%20%3D%20node%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.length%2B%2B%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%5Cn%20%20insert(position%2C%20element)%20%7B%5Cn%20%20%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20%7B%5Cn%20%20%20%20%20%20return%20false%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20var%20node%20%3D%20new%20ListNode(element)%3B%5Cn%20%20%20%20if%20(position%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20node.next%20%3D%20this.head%3B%5Cn%20%20%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20var%20previous%20%3D%20this.getElementAt(position%20-%201)%3B%5Cn%20%20%20%20%20%20node.next%20%3D%20previous.next%3B%5Cn%20%20%20%20%20%20previous.next%20%3D%20node%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.length%2B%2B%3B%5Cn%20%20%20%20return%20true%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%E8%BF%99%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%5Cn%20%20removeAt(position)%20%7B%5Cn%20%20%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20%7B%5Cn%20%20%20%20%20%20return%20null%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20var%20current%20%3D%20this.head%3B%5Cn%20%20%20%20if%20(position%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20this.head%20%3D%20current.next%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20var%20previous%20%3D%20this.getElementAt(position%20-%201)%3B%5Cn%20%20%20%20%20%20current%20%3D%20previous.next%3B%5Cn%20%20%20%20%20%20previous.next%20%3D%20current.next%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.length--%3B%5Cn%20%20%20%20return%20current.element%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%83%E7%B4%A0%5Cn%20%20remove(element)%20%7B%5Cn%20%20%20%20var%20index%20%3D%20this.indexOf(element)%3B%5Cn%20%20%20%20return%20this.removeAt(index)%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%BB%99%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E7%B4%A2%E5%BC%95%5Cn%20%20indexOf(element)%20%7B%5Cn%20%20%20%20var%20current%20%3D%20this.head%3B%5Cn%20%20%20%20for%20(var%20i%20%3D%200%3B%20i%20%3C%20this.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20if%20(current.element%20%3D%3D%3D%20element)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20i%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20current%20%3D%20current.next%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20-1%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%B4%A2%E5%BC%95%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%83%E7%B4%A0%5Cn%20%20getElementAt(position)%20%7B%5Cn%20%20%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20%7B%5Cn%20%20%20%20%20%20return%20null%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20var%20current%20%3D%20this.head%3B%5Cn%20%20%20%20for%20(var%20i%20%3D%200%3B%20i%20%3C%20position%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20current%20%3D%20current.next%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20current%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%5Cn%20%20isEmpty()%20%7B%5Cn%20%20%20%20%2F%2F%20return%20this.head%20%3D%3D%3D%20null%3B%5Cn%20%20%20%20return%20this.length%20%3D%3D%3D%200%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%5Cn%20%20size()%20%7B%5Cn%20%20%20%20return%20this.length%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E5%A4%B4%E8%8A%82%E7%82%B9%5Cn%20%20getHead()%20%7B%5Cn%20%20%20%20return%20this.head%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%5Cn%20%20clear()%20%7B%5Cn%20%20%20%20this.head%20%3D%20null%3B%5Cn%20%20%20%20this.length%20%3D%200%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8C%89%E6%8C%87%E5%AE%9A%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%EF%BC%8C%E6%96%B9%E4%BE%BF%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C%5Cn%20%20toString()%20%7B%5Cn%20%20%20%20var%20current%20%3D%20this.head%3B%5Cn%20%20%20%20var%20s%20%3D%20''%3B%5Cn%5Cn%20%20%20%20while%20(current)%20%7B%5Cn%20%20%20%20%20%20var%20next%20%3D%20current.next%3B%5Cn%20%20%20%20%20%20next%20%3D%20next%20%3F%20next.element%20%3A%20'null'%3B%5Cn%20%20%20%20%20%20s%20%2B%3D%20%60%5Belement%3A%20%24%7Bcurrent.element%7D%2C%20next%3A%20%24%7Bnext%7D%5D%20%60%3B%5Cn%20%20%20%20%20%20current%20%3D%20current.next%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20return%20s%3B%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2227d7fcec%22%7D\"></card><p data-lake-id=\"42752743bc6d3f9f6c928fb47989b8c2_p_16\" id=\"42752743bc6d3f9f6c928fb47989b8c2_p_16\"><br></p><ul list=\"u83329e10\"><li fid=\"ub4721754\" data-lake-id=\"a012eaef546925b976a236f8bd3f64e7_li_7\" id=\"a012eaef546925b976a236f8bd3f64e7_li_7\"><span data-lake-id=\"uc3c3ca2a\" id=\"uc3c3ca2a\">让我们从查找链表元素的方法 </span><code data-lake-id=\"u6e77fc35\" id=\"u6e77fc35\"><span data-lake-id=\"udeab1f25\" id=\"udeab1f25\">getElementAt()</span></code><span data-lake-id=\"ue40dae9d\" id=\"ue40dae9d\"> 开始，因为后面我们会多次用到它。</span></li></ul><p data-lake-id=\"c5eaf555cee01ec836fc749258c6179d_p_17\" id=\"c5eaf555cee01ec836fc749258c6179d_p_17\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22getElementAt(position)%20%7B%5Cn%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20%7B%5Cn%20%20%20%20return%20null%3B%5Cn%20%20%7D%5Cn%20%20var%20current%20%3D%20this.head%3B%5Cn%20%20for%20(var%20i%20%3D%200%3B%20i%20%3C%20position%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20current%20%3D%20current.next%3B%5Cn%20%20%7D%5Cn%20%20return%20current%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2263f782ef%22%7D\"></card><p data-lake-id=\"3f8949dd5527f0c9624c3fd3faefb76f_p_18\" id=\"3f8949dd5527f0c9624c3fd3faefb76f_p_18\"><br></p><blockquote data-lake-id=\"u76d289c2\" id=\"u76d289c2\"><p data-lake-id=\"c6ec48e23d522d65bf625dd7fc70dcaf_p_19\" id=\"c6ec48e23d522d65bf625dd7fc70dcaf_p_19\"><span data-lake-id=\"u2f0e03e2\" id=\"u2f0e03e2\">首先判断参数 </span><code data-lake-id=\"u2d1f6d49\" id=\"u2d1f6d49\"><span data-lake-id=\"u85077e22\" id=\"u85077e22\">position</span></code><span data-lake-id=\"u74243df5\" id=\"u74243df5\"> 的边界值，如果值超出了索引的范围（小于 </span><code data-lake-id=\"u8885722f\" id=\"u8885722f\"><span data-lake-id=\"u20f670a4\" id=\"u20f670a4\">0</span></code><span data-lake-id=\"u287e4911\" id=\"u287e4911\"> 或者大于</span><code data-lake-id=\"udffda34f\" id=\"udffda34f\"><span data-lake-id=\"ue04d1bec\" id=\"ue04d1bec\">length - 1</span></code><span data-lake-id=\"ude39cc2d\" id=\"ude39cc2d\">），则返回 </span><code data-lake-id=\"uffc21cc8\" id=\"uffc21cc8\"><span data-lake-id=\"ub5093efa\" id=\"ub5093efa\">null</span></code><span data-lake-id=\"u24e8801a\" id=\"u24e8801a\">。我们从链表的 </span><code data-lake-id=\"u8ba8efe1\" id=\"u8ba8efe1\"><span data-lake-id=\"u3380e72d\" id=\"u3380e72d\">head</span></code><span data-lake-id=\"ub77d7b68\" id=\"ub77d7b68\"> 开始，遍历整个链表直到找到对应索引位置的节点，然后返回这个节点。是不是很简单？和所有有序数据集合一样，链表的索引默认从 </span><code data-lake-id=\"u524f719b\" id=\"u524f719b\"><span data-lake-id=\"u74e1cb20\" id=\"u74e1cb20\">0</span></code><span data-lake-id=\"udd2f84e5\" id=\"udd2f84e5\"> 开始，只要找到了链表的头（所以我们必须在 </span><code data-lake-id=\"u33b72355\" id=\"u33b72355\"><span data-lake-id=\"u32948c42\" id=\"u32948c42\">LinkList</span></code><span data-lake-id=\"u33bbd2cb\" id=\"u33bbd2cb\"> 类中保存 </span><code data-lake-id=\"u445a12bc\" id=\"u445a12bc\"><span data-lake-id=\"u9355d6af\" id=\"u9355d6af\">head</span></code><span data-lake-id=\"ub1ce67de\" id=\"ub1ce67de\"> 值），然后就可以遍历找到索引所在位置的元素。</span></p></blockquote><p data-lake-id=\"db841a6e995b001085603629a3ace379_p_20\" id=\"db841a6e995b001085603629a3ace379_p_20\"><br></p><ul list=\"u9d0da195\"><li fid=\"u1b0e624d\" data-lake-id=\"2d66a6505ab279bb08b85117369010b7_li_8\" id=\"2d66a6505ab279bb08b85117369010b7_li_8\"><span data-lake-id=\"u36e428da\" id=\"u36e428da\">有了 </span><code data-lake-id=\"u1e823d9f\" id=\"u1e823d9f\"><span data-lake-id=\"u50288188\" id=\"u50288188\">getElementAt()</span></code><span data-lake-id=\"u4109938c\" id=\"u4109938c\"> 方法，接下来我们就可以很方便地实现 </span><code data-lake-id=\"u2c8577ba\" id=\"u2c8577ba\"><span data-lake-id=\"udc43ae66\" id=\"udc43ae66\">append()</span></code><span data-lake-id=\"u697ad50a\" id=\"u697ad50a\"> 方法，用来在链表的尾部添加新节点。</span></li></ul><p data-lake-id=\"54d418504a63791b75a5f497078fa24a_p_21\" id=\"54d418504a63791b75a5f497078fa24a_p_21\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22append(element)%20%7B%5Cn%20%20var%20node%20%3D%20new%20ListNode(element)%3B%5Cn%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E9%93%BE%E8%A1%A8%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%88%99%E5%B0%86%20head%20%E6%8C%87%E5%90%91%20node%5Cn%20%20if%20(this.head%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20%2F%2F%20%E5%90%A6%E5%88%99%EF%BC%8C%E6%89%BE%E5%88%B0%E9%93%BE%E8%A1%A8%E5%B0%BE%E9%83%A8%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E7%84%B6%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0%5Cn%20%20%20%20var%20current%20%3D%20this.getElementAt(this.length%20-%201)%3B%5Cn%20%20%20%20current.next%20%3D%20node%3B%5Cn%20%20%7D%5Cn%20%20this.length%2B%2B%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22fe0473b5%22%7D\"></card><p data-lake-id=\"37928cd1f32681ee4810a9ab9d3c1104_p_22\" id=\"37928cd1f32681ee4810a9ab9d3c1104_p_22\"><br></p><blockquote data-lake-id=\"u94e0c23e\" id=\"u94e0c23e\"><p data-lake-id=\"0d2b77f2199ac7265917a3f688cdcc8b_p_23\" id=\"0d2b77f2199ac7265917a3f688cdcc8b_p_23\"><span data-lake-id=\"ua5aa55ae\" id=\"ua5aa55ae\">如果链表的 </span><code data-lake-id=\"u378b5909\" id=\"u378b5909\"><span data-lake-id=\"ua841e2f3\" id=\"ua841e2f3\">head</span></code><span data-lake-id=\"u19c84876\" id=\"u19c84876\"> 为 </span><code data-lake-id=\"u5702368b\" id=\"u5702368b\"><span data-lake-id=\"u26450044\" id=\"u26450044\">null</span></code><span data-lake-id=\"ucd23403c\" id=\"ucd23403c\">（这种情况表示链表为空），则直接将 </span><code data-lake-id=\"u9f0db5f9\" id=\"u9f0db5f9\"><span data-lake-id=\"ucf2f402c\" id=\"ucf2f402c\">head</span></code><span data-lake-id=\"u7b5aef9f\" id=\"u7b5aef9f\"> 指向新添加的元素。否则，通过 </span><code data-lake-id=\"u1806833f\" id=\"u1806833f\"><span data-lake-id=\"uc6ec1e48\" id=\"uc6ec1e48\">getElementAt()</span></code><span data-lake-id=\"u8aa2e8a4\" id=\"u8aa2e8a4\"> 方法找到链表的最后一个节点，将该节点的 </span><code data-lake-id=\"u434abfd7\" id=\"u434abfd7\"><span data-lake-id=\"ua9b59c2e\" id=\"ua9b59c2e\">next</span></code><span data-lake-id=\"u2f59bbd4\" id=\"u2f59bbd4\"> 指针指向新添加的元素。新添加的元素的 </span><code data-lake-id=\"u05cd3dc5\" id=\"u05cd3dc5\"><span data-lake-id=\"u7afd5448\" id=\"u7afd5448\">next</span></code><span data-lake-id=\"u15615cca\" id=\"u15615cca\"> 指针默认为 </span><code data-lake-id=\"ubffe0c81\" id=\"ubffe0c81\"><span data-lake-id=\"uda186186\" id=\"uda186186\">null</span></code><span data-lake-id=\"uee1e9a5c\" id=\"uee1e9a5c\">，链表最后一个元素的 </span><code data-lake-id=\"u3d9f3905\" id=\"u3d9f3905\"><span data-lake-id=\"ufeb2ff50\" id=\"ufeb2ff50\">next</span></code><span data-lake-id=\"u6a111c88\" id=\"u6a111c88\"> 值为 </span><code data-lake-id=\"u3c971ab6\" id=\"u3c971ab6\"><span data-lake-id=\"u6366ea77\" id=\"u6366ea77\">null</span></code><span data-lake-id=\"u21aa048c\" id=\"u21aa048c\">。将节点挂到链表上之后，不要忘记将链表的长度加 </span><code data-lake-id=\"u79ec470b\" id=\"u79ec470b\"><span data-lake-id=\"uca8d4841\" id=\"uca8d4841\">1</span></code><span data-lake-id=\"u03dd7e8a\" id=\"u03dd7e8a\">，我们需要通过</span><code data-lake-id=\"ud5e8af80\" id=\"ud5e8af80\"><span data-lake-id=\"u7a39cf94\" id=\"u7a39cf94\">length</span></code><span data-lake-id=\"ud8905b6f\" id=\"ud8905b6f\"> 属性来记录链表的长度。</span></p></blockquote><p data-lake-id=\"1f3b4b4a4867a8b756c196b38558d0c4_p_24\" id=\"1f3b4b4a4867a8b756c196b38558d0c4_p_24\"><br></p><ul list=\"ud53d8a27\"><li fid=\"u7abdc252\" data-lake-id=\"b0ece2beb942cca306a5d6e038dbff74_li_9\" id=\"b0ece2beb942cca306a5d6e038dbff74_li_9\"><span data-lake-id=\"u4b95fd69\" id=\"u4b95fd69\">接下来我们要实现 </span><code data-lake-id=\"u993c7716\" id=\"u993c7716\"><span data-lake-id=\"ue6cc8fe5\" id=\"ue6cc8fe5\">insert()</span></code><span data-lake-id=\"u7ea15ebe\" id=\"u7ea15ebe\"> 方法，可以在链表的任意位置添加节点。</span></li></ul><p data-lake-id=\"3afe72986fc83f6913935faccbcf69b2_p_25\" id=\"3afe72986fc83f6913935faccbcf69b2_p_25\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22insert(position%2C%20element)%20%7B%5Cn%20%20%2F%2F%20position%20%E4%B8%8D%E8%83%BD%E8%B6%85%E8%BF%87%E8%BE%B9%E7%95%8C%E5%80%BC%5Cn%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20%7B%5Cn%20%20%20%20return%20false%3B%5Cn%20%20%7D%5Cn%5Cn%20%20var%20node%20%3D%20new%20ListNode(element)%3B%5Cn%5Cn%20%20if%20(position%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20node.next%20%3D%20this.head%3B%5Cn%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20var%20previous%20%3D%20this.getElementAt(position%20-%201)%3B%5Cn%20%20%20%20node.next%20%3D%20previous.next%3B%5Cn%20%20%20%20previous.next%20%3D%20node%3B%20%20%20%20%5Cn%20%20%7D%5Cn%20%20this.length%2B%2B%3B%5Cn%20%20return%20true%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%220fadeda0%22%7D\"></card><p data-lake-id=\"b57de0a6a045efefe71d109094be9ddc_p_26\" id=\"b57de0a6a045efefe71d109094be9ddc_p_26\"><br></p><blockquote data-lake-id=\"u4bbbf68b\" id=\"u4bbbf68b\"><p data-lake-id=\"fa9fe669f446436952510d0b04f9a327_p_27\" id=\"fa9fe669f446436952510d0b04f9a327_p_27\"><span data-lake-id=\"uccee8708\" id=\"uccee8708\">首先也是要判断参数 </span><code data-lake-id=\"u821eaff5\" id=\"u821eaff5\"><span data-lake-id=\"u8edb1c36\" id=\"u8edb1c36\">position</span></code><span data-lake-id=\"u93fea7fd\" id=\"u93fea7fd\"> 的边界值，不能越界。当 </span><code data-lake-id=\"uf4ed566f\" id=\"uf4ed566f\"><span data-lake-id=\"u69819fa0\" id=\"u69819fa0\">position</span></code><span data-lake-id=\"ud6a8b388\" id=\"ud6a8b388\"> 的值为 </span><code data-lake-id=\"ua1fb584f\" id=\"ua1fb584f\"><span data-lake-id=\"u4239694a\" id=\"u4239694a\">0</span></code><span data-lake-id=\"uc002f5c9\" id=\"uc002f5c9\"> 时，表示要在链表的头部插入新节点，对应的操作如下图所示。将新插入节点的 </span><code data-lake-id=\"u252cf3a8\" id=\"u252cf3a8\"><span data-lake-id=\"u95cd2611\" id=\"u95cd2611\">next</span></code><span data-lake-id=\"uac10c0a4\" id=\"uac10c0a4\"> 指针指向现在的 </span><code data-lake-id=\"u0be303d2\" id=\"u0be303d2\"><span data-lake-id=\"u8d0f3ea2\" id=\"u8d0f3ea2\">head</span></code><span data-lake-id=\"u875f0e0c\" id=\"u875f0e0c\">，然后更新 </span><code data-lake-id=\"uc03d76be\" id=\"uc03d76be\"><span data-lake-id=\"u2d0a0f07\" id=\"u2d0a0f07\">head</span></code><span data-lake-id=\"u90512502\" id=\"u90512502\"> 的值为新插入的节点。</span></p></blockquote><p data-lake-id=\"c2f989dd0f058d43258fb7a314f90ca4\" id=\"c2f989dd0f058d43258fb7a314f90ca4\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F732231%2F1608704395087-c23664dd-c205-44d5-9e63-870bf14ec0b1.png%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A687%2C%22height%22%3A205%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22linkList_insert1.png%22%2C%22size%22%3A11778%2C%22originWidth%22%3A687%2C%22originHeight%22%3A205%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22next%20node%20previousnode%20node%20item%20item%20null%20item%20next%20next%20next%20item%20next%20newnode%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A506.06277%2C%22y%22%3A11.406197%2C%22width%22%3A30.366059999999948%2C%22height%22%3A10.297078999999998%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A161.6093%2C%22y%22%3A18.781984%2C%22width%22%3A34.58182000000002%2C%22height%22%3A11.228644%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A317.94193%2C%22y%22%3A18.140806%2C%22width%22%3A91.76634999999999%2C%22height%22%3A12.158783999999997%2C%22text%22%3A%22previousnode%22%7D%2C%7B%22x%22%3A503.442%2C%22y%22%3A27.31118%2C%22width%22%3A34.254839999999945%2C%22height%22%3A10.489530000000002%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A483.4949%2C%22y%22%3A63.348392%2C%22width%22%3A29.37265000000008%2C%22height%22%3A11.921067999999998%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A142.65611%2C%22y%22%3A63.72621%2C%22width%22%3A29.47578999999999%2C%22height%22%3A11.366189999999996%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A633.65845%2C%22y%22%3A62.912506%2C%22width%22%3A25.942649999999958%2C%22height%22%3A12.503843999999994%2C%22text%22%3A%22null%22%7D%2C%7B%22x%22%3A320.38937%2C%22y%22%3A63.783665%2C%22width%22%3A30.223929999999996%2C%22height%22%3A11.340685000000008%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A534.61707%2C%22y%22%3A64.66668%2C%22width%22%3A30.77493000000004%2C%22height%22%3A10.040850000000006%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A193.31532%2C%22y%22%3A64.66494%2C%22width%22%3A31.843109999999996%2C%22height%22%3A10.354739999999993%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A371.63266%2C%22y%22%3A64.69579%2C%22width%22%3A31.030340000000024%2C%22height%22%3A10.359293999999991%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A80.88594%2C%22y%22%3A151.08467%2C%22width%22%3A29.796189999999996%2C%22height%22%3A10.491330000000005%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A131.8412%2C%22y%22%3A152.00496%2C%22width%22%3A30.551930000000027%2C%22height%22%3A9.328399999999988%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A92.494865%2C%22y%22%3A185.36224%2C%22width%22%3A63.93178499999999%2C%22height%22%3A11.247359999999986%2C%22text%22%3A%22newnode%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f1f1f1%22%2C%22id%22%3A%22ZmDav%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"d657ac1e4c3211af4f7dcea889518735_p_30\" id=\"d657ac1e4c3211af4f7dcea889518735_p_30\"><br></p><blockquote data-lake-id=\"ubd4230b2\" id=\"ubd4230b2\"><p data-lake-id=\"16010a0caa57e486c6540ca460620ade_p_31\" id=\"16010a0caa57e486c6540ca460620ade_p_31\"><span data-lake-id=\"ue8d0c137\" id=\"ue8d0c137\">如果要插入的节点在链表的中间或者尾部，对应的操作如下图。假设链表长度为 </span><code data-lake-id=\"u354fcd4f\" id=\"u354fcd4f\"><span data-lake-id=\"u8bd04cfa\" id=\"u8bd04cfa\">3</span></code><span data-lake-id=\"u27c69c16\" id=\"u27c69c16\">，要在位置 </span><code data-lake-id=\"u1c9bbaf4\" id=\"u1c9bbaf4\"><span data-lake-id=\"u53116708\" id=\"u53116708\">2</span></code><span data-lake-id=\"uafbc08bd\" id=\"uafbc08bd\"> 插入新节点，我们首先找到位置 </span><code data-lake-id=\"uc7c25673\" id=\"uc7c25673\"><span data-lake-id=\"u3e6ca566\" id=\"u3e6ca566\">2</span></code><span data-lake-id=\"uae4b8914\" id=\"uae4b8914\"> 的前一个节点 </span><code data-lake-id=\"u01b15ff1\" id=\"u01b15ff1\"><span data-lake-id=\"u35ab2268\" id=\"u35ab2268\">previous node</span></code><span data-lake-id=\"u5c191ffb\" id=\"u5c191ffb\">，将新节点 </span><code data-lake-id=\"u4654c15c\" id=\"u4654c15c\"><span data-lake-id=\"uf6d1a8aa\" id=\"uf6d1a8aa\">new node</span></code><span data-lake-id=\"ud6e5a085\" id=\"ud6e5a085\"> 的 </span><code data-lake-id=\"u5f76e979\" id=\"u5f76e979\"><span data-lake-id=\"ua6888701\" id=\"ua6888701\">next</span></code><span data-lake-id=\"u827f8329\" id=\"u827f8329\"> 指针指向 </span><code data-lake-id=\"ue418ead7\" id=\"ue418ead7\"><span data-lake-id=\"u0f69bda8\" id=\"u0f69bda8\">previous node</span></code><span data-lake-id=\"u605093b3\" id=\"u605093b3\"> 的 </span><code data-lake-id=\"u8a56d6a2\" id=\"u8a56d6a2\"><span data-lake-id=\"uc7cb6dbc\" id=\"uc7cb6dbc\">next</span></code><span data-lake-id=\"u15bc13c9\" id=\"u15bc13c9\"> 所对应的节点，然后再将</span><code data-lake-id=\"u930bf7c2\" id=\"u930bf7c2\"><span data-lake-id=\"u0176f75c\" id=\"u0176f75c\">previous node</span></code><span data-lake-id=\"u9bc1cbc3\" id=\"u9bc1cbc3\"> 的 </span><code data-lake-id=\"ubd3765f5\" id=\"ubd3765f5\"><span data-lake-id=\"uf062890d\" id=\"uf062890d\">next</span></code><span data-lake-id=\"u0248c453\" id=\"u0248c453\"> 指针指向 </span><code data-lake-id=\"ufb3eb889\" id=\"ufb3eb889\"><span data-lake-id=\"u83cb759f\" id=\"u83cb759f\">new node</span></code><span data-lake-id=\"ubbd081ef\" id=\"ubbd081ef\">，这样就把新节点挂到链表中了。考虑一下，当插入的节点在链表的尾部，这种情况也是适用的。而如果链表为空，即链表的 </span><code data-lake-id=\"u1224e8f1\" id=\"u1224e8f1\"><span data-lake-id=\"uc3c36ff5\" id=\"uc3c36ff5\">head</span></code><span data-lake-id=\"uec1bef87\" id=\"uec1bef87\"> 为 </span><code data-lake-id=\"u8ada760f\" id=\"u8ada760f\"><span data-lake-id=\"ubb5aecff\" id=\"ubb5aecff\">null</span></code><span data-lake-id=\"u11084a44\" id=\"u11084a44\">，则参数 </span><code data-lake-id=\"ue995b383\" id=\"ue995b383\"><span data-lake-id=\"u03742e69\" id=\"u03742e69\">position</span></code><span data-lake-id=\"u3616d059\" id=\"u3616d059\"> 会超出边界条件，从而 </span><code data-lake-id=\"u7310f4a1\" id=\"u7310f4a1\"><span data-lake-id=\"u6dadbc0d\" id=\"u6dadbc0d\">insert()</span></code><span data-lake-id=\"u8603a7d5\" id=\"u8603a7d5\"> 方法会直接返回 </span><code data-lake-id=\"u589b80df\" id=\"u589b80df\"><span data-lake-id=\"u1cf02b81\" id=\"u1cf02b81\">false</span></code><span data-lake-id=\"uccd7c358\" id=\"uccd7c358\">。</span></p></blockquote><p data-lake-id=\"39abba9494ef6da94608fbd0e487aa60_p_34\" id=\"39abba9494ef6da94608fbd0e487aa60_p_34\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F732231%2F1608704419032-051f8ebf-b913-43a0-8473-afb6535e64f9.png%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A687%2C%22height%22%3A205%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22linkList_insert2.png%22%2C%22size%22%3A12178%2C%22originWidth%22%3A687%2C%22originHeight%22%3A205%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22next%20previousnode%20node%20node%20head%20null%20item%20item%20item%20next%20next%20next%20newnode%20item%20next%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A486.70398%2C%22y%22%3A10.381889%2C%22width%22%3A30.37787000000003%2C%22height%22%3A10.050734%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A298.2634%2C%22y%22%3A16.880514%2C%22width%22%3A92.67239999999998%2C%22height%22%3A12.885589999999997%2C%22text%22%3A%22previousnode%22%7D%2C%7B%22x%22%3A142.67905%2C%22y%22%3A18.002035%2C%22width%22%3A34.36543%2C%22height%22%3A10.737446000000002%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A484.5933%2C%22y%22%3A26.065659%2C%22width%22%3A34.18859999999995%2C%22height%22%3A11.262908999999997%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A19.50176%2C%22y%22%3A62.512894%2C%22width%22%3A32.813559999999995%2C%22height%22%3A11.474266%2C%22text%22%3A%22head%22%7D%2C%7B%22x%22%3A613.7558%2C%22y%22%3A62.151432%2C%22width%22%3A26.328859999999963%2C%22height%22%3A11.520763000000002%2C%22text%22%3A%22null%22%7D%2C%7B%22x%22%3A301.52686%2C%22y%22%3A62.80685%2C%22width%22%3A29.505240000000015%2C%22height%22%3A11.118214000000009%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A123.71067%2C%22y%22%3A63.38109%2C%22width%22%3A29.72469000000001%2C%22height%22%3A10.234274%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A465.00342%2C%22y%22%3A63.478413%2C%22width%22%3A29.37491%2C%22height%22%3A10.016187000000002%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A351.4028%2C%22y%22%3A63.774776%2C%22width%22%3A32.363279999999975%2C%22height%22%3A10.150443999999993%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A175.31587%2C%22y%22%3A63.781933%2C%22width%22%3A30.21067000000002%2C%22height%22%3A10.014687000000002%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A516.09326%2C%22y%22%3A63.995113%2C%22width%22%3A30.17874000000006%2C%22height%22%3A9.795237%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A388.83118%2C%22y%22%3A116.629814%2C%22width%22%3A66.14159999999998%2C%22height%22%3A11.478186000000008%2C%22text%22%3A%22newnode%22%7D%2C%7B%22x%22%3A377.33664%2C%22y%22%3A164.3139%2C%22width%22%3A30.064610000000016%2C%22height%22%3A10.497210000000024%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A428.41666%2C%22y%22%3A164.96535%2C%22width%22%3A31.731040000000007%2C%22height%22%3A9.828609999999998%2C%22text%22%3A%22next%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f1f1f1%22%2C%22id%22%3A%22JgFG3%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><blockquote data-lake-id=\"u06162ddc\" id=\"u06162ddc\"><p data-lake-id=\"ae75bb4df811b53ac3c664c56d8c1fa3_p_35\" id=\"ae75bb4df811b53ac3c664c56d8c1fa3_p_35\"><span data-lake-id=\"ue0322d79\" id=\"ue0322d79\">最后，别忘了更新 </span><code data-lake-id=\"u7fa7142f\" id=\"u7fa7142f\"><span data-lake-id=\"ufd35371f\" id=\"ufd35371f\">length</span></code><span data-lake-id=\"ubea74e9a\" id=\"ubea74e9a\"> 属性的值，将链表的长度加 </span><code data-lake-id=\"u39eb9a7c\" id=\"u39eb9a7c\"><span data-lake-id=\"u91bb1e98\" id=\"u91bb1e98\">1</span></code><span data-lake-id=\"ubd13dc4d\" id=\"ubd13dc4d\">。</span></p></blockquote><p data-lake-id=\"6f8f966688575a1f666bafa122494f73_p_36\" id=\"6f8f966688575a1f666bafa122494f73_p_36\"><br></p><ul list=\"u51be0bd5\"><li fid=\"uef8e4162\" data-lake-id=\"97dcf5372a3cedc8fc0514642c0cbfa4_li_10\" id=\"97dcf5372a3cedc8fc0514642c0cbfa4_li_10\"><span data-lake-id=\"uaf6955ab\" id=\"uaf6955ab\">按照相同的方式，我们可以很容易地写出 </span><code data-lake-id=\"u03122194\" id=\"u03122194\"><span data-lake-id=\"uc127fda5\" id=\"uc127fda5\">removeAt()</span></code><span data-lake-id=\"ua54ba272\" id=\"ua54ba272\"> 方法，用来删除链表中指定位置的节点。</span></li></ul><p data-lake-id=\"ab57135091a86c42cc63ec67ac068a45_p_37\" id=\"ab57135091a86c42cc63ec67ac068a45_p_37\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22removeAt(position)%20%7B%5Cn%20%20%2F%2F%20position%20%E4%B8%8D%E8%83%BD%E8%B6%85%E5%87%BA%E8%BE%B9%E7%95%8C%E5%80%BC%5Cn%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20%7B%5Cn%20%20%20%20return%20null%3B%5Cn%20%20%7D%5Cn%20%20var%20current%20%3D%20this.head%3B%5Cn%20%20if%20(position%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20this.head%20%3D%20current.next%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20var%20previous%20%3D%20this.getElementAt(position%20-%201)%3B%5Cn%20%20%20%20current%20%3D%20previous.next%3B%5Cn%20%20%20%20previous.next%20%3D%20current.next%3B%5Cn%20%20%7D%5Cn%20%20this.length--%3B%5Cn%20%20return%20current.element%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22267e369c%22%7D\"></card><p data-lake-id=\"82f45866a429f6224b2e92c65bfda254_p_38\" id=\"82f45866a429f6224b2e92c65bfda254_p_38\"><br></p><blockquote data-lake-id=\"ue722be88\" id=\"ue722be88\"><p data-lake-id=\"3f3fd98cb4e8eab62e88d532e3d7b0c3_p_39\" id=\"3f3fd98cb4e8eab62e88d532e3d7b0c3_p_39\"><span data-lake-id=\"uc5e1925d\" id=\"uc5e1925d\">下面两张示意图说明了从链表头部和其它位置删除节点的情况。</span></p></blockquote><p data-lake-id=\"fb18d8c69d5615182defd0ad2553d6e4\" id=\"fb18d8c69d5615182defd0ad2553d6e4\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F732231%2F1608705111553-9ff6c07c-5b98-408d-952e-625082c91c70.png%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A687%2C%22height%22%3A205%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22linkList_removeAt1.png%22%2C%22size%22%3A10618%2C%22originWidth%22%3A687%2C%22originHeight%22%3A205%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22node%20node%20node%20null%20head%20item%20item%20next%20item%20next%20next%20head%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A142.74104%2C%22y%22%3A17.974281%2C%22width%22%3A33.280550000000005%2C%22height%22%3A10.765578999999999%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A325.45193%2C%22y%22%3A18.010843%2C%22width%22%3A34.240819999999985%2C%22height%22%3A10.874747%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A484.48935%2C%22y%22%3A18.002%2C%22width%22%3A34.10274999999996%2C%22height%22%3A10.842124000000002%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A613.7885%2C%22y%22%3A62.084606%2C%22width%22%3A26.166759999999954%2C%22height%22%3A11.500744000000005%2C%22text%22%3A%22null%22%7D%2C%7B%22x%22%3A19.608866%2C%22y%22%3A62.858337%2C%22width%22%3A33.204866%2C%22height%22%3A11.382202999999997%2C%22text%22%3A%22head%22%7D%2C%7B%22x%22%3A122.921974%2C%22y%22%3A63.14243%2C%22width%22%3A32.24097599999999%2C%22height%22%3A11.996990000000004%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A464.71945%2C%22y%22%3A63.22017%2C%22width%22%3A29.806399999999996%2C%22height%22%3A10.746009999999991%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A352.18567%2C%22y%22%3A63.258266%2C%22width%22%3A32.02724999999998%2C%22height%22%3A10.723554%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A301.59378%2C%22y%22%3A63.699635%2C%22width%22%3A28.783389999999997%2C%22height%22%3A9.685595000000006%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A516.25226%2C%22y%22%3A63.473892%2C%22width%22%3A30.40844000000004%2C%22height%22%3A10.508537999999994%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A171.1699%2C%22y%22%3A62.714703%2C%22width%22%3A34.65491%2C%22height%22%3A13.198696999999996%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A186.50978%2C%22y%22%3A156.83783%2C%22width%22%3A33.67819%2C%22height%22%3A12.606750000000005%2C%22text%22%3A%22head%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f2f2f2%22%2C%22id%22%3A%22MhjJL%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"aebb7af96a9ee3c9b7a669f28fef1d7e_p_42\" id=\"aebb7af96a9ee3c9b7a669f28fef1d7e_p_42\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F732231%2F1608705120449-8a4c3bff-e7e3-4338-883f-c230e291392b.png%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A687%2C%22height%22%3A205%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22linkList_removeAt2.png%22%2C%22size%22%3A8551%2C%22originWidth%22%3A687%2C%22originHeight%22%3A205%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22node%20node%20node%20head%20null%20item%20item%20itemr%20next%20next%20next%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A325.6335%2C%22y%22%3A17.924881%2C%22width%22%3A33.85949999999997%2C%22height%22%3A11.282003%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A484.39163%2C%22y%22%3A18.002089%2C%22width%22%3A34.17366999999996%2C%22height%22%3A10.794611%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A142.62932%2C%22y%22%3A18.00202%2C%22width%22%3A34.40761999999998%2C%22height%22%3A10.737247%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A19.50155%2C%22y%22%3A62.516537%2C%22width%22%3A32.82837%2C%22height%22%3A11.471783000000002%2C%22text%22%3A%22head%22%7D%2C%7B%22x%22%3A613.75037%2C%22y%22%3A62.084606%2C%22width%22%3A26.242180000000076%2C%22height%22%3A11.587573999999996%2C%22text%22%3A%22null%22%7D%2C%7B%22x%22%3A123.63029%2C%22y%22%3A63.35577%2C%22width%22%3A29.864599999999996%2C%22height%22%3A10.660909999999994%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A464.55078%2C%22y%22%3A63.400955%2C%22width%22%3A30.220860000000016%2C%22height%22%3A10.565064999999997%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A300.68094%2C%22y%22%3A62.969975%2C%22width%22%3A34.91836000000001%2C%22height%22%3A11.445995000000003%2C%22text%22%3A%22itemr%22%7D%2C%7B%22x%22%3A175.18298%2C%22y%22%3A63.901417%2C%22width%22%3A30.317830000000015%2C%22height%22%3A10.014698000000003%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A516.2929%2C%22y%22%3A63.85512%2C%22width%22%3A30.251499999999965%2C%22height%22%3A10.254414999999995%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A351.75256%2C%22y%22%3A64.23481%2C%22width%22%3A32.31307999999996%2C%22height%22%3A10.026184%2C%22text%22%3A%22next%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f2f2f2%22%2C%22id%22%3A%22R7Y5r%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"157b805d005afe38c7c2d5198b31ee6e_p_44\" id=\"157b805d005afe38c7c2d5198b31ee6e_p_44\"><br></p><blockquote data-lake-id=\"u40114e83\" id=\"u40114e83\"><p data-lake-id=\"1e5528b26a18d968e53320129af8e26f_p_45\" id=\"1e5528b26a18d968e53320129af8e26f_p_45\"><span data-lake-id=\"uc6b2dac0\" id=\"uc6b2dac0\">如果要删除的节点为链表的头部，只需要将 </span><code data-lake-id=\"u7c275083\" id=\"u7c275083\"><span data-lake-id=\"u2e48bcf3\" id=\"u2e48bcf3\">head</span></code><span data-lake-id=\"u15a4fa19\" id=\"u15a4fa19\"> 移到下一个节点即可。如果当前链表只有一个节点，那么下一个节点为 </span><code data-lake-id=\"u125c6253\" id=\"u125c6253\"><span data-lake-id=\"u9ff24cbd\" id=\"u9ff24cbd\">null</span></code><span data-lake-id=\"u2a6c5b07\" id=\"u2a6c5b07\">，此时将 </span><code data-lake-id=\"u2fd36e42\" id=\"u2fd36e42\"><span data-lake-id=\"u56750daa\" id=\"u56750daa\">head</span></code><span data-lake-id=\"u0aa74625\" id=\"u0aa74625\"> 指向下一个节点等同于将 </span><code data-lake-id=\"ufd310783\" id=\"ufd310783\"><span data-lake-id=\"u2f14acfc\" id=\"u2f14acfc\">head</span></code><span data-lake-id=\"u19cc259e\" id=\"u19cc259e\"> 设置成 </span><code data-lake-id=\"u5fc221a9\" id=\"u5fc221a9\"><span data-lake-id=\"u140c6ab3\" id=\"u140c6ab3\">null</span></code><span data-lake-id=\"u411cd207\" id=\"u411cd207\">，删除之后链表为空。如果要删除的节点在链表的中间部分，我们需要找出 </span><code data-lake-id=\"ue24fa466\" id=\"ue24fa466\"><span data-lake-id=\"u0e5be677\" id=\"u0e5be677\">position</span></code><span data-lake-id=\"u729da3f1\" id=\"u729da3f1\"> 所在位置的前一个节点，将它的 </span><code data-lake-id=\"ud44f2699\" id=\"ud44f2699\"><span data-lake-id=\"u82da290e\" id=\"u82da290e\">next</span></code><span data-lake-id=\"uaa24a9ac\" id=\"uaa24a9ac\"> 指针指向 </span><code data-lake-id=\"u3d4f1a9b\" id=\"u3d4f1a9b\"><span data-lake-id=\"uf5d2076b\" id=\"uf5d2076b\">position</span></code><span data-lake-id=\"u4b247dd9\" id=\"u4b247dd9\"> 所在位置的下一个节点。总之，删除节点只需要修改相应节点的指针，使断开位置左右相邻的节点重新连接上。被删除的节点由于再也没有其它部分的引用而被丢弃在内存中，等待垃圾回收器来清除。</span></p></blockquote><p data-lake-id=\"e81b6efc8e2153cf8aa53e3b04d7f22c_p_46\" id=\"e81b6efc8e2153cf8aa53e3b04d7f22c_p_46\"><br></p><blockquote data-lake-id=\"u50a56bef\" id=\"u50a56bef\"><p data-lake-id=\"d836f2fb214ecaed8dec32fa40e17e5f_p_47\" id=\"d836f2fb214ecaed8dec32fa40e17e5f_p_47\"><span data-lake-id=\"u7f7c832b\" id=\"u7f7c832b\">最后，别忘了将链表的长度减 </span><code data-lake-id=\"uece4ee7f\" id=\"uece4ee7f\"><span data-lake-id=\"uc271d24c\" id=\"uc271d24c\">1</span></code><span data-lake-id=\"u724715e7\" id=\"u724715e7\">。</span></p></blockquote><p data-lake-id=\"aa95668f5a65b03373d1b0b3f9f8d3a6_p_48\" id=\"aa95668f5a65b03373d1b0b3f9f8d3a6_p_48\"><br></p><ul list=\"u72956b84\"><li fid=\"ua0266eeb\" data-lake-id=\"090d05326053a60eb487c6f1a8adb0fd_li_11\" id=\"090d05326053a60eb487c6f1a8adb0fd_li_11\"><span data-lake-id=\"udbc604ef\" id=\"udbc604ef\">下面我们来看看 </span><code data-lake-id=\"ub64a6196\" id=\"ub64a6196\"><span data-lake-id=\"udf8ef23e\" id=\"udf8ef23e\">indexOf()</span></code><span data-lake-id=\"u55f9e39d\" id=\"u55f9e39d\"> 方法，该方法返回给定元素在链表中的索引位置。</span></li></ul><p data-lake-id=\"233f53790c0b9d757f931748dd4d9e1e_p_49\" id=\"233f53790c0b9d757f931748dd4d9e1e_p_49\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22indexOf(element)%20%7B%5Cn%20%20var%20current%20%3D%20this.head%3B%5Cn%5Cn%20%20for%20(var%20i%20%3D%200%3B%20i%20%3C%20this.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20if%20(current.element%20%3D%3D%3D%20element)%20%7B%5Cn%20%20%20%20%20%20return%20i%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20current%20%3D%20current.next%3B%5Cn%20%20%7D%5Cn%5Cn%20%20return%20-1%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2278f94abd%22%7D\"></card><p data-lake-id=\"4108a5bc411c7547dc6876b612b07f81_p_50\" id=\"4108a5bc411c7547dc6876b612b07f81_p_50\"><br></p><blockquote data-lake-id=\"u0c8e6b17\" id=\"u0c8e6b17\"><p data-lake-id=\"d3d16a640dc72a5f6ecfe699df4eb251_p_51\" id=\"d3d16a640dc72a5f6ecfe699df4eb251_p_51\"><span data-lake-id=\"uff4cf646\" id=\"uff4cf646\">我们从链表的头部开始遍历，直到找到和给定元素相同的元素，然后返回对应的索引号。如果没有找到对应的元素，则返回 </span><code data-lake-id=\"u9100f7d8\" id=\"u9100f7d8\"><span data-lake-id=\"u1ac1b00c\" id=\"u1ac1b00c\">-1</span></code><span data-lake-id=\"u8b234dd9\" id=\"u8b234dd9\">。</span></p></blockquote><p data-lake-id=\"bc2359f7bb1e32241fa27f528e60a125_p_52\" id=\"bc2359f7bb1e32241fa27f528e60a125_p_52\"><br></p><ul list=\"uf87d80cc\"><li fid=\"ub4aa0d8c\" data-lake-id=\"9c9801a1b5710689441aea5114c5451d_li_12\" id=\"9c9801a1b5710689441aea5114c5451d_li_12\"><span data-lake-id=\"u0f3edac9\" id=\"u0f3edac9\">在 </span><code data-lake-id=\"u1fd75e8b\" id=\"u1fd75e8b\"><span data-lake-id=\"u82207bcd\" id=\"u82207bcd\">isEmpty()</span></code><span data-lake-id=\"u2ec54f1b\" id=\"u2ec54f1b\"> 方法中，我们可以根据 </span><code data-lake-id=\"ueeae6bf5\" id=\"ueeae6bf5\"><span data-lake-id=\"ue04b7e02\" id=\"ue04b7e02\">length</span></code><span data-lake-id=\"uf4965447\" id=\"uf4965447\"> 是否为 </span><code data-lake-id=\"uf05142ea\" id=\"uf05142ea\"><span data-lake-id=\"u37d74a62\" id=\"u37d74a62\">0</span></code><span data-lake-id=\"u9285002a\" id=\"u9285002a\"> 来判断链表是否为空，当然也可以根据 </span><code data-lake-id=\"ud7829123\" id=\"ud7829123\"><span data-lake-id=\"u345cdc3c\" id=\"u345cdc3c\">head</span></code><span data-lake-id=\"u488829d3\" id=\"u488829d3\"> 是否为 </span><code data-lake-id=\"ufd515156\" id=\"ufd515156\"><span data-lake-id=\"uae989dd0\" id=\"uae989dd0\">null</span></code><span data-lake-id=\"u12aa8a60\" id=\"u12aa8a60\"> 来进行判断，前提是所有涉及到链表节点添加和移除的方法都要正确地更新 </span><code data-lake-id=\"u33b5438c\" id=\"u33b5438c\"><span data-lake-id=\"u97533b68\" id=\"u97533b68\">length</span></code><span data-lake-id=\"ufd89c1e2\" id=\"ufd89c1e2\"> 和 </span><code data-lake-id=\"uc3ce1438\" id=\"uc3ce1438\"><span data-lake-id=\"u2299a19d\" id=\"u2299a19d\">head</span></code><span data-lake-id=\"u7ef75f43\" id=\"u7ef75f43\">。</span><code data-lake-id=\"u3e013942\" id=\"u3e013942\"><span data-lake-id=\"u87bcae64\" id=\"u87bcae64\">toString()</span></code><span data-lake-id=\"ueb99db44\" id=\"ueb99db44\"> 方法只是为了方便测试而编写的，我们来看看几个测试用例：</span></li></ul><p data-lake-id=\"0c6a7643ebb3931744a90899eb00ce0b_p_53\" id=\"0c6a7643ebb3931744a90899eb00ce0b_p_53\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20linkList%20%3D%20new%20LinkList()%3B%5CnlinkList.append(10)%3B%5CnlinkList.append(15)%3B%5CnlinkList.append(20)%3B%5Cnconsole.log(linkList.toString())%3B%5Cn%5CnlinkList.insert(0%2C%209)%3B%5CnlinkList.insert(2%2C%2011)%3B%5CnlinkList.insert(5%2C%2025)%3B%5Cnconsole.log(linkList.toString())%3B%5Cn%5Cnconsole.log(linkList.removeAt(0))%3B%5Cnconsole.log(linkList.removeAt(1))%3B%5Cnconsole.log(linkList.removeAt(3))%3B%5Cnconsole.log(linkList.toString())%3B%5Cn%5Cnconsole.log(linkList.indexOf(20))%3B%5Cn%5CnlinkList.remove(20)%3B%5Cn%5Cnconsole.log(linkList.toString())%3B%5Cn%5CnlinkList.clear()%3B%5Cnconsole.log(linkList.size())%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22caa0199a%22%7D\"></card><p data-lake-id=\"a74a1ae9e5a12e5ca252284043884853_p_55\" id=\"a74a1ae9e5a12e5ca252284043884853_p_55\"><br></p><p data-lake-id=\"c7813883a63e45a345fd6584f3605108\" id=\"c7813883a63e45a345fd6584f3605108\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F732231%2F1608705261819-5917b870-8756-4de9-8e66-be0548d56213.png%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A1306%2C%22height%22%3A171%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22linkList_test.png%22%2C%22size%22%3A14507%2C%22originWidth%22%3A1306%2C%22originHeight%22%3A171%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22element%3A10xt%20wmttm..m..m%2011%2025%20%5BeLement%3A10%2Cxt%3A%5D%5Blemxm%20%5Belement%3A10%2Cnext%3A15%5D%5Belement%3A15%2Cnext%3Anu%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A17.72108%2C%22y%22%3A0.5884281%2C%22width%22%3A644.1486699999999%2C%22height%22%3A15.528364900000001%2C%22text%22%3A%22element%3A10xt%22%7D%2C%7B%22x%22%3A10.676041%2C%22y%22%3A18.688345%2C%22width%22%3A1290.015259%2C%22height%22%3A16.935635%2C%22text%22%3A%22wmttm..m..m%22%7D%2C%7B%22x%22%3A3.8322735%2C%22y%22%3A51.38395%2C%22width%22%3A17.9600505%2C%22height%22%3A17.9600505%2C%22text%22%3A%2211%22%7D%2C%7B%22x%22%3A3.4070225%2C%22y%22%3A71.39826%2C%22width%22%3A21.6741295%2C%22height%22%3A16.744310000000013%2C%22text%22%3A%2225%22%7D%2C%7B%22x%22%3A11.556256%2C%22y%22%3A84.34807%2C%22width%22%3A650.201004%2C%22height%22%3A23.850579999999994%2C%22text%22%3A%22%5BeLement%3A10%2Cxt%3A%5D%5Blemxm%22%7D%2C%7B%22x%22%3A8.717152%2C%22y%22%3A123.236664%2C%22width%22%3A438.092118%2C%22height%22%3A20.78988599999998%2C%22text%22%3A%22%5Belement%3A10%2Cnext%3A15%5D%5Belement%3A15%2Cnext%3Anu%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%232b2b24%22%2C%22id%22%3A%22ivo2u%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"a6e7204180aba568d27cc7b95d0717fd_p_56\" id=\"a6e7204180aba568d27cc7b95d0717fd_p_56\"><br></p><h2 data-lake-id=\"b5fb11e9\" id=\"b5fb11e9\"><span data-lake-id=\"ud2a4903b\" id=\"ud2a4903b\">双向链表</span></h2><p data-lake-id=\"67592880a847e874a0da3af4d564ef1f_p_57\" id=\"67592880a847e874a0da3af4d564ef1f_p_57\"><br></p><h3 data-lake-id=\"52b36576-1\" id=\"52b36576-1\"><span data-lake-id=\"u13d2cc6f\" id=\"u13d2cc6f\">步骤</span></h3><p data-lake-id=\"e3c9bad72638009a374744280c63ecc6_p_58\" id=\"e3c9bad72638009a374744280c63ecc6_p_58\"><br></p><blockquote data-lake-id=\"u06d3fa2c\" id=\"u06d3fa2c\"><p data-lake-id=\"71dfa86733f47d82c73b38a06d62e761_p_59\" id=\"71dfa86733f47d82c73b38a06d62e761_p_59\"><span data-lake-id=\"u7ea6b287\" id=\"u7ea6b287\">由于双向链表具有单向链表的所有特性，因此我们的双向链表类可以继承自前面的单向链表类，不过辅助类 </span><code data-lake-id=\"u83ed73f2\" id=\"u83ed73f2\"><span data-lake-id=\"u651b0312\" id=\"u651b0312\">Node</span></code><span data-lake-id=\"ufefe58eb\" id=\"ufefe58eb\"> 需要添加一个 </span><code data-lake-id=\"u70fd5413\" id=\"u70fd5413\"><span data-lake-id=\"u7b64fb8a\" id=\"u7b64fb8a\">prev</span></code><span data-lake-id=\"uec595e60\" id=\"uec595e60\"> 属性，用来指向前一个节点。</span></p></blockquote><p data-lake-id=\"daa3e859dfee1b8825cb9c219dcb2526_p_60\" id=\"daa3e859dfee1b8825cb9c219dcb2526_p_60\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20Node(element)%20%7B%5Cn%20%20this.element%20%3D%20element%3B%5Cn%20%20this.next%20%3D%20null%3B%5Cn%20%20this.prev%20%3D%20null%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22d581a74e%22%7D\"></card><p data-lake-id=\"d89d8c6a729313c0d25f9b1742c0d590_p_61\" id=\"d89d8c6a729313c0d25f9b1742c0d590_p_61\"><br></p><ul list=\"ueba100de\"><li fid=\"u1dcaa703\" data-lake-id=\"4c0fde53ab52bab59735979a46c369e6_li_13\" id=\"4c0fde53ab52bab59735979a46c369e6_li_13\"><span data-lake-id=\"udefab87c\" id=\"udefab87c\">下面是继承自 </span><code data-lake-id=\"u3d2857d0\" id=\"u3d2857d0\"><span data-lake-id=\"ua99b968d\" id=\"ua99b968d\">LinkList</span></code><span data-lake-id=\"u7675c546\" id=\"u7675c546\"> 类的双向链表类的基本骨架</span></li></ul><p data-lake-id=\"9b034733f43578c770243b15c945bc07_p_62\" id=\"9b034733f43578c770243b15c945bc07_p_62\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20DoubleLinkList%20extends%20LinkList%20%7B%5Cn%20%20constructor()%20%7B%5Cn%20%20%20%20super()%3B%5Cn%20%20%20%20this.tail%20%3D%20null%3B%20%2F%2F%20%E5%B0%BE%E8%8A%82%E7%82%B9%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22ada9a947%22%7D\"></card><p data-lake-id=\"87e34965e50e2c8e31ce44a85667e8dd_p_63\" id=\"87e34965e50e2c8e31ce44a85667e8dd_p_63\"><br></p><ul list=\"ud2adf7b9\"><li fid=\"ud5660613\" data-lake-id=\"e7deef6eec135673422c81bcb1e849fa_li_14\" id=\"e7deef6eec135673422c81bcb1e849fa_li_14\"><span data-lake-id=\"u4a0c823e\" id=\"u4a0c823e\">先来看看 </span><code data-lake-id=\"u34e7f147\" id=\"u34e7f147\"><span data-lake-id=\"ua8b0aaa7\" id=\"ua8b0aaa7\">append()</span></code><span data-lake-id=\"uaf5d7986\" id=\"uaf5d7986\"> 方法的实现。当链表为空时，除了要将 </span><code data-lake-id=\"u62aefe0d\" id=\"u62aefe0d\"><span data-lake-id=\"u050d1276\" id=\"u050d1276\">head</span></code><span data-lake-id=\"u648e814c\" id=\"u648e814c\"> 指向当前添加的节点外，还要将 </span><code data-lake-id=\"uf1243639\" id=\"uf1243639\"><span data-lake-id=\"u4b7e6e34\" id=\"u4b7e6e34\">tail</span></code><span data-lake-id=\"u423480a1\" id=\"u423480a1\"> 也指向当前要添加的节点。当链表不为空时，直接将 </span><code data-lake-id=\"u8c1f2a1b\" id=\"u8c1f2a1b\"><span data-lake-id=\"uc1517b4c\" id=\"uc1517b4c\">tail</span></code><span data-lake-id=\"u48c90bc7\" id=\"u48c90bc7\"> 的 </span><code data-lake-id=\"u1e4fe6de\" id=\"u1e4fe6de\"><span data-lake-id=\"ue70ae291\" id=\"ue70ae291\">next</span></code><span data-lake-id=\"u1618bf60\" id=\"u1618bf60\"> 指向当前要添加的节点 </span><code data-lake-id=\"u94e9ae41\" id=\"u94e9ae41\"><span data-lake-id=\"u3ee37498\" id=\"u3ee37498\">node</span></code><span data-lake-id=\"u08526f30\" id=\"u08526f30\">，然后修改 </span><code data-lake-id=\"u1c0cf70f\" id=\"u1c0cf70f\"><span data-lake-id=\"u65b4dbfb\" id=\"u65b4dbfb\">node</span></code><span data-lake-id=\"u4ebad9da\" id=\"u4ebad9da\"> 的 </span><code data-lake-id=\"u0173ddc7\" id=\"u0173ddc7\"><span data-lake-id=\"uba25d680\" id=\"uba25d680\">prev</span></code><span data-lake-id=\"uf6deb859\" id=\"uf6deb859\"> 指向旧的 </span><code data-lake-id=\"u37cb4582\" id=\"u37cb4582\"><span data-lake-id=\"u75153f77\" id=\"u75153f77\">tail</span></code><span data-lake-id=\"uef46ece3\" id=\"uef46ece3\">，最后修改 </span><code data-lake-id=\"uc7257f4c\" id=\"uc7257f4c\"><span data-lake-id=\"ucc309738\" id=\"ucc309738\">tail</span></code><span data-lake-id=\"u929f1f63\" id=\"u929f1f63\"> 为新添加的节点。我们不需要从头开始遍历整个链表，而通过 </span><code data-lake-id=\"u0f9def48\" id=\"u0f9def48\"><span data-lake-id=\"u8d5c515e\" id=\"u8d5c515e\">tail</span></code><span data-lake-id=\"uae3d3836\" id=\"uae3d3836\"> 可以直接找到链表的尾部，这一点比单向链表的操作要更方便。最后将 </span><code data-lake-id=\"u6e6a2937\" id=\"u6e6a2937\"><span data-lake-id=\"u87d2e329\" id=\"u87d2e329\">length</span></code><span data-lake-id=\"uaf0009ba\" id=\"uaf0009ba\"> 的值加 </span><code data-lake-id=\"u9461eb26\" id=\"u9461eb26\"><span data-lake-id=\"u90aed7f5\" id=\"u90aed7f5\">1</span></code><span data-lake-id=\"u629cf6db\" id=\"u629cf6db\">，修改链表的长度。</span></li></ul><p data-lake-id=\"b3add770127d8c2a5064673aa8a9731f_p_64\" id=\"b3add770127d8c2a5064673aa8a9731f_p_64\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22append(element)%20%7B%5Cn%20%20var%20node%20%3D%20new%20Node(element)%3B%5Cn%5Cn%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E9%93%BE%E8%A1%A8%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%88%99%E5%B0%86%20head%20%E5%92%8C%20tail%20%E9%83%BD%E6%8C%87%E5%90%91%E5%BD%93%E5%89%8D%E6%B7%BB%E5%8A%A0%E7%9A%84%E8%8A%82%E7%82%B9%5Cn%20%20if%20(this.head%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%20%20this.tail%20%3D%20node%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20%2F%2F%20%E5%90%A6%E5%88%99%EF%BC%8C%E5%B0%86%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E9%83%A8%5Cn%20%20%20%20this.tail.next%20%3D%20node%3B%5Cn%20%20%20%20node.prev%20%3D%20this.tail%3B%5Cn%20%20%20%20this.tail%20%3D%20node%3B%5Cn%20%20%7D%5Cn%20%20this.length%2B%2B%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2282b5988d%22%7D\"></card><p data-lake-id=\"2a81d6eed31dfd1dc3c193bbdb75c1a1_p_65\" id=\"2a81d6eed31dfd1dc3c193bbdb75c1a1_p_65\"><br></p><ul list=\"uad5eb05e\"><li fid=\"ua08fd35f\" data-lake-id=\"fb612dbf2bb2e66d056a6eaabc751c4a_li_15\" id=\"fb612dbf2bb2e66d056a6eaabc751c4a_li_15\"><span data-lake-id=\"u08febd7b\" id=\"u08febd7b\">由于双向链表可以从链表的尾部往前遍历，所以我们修改了 </span><code data-lake-id=\"uea665eb0\" id=\"uea665eb0\"><span data-lake-id=\"uefb9c607\" id=\"uefb9c607\">getElementAt()</span></code><span data-lake-id=\"ud7322268\" id=\"ud7322268\"> 方法，对基类中单向链表的方法进行了改写。当要查找的元素的索引号大于链表长度的一半时，从链表的尾部开始遍历。</span></li></ul><p data-lake-id=\"cf44cb59378505901ec625cdc88d7d91_p_66\" id=\"cf44cb59378505901ec625cdc88d7d91_p_66\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22getELementAt(position)%20%7B%5Cn%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20return%20null%3B%5Cn%20%20%2F%2F%20%E4%BB%8E%E5%90%8E%E5%90%91%E5%89%8D%E9%81%8D%E5%8E%86%5Cn%20%20if%20(position%20%3E%20Math.floor(this.length%20%2F%202))%20%7B%5Cn%20%20%20%20var%20current%20%3D%20this.tail%3B%5Cn%20%20%20%20for%20(var%20i%20%3D%20this.length%20-%201%3B%20i%20%3E%20position%3B%20i--)%20%7B%5Cn%20%20%20%20%20%20current%20%3D%20current.prev%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20current%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20return%20super.getELementAt(position)%3B%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2292923481%22%7D\"></card><p data-lake-id=\"152302cc03cd3433e252fd8fbe4bade7_p_67\" id=\"152302cc03cd3433e252fd8fbe4bade7_p_67\"><br></p><blockquote data-lake-id=\"ua1bfc6ae\" id=\"ua1bfc6ae\"><p data-lake-id=\"4d870fc948e9f1e7f3f99b3638b5d172_p_68\" id=\"4d870fc948e9f1e7f3f99b3638b5d172_p_68\"><span data-lake-id=\"u71700299\" id=\"u71700299\">有两种遍历方式，从前往后遍历调用的是基类单向链表里的方法，从后往前遍历需要用到节点的 </span><code data-lake-id=\"u727affcb\" id=\"u727affcb\"><span data-lake-id=\"ubb4b2266\" id=\"ubb4b2266\">prev</span></code><span data-lake-id=\"u70817fdb\" id=\"u70817fdb\"> 指针，用来查找前一个节点。</span></p></blockquote><p data-lake-id=\"956e0d4312e941b77cd57ec35c294aff_p_69\" id=\"956e0d4312e941b77cd57ec35c294aff_p_69\"><br></p><ul list=\"ub106345e\"><li fid=\"ufb793f35\" data-lake-id=\"1c6b2cbaa20f2b95f254bde42dfcc6be_li_16\" id=\"1c6b2cbaa20f2b95f254bde42dfcc6be_li_16\"><span data-lake-id=\"u668af0dd\" id=\"u668af0dd\">我们同时还需要修改 </span><code data-lake-id=\"u9eeba64b\" id=\"u9eeba64b\"><span data-lake-id=\"ucba4d025\" id=\"ucba4d025\">insert()</span></code><span data-lake-id=\"udca48074\" id=\"udca48074\"> 和 </span><code data-lake-id=\"ubd1bd4d7\" id=\"ubd1bd4d7\"><span data-lake-id=\"ua9b0f579\" id=\"ua9b0f579\">removeAt()</span></code><span data-lake-id=\"u8d0b2519\" id=\"u8d0b2519\"> 这两个方法。记住，与单向链表唯一的区别就是要同时维护 </span><code data-lake-id=\"u77a27df3\" id=\"u77a27df3\"><span data-lake-id=\"u75bf2d86\" id=\"u75bf2d86\">head</span></code><span data-lake-id=\"u112ab9e5\" id=\"u112ab9e5\"> 和 </span><code data-lake-id=\"u670ea764\" id=\"u670ea764\"><span data-lake-id=\"u93851976\" id=\"u93851976\">tail</span></code><span data-lake-id=\"uba7d651a\" id=\"uba7d651a\">，以及每一个节点上的 </span><code data-lake-id=\"udc63186a\" id=\"udc63186a\"><span data-lake-id=\"ua98b5130\" id=\"ua98b5130\">next</span></code><span data-lake-id=\"u9cd06e8f\" id=\"u9cd06e8f\"> 和 </span><code data-lake-id=\"u6155cda0\" id=\"u6155cda0\"><span data-lake-id=\"u1fec8335\" id=\"u1fec8335\">prev</span></code><span data-lake-id=\"u1f3b668a\" id=\"u1f3b668a\"> 指针。</span></li></ul><p data-lake-id=\"67523e0fa28fe87849ce38cd391e3347_p_70\" id=\"67523e0fa28fe87849ce38cd391e3347_p_70\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22insert(position%2C%20element)%20%7B%5Cn%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20return%20false%3B%5Cn%5Cn%20%20%2F%2F%20%E6%8F%92%E5%85%A5%E5%88%B0%E5%B0%BE%E9%83%A8%5Cn%20%20if%20(position%20%3D%3D%3D%20this.length)%20%7B%5Cn%20%20%20%20this.append(element)%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20var%20node%20%3D%20new%20ListNode(element)%3B%5Cn%20%20%20%20%2F%2F%20%E6%8F%92%E5%85%A5%E5%88%B0%E5%A4%B4%E9%83%A8%5Cn%20%20%20%20if%20(position%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20if%20(this.head%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%20%20%20%20%20%20this.tail%20%3D%20node%3B%5Cn%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20node.next%20%3D%20this.head%3B%5Cn%20%20%20%20%20%20%20%20this.head.prev%20%3D%20node%3B%5Cn%20%20%20%20%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%2F%2F%20%E6%8F%92%E5%85%A5%E5%88%B0%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE%5Cn%20%20%20%20%20%20var%20current%20%3D%20this.getElementAt(position)%3B%5Cn%20%20%20%20%20%20var%20previous%20%3D%20current.prev%3B%5Cn%20%20%20%20%20%20node.next%20%3D%20current%3B%5Cn%20%20%20%20%20%20node.prev%20%3D%20previous%3B%5Cn%20%20%20%20%20%20previous.next%20%3D%20node%3B%5Cn%20%20%20%20%20%20current.prev%20%3D%20node%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20this.length%2B%2B%3B%5Cn%20%20return%20true%3B%5Cn%7D%5Cn%5CnremoveAt(position)%20%7B%5Cn%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20return%20null%3B%5Cn%5Cn%20%20var%20current%20%3D%20this.head%3B%5Cn%20%20var%20previous%3B%5Cn%5Cn%20%20%2F%2F%20%E7%A7%BB%E9%99%A4%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0%5Cn%20%20if%20(position%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20this.head%20%3D%20current.next%3B%5Cn%20%20%20%20this.head.prev%20%3D%20null%3B%5Cn%20%20%20%20if%20(this.length%20%3D%3D%3D%201)%20%7B%5Cn%20%20%20%20%20%20this.tail%20%3D%20null%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%20else%20if%20(position%20%3D%3D%3D%20this.length%20-%201)%20%7B%5Cn%20%20%20%20%2F%2F%20%E7%A7%BB%E9%99%A4%E5%B0%BE%E9%83%A8%E5%85%83%E7%B4%A0%5Cn%20%20%20%20current%20%3D%20this.tail%3B%5Cn%20%20%20%20this.tail%20%3D%20current.prev%3B%5Cn%20%20%20%20this.tail.next%20%3D%20null%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20%2F%2F%20%E7%A7%BB%E9%99%A4%E4%B8%AD%E9%97%B4%E5%85%83%E7%B4%A0%5Cn%20%20%20%20current%20%3D%20this.getELementAt(position)%3B%5Cn%20%20%20%20previous%20%3D%20current.prev%3B%5Cn%20%20%20%20previous.next%20%3D%20current.next%3B%5Cn%20%20%20%20current.next.prev%20%3D%20previous%3B%5Cn%20%20%7D%5Cn%20%20this.length--%3B%5Cn%20%20return%20current.element%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22e965d6f7%22%7D\"></card><p data-lake-id=\"b7f5c253c3fb3956b40638fc0613cbf9_p_71\" id=\"b7f5c253c3fb3956b40638fc0613cbf9_p_71\"><br></p><ul list=\"u11e07ce0\"><li fid=\"u24cd7a06\" data-lake-id=\"1e25a43370983bdf041a1d8097c0bd11_li_17\" id=\"1e25a43370983bdf041a1d8097c0bd11_li_17\"><span data-lake-id=\"u1cbe03ab\" id=\"u1cbe03ab\">操作过程中需要判断一些特殊情况，例如链表的头和尾，以及当前链表是否为空等等，否则程序可能会在某些特殊情况下导致越界和报错。下面是一个完整的双向链表类的代码</span></li></ul><p data-lake-id=\"200b796b4b1f5a36aa12caae6b6fa3d8_p_72\" id=\"200b796b4b1f5a36aa12caae6b6fa3d8_p_72\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20DoubleLinkList%20extends%20LinkList%20%7B%5Cn%20%20constructor()%20%7B%5Cn%20%20%20%20super()%3B%5Cn%20%20%20%20this.tail%20%3D%20null%3B%5Cn%20%20%7D%5Cn%20%20append(element)%20%7B%5Cn%20%20%20%20var%20node%20%3D%20new%20ListNode(element)%3B%5Cn%20%20%20%20if%20(this.head%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%20%20%20%20this.tail%20%3D%20node%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20this.tail.next%20%3D%20node%3B%5Cn%20%20%20%20%20%20node.prev%20%3D%20this.tail%3B%5Cn%20%20%20%20%20%20this.tail%20%3D%20node%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.length%2B%2B%3B%5Cn%20%20%7D%5Cn%20%20getElementAt(position)%20%7B%5Cn%20%20%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20return%20null%3B%5Cn%20%20%20%20if%20(position%20%3E%20Math.floor(this.length%20%2F%202))%20%7B%5Cn%20%20%20%20%20%20var%20current%20%3D%20this.tail%3B%5Cn%20%20%20%20%20%20for%20(var%20i%20%3D%20this.length%20-%201%3B%20i%20%3E%20position%3B%20i--)%20%7B%5Cn%20%20%20%20%20%20%20%20current%20%3D%20current.prev%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20return%20current%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20super.getElementAt(position)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20insert(position%2C%20element)%20%7B%5Cn%20%20%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20return%20false%3B%5Cn%5Cn%20%20%20%20if%20(position%20%3D%3D%3D%20this.length)%20%7B%5Cn%20%20%20%20%20%20this.append(element)%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20var%20node%20%3D%20new%20ListNode(element)%3B%5Cn%20%20%20%20%20%20if%20(position%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(this.head%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%20%20%20%20%20%20%20%20this.tail%20%3D%20node%3B%5Cn%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20node.next%20%3D%20this.head%3B%5Cn%20%20%20%20%20%20%20%20%20%20this.head.prev%20%3D%20node%3B%5Cn%20%20%20%20%20%20%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20var%20current%20%3D%20this.getElementAt(position)%3B%5Cn%20%20%20%20%20%20%20%20var%20previous%20%3D%20current.prev%3B%5Cn%20%20%20%20%20%20%20%20node.next%20%3D%20current%3B%5Cn%20%20%20%20%20%20%20%20node.prev%20%3D%20previous%3B%5Cn%20%20%20%20%20%20%20%20previous.next%20%3D%20node%3B%5Cn%20%20%20%20%20%20%20%20current.prev%20%3D%20node%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.length%2B%2B%3B%5Cn%20%20%20%20return%20true%3B%5Cn%20%20%7D%5Cn%20%20removeAt(position)%20%7B%5Cn%20%20%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20return%20null%3B%5Cn%20%20%20%20var%20current%20%3D%20this.head%3B%5Cn%20%20%20%20var%20previous%3B%5Cn%20%20%20%20if%20(position%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20this.head%20%3D%20current.next%3B%5Cn%20%20%20%20%20%20this.head.prev%20%3D%20null%3B%5Cn%20%20%20%20%20%20if%20(this.length%20%3D%3D%3D%201)%20%7B%5Cn%20%20%20%20%20%20%20%20this.tail%20%3D%20null%3B%20%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%20else%20if%20(position%20%3D%3D%3D%20this.length%20-%201)%20%7B%5Cn%20%20%20%20%20%20current%20%3D%20this.tail%3B%5Cn%20%20%20%20%20%20this.tail%20%3D%20current.prev%3B%5Cn%20%20%20%20%20%20this.tail.next%20%3D%20null%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20current%20%3D%20this.getElementAt(position)%3B%5Cn%20%20%20%20%20%20previous%20%3D%20current.prev%3B%5Cn%20%20%20%20%20%20previous.next%20%3D%20current.next%3B%5Cn%20%20%20%20%20%20current.next.prev%20%3D%20previous%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.length--%3B%5Cn%20%20%20%20return%20current.element%3B%5Cn%20%20%7D%5Cn%20%20getTail()%20%7B%5Cn%20%20%20%20return%20this.tail%3B%5Cn%20%20%7D%5Cn%20%20clear()%20%7B%5Cn%20%20%20%20super.clear()%3B%5Cn%20%20%20%20this.tail%20%3D%20null%3B%5Cn%20%20%7D%5Cn%20%20toString()%20%7B%5Cn%20%20%20%20var%20current%20%3D%20this.head%3B%5Cn%20%20%20%20var%20s%20%3D%20''%3B%5Cn%5Cn%20%20%20%20while%20(current)%20%7B%5Cn%20%20%20%20%20%20var%20next%20%3D%20current.next%3B%5Cn%20%20%20%20%20%20var%20previous%20%3D%20current.prev%3B%5Cn%20%20%20%20%20%20next%20%3D%20next%20%3F%20next.element%20%3A%20'null'%3B%5Cn%20%20%20%20%20%20previous%20%3D%20previous%20%3F%20previous.element%20%3A%20'null'%3B%5Cn%20%20%20%20%20%20s%20%2B%3D%20%60%5Belement%3A%20%24%7Bcurrent.element%7D%2C%20prev%3A%20%24%7Bprevious%7D%2C%20next%3A%20%24%7Bnext%7D%5D%60%3B%5Cn%20%20%20%20%20%20current%20%3D%20current.next%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20return%20s%3B%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%224cc9d200%22%7D\"></card><p data-lake-id=\"7e9db6e1dddd1090f9cbf7742b89f0d6_p_73\" id=\"7e9db6e1dddd1090f9cbf7742b89f0d6_p_73\"><br></p><ul list=\"ufc73a7cf\"><li fid=\"u119345c6\" data-lake-id=\"472e55dbf4deef5e801a1aea0c8b6d12_li_18\" id=\"472e55dbf4deef5e801a1aea0c8b6d12_li_18\"><span data-lake-id=\"u15a83073\" id=\"u15a83073\">我们重写了 </span><code data-lake-id=\"u288a229a\" id=\"u288a229a\"><span data-lake-id=\"u346cc75c\" id=\"u346cc75c\">toString()</span></code><span data-lake-id=\"u62722cdd\" id=\"u62722cdd\"> 方法以方便更加清楚地查看测试结果。下面是一些测试用例：</span></li></ul><p data-lake-id=\"d36608d2dcf9f070081537010b5adfb3_p_74\" id=\"d36608d2dcf9f070081537010b5adfb3_p_74\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20doubleLinkList%20%3D%20new%20DoubleLinkList()%3B%5CndoubleLinkList.append(10)%3B%5CndoubleLinkList.append(15)%3B%5CndoubleLinkList.append(20)%3B%5CndoubleLinkList.append(25)%3B%5CndoubleLinkList.append(30)%3B%5Cnconsole.log(doubleLinkList.toString())%3B%5Cnconsole.log(doubleLinkList.getElementAt(1).element)%3B%5Cnconsole.log(doubleLinkList.getElementAt(2).element)%3B%5Cnconsole.log(doubleLinkList.getElementAt(3).element)%3B%5Cn%5CndoubleLinkList.insert(0%2C%209)%3B%5CndoubleLinkList.insert(4%2C%2024)%3B%5CndoubleLinkList.insert(7%2C%2035)%3B%5Cnconsole.log(doubleLinkList.toString())%3B%5Cn%5Cnconsole.log(doubleLinkList.removeAt(0))%3B%5Cnconsole.log(doubleLinkList.removeAt(1))%3B%5Cnconsole.log(doubleLinkList.removeAt(5))%3B%5Cnconsole.log(doubleLinkList.toString())%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2225634705%22%7D\"></card><p data-lake-id=\"cee026a6997be2fe2ca3b5d6e2ce2bf0_p_75\" id=\"cee026a6997be2fe2ca3b5d6e2ce2bf0_p_75\"><br></p><p data-lake-id=\"28a7c119a7b8708c8cfc9833004e4e86_p_76\" id=\"28a7c119a7b8708c8cfc9833004e4e86_p_76\"><span data-lake-id=\"uf199c451\" id=\"uf199c451\">-　对应的结果如下</span></p><p data-lake-id=\"9fc1a1e32cf7c324fef5888bc3009382_p_77\" id=\"9fc1a1e32cf7c324fef5888bc3009382_p_77\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%5Belement%3A%2010%2C%20prev%3A%20null%2C%20next%3A%2015%5D%20%5Belement%3A%2015%2C%20prev%3A%2010%2C%20next%3A%2020%5D%20%5Belement%3A%2020%2C%20prev%3A%2015%2C%20next%3A%2025%5D%20%5Belement%3A%2025%2C%20prev%3A%2020%2C%20next%3A%2030%5D%20%5Belement%3A%2030%2C%20prev%3A%2025%2C%20next%3A%20null%5D%20%5Cn20%5Cn%5Belement%3A%209%2C%20prev%3A%20null%2C%20next%3A%2010%5D%20%5Belement%3A%2010%2C%20prev%3A%209%2C%20next%3A%2015%5D%20%5Belement%3A%2015%2C%20prev%3A%2010%2C%20next%3A%2020%5D%20%5Belement%3A%2020%2C%20prev%3A%2015%2C%20next%3A%2024%5D%20%5Belement%3A%2024%2C%20prev%3A%2020%2C%20next%3A%2025%5D%20%5Belement%3A%2025%2C%20prev%3A%2024%2C%20next%3A%2030%5D%20%5Belement%3A%2030%2C%20prev%3A%2025%2C%20next%3A%2035%5D%20%5Belement%3A%2035%2C%20prev%3A%2030%2C%20next%3A%20null%5D%20%5Cn15%5Cn%5Belement%3A%2010%2C%20prev%3A%20null%2C%20next%3A%2020%5D%20%5Belement%3A%2020%2C%20prev%3A%2010%2C%20next%3A%2024%5D%20%5Belement%3A%2024%2C%20prev%3A%2020%2C%20next%3A%2025%5D%20%5Belement%3A%2025%2C%20prev%3A%2024%2C%20next%3A%2035%5D%20%5Belement%3A%2035%2C%20prev%3A%2025%2C%20next%3A%20null%5D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22aff9010a%22%7D\"></card><p data-lake-id=\"f585fed1cef9af7641b65ac1c4919258_p_78\" id=\"f585fed1cef9af7641b65ac1c4919258_p_78\"><br></p><h2 data-lake-id=\"e99bcd83\" id=\"e99bcd83\"><span data-lake-id=\"u0bb5bb66\" id=\"u0bb5bb66\">循环链表</span></h2><p data-lake-id=\"f855fcce122120d1233c03106e601338_p_79\" id=\"f855fcce122120d1233c03106e601338_p_79\"><br></p><h3 data-lake-id=\"61a3ec66\" id=\"61a3ec66\"><span data-lake-id=\"u9a7174df\" id=\"u9a7174df\">介绍</span></h3><p data-lake-id=\"cacc5e28cdefa24e262c83e0ab2a3ade_p_80\" id=\"cacc5e28cdefa24e262c83e0ab2a3ade_p_80\"><br></p><blockquote data-lake-id=\"uced1c78c\" id=\"uced1c78c\"><p data-lake-id=\"9ba304ef5ef40b56856fd834e2552ea3_p_81\" id=\"9ba304ef5ef40b56856fd834e2552ea3_p_81\"><span data-lake-id=\"u0bdd31e3\" id=\"u0bdd31e3\">顾名思义，循环链表的尾部指向它自己的头部。循环链表可以有单向循环链表，也可以有双向循环链表。下面是单向循环链表和双向循环链表的数据结构示意图</span></p></blockquote><p data-lake-id=\"1a51c9f1188a20d8f4ddd78fcfd5029c\" id=\"1a51c9f1188a20d8f4ddd78fcfd5029c\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F732231%2F1608705287564-4531cdeb-9452-4e71-a303-44e9c7c6e029.png%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A813%2C%22height%22%3A299%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22linkList_around.png%22%2C%22size%22%3A13882%2C%22originWidth%22%3A813%2C%22originHeight%22%3A299%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22node%20node%20node%20head%20item%20item%20item%20next%20next%20next%20node%20node%20node%20tail%20heade%20item%20item%20next%20item%20next%20prev%20next%20prey%20prev%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A524.976%2C%22y%22%3A2.5966797%2C%22width%22%3A35.32320000000004%2C%22height%22%3A11.0219473%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A353.00525%2C%22y%22%3A3.244418%2C%22width%22%3A36.45898%2C%22height%22%3A10.162554%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A197.26483%2C%22y%22%3A5.196489%2C%22width%22%3A34.83769000000001%2C%22height%22%3A11.045231000000001%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A63.26903%2C%22y%22%3A22.279266%2C%22width%22%3A33.380539999999996%2C%22height%22%3A11.766254000000004%2C%22text%22%3A%22head%22%7D%2C%7B%22x%22%3A332.6144%2C%22y%22%3A40.883404%2C%22width%22%3A29.332220000000007%2C%22height%22%3A10.695656%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A172.91351%2C%22y%22%3A41.609467%2C%22width%22%3A28.80811%2C%22height%22%3A10.1963%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A494.78796%2C%22y%22%3A41.646442%2C%22width%22%3A29.363839999999982%2C%22height%22%3A10.406128000000002%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A383.62033%2C%22y%22%3A41.65988%2C%22width%22%3A31.288089999999954%2C%22height%22%3A10.340119999999999%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A545.7431%2C%22y%22%3A41.92435%2C%22width%22%3A30.922900000000027%2C%22height%22%3A10.71499%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A223.65556%2C%22y%22%3A41.902332%2C%22width%22%3A32.53450000000001%2C%22height%22%3A10.830230999999998%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A590.624%2C%22y%22%3A181.6245%2C%22width%22%3A34.23529999999994%2C%22height%22%3A12.319729999999993%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A381.30295%2C%22y%22%3A182.03859%2C%22width%22%3A34.51488999999998%2C%22height%22%3A11.29477%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A170.25533%2C%22y%22%3A182.69096%2C%22width%22%3A35.26547000000002%2C%22height%22%3A11.15909000000002%2C%22text%22%3A%22node%22%7D%2C%7B%22x%22%3A752.8399%2C%22y%22%3A209.72145%2C%22width%22%3A20.951540000000023%2C%22height%22%3A13.009889999999984%2C%22text%22%3A%22tail%22%7D%2C%7B%22x%22%3A22.085005%2C%22y%22%3A211.61293%2C%22width%22%3A31.317075%2C%22height%22%3A10.358609999999999%2C%22text%22%3A%22heade%22%7D%2C%7B%22x%22%3A592.07184%2C%22y%22%3A222.94673%2C%22width%22%3A30.895860000000084%2C%22height%22%3A12.82186999999999%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A382.54434%2C%22y%22%3A223.02922%2C%22width%22%3A30.269720000000007%2C%22height%22%3A11.771029999999996%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A434.271%2C%22y%22%3A223.66113%2C%22width%22%3A31.624259999999992%2C%22height%22%3A10.988939999999985%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A171.70848%2C%22y%22%3A224.05977%2C%22width%22%3A30.61794999999998%2C%22height%22%3A11.349490000000003%2C%22text%22%3A%22item%22%7D%2C%7B%22x%22%3A224.12177%2C%22y%22%3A224.69048%2C%22width%22%3A30.833079999999995%2C%22height%22%3A10.967279999999988%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A333.1784%2C%22y%22%3A224.96663%2C%22width%22%3A30.10300000000001%2C%22height%22%3A10.945480000000003%2C%22text%22%3A%22prev%22%7D%2C%7B%22x%22%3A643.1651%2C%22y%22%3A225.12746%2C%22width%22%3A30.893499999999904%2C%22height%22%3A8.968909999999994%2C%22text%22%3A%22next%22%7D%2C%7B%22x%22%3A542.4132%2C%22y%22%3A224.6579%2C%22width%22%3A29.020330000000058%2C%22height%22%3A10.669549999999987%2C%22text%22%3A%22prey%22%7D%2C%7B%22x%22%3A122.22065%2C%22y%22%3A225.19884%2C%22width%22%3A29.5043%2C%22height%22%3A10.840850000000017%2C%22text%22%3A%22prev%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23d1d1d1%22%2C%22id%22%3A%22jcuvb%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"470257ffbff08ad0eedbc557452f8c66_p_84\" id=\"470257ffbff08ad0eedbc557452f8c66_p_84\"><br></p><blockquote data-lake-id=\"u92eaa0ae\" id=\"u92eaa0ae\"><p data-lake-id=\"e58586690da8f83c90d1fcda883aeab1_p_85\" id=\"e58586690da8f83c90d1fcda883aeab1_p_85\"><span data-lake-id=\"ue7af55fa\" id=\"ue7af55fa\">在实现循环链表时，需要确保最后一个元素的 </span><code data-lake-id=\"u0124896c\" id=\"u0124896c\"><span data-lake-id=\"u41dc74d9\" id=\"u41dc74d9\">next</span></code><span data-lake-id=\"ue4c4a767\" id=\"ue4c4a767\"> 指针指向 </span><code data-lake-id=\"ud93d452b\" id=\"ud93d452b\"><span data-lake-id=\"uc6979512\" id=\"uc6979512\">head</span></code><span data-lake-id=\"u323efdb1\" id=\"u323efdb1\">。下面是单向循环链表的完整代码</span></p></blockquote><p data-lake-id=\"c07d4a2054239914d4a014d7d64fcf23_p_86\" id=\"c07d4a2054239914d4a014d7d64fcf23_p_86\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20CircularLinkList%20extends%20LinkList%20%7B%5Cn%20%20constructor()%20%7B%5Cn%20%20%20%20super()%3B%5Cn%20%20%7D%5Cn%20%20append(element)%20%7B%5Cn%20%20%20%20let%20node%20%3D%20new%20ListNode(element)%3B%5Cn%20%20%20%20if%20(this.head%20%3D%3D%3D%20null)%20this.head%20%3D%20node%3B%5Cn%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20let%20current%20%3D%20this.getElementAt(this.length%20-%201)%3B%5Cn%20%20%20%20%20%20current.next%20%3D%20node%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F%2F%20%E5%B0%86%E6%96%B0%E6%B7%BB%E5%8A%A0%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84%20next%20%E6%8C%87%E5%90%91%20head%5Cn%20%20%20%20node.next%20%3D%20this.head%3B%5Cn%20%20%20%20this.length%2B%2B%3B%5Cn%20%20%7D%5Cn%20%20insert(element%2C%20position)%20%7B%5Cn%20%20%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20return%20false%3B%5Cn%20%20%20%20let%20node%20%3D%20new%20ListNode(element)%3B%5Cn%20%20%20%20if%20(position%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20node.next%20%3D%20this.head%3B%5Cn%20%20%20%20%20%20let%20current%20%3D%20this.getElementAt(this.length%20-%201)%3B%5Cn%20%20%20%20%20%20current.next%20%3D%20node%3B%5Cn%20%20%20%20%20%20this.head%20%3D%20node%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20var%20previous%20%3D%20this.getElementAt(position%20-%201)%3B%5Cn%20%20%20%20%20%20node.next%20%3D%20previous.next%3B%5Cn%20%20%20%20%20%20previous.next%20%3D%20node%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.length%2B%2B%3B%5Cn%20%20%20%20return%20true%3B%5Cn%20%20%7D%5Cn%20%20removeAt(position)%20%7B%5Cn%20%20%20%20if%20(position%20%3C%200%20%7C%7C%20position%20%3E%20this.length%20-%201)%20return%20null%3B%5Cn%20%20%20%20let%20current%20%3D%20this.head%3B%5Cn%20%20%20%20if%20(position%20%3D%3D%3D%200)%20this.head%20%3D%20current.next%3B%5Cn%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20let%20previous%20%3D%20this.getElementAt(position%20-%201)%3B%5Cn%20%20%20%20%20%20current%20%3D%20previous.next%3B%5Cn%20%20%20%20%20%20previous.next%20%3D%20current.next%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20this.length--%3B%5Cn%20%20%20%20if%20(this.length%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20let%20last%20%3D%20this.getElementAt(this.length%20-%201)%3B%5Cn%20%20%20%20%20%20last.next%20%3D%20this.head%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20current.element%3B%5Cn%20%20%7D%5Cn%20%20toString()%20%7B%5Cn%20%20%20%20let%20current%20%3D%20this.head%3B%5Cn%20%20%20%20let%20s%20%3D%20''%3B%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20this.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20let%20next%20%3D%20current.next%3B%5Cn%20%20%20%20%20%20next%20%3D%20next%20%3F%20next.element%20%3A%20'null'%3B%5Cn%20%20%20%20%20%20s%20%2B%3D%20%60%5Belement%3A%20%24%7Bcurrent.element%7D%2C%20next%3A%20%24%7Bnext%7D%5D%60%3B%5Cn%20%20%20%20%20%20current%20%3D%20current.next%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%220e5a6b7f%22%7D\"></card><p data-lake-id=\"bd67236b6b40e1ddeba66aa4c905c5af_p_87\" id=\"bd67236b6b40e1ddeba66aa4c905c5af_p_87\"><br></p><ul list=\"u7aca9f80\"><li fid=\"u8c62ef8e\" data-lake-id=\"d37c3e02383ce61ac96e1a5ffe252903_li_19\" id=\"d37c3e02383ce61ac96e1a5ffe252903_li_19\"><span data-lake-id=\"uad231c34\" id=\"uad231c34\">单向循环链表的测试用例</span></li></ul><p data-lake-id=\"ac4c0d2013d04adfac6d2e9459525ac0_p_88\" id=\"ac4c0d2013d04adfac6d2e9459525ac0_p_88\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20circularLinkList%20%3D%20new%20CircularLinkList()%3B%5CncircularLinkList.append(10)%3B%5CncircularLinkList.append(15)%3B%5CncircularLinkList.append(20)%3B%5Cn%5Cnconsole.log(circularLinkList.toString())%3B%5Cn%5CncircularLinkList.insert(0%2C%209)%3B%5CncircularLinkList.insert(3%2C%2025)%3B%5Cnconsole.log(circularLinkList.toString())%3B%5Cn%5Cnconsole.log(circularLinkList.removeAt(0))%3B%5Cnconsole.log(circularLinkList.toString())%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22dd66533a%22%7D\"></card><p data-lake-id=\"ab51a4ad9cb9ee48199bb5c9fc6715a2_p_89\" id=\"ab51a4ad9cb9ee48199bb5c9fc6715a2_p_89\"><br></p><p data-lake-id=\"98cc90e5a061e870651ed34f20c695df_p_90\" id=\"98cc90e5a061e870651ed34f20c695df_p_90\"><span data-lake-id=\"u5bae6962\" id=\"u5bae6962\">-　对应的结果如下</span></p><p data-lake-id=\"55b4793bc7d98162a0d6addc99b469ec\" id=\"55b4793bc7d98162a0d6addc99b469ec\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F732231%2F1608705316856-b6b81605-b48c-462c-adc6-57b21fecd1bf.png%22%2C%22originalType%22%3A%22binary%22%2C%22width%22%3A1086%2C%22height%22%3A87%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22linList_around_result.png%22%2C%22size%22%3A9699%2C%22originWidth%22%3A1086%2C%22originHeight%22%3A87%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22felemnt%3A10%2Cxt%3A%2010)lelement%3Aox%20element%3A9%2Cnext%3A%20felemnt%3A10%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A13.544163%2C%22y%22%3A1.260932%2C%22width%22%3A627.517607%2C%22height%22%3A18.81276%2C%22text%22%3A%22felemnt%3A10%2Cxt%3A%22%7D%2C%7B%22x%22%3A175.30183%2C%22y%22%3A16.98083%2C%22width%22%3A882.7585700000001%2C%22height%22%3A21.432570000000002%2C%22text%22%3A%2210)lelement%3Aox%22%7D%2C%7B%22x%22%3A7.3585167%2C%22y%22%3A21.21903%2C%22width%22%3A152.18799330000002%2C%22height%22%3A15.448027%2C%22text%22%3A%22element%3A9%2Cnext%3A%22%7D%2C%7B%22x%22%3A7.2991314%2C%22y%22%3A55.6611%2C%22width%22%3A852.0947686000001%2C%22height%22%3A18.439616000000008%2C%22text%22%3A%22felemnt%3A10%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%232e2e26%22%2C%22id%22%3A%22ODmE6%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 4211,
  "created_at": "2020-08-09T08:03:42.000Z",
  "updated_at": "2023-11-19T17:54:57.000Z",
  "content_updated_at": "2023-11-19T17:54:56.000Z",
  "published_at": "2023-11-19T17:54:56.000Z",
  "first_published_at": "2020-08-09T08:03:42.000Z",
  "book": {
    "id": 24854102,
    "type": "Book",
    "slug": "gm8h7g",
    "name": "算法 algorithm",
    "user_id": 732231,
    "description": "算法基础、leetCode",
    "toc_yml": "- type: META\n  count: 17\n  display_level: all\n  tail_type: UPDATED_AT\n  base_version_id: 372567226\n  published: true\n  max_level: 1\n  last_updated_at: 2023-11-19T18:02:44.264Z\n  version_id: 372567245\n- type: TITLE\n  title: 算法刷题索引\n  uuid: 9iuletCnX8AA1DWl\n  url: ''\n  prev_uuid: ''\n  sibling_uuid: BMR7y68MzsRsLpq6\n  child_uuid: 4IS2N309UG8zzeKG\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: LeetCode 热题 🔥 100\n  uuid: 4IS2N309UG8zzeKG\n  url: im0vt7\n  prev_uuid: 9iuletCnX8AA1DWl\n  sibling_uuid: uioHkKsczkPGgdyr\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67808056\n  level: 1\n  id: 67808056\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 剑指 offer 第二版\n  uuid: uioHkKsczkPGgdyr\n  url: dotw59\n  prev_uuid: 4IS2N309UG8zzeKG\n  sibling_uuid: syezq9xwx3badLKu\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810801\n  level: 1\n  id: 67810801\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: LeetCode 精选 TOP 面试题\n  uuid: syezq9xwx3badLKu\n  url: brcxx5\n  prev_uuid: uioHkKsczkPGgdyr\n  sibling_uuid: PKQxO_4GM33AkW__\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810529\n  level: 1\n  id: 67810529\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 剑指 offer 专项突击版\n  uuid: PKQxO_4GM33AkW__\n  url: mff6ll\n  prev_uuid: syezq9xwx3badLKu\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810920\n  level: 1\n  id: 67810920\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 数据结构\n  uuid: BMR7y68MzsRsLpq6\n  url: ''\n  prev_uuid: 9iuletCnX8AA1DWl\n  sibling_uuid: zvwUUlHnEeEhPJ9v\n  child_uuid: E-fia709YBhQtJrt\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 对象 object\n  uuid: E-fia709YBhQtJrt\n  url: aogq4f\n  prev_uuid: BMR7y68MzsRsLpq6\n  sibling_uuid: D7LcTHUXkpP6SYG4\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432408\n  level: 1\n  id: 11432408\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 数组 array\n  uuid: D7LcTHUXkpP6SYG4\n  url: oq0mk5\n  prev_uuid: E-fia709YBhQtJrt\n  sibling_uuid: LwftOZYaPeqjwhdS\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432407\n  level: 1\n  id: 11432407\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字符串 string\n  uuid: LwftOZYaPeqjwhdS\n  url: sih9mc\n  prev_uuid: D7LcTHUXkpP6SYG4\n  sibling_uuid: dj5FuaOaHSda1AbK\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432412\n  level: 1\n  id: 11432412\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 栈 stack\n  uuid: dj5FuaOaHSda1AbK\n  url: xi2mh9\n  prev_uuid: LwftOZYaPeqjwhdS\n  sibling_uuid: IOag-iKKv87hGhdm\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435979\n  level: 1\n  id: 11435979\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 队列 queue\n  uuid: IOag-iKKv87hGhdm\n  url: hroghz\n  prev_uuid: dj5FuaOaHSda1AbK\n  sibling_uuid: 778WMx0aXLZVUl9p\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435969\n  level: 1\n  id: 11435969\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 链表 Linkist\n  uuid: 778WMx0aXLZVUl9p\n  url: mo7sde\n  prev_uuid: IOag-iKKv87hGhdm\n  sibling_uuid: j9b8vxS9kTz8xa3x\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435962\n  level: 1\n  id: 11435962\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 树 tree\n  uuid: j9b8vxS9kTz8xa3x\n  url: glas5w\n  prev_uuid: 778WMx0aXLZVUl9p\n  sibling_uuid: QARpKzPBR5puFByT\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435974\n  level: 1\n  id: 11435974\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 图 graph\n  uuid: QARpKzPBR5puFByT\n  url: dgduok\n  prev_uuid: j9b8vxS9kTz8xa3x\n  sibling_uuid: kKoPgVQTytiILSgY\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435966\n  level: 1\n  id: 11435966\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 集合 set\n  uuid: kKoPgVQTytiILSgY\n  url: ub10iw\n  prev_uuid: QARpKzPBR5puFByT\n  sibling_uuid: R7qhLVPS4xKQZLD7\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435960\n  level: 1\n  id: 11435960\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字典和散列表 dictionary & hash table\n  uuid: R7qhLVPS4xKQZLD7\n  url: aq5vbp\n  prev_uuid: kKoPgVQTytiILSgY\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435958\n  level: 1\n  id: 11435958\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 动态规划\n  uuid: zvwUUlHnEeEhPJ9v\n  url: mnfkhynksc1h459r\n  prev_uuid: BMR7y68MzsRsLpq6\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147451432\n  level: 0\n  id: 147451432\n  open_window: 1\n  visible: 0\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 16,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-19T18:02:44.299Z",
    "created_at": "2022-02-21T07:49:26.000Z",
    "updated_at": "2023-11-19T18:02:44.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-22T20:13:30.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/gm8h7g",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 2126502132,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}