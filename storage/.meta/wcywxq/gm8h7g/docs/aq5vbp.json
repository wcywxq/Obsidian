{
  "id": 11435958,
  "slug": "aq5vbp",
  "title": "字典和散列表 dictionary & hash table",
  "description": "链接在前一篇文章中，我们介绍了如何在 JavaScript 中实现集合。字典和集合的主要区别就在于，集合中数据是以[值，值]的形式保存的，我们只关心值本身；而在字典和散列表中数据是以[键，值]的形式保存的，键不能重复，我们不仅关心键，也关心键所对应的值。我们也可以把字典称之为映射表。由于字典和...",
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1646368542821-e21547f7-16a8-4cc5-9aaf-b804f938c10f.png",
  "user_id": 732231,
  "book_id": 24854102,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><p id=\"ubb23f819\" class=\"ne-p\"><a href=\"https://www.cnblogs.com/jaxu/p/11302315.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11302315.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">链接</span></a><span class=\"ne-text\"><br /></span></p><p id=\"u8f37aaa1\" class=\"ne-p\"><br></p><p id=\"ude8db97f\" class=\"ne-p\"><span class=\"ne-text\">在</span><a href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">前一篇文章</span></a><span class=\"ne-text\">中，我们介绍了如何在 JavaScript 中实现集合。字典和集合的主要区别就在于，集合中数据是以</span><strong><span class=\"ne-text\">[值，值]</span></strong><span class=\"ne-text\">的形式保存的，我们只关心值本身；而在字典和散列表中数据是以</span><strong><span class=\"ne-text\">[键，值]</span></strong><span class=\"ne-text\">的形式保存的，键不能重复，我们不仅关心键，也关心键所对应的值。<br /></span><span class=\"ne-text\">我们也可以把字典称之为映射表。由于字典和集合很相似，我们可以在</span><a href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">前一篇文章</span></a><span class=\"ne-text\">中的集合类 Set 的基础上来实现我们的字典类 Dictionary。与 Set 类相似，ES6 的原生 Map 类已经实现了字典的全部功能，稍后我们会介绍它的用法。<br /></span><span class=\"ne-text\">下面是我们的 Dictionary 字典类的实现代码：<br /></span><span class=\"ne-text\"></span></p><p id=\"ud5dee9ce\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"f89ca54c\" class=\"ne-codeblock language-javascript\"><code>class Dictionary {\n    constructor() {\n        this.items = {}\n    }\n\n    set(key, value) {\n        // 向字典中添加或修改元素\n        this.items[key] = value\n    }\n\n    get(key) {\n        // 通过键值查找字典中的值\n        return this.items[key]\n    }\n\n    delete(key) {\n        // 通过使用键值来从字典中删除对应的元素\n        if (this.has(key)) {\n            delete this.items[key]\n            return true\n        }\n        return false\n    }\n\n    has(key) {\n        // 判断给定的键值是否存在于字典中\n        return this.items.hasOwnProperty(key)\n    }\n\n    clear() {\n        // 清空字典内容\n        this.items = {}\n    }\n\n    size() {\n        // 返回字典中所有元素的数量\n        return Object.keys(this.items).length\n    }\n\n    keys() {\n        // 返回字典中所有的键值\n        return Object.keys(this.items)\n    }\n\n    values() {\n        // 返回字典中所有的值\n        return Object.values(this.items)\n    }\n\n    getItems() {\n        // 返回字典中的所有元素\n        return this.items\n    }\n}</code></pre><p id=\"udb620664\" class=\"ne-p\"><br></p><p id=\"u086c61fe\" class=\"ne-p\"><span class=\"ne-text\">与 Set 类很相似，只是把其中 value 的部分替换成了 key。我们来看看一些测试用例：<br /></span><span class=\"ne-text\"></span></p><p id=\"u79dcc862\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"86f2b0c2\" class=\"ne-codeblock language-javascript\"><code>let Dictionary = require(&quot;./dictionary&quot;)\n\nlet dictionary = new Dictionary()\ndictionary.set(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;)\ndictionary.set(&quot;John&quot;, &quot;john@email.com&quot;)\ndictionary.set(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;)\nconsole.log(dictionary.has(&quot;Gandalf&quot;)) // true\nconsole.log(dictionary.size()) // 3\nconsole.log(dictionary.keys()) // [ 'Gandalf', 'John', 'Tyrion' ]\nconsole.log(dictionary.values()) // [ 'gandalf@email.com', 'john@email.com', 'tyrion@email.com' ]\nconsole.log(dictionary.get(&quot;Tyrion&quot;)) // tyrion@email.com\n\ndictionary.delete(&quot;John&quot;)\nconsole.log(dictionary.keys()) // [ 'Gandalf', 'Tyrion' ]\nconsole.log(dictionary.values()) // [ 'gandalf@email.com', 'tyrion@email.com' ]\nconsole.log(dictionary.getItems()) // { Gandalf: 'gandalf@email.com', Tyrion: 'tyrion@email.com' }</code></pre><p id=\"u85001157\" class=\"ne-p\"><br></p><p id=\"uc5bbf7c2\" class=\"ne-p\"><span class=\"ne-text\">相应地，下面是使用 ES6 的原生 Map 类的测试结果：</span></p><p id=\"u8b3cc6ae\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"a3c4a3d2\" class=\"ne-codeblock language-javascript\"><code>let dictionary = new Map()\ndictionary.set(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;)\ndictionary.set(&quot;John&quot;, &quot;john@email.com&quot;)\ndictionary.set(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;)\nconsole.log(dictionary.has(&quot;Gandalf&quot;)) // true\nconsole.log(dictionary.size) // 3\nconsole.log(dictionary.keys()) // [Map Iterator] { 'Gandalf', 'John', 'Tyrion' }\nconsole.log(dictionary.values()) // [Map Iterator] { 'gandalf@email.com', 'john@email.com', 'tyrion@email.com' }\nconsole.log(dictionary.get(&quot;Tyrion&quot;)) // tyrion@email.com\n\ndictionary.delete(&quot;John&quot;)\nconsole.log(dictionary.keys()) // [Map Iterator] { 'Gandalf', 'Tyrion' }\nconsole.log(dictionary.values()) // [Map Iterator] { 'gandalf@email.com', 'tyrion@email.com' }\nconsole.log(dictionary.entries()) // [Map Iterator] { [ Gandalf: 'gandalf@email.com' ], [ Tyrion: 'tyrion@email.com' ] }</code></pre><p id=\"u6578529b\" class=\"ne-p\"><br></p><p id=\"uc9c56cd9\" class=\"ne-p\"><span class=\"ne-text\">和前面我们自定义的 Dictionary 类稍微有一点不同，values()方法和 keys()方法返回的不是一个数组，而是 Iterator 迭代器。另一个就是这里的 size 是一个属性而不是方法，然后就是 Map 类没有 getItems()方法，取而代之的是 entries()方法，它返回的也是一个 Iterator。有关 Map 类的详细详细介绍可以查看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">这里</span></a><span class=\"ne-text\">。<br /></span><span class=\"ne-text\">在 ES6 中，除了原生的 Set 和 Map 类外，还有它们的弱化版本，分别是</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">WeakSet</span></a><span class=\"ne-text\">和</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">WeakMap</span></a><span class=\"ne-text\">，我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——栈的实现与应用》</span></a><span class=\"ne-text\">一文中已经见过 WeakMap 的使用了。Map 和 Set 与它们各自的弱化版本之间的主要区别是：</span></p><p id=\"ubb3a0258\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u74da225b\" data-lake-index-type=\"0\"><span class=\"ne-text\">WeakSet 或 WeakMap 类没有 entries、keys 和 values 等迭代器方法，只能通过 get 和 set 方法访问和设置其中的值。这也是为什么我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——栈的实现与应用》</span></a><span class=\"ne-text\">一文中要使用 WeakMap 类来定义类的私有属性的原因。</span></li><li id=\"u0f0e4bf7\" data-lake-index-type=\"0\"><span class=\"ne-text\">只能用对应作为键值，或者说其中的内容只能是对象，而不能是数字、字符串、布尔值等基本数据类型。</span></li></ul><p id=\"ud81b694b\" class=\"ne-p\"><br></p><p id=\"ufa4338d7\" class=\"ne-p\"><span class=\"ne-text\">弱化的 Map 和 Set 类主要是为了提供 JavaScript 代码的性能。</span></p><p id=\"ua79a5815\" class=\"ne-p\"><br></p><h3 id=\"02d41e53\"><span class=\"ne-text\">散列表</span></h3><p id=\"ua6d6b17e\" class=\"ne-p\"><br></p><p id=\"ub4400246\" class=\"ne-p\"><span class=\"ne-text\">散列表（或者叫哈希表），是一种改进的 dictionary，它将 key 通过一个固定的算法（散列函数或哈希函数）得出一个数字，然后将 dictionary 中 key 所对应的 value 存放到这个数字所对应的数组下标所包含的存储空间中。在原始的 dictionary 中，如果要查找某个 key 所对应的 value，我们需要遍历整个字典。为了提高查询的效率，我们将 key 对应的 value 保存到数组里，只要 key 不变，使用相同的散列函数计算出来的数字就是固定的，于是就可以很快地在数组中找到你想要查找的 value。下面是散列表的数据结构示意图：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368542821-e21547f7-16a8-4cc5-9aaf-b804f938c10f.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=ue683a1cd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=414&amp;originWidth=615&amp;originalType=url&amp;ratio=1&amp;size=25678&amp;status=done&amp;style=none&amp;taskId=u2a55325f-d9c8-446e-8a75-7d1c87ff9a8\" width=\"615\" id=\"qfGum\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">下面是我们散列函数 loseloseHashCode()的实现代码：</span></p><p id=\"u61b157cd\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"a9b5b063\" class=\"ne-codeblock language-javascript\"><code>loseloseHashCode (key) {\n    let hash = 0;\n    for (let i = 0; i &lt; key.length; i++) {\n        hash += key.charCodeAt(i);\n    }\n    return hash % 37;\n}</code></pre><p id=\"uc1f3b72f\" class=\"ne-p\"><br></p><p id=\"u0fc32838\" class=\"ne-p\"><span class=\"ne-text\">这个散列函数的实现很简单，我们将传入的 key 中的每一个字符使用 charCodeAt()函数（有关该函数的详细内容可以查看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">这里</span></a><span class=\"ne-text\">）将其转换成 ASCII 码，然后将这些 ASCII 码相加，最后用 37 求余，得到一个数字，这个数字就是这个 key 所对应的 hash 值。接下来要做的就是将 value 存放到 hash 值所对应的数组的存储空间内。下面是我们的 HashTable 类的主要实现代码：</span></p><p id=\"u135bf106\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"1720f7ca\" class=\"ne-codeblock language-javascript\"><code>class HashTable {\n    constructor() {\n        this.table = []\n    }\n\n    loseloseHashCode(key) {\n        // 散列函数\n        let hash = 0\n        for (let i = 0; i &lt; key.length; i++) {\n            hash += key.charCodeAt(i)\n        }\n        return hash % 37\n    }\n\n    put(key, value) {\n        // 将键值对存放到哈希表中\n        let position = this.loseloseHashCode(key)\n        console.log(`${position} - ${key}`)\n        this.table[position] = value\n    }\n\n    get(key) {\n        // 通过key查找哈希表中的值\n        return this.table[this.loseloseHashCode(key)]\n    }\n\n    remove(key) {\n        // 通过key从哈希表中删除对应的值\n        this.table[this.loseloseHashCode(key)] = undefined\n    }\n\n    isEmpty() {\n        // 判断哈希表是否为空\n        return this.size() === 0\n    }\n\n    size() {\n        // 返回哈希表的长度\n        let count = 0\n        this.table.forEach(item =&gt; {\n            if (item !== undefined) count++\n        })\n        return count\n    }\n\n    clear() {\n        // 清空哈希表\n        this.table = []\n    }\n}</code></pre><p id=\"u51026c47\" class=\"ne-p\"><br></p><p id=\"u5ce428ab\" class=\"ne-p\"><span class=\"ne-text\">测试一下上面的这些方法：</span></p><p id=\"ub159cbf7\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"6e2a8e37\" class=\"ne-codeblock language-javascript\"><code>let HashTable = require(&quot;./hashtable&quot;)\n\nlet hash = new HashTable()\nhash.put(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;) // 19 - Gandalf\nhash.put(&quot;John&quot;, &quot;john@email.com&quot;) // 29 - John\nhash.put(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;) // 16 - Tyrion\n\nconsole.log(hash.isEmpty()) // false\nconsole.log(hash.size()) // 3\nconsole.log(hash.get(&quot;Gandalf&quot;)) // gandalf@email.com\nconsole.log(hash.get(&quot;Loiane&quot;)) // undefined\n\nhash.remove(&quot;Gandalf&quot;)\nconsole.log(hash.get(&quot;Gandalf&quot;)) // undefined\nhash.clear()\nconsole.log(hash.size()) // 0\nconsole.log(hash.isEmpty()) // true</code></pre><p id=\"u7e4d014b\" class=\"ne-p\"><br></p><p id=\"u3e1414e0\" class=\"ne-p\"><span class=\"ne-text\">为了方便查看 hash 值和 value 的对应关系，我们在 put()方法中加入了一行 console.log()，用来打印 key 的 hash 值和 value 之间的对应关系。可以看到，测试的结果和前面我们给出的示意图是一致的。<br /></span><span class=\"ne-text\">散列集合的实现和散列表类似，只不过在散列集合中不再使用键值对，而是只有值没有键。这个我们在前面介绍集合和字典的时候已经讲过了，这里不再赘述。<br /></span><span class=\"ne-text\">细心的同学可能已经发现了，这里我们提供的散列函数可能过于简单，以致于我们无法保证通过散列函数计算出来的 hash 值一定是唯一的。换句话说，传入不同的 key 值，我们有可能会得到相同的 hash 值。尝试一下下面这些 keys：</span></p><p id=\"u7eb44628\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"8a25d3af\" class=\"ne-codeblock language-javascript\"><code>let hash = new HashTable()\nhash.put(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;)\nhash.put(&quot;John&quot;, &quot;john@email.com&quot;)\nhash.put(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;)\nhash.put(&quot;Aaron&quot;, &quot;aaron@email.com&quot;)\nhash.put(&quot;Donnie&quot;, &quot;donnie@email.com&quot;)\nhash.put(&quot;Ana&quot;, &quot;ana@email.com&quot;)\nhash.put(&quot;Jamie&quot;, &quot;jamie@email.com&quot;)\nhash.put(&quot;Sue&quot;, &quot;sue@email.com&quot;)\nhash.put(&quot;Mindy&quot;, &quot;mindy@email.com&quot;)\nhash.put(&quot;Paul&quot;, &quot;paul@email.com&quot;)\nhash.put(&quot;Nathan&quot;, &quot;nathan@email.com&quot;)</code></pre><p id=\"u3cd834a5\" class=\"ne-p\"><br></p><p id=\"u05417d56\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368595446-4d8db671-fdd7-42d2-9815-827750bba9f4.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u5cd5ea63&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=217&amp;originalType=url&amp;ratio=1&amp;size=12348&amp;status=done&amp;style=none&amp;taskId=u208e6fcd-a64f-42f2-b685-9bd3444dd97\" width=\"217\" id=\"IzjET\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">从结果中可以看到，尽管有些 keys 不同，但是通过我们提供的散列函数居然得到了相同的 hash 值，这显然违背了我们的设计原则。在哈希表中，这个叫做散列冲突，为了得到一个可靠的哈希表，我们必须尽可能地避免散列冲突。那如何避免这种冲突呢？这里介绍两种解决冲突的方法：分离链接和线性探查。</span></p><p id=\"uebdfafa0\" class=\"ne-p\"><br></p><h4 id=\"2afa3875\"><span class=\"ne-text\">分离链接</span></h4><p id=\"ua50af096\" class=\"ne-p\"><br></p><p id=\"ub436d0ca\" class=\"ne-p\"><span class=\"ne-text\">所谓分离链接，就是将原本存储在哈希表中的值改成链表，这样在哈希表的同一个位置上，就可以存储多个不同的值。链表中的每一个元素，同时存储了 key 和 value。示意图如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368603606-2893c36d-392a-498a-9715-0a6483b9d997.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u9dd6e4e0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=624&amp;originWidth=817&amp;originalType=url&amp;ratio=1&amp;size=44528&amp;status=done&amp;style=none&amp;taskId=ud2372fb7-ef28-4f56-a190-8dc43b1853e\" width=\"817\" id=\"CK3Vn\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">这样，当不同的 key 通过散列函数计算出相同的 hash 值时，我们只需要找到数组中对应的位置，然后往其中的链表添加新的节点即可，从而有效地避免了散列冲突。为了实现这种数据结构，我们需要定义一个新的辅助类 ValuePair，它的内容如下：</span></p><p id=\"u69583c1c\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3e132302\" class=\"ne-codeblock language-javascript\"><code>let ValuePair = function (key, value) {\n    this.key = key\n    this.value = value\n\n    this.toString = function () {\n        // 提供toString()方法以方便我们测试\n        return `[${this.key} - ${this.value}]`\n    }\n}</code></pre><p id=\"ue14c050f\" class=\"ne-p\"><br></p><p id=\"u7c3301df\" class=\"ne-p\"><span class=\"ne-text\">ValuePair 类具有两个属性，key 和 value，用来保存我们要存入到散列表中的元素的键值对。toString()方法在这里不是必须的，该方法是为了后面我们方便测试。<br /></span><span class=\"ne-text\">新的采用了分离链接的 HashTableSeparateChaining 类可以继承自前面的 HashTable 类，完整的代码如下：</span></p><p id=\"u0c6e738c\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"62701b61\" class=\"ne-codeblock language-javascript\"><code>class HashTableSeparateChaining extends HashTable {\n    constructor() {\n        super()\n    }\n\n    put(key, value) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] === undefined) {\n            this.table[position] = new LinkedList() // 单向链表，需要引入LinkedList类\n        }\n        this.table[position].append(new ValuePair(key, value))\n    }\n\n    get(key) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] !== undefined) {\n            let current = this.table[position].getHead()\n            while (current) {\n                if (current.element.key === key) return current.element.value\n                current = current.next\n            }\n        }\n        return undefined\n    }\n\n    remove(key) {\n        let position = this.loseloseHashCode(key)\n        let hash = this.table[position]\n\n        if (hash !== undefined) {\n            let current = hash.getHead()\n            while (current) {\n                if (current.element.key === key) {\n                    hash.remove(current.element)\n                    if (hash.isEmpty()) this.table[position] = undefined\n                    return true\n                }\n                current = current.next\n            }\n        }\n\n        return false\n    }\n\n    size() {\n        let count = 0\n        this.table.forEach(item =&gt; {\n            if (item !== undefined) count += item.size()\n        })\n        return count\n    }\n\n    toString() {\n        let objString = &quot;&quot;\n        for (let i = 0; i &lt; this.table.length; i++) {\n            let ci = this.table[i]\n            if (ci === undefined) continue\n\n            objString += `${i}: `\n            let current = ci.getHead()\n            while (current) {\n                objString += current.element.toString()\n                current = current.next\n                if (current) objString += &quot;, &quot;\n            }\n            objString += &quot;\\r\\n&quot;\n        }\n        return objString\n    }\n}</code></pre><p id=\"u9a7bcdb5\" class=\"ne-p\"><br></p><p id=\"ufc2f9ed1\" class=\"ne-p\"><span class=\"ne-text\">其中的 LinkedList 类为单向链表，具体内容可以查看</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——链表的实现与应用》</span></a><span class=\"ne-text\">。注意，现在 hash 数组中的每一个元素都是一个单向链表，单向链表的所有操作我们可以借助于 LinkedList 类来完成。我们重写了 size()方法，因为现在要计算的是数组中所有链表的长度总和。<br /></span><span class=\"ne-text\">下面是 HashTableSeparateChaining 类的测试用例及结果：</span></p><p id=\"ub0a4ecdd\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"07ce9f22\" class=\"ne-codeblock language-javascript\"><code>let hash = new HashTableSeparateChaining()\n\nhash.put(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;)\nhash.put(&quot;John&quot;, &quot;john@email.com&quot;)\nhash.put(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;)\nhash.put(&quot;Aaron&quot;, &quot;aaron@email.com&quot;)\nhash.put(&quot;Donnie&quot;, &quot;donnie@email.com&quot;)\nhash.put(&quot;Ana&quot;, &quot;ana@email.com&quot;)\nhash.put(&quot;Jamie&quot;, &quot;jamie@email.com&quot;)\nhash.put(&quot;Sue&quot;, &quot;sue@email.com&quot;)\nhash.put(&quot;Mindy&quot;, &quot;mindy@email.com&quot;)\nhash.put(&quot;Paul&quot;, &quot;paul@email.com&quot;)\nhash.put(&quot;Nathan&quot;, &quot;nathan@email.com&quot;)\n\nconsole.log(hash.toString())\nconsole.log(`size: ${hash.size()}`)\nconsole.log(hash.get(&quot;John&quot;))\n\nconsole.log(hash.remove(&quot;Ana&quot;))\nconsole.log(hash.remove(&quot;John&quot;))\nconsole.log(hash.toString())</code></pre><p id=\"u396f083b\" class=\"ne-p\"><br></p><p id=\"u7f03c632\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368646270-fbd61d17-9e27-478b-a83a-70ed90b6bce8.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u2d23b493&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=340&amp;originWidth=552&amp;originalType=url&amp;ratio=1&amp;size=61098&amp;status=done&amp;style=none&amp;taskId=u6c6a702c-708f-404b-9d42-0bc24edd1af\" width=\"552\" id=\"FOP77\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">可以看到，结果和上面示意图上给出的是一致的，size()、remove()和 get()方法的执行结果也符合预期。</span></p><p id=\"u81626c4a\" class=\"ne-p\"><br></p><h4 id=\"c112812d\"><span class=\"ne-text\">线性探查</span></h4><p id=\"u3e872e71\" class=\"ne-p\"><br></p><p id=\"u38997bfd\" class=\"ne-p\"><span class=\"ne-text\">避免散列冲突的另一种方法是线性探查。当向哈希数组中添加某一个新元素时，如果该位置上已经有数据了，就继续尝试下一个位置，直到对应的位置上没有数据时，就在该位置上添加数据。我们将上面的例子改成线性探查的方式，存储结果如下图所示：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368655095-ed011a25-7207-4935-b32f-0d16faf4e827.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u51c68182&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=670&amp;originWidth=456&amp;originalType=url&amp;ratio=1&amp;size=42116&amp;status=done&amp;style=none&amp;taskId=uba6b97a5-7003-4655-9772-cec30f3a5ea\" width=\"456\" id=\"ynYbg\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">现在我们不需要单向链表 LinkedList 类了，但是 ValuePair 类仍然是需要的。同样的，我们的 HashTableLinearProbing 类继承自 HashTable 类，完整的代码如下：</span></p><p id=\"u5301a5d8\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"c06c862c\" class=\"ne-codeblock language-javascript\"><code>class HashTableLinearProbing extends HashTable {\n    constructor() {\n        super()\n    }\n\n    put(key, value) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] === undefined) {\n            this.table[position] = new ValuePair(key, value)\n        } else {\n            let index = position + 1\n            while (this.table[index] !== undefined) {\n                index++\n            }\n            this.table[index] = new ValuePair(key, value)\n        }\n    }\n\n    get(key) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] !== undefined) {\n            if (this.table[position].key === key) return this.table[position].value\n            let index = position + 1\n            while (this.table[index] !== undefined &amp;&amp; this.table[index].key !== key) {\n                index++\n            }\n            return this.table[index].value\n        }\n        return undefined\n    }\n\n    remove(key) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] !== undefined) {\n            if (this.table[position].key === key) {\n                this.table[position] = undefined\n                return true\n            }\n            let index = position + 1\n            while (this.table[index] !== undefined &amp;&amp; this.table[index].key !== key) {\n                index++\n            }\n            this.table[index] = undefined\n            return true\n        }\n        return false\n    }\n\n    toString() {\n        let objString = &quot;&quot;\n        for (let i = 0; i &lt; this.table.length; i++) {\n            let ci = this.table[i]\n            if (ci === undefined) continue\n\n            objString += `${i}: ${ci}\\r\\n`\n        }\n        return objString\n    }\n}</code></pre><p id=\"u524a57fa\" class=\"ne-p\"><br></p><p id=\"u18641080\" class=\"ne-p\"><span class=\"ne-text\">使用上面和 HashTableSeparateChaining 类相同的测试用例，我们来看看测试结果：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368672669-14fd7f0a-e601-467e-86d9-cedc1477c2de.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u808a989f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=457&amp;originWidth=317&amp;originalType=url&amp;ratio=1&amp;size=45391&amp;status=done&amp;style=none&amp;taskId=uafa43c0d-f3b8-4bef-b6f5-0a0671e67e7\" width=\"317\" id=\"db7dV\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">可以和 HashTableSeparateChaining 类的测试结果比较一下，多出来的位置 6、14、17、33，正是 HashTableSeparateChaining 类中每一个链表的剩余部分。get()和 remove()方法也能正常工作，我们不需要重写 size()方法，和基类 HashTable 中一样，hash 数组中每一个位置只保存了一个元素。另一个要注意的地方是，由于 JavaScript 中定义数组时不需要提前给出数组的长度，因此我们可以很容易地利用 JavaScript 语言的这一特性来实现线性探查。在某些编程语言中，数组的定义是必须明确给出长度的，这时我们就需要重新考虑我们的 HashLinearProbing 类的实现了。<br /></span><span class=\"ne-text\">loseloseHashCode()散列函数并不是一个表现良好的散列函数，正如你所看到的，它会很轻易地产生散列冲突。一个表现良好的散列函数必须能够尽可能低地减少散列冲突，并提高性能。我们可以在网上找一些不同的散列函数的实现方法，下面是一个比 loseloseHashCode()更好的散列函数 djb2HashCode()：</span></p><p id=\"u222465fb\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"e1f3531c\" class=\"ne-codeblock language-javascript\"><code>djb2HashCode (key) {\n    let hash = 5381;\n    for (let i = 0; i &lt; key.length; i++) {\n        hash = hash * 33 + key.charCodeAt(i);\n    }\n    return hash % 1013;\n}</code></pre><p id=\"uc8f6a2df\" class=\"ne-p\"><br></p><p id=\"ud5ad36de\" class=\"ne-p\"><span class=\"ne-text\">我们用相同的测试用例来测试 dj2HashCode()，下面是测试结果：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368688283-0ecfeac9-87ad-4aad-baeb-b362011cc85b.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=ueb108685&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=211&amp;originWidth=154&amp;originalType=url&amp;ratio=1&amp;size=14706&amp;status=done&amp;style=none&amp;taskId=ucc1b174c-5ba6-4308-9ddf-90d8f294e3d\" width=\"154\" id=\"uzgtb\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">这次没有冲突！然而这并不是最好的散列函数，但它是社区最推崇的散列函数之一。</span></p></div>",
  "body": "[链接](https://www.cnblogs.com/jaxu/p/11302315.html)\n\n在[前一篇文章](https://www.cnblogs.com/jaxu/p/11287315.html)中，我们介绍了如何在 JavaScript 中实现集合。字典和集合的主要区别就在于，集合中数据是以**[值，值]**的形式保存的，我们只关心值本身；而在字典和散列表中数据是以**[键，值]**的形式保存的，键不能重复，我们不仅关心键，也关心键所对应的值。<br />我们也可以把字典称之为映射表。由于字典和集合很相似，我们可以在[前一篇文章](https://www.cnblogs.com/jaxu/p/11287315.html)中的集合类 Set 的基础上来实现我们的字典类 Dictionary。与 Set 类相似，ES6 的原生 Map 类已经实现了字典的全部功能，稍后我们会介绍它的用法。<br />下面是我们的 Dictionary 字典类的实现代码：<br />\n\n```javascript\nclass Dictionary {\n    constructor() {\n        this.items = {}\n    }\n\n    set(key, value) {\n        // 向字典中添加或修改元素\n        this.items[key] = value\n    }\n\n    get(key) {\n        // 通过键值查找字典中的值\n        return this.items[key]\n    }\n\n    delete(key) {\n        // 通过使用键值来从字典中删除对应的元素\n        if (this.has(key)) {\n            delete this.items[key]\n            return true\n        }\n        return false\n    }\n\n    has(key) {\n        // 判断给定的键值是否存在于字典中\n        return this.items.hasOwnProperty(key)\n    }\n\n    clear() {\n        // 清空字典内容\n        this.items = {}\n    }\n\n    size() {\n        // 返回字典中所有元素的数量\n        return Object.keys(this.items).length\n    }\n\n    keys() {\n        // 返回字典中所有的键值\n        return Object.keys(this.items)\n    }\n\n    values() {\n        // 返回字典中所有的值\n        return Object.values(this.items)\n    }\n\n    getItems() {\n        // 返回字典中的所有元素\n        return this.items\n    }\n}\n```\n\n与 Set 类很相似，只是把其中 value 的部分替换成了 key。我们来看看一些测试用例：<br />\n\n```javascript\nlet Dictionary = require(\"./dictionary\")\n\nlet dictionary = new Dictionary()\ndictionary.set(\"Gandalf\", \"gandalf@email.com\")\ndictionary.set(\"John\", \"john@email.com\")\ndictionary.set(\"Tyrion\", \"tyrion@email.com\")\nconsole.log(dictionary.has(\"Gandalf\")) // true\nconsole.log(dictionary.size()) // 3\nconsole.log(dictionary.keys()) // [ 'Gandalf', 'John', 'Tyrion' ]\nconsole.log(dictionary.values()) // [ 'gandalf@email.com', 'john@email.com', 'tyrion@email.com' ]\nconsole.log(dictionary.get(\"Tyrion\")) // tyrion@email.com\n\ndictionary.delete(\"John\")\nconsole.log(dictionary.keys()) // [ 'Gandalf', 'Tyrion' ]\nconsole.log(dictionary.values()) // [ 'gandalf@email.com', 'tyrion@email.com' ]\nconsole.log(dictionary.getItems()) // { Gandalf: 'gandalf@email.com', Tyrion: 'tyrion@email.com' }\n```\n\n相应地，下面是使用 ES6 的原生 Map 类的测试结果：\n\n```javascript\nlet dictionary = new Map()\ndictionary.set(\"Gandalf\", \"gandalf@email.com\")\ndictionary.set(\"John\", \"john@email.com\")\ndictionary.set(\"Tyrion\", \"tyrion@email.com\")\nconsole.log(dictionary.has(\"Gandalf\")) // true\nconsole.log(dictionary.size) // 3\nconsole.log(dictionary.keys()) // [Map Iterator] { 'Gandalf', 'John', 'Tyrion' }\nconsole.log(dictionary.values()) // [Map Iterator] { 'gandalf@email.com', 'john@email.com', 'tyrion@email.com' }\nconsole.log(dictionary.get(\"Tyrion\")) // tyrion@email.com\n\ndictionary.delete(\"John\")\nconsole.log(dictionary.keys()) // [Map Iterator] { 'Gandalf', 'Tyrion' }\nconsole.log(dictionary.values()) // [Map Iterator] { 'gandalf@email.com', 'tyrion@email.com' }\nconsole.log(dictionary.entries()) // [Map Iterator] { [ Gandalf: 'gandalf@email.com' ], [ Tyrion: 'tyrion@email.com' ] }\n```\n\n和前面我们自定义的 Dictionary 类稍微有一点不同，values()方法和 keys()方法返回的不是一个数组，而是 Iterator 迭代器。另一个就是这里的 size 是一个属性而不是方法，然后就是 Map 类没有 getItems()方法，取而代之的是 entries()方法，它返回的也是一个 Iterator。有关 Map 类的详细详细介绍可以查看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)。<br />在 ES6 中，除了原生的 Set 和 Map 类外，还有它们的弱化版本，分别是[WeakSet](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)和[WeakMap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)，我们在[《JavaScript 数据结构——栈的实现与应用》](https://www.cnblogs.com/jaxu/p/11264017.html)一文中已经见过 WeakMap 的使用了。Map 和 Set 与它们各自的弱化版本之间的主要区别是：\n\n- WeakSet 或 WeakMap 类没有 entries、keys 和 values 等迭代器方法，只能通过 get 和 set 方法访问和设置其中的值。这也是为什么我们在[《JavaScript 数据结构——栈的实现与应用》](https://www.cnblogs.com/jaxu/p/11264017.html)一文中要使用 WeakMap 类来定义类的私有属性的原因。\n- 只能用对应作为键值，或者说其中的内容只能是对象，而不能是数字、字符串、布尔值等基本数据类型。\n\n弱化的 Map 和 Set 类主要是为了提供 JavaScript 代码的性能。\n\n<a name=\"02d41e53\"></a>\n### 散列表\n\n散列表（或者叫哈希表），是一种改进的 dictionary，它将 key 通过一个固定的算法（散列函数或哈希函数）得出一个数字，然后将 dictionary 中 key 所对应的 value 存放到这个数字所对应的数组下标所包含的存储空间中。在原始的 dictionary 中，如果要查找某个 key 所对应的 value，我们需要遍历整个字典。为了提高查询的效率，我们将 key 对应的 value 保存到数组里，只要 key 不变，使用相同的散列函数计算出来的数字就是固定的，于是就可以很快地在数组中找到你想要查找的 value。下面是散列表的数据结构示意图：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368542821-e21547f7-16a8-4cc5-9aaf-b804f938c10f.png#clientId=uab33f410-eee0-4&from=paste&id=ue683a1cd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=414&originWidth=615&originalType=url&ratio=1&size=25678&status=done&style=none&taskId=u2a55325f-d9c8-446e-8a75-7d1c87ff9a8#averageHue=%23f6f6f6&id=qfGum&originHeight=414&originWidth=615&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />下面是我们散列函数 loseloseHashCode()的实现代码：\n\n```javascript\nloseloseHashCode (key) {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n        hash += key.charCodeAt(i);\n    }\n    return hash % 37;\n}\n```\n\n这个散列函数的实现很简单，我们将传入的 key 中的每一个字符使用 charCodeAt()函数（有关该函数的详细内容可以查看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)）将其转换成 ASCII 码，然后将这些 ASCII 码相加，最后用 37 求余，得到一个数字，这个数字就是这个 key 所对应的 hash 值。接下来要做的就是将 value 存放到 hash 值所对应的数组的存储空间内。下面是我们的 HashTable 类的主要实现代码：\n\n```javascript\nclass HashTable {\n    constructor() {\n        this.table = []\n    }\n\n    loseloseHashCode(key) {\n        // 散列函数\n        let hash = 0\n        for (let i = 0; i < key.length; i++) {\n            hash += key.charCodeAt(i)\n        }\n        return hash % 37\n    }\n\n    put(key, value) {\n        // 将键值对存放到哈希表中\n        let position = this.loseloseHashCode(key)\n        console.log(`${position} - ${key}`)\n        this.table[position] = value\n    }\n\n    get(key) {\n        // 通过key查找哈希表中的值\n        return this.table[this.loseloseHashCode(key)]\n    }\n\n    remove(key) {\n        // 通过key从哈希表中删除对应的值\n        this.table[this.loseloseHashCode(key)] = undefined\n    }\n\n    isEmpty() {\n        // 判断哈希表是否为空\n        return this.size() === 0\n    }\n\n    size() {\n        // 返回哈希表的长度\n        let count = 0\n        this.table.forEach(item => {\n            if (item !== undefined) count++\n        })\n        return count\n    }\n\n    clear() {\n        // 清空哈希表\n        this.table = []\n    }\n}\n```\n\n测试一下上面的这些方法：\n\n```javascript\nlet HashTable = require(\"./hashtable\")\n\nlet hash = new HashTable()\nhash.put(\"Gandalf\", \"gandalf@email.com\") // 19 - Gandalf\nhash.put(\"John\", \"john@email.com\") // 29 - John\nhash.put(\"Tyrion\", \"tyrion@email.com\") // 16 - Tyrion\n\nconsole.log(hash.isEmpty()) // false\nconsole.log(hash.size()) // 3\nconsole.log(hash.get(\"Gandalf\")) // gandalf@email.com\nconsole.log(hash.get(\"Loiane\")) // undefined\n\nhash.remove(\"Gandalf\")\nconsole.log(hash.get(\"Gandalf\")) // undefined\nhash.clear()\nconsole.log(hash.size()) // 0\nconsole.log(hash.isEmpty()) // true\n```\n\n为了方便查看 hash 值和 value 的对应关系，我们在 put()方法中加入了一行 console.log()，用来打印 key 的 hash 值和 value 之间的对应关系。可以看到，测试的结果和前面我们给出的示意图是一致的。<br />散列集合的实现和散列表类似，只不过在散列集合中不再使用键值对，而是只有值没有键。这个我们在前面介绍集合和字典的时候已经讲过了，这里不再赘述。<br />细心的同学可能已经发现了，这里我们提供的散列函数可能过于简单，以致于我们无法保证通过散列函数计算出来的 hash 值一定是唯一的。换句话说，传入不同的 key 值，我们有可能会得到相同的 hash 值。尝试一下下面这些 keys：\n\n```javascript\nlet hash = new HashTable()\nhash.put(\"Gandalf\", \"gandalf@email.com\")\nhash.put(\"John\", \"john@email.com\")\nhash.put(\"Tyrion\", \"tyrion@email.com\")\nhash.put(\"Aaron\", \"aaron@email.com\")\nhash.put(\"Donnie\", \"donnie@email.com\")\nhash.put(\"Ana\", \"ana@email.com\")\nhash.put(\"Jamie\", \"jamie@email.com\")\nhash.put(\"Sue\", \"sue@email.com\")\nhash.put(\"Mindy\", \"mindy@email.com\")\nhash.put(\"Paul\", \"paul@email.com\")\nhash.put(\"Nathan\", \"nathan@email.com\")\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368595446-4d8db671-fdd7-42d2-9815-827750bba9f4.png#clientId=uab33f410-eee0-4&from=paste&id=u5cd5ea63&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=217&originalType=url&ratio=1&size=12348&status=done&style=none&taskId=u208e6fcd-a64f-42f2-b685-9bd3444dd97#averageHue=%232d2d25&id=IzjET&originHeight=200&originWidth=217&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />从结果中可以看到，尽管有些 keys 不同，但是通过我们提供的散列函数居然得到了相同的 hash 值，这显然违背了我们的设计原则。在哈希表中，这个叫做散列冲突，为了得到一个可靠的哈希表，我们必须尽可能地避免散列冲突。那如何避免这种冲突呢？这里介绍两种解决冲突的方法：分离链接和线性探查。\n\n<a name=\"2afa3875\"></a>\n#### 分离链接\n\n所谓分离链接，就是将原本存储在哈希表中的值改成链表，这样在哈希表的同一个位置上，就可以存储多个不同的值。链表中的每一个元素，同时存储了 key 和 value。示意图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368603606-2893c36d-392a-498a-9715-0a6483b9d997.png#clientId=uab33f410-eee0-4&from=paste&id=u9dd6e4e0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=624&originWidth=817&originalType=url&ratio=1&size=44528&status=done&style=none&taskId=ud2372fb7-ef28-4f56-a190-8dc43b1853e#averageHue=%23f2f2f2&id=CK3Vn&originHeight=624&originWidth=817&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />这样，当不同的 key 通过散列函数计算出相同的 hash 值时，我们只需要找到数组中对应的位置，然后往其中的链表添加新的节点即可，从而有效地避免了散列冲突。为了实现这种数据结构，我们需要定义一个新的辅助类 ValuePair，它的内容如下：\n\n```javascript\nlet ValuePair = function (key, value) {\n    this.key = key\n    this.value = value\n\n    this.toString = function () {\n        // 提供toString()方法以方便我们测试\n        return `[${this.key} - ${this.value}]`\n    }\n}\n```\n\nValuePair 类具有两个属性，key 和 value，用来保存我们要存入到散列表中的元素的键值对。toString()方法在这里不是必须的，该方法是为了后面我们方便测试。<br />新的采用了分离链接的 HashTableSeparateChaining 类可以继承自前面的 HashTable 类，完整的代码如下：\n\n```javascript\nclass HashTableSeparateChaining extends HashTable {\n    constructor() {\n        super()\n    }\n\n    put(key, value) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] === undefined) {\n            this.table[position] = new LinkedList() // 单向链表，需要引入LinkedList类\n        }\n        this.table[position].append(new ValuePair(key, value))\n    }\n\n    get(key) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] !== undefined) {\n            let current = this.table[position].getHead()\n            while (current) {\n                if (current.element.key === key) return current.element.value\n                current = current.next\n            }\n        }\n        return undefined\n    }\n\n    remove(key) {\n        let position = this.loseloseHashCode(key)\n        let hash = this.table[position]\n\n        if (hash !== undefined) {\n            let current = hash.getHead()\n            while (current) {\n                if (current.element.key === key) {\n                    hash.remove(current.element)\n                    if (hash.isEmpty()) this.table[position] = undefined\n                    return true\n                }\n                current = current.next\n            }\n        }\n\n        return false\n    }\n\n    size() {\n        let count = 0\n        this.table.forEach(item => {\n            if (item !== undefined) count += item.size()\n        })\n        return count\n    }\n\n    toString() {\n        let objString = \"\"\n        for (let i = 0; i < this.table.length; i++) {\n            let ci = this.table[i]\n            if (ci === undefined) continue\n\n            objString += `${i}: `\n            let current = ci.getHead()\n            while (current) {\n                objString += current.element.toString()\n                current = current.next\n                if (current) objString += \", \"\n            }\n            objString += \"\\r\\n\"\n        }\n        return objString\n    }\n}\n```\n\n其中的 LinkedList 类为单向链表，具体内容可以查看[《JavaScript 数据结构——链表的实现与应用》](https://www.cnblogs.com/jaxu/p/11277732.html)。注意，现在 hash 数组中的每一个元素都是一个单向链表，单向链表的所有操作我们可以借助于 LinkedList 类来完成。我们重写了 size()方法，因为现在要计算的是数组中所有链表的长度总和。<br />下面是 HashTableSeparateChaining 类的测试用例及结果：\n\n```javascript\nlet hash = new HashTableSeparateChaining()\n\nhash.put(\"Gandalf\", \"gandalf@email.com\")\nhash.put(\"John\", \"john@email.com\")\nhash.put(\"Tyrion\", \"tyrion@email.com\")\nhash.put(\"Aaron\", \"aaron@email.com\")\nhash.put(\"Donnie\", \"donnie@email.com\")\nhash.put(\"Ana\", \"ana@email.com\")\nhash.put(\"Jamie\", \"jamie@email.com\")\nhash.put(\"Sue\", \"sue@email.com\")\nhash.put(\"Mindy\", \"mindy@email.com\")\nhash.put(\"Paul\", \"paul@email.com\")\nhash.put(\"Nathan\", \"nathan@email.com\")\n\nconsole.log(hash.toString())\nconsole.log(`size: ${hash.size()}`)\nconsole.log(hash.get(\"John\"))\n\nconsole.log(hash.remove(\"Ana\"))\nconsole.log(hash.remove(\"John\"))\nconsole.log(hash.toString())\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368646270-fbd61d17-9e27-478b-a83a-70ed90b6bce8.png#clientId=uab33f410-eee0-4&from=paste&id=u2d23b493&margin=%5Bobject%20Object%5D&name=image.png&originHeight=340&originWidth=552&originalType=url&ratio=1&size=61098&status=done&style=none&taskId=u6c6a702c-708f-404b-9d42-0bc24edd1af#averageHue=%232f2f27&id=FOP77&originHeight=340&originWidth=552&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />可以看到，结果和上面示意图上给出的是一致的，size()、remove()和 get()方法的执行结果也符合预期。\n\n<a name=\"c112812d\"></a>\n#### 线性探查\n\n避免散列冲突的另一种方法是线性探查。当向哈希数组中添加某一个新元素时，如果该位置上已经有数据了，就继续尝试下一个位置，直到对应的位置上没有数据时，就在该位置上添加数据。我们将上面的例子改成线性探查的方式，存储结果如下图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368655095-ed011a25-7207-4935-b32f-0d16faf4e827.png#clientId=uab33f410-eee0-4&from=paste&id=u51c68182&margin=%5Bobject%20Object%5D&name=image.png&originHeight=670&originWidth=456&originalType=url&ratio=1&size=42116&status=done&style=none&taskId=uba6b97a5-7003-4655-9772-cec30f3a5ea#averageHue=%23ebebeb&id=ynYbg&originHeight=670&originWidth=456&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />现在我们不需要单向链表 LinkedList 类了，但是 ValuePair 类仍然是需要的。同样的，我们的 HashTableLinearProbing 类继承自 HashTable 类，完整的代码如下：\n\n```javascript\nclass HashTableLinearProbing extends HashTable {\n    constructor() {\n        super()\n    }\n\n    put(key, value) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] === undefined) {\n            this.table[position] = new ValuePair(key, value)\n        } else {\n            let index = position + 1\n            while (this.table[index] !== undefined) {\n                index++\n            }\n            this.table[index] = new ValuePair(key, value)\n        }\n    }\n\n    get(key) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] !== undefined) {\n            if (this.table[position].key === key) return this.table[position].value\n            let index = position + 1\n            while (this.table[index] !== undefined && this.table[index].key !== key) {\n                index++\n            }\n            return this.table[index].value\n        }\n        return undefined\n    }\n\n    remove(key) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] !== undefined) {\n            if (this.table[position].key === key) {\n                this.table[position] = undefined\n                return true\n            }\n            let index = position + 1\n            while (this.table[index] !== undefined && this.table[index].key !== key) {\n                index++\n            }\n            this.table[index] = undefined\n            return true\n        }\n        return false\n    }\n\n    toString() {\n        let objString = \"\"\n        for (let i = 0; i < this.table.length; i++) {\n            let ci = this.table[i]\n            if (ci === undefined) continue\n\n            objString += `${i}: ${ci}\\r\\n`\n        }\n        return objString\n    }\n}\n```\n\n使用上面和 HashTableSeparateChaining 类相同的测试用例，我们来看看测试结果：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368672669-14fd7f0a-e601-467e-86d9-cedc1477c2de.png#clientId=uab33f410-eee0-4&from=paste&id=u808a989f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=457&originWidth=317&originalType=url&ratio=1&size=45391&status=done&style=none&taskId=uafa43c0d-f3b8-4bef-b6f5-0a0671e67e7#averageHue=%232f2f27&id=db7dV&originHeight=457&originWidth=317&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />可以和 HashTableSeparateChaining 类的测试结果比较一下，多出来的位置 6、14、17、33，正是 HashTableSeparateChaining 类中每一个链表的剩余部分。get()和 remove()方法也能正常工作，我们不需要重写 size()方法，和基类 HashTable 中一样，hash 数组中每一个位置只保存了一个元素。另一个要注意的地方是，由于 JavaScript 中定义数组时不需要提前给出数组的长度，因此我们可以很容易地利用 JavaScript 语言的这一特性来实现线性探查。在某些编程语言中，数组的定义是必须明确给出长度的，这时我们就需要重新考虑我们的 HashLinearProbing 类的实现了。<br />loseloseHashCode()散列函数并不是一个表现良好的散列函数，正如你所看到的，它会很轻易地产生散列冲突。一个表现良好的散列函数必须能够尽可能低地减少散列冲突，并提高性能。我们可以在网上找一些不同的散列函数的实现方法，下面是一个比 loseloseHashCode()更好的散列函数 djb2HashCode()：\n\n```javascript\ndjb2HashCode (key) {\n    let hash = 5381;\n    for (let i = 0; i < key.length; i++) {\n        hash = hash * 33 + key.charCodeAt(i);\n    }\n    return hash % 1013;\n}\n```\n\n我们用相同的测试用例来测试 dj2HashCode()，下面是测试结果：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646368688283-0ecfeac9-87ad-4aad-baeb-b362011cc85b.png#clientId=uab33f410-eee0-4&from=paste&id=ueb108685&margin=%5Bobject%20Object%5D&name=image.png&originHeight=211&originWidth=154&originalType=url&ratio=1&size=14706&status=done&style=none&taskId=ucc1b174c-5ba6-4308-9ddf-90d8f294e3d#averageHue=%232f2f27&id=uzgtb&originHeight=211&originWidth=154&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />这次没有冲突！然而这并不是最好的散列函数，但它是社区最推崇的散列函数之一。\n",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><p id=\"ubb23f819\" class=\"ne-p\"><a href=\"https://www.cnblogs.com/jaxu/p/11302315.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11302315.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">链接</span></a><span class=\"ne-text\"><br /></span></p><p id=\"u8f37aaa1\" class=\"ne-p\"><br></p><p id=\"ude8db97f\" class=\"ne-p\"><span class=\"ne-text\">在</span><a href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">前一篇文章</span></a><span class=\"ne-text\">中，我们介绍了如何在 JavaScript 中实现集合。字典和集合的主要区别就在于，集合中数据是以</span><strong><span class=\"ne-text\">[值，值]</span></strong><span class=\"ne-text\">的形式保存的，我们只关心值本身；而在字典和散列表中数据是以</span><strong><span class=\"ne-text\">[键，值]</span></strong><span class=\"ne-text\">的形式保存的，键不能重复，我们不仅关心键，也关心键所对应的值。<br /></span><span class=\"ne-text\">我们也可以把字典称之为映射表。由于字典和集合很相似，我们可以在</span><a href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">前一篇文章</span></a><span class=\"ne-text\">中的集合类 Set 的基础上来实现我们的字典类 Dictionary。与 Set 类相似，ES6 的原生 Map 类已经实现了字典的全部功能，稍后我们会介绍它的用法。<br /></span><span class=\"ne-text\">下面是我们的 Dictionary 字典类的实现代码：<br /></span><span class=\"ne-text\"></span></p><p id=\"ud5dee9ce\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"f89ca54c\" class=\"ne-codeblock language-javascript\"><code>class Dictionary {\n    constructor() {\n        this.items = {}\n    }\n\n    set(key, value) {\n        // 向字典中添加或修改元素\n        this.items[key] = value\n    }\n\n    get(key) {\n        // 通过键值查找字典中的值\n        return this.items[key]\n    }\n\n    delete(key) {\n        // 通过使用键值来从字典中删除对应的元素\n        if (this.has(key)) {\n            delete this.items[key]\n            return true\n        }\n        return false\n    }\n\n    has(key) {\n        // 判断给定的键值是否存在于字典中\n        return this.items.hasOwnProperty(key)\n    }\n\n    clear() {\n        // 清空字典内容\n        this.items = {}\n    }\n\n    size() {\n        // 返回字典中所有元素的数量\n        return Object.keys(this.items).length\n    }\n\n    keys() {\n        // 返回字典中所有的键值\n        return Object.keys(this.items)\n    }\n\n    values() {\n        // 返回字典中所有的值\n        return Object.values(this.items)\n    }\n\n    getItems() {\n        // 返回字典中的所有元素\n        return this.items\n    }\n}</code></pre><p id=\"udb620664\" class=\"ne-p\"><br></p><p id=\"u086c61fe\" class=\"ne-p\"><span class=\"ne-text\">与 Set 类很相似，只是把其中 value 的部分替换成了 key。我们来看看一些测试用例：<br /></span><span class=\"ne-text\"></span></p><p id=\"u79dcc862\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"86f2b0c2\" class=\"ne-codeblock language-javascript\"><code>let Dictionary = require(&quot;./dictionary&quot;)\n\nlet dictionary = new Dictionary()\ndictionary.set(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;)\ndictionary.set(&quot;John&quot;, &quot;john@email.com&quot;)\ndictionary.set(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;)\nconsole.log(dictionary.has(&quot;Gandalf&quot;)) // true\nconsole.log(dictionary.size()) // 3\nconsole.log(dictionary.keys()) // [ 'Gandalf', 'John', 'Tyrion' ]\nconsole.log(dictionary.values()) // [ 'gandalf@email.com', 'john@email.com', 'tyrion@email.com' ]\nconsole.log(dictionary.get(&quot;Tyrion&quot;)) // tyrion@email.com\n\ndictionary.delete(&quot;John&quot;)\nconsole.log(dictionary.keys()) // [ 'Gandalf', 'Tyrion' ]\nconsole.log(dictionary.values()) // [ 'gandalf@email.com', 'tyrion@email.com' ]\nconsole.log(dictionary.getItems()) // { Gandalf: 'gandalf@email.com', Tyrion: 'tyrion@email.com' }</code></pre><p id=\"u85001157\" class=\"ne-p\"><br></p><p id=\"uc5bbf7c2\" class=\"ne-p\"><span class=\"ne-text\">相应地，下面是使用 ES6 的原生 Map 类的测试结果：</span></p><p id=\"u8b3cc6ae\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"a3c4a3d2\" class=\"ne-codeblock language-javascript\"><code>let dictionary = new Map()\ndictionary.set(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;)\ndictionary.set(&quot;John&quot;, &quot;john@email.com&quot;)\ndictionary.set(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;)\nconsole.log(dictionary.has(&quot;Gandalf&quot;)) // true\nconsole.log(dictionary.size) // 3\nconsole.log(dictionary.keys()) // [Map Iterator] { 'Gandalf', 'John', 'Tyrion' }\nconsole.log(dictionary.values()) // [Map Iterator] { 'gandalf@email.com', 'john@email.com', 'tyrion@email.com' }\nconsole.log(dictionary.get(&quot;Tyrion&quot;)) // tyrion@email.com\n\ndictionary.delete(&quot;John&quot;)\nconsole.log(dictionary.keys()) // [Map Iterator] { 'Gandalf', 'Tyrion' }\nconsole.log(dictionary.values()) // [Map Iterator] { 'gandalf@email.com', 'tyrion@email.com' }\nconsole.log(dictionary.entries()) // [Map Iterator] { [ Gandalf: 'gandalf@email.com' ], [ Tyrion: 'tyrion@email.com' ] }</code></pre><p id=\"u6578529b\" class=\"ne-p\"><br></p><p id=\"uc9c56cd9\" class=\"ne-p\"><span class=\"ne-text\">和前面我们自定义的 Dictionary 类稍微有一点不同，values()方法和 keys()方法返回的不是一个数组，而是 Iterator 迭代器。另一个就是这里的 size 是一个属性而不是方法，然后就是 Map 类没有 getItems()方法，取而代之的是 entries()方法，它返回的也是一个 Iterator。有关 Map 类的详细详细介绍可以查看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">这里</span></a><span class=\"ne-text\">。<br /></span><span class=\"ne-text\">在 ES6 中，除了原生的 Set 和 Map 类外，还有它们的弱化版本，分别是</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">WeakSet</span></a><span class=\"ne-text\">和</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">WeakMap</span></a><span class=\"ne-text\">，我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——栈的实现与应用》</span></a><span class=\"ne-text\">一文中已经见过 WeakMap 的使用了。Map 和 Set 与它们各自的弱化版本之间的主要区别是：</span></p><p id=\"ubb3a0258\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u74da225b\" data-lake-index-type=\"0\"><span class=\"ne-text\">WeakSet 或 WeakMap 类没有 entries、keys 和 values 等迭代器方法，只能通过 get 和 set 方法访问和设置其中的值。这也是为什么我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——栈的实现与应用》</span></a><span class=\"ne-text\">一文中要使用 WeakMap 类来定义类的私有属性的原因。</span></li><li id=\"u0f0e4bf7\" data-lake-index-type=\"0\"><span class=\"ne-text\">只能用对应作为键值，或者说其中的内容只能是对象，而不能是数字、字符串、布尔值等基本数据类型。</span></li></ul><p id=\"ud81b694b\" class=\"ne-p\"><br></p><p id=\"ufa4338d7\" class=\"ne-p\"><span class=\"ne-text\">弱化的 Map 和 Set 类主要是为了提供 JavaScript 代码的性能。</span></p><p id=\"ua79a5815\" class=\"ne-p\"><br></p><h3 id=\"02d41e53\"><span class=\"ne-text\">散列表</span></h3><p id=\"ua6d6b17e\" class=\"ne-p\"><br></p><p id=\"ub4400246\" class=\"ne-p\"><span class=\"ne-text\">散列表（或者叫哈希表），是一种改进的 dictionary，它将 key 通过一个固定的算法（散列函数或哈希函数）得出一个数字，然后将 dictionary 中 key 所对应的 value 存放到这个数字所对应的数组下标所包含的存储空间中。在原始的 dictionary 中，如果要查找某个 key 所对应的 value，我们需要遍历整个字典。为了提高查询的效率，我们将 key 对应的 value 保存到数组里，只要 key 不变，使用相同的散列函数计算出来的数字就是固定的，于是就可以很快地在数组中找到你想要查找的 value。下面是散列表的数据结构示意图：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368542821-e21547f7-16a8-4cc5-9aaf-b804f938c10f.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=ue683a1cd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=414&amp;originWidth=615&amp;originalType=url&amp;ratio=1&amp;size=25678&amp;status=done&amp;style=none&amp;taskId=u2a55325f-d9c8-446e-8a75-7d1c87ff9a8\" width=\"615\" id=\"qfGum\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">下面是我们散列函数 loseloseHashCode()的实现代码：</span></p><p id=\"u61b157cd\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"a9b5b063\" class=\"ne-codeblock language-javascript\"><code>loseloseHashCode (key) {\n    let hash = 0;\n    for (let i = 0; i &lt; key.length; i++) {\n        hash += key.charCodeAt(i);\n    }\n    return hash % 37;\n}</code></pre><p id=\"uc1f3b72f\" class=\"ne-p\"><br></p><p id=\"u0fc32838\" class=\"ne-p\"><span class=\"ne-text\">这个散列函数的实现很简单，我们将传入的 key 中的每一个字符使用 charCodeAt()函数（有关该函数的详细内容可以查看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">这里</span></a><span class=\"ne-text\">）将其转换成 ASCII 码，然后将这些 ASCII 码相加，最后用 37 求余，得到一个数字，这个数字就是这个 key 所对应的 hash 值。接下来要做的就是将 value 存放到 hash 值所对应的数组的存储空间内。下面是我们的 HashTable 类的主要实现代码：</span></p><p id=\"u135bf106\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"1720f7ca\" class=\"ne-codeblock language-javascript\"><code>class HashTable {\n    constructor() {\n        this.table = []\n    }\n\n    loseloseHashCode(key) {\n        // 散列函数\n        let hash = 0\n        for (let i = 0; i &lt; key.length; i++) {\n            hash += key.charCodeAt(i)\n        }\n        return hash % 37\n    }\n\n    put(key, value) {\n        // 将键值对存放到哈希表中\n        let position = this.loseloseHashCode(key)\n        console.log(`${position} - ${key}`)\n        this.table[position] = value\n    }\n\n    get(key) {\n        // 通过key查找哈希表中的值\n        return this.table[this.loseloseHashCode(key)]\n    }\n\n    remove(key) {\n        // 通过key从哈希表中删除对应的值\n        this.table[this.loseloseHashCode(key)] = undefined\n    }\n\n    isEmpty() {\n        // 判断哈希表是否为空\n        return this.size() === 0\n    }\n\n    size() {\n        // 返回哈希表的长度\n        let count = 0\n        this.table.forEach(item =&gt; {\n            if (item !== undefined) count++\n        })\n        return count\n    }\n\n    clear() {\n        // 清空哈希表\n        this.table = []\n    }\n}</code></pre><p id=\"u51026c47\" class=\"ne-p\"><br></p><p id=\"u5ce428ab\" class=\"ne-p\"><span class=\"ne-text\">测试一下上面的这些方法：</span></p><p id=\"ub159cbf7\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"6e2a8e37\" class=\"ne-codeblock language-javascript\"><code>let HashTable = require(&quot;./hashtable&quot;)\n\nlet hash = new HashTable()\nhash.put(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;) // 19 - Gandalf\nhash.put(&quot;John&quot;, &quot;john@email.com&quot;) // 29 - John\nhash.put(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;) // 16 - Tyrion\n\nconsole.log(hash.isEmpty()) // false\nconsole.log(hash.size()) // 3\nconsole.log(hash.get(&quot;Gandalf&quot;)) // gandalf@email.com\nconsole.log(hash.get(&quot;Loiane&quot;)) // undefined\n\nhash.remove(&quot;Gandalf&quot;)\nconsole.log(hash.get(&quot;Gandalf&quot;)) // undefined\nhash.clear()\nconsole.log(hash.size()) // 0\nconsole.log(hash.isEmpty()) // true</code></pre><p id=\"u7e4d014b\" class=\"ne-p\"><br></p><p id=\"u3e1414e0\" class=\"ne-p\"><span class=\"ne-text\">为了方便查看 hash 值和 value 的对应关系，我们在 put()方法中加入了一行 console.log()，用来打印 key 的 hash 值和 value 之间的对应关系。可以看到，测试的结果和前面我们给出的示意图是一致的。<br /></span><span class=\"ne-text\">散列集合的实现和散列表类似，只不过在散列集合中不再使用键值对，而是只有值没有键。这个我们在前面介绍集合和字典的时候已经讲过了，这里不再赘述。<br /></span><span class=\"ne-text\">细心的同学可能已经发现了，这里我们提供的散列函数可能过于简单，以致于我们无法保证通过散列函数计算出来的 hash 值一定是唯一的。换句话说，传入不同的 key 值，我们有可能会得到相同的 hash 值。尝试一下下面这些 keys：</span></p><p id=\"u7eb44628\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"8a25d3af\" class=\"ne-codeblock language-javascript\"><code>let hash = new HashTable()\nhash.put(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;)\nhash.put(&quot;John&quot;, &quot;john@email.com&quot;)\nhash.put(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;)\nhash.put(&quot;Aaron&quot;, &quot;aaron@email.com&quot;)\nhash.put(&quot;Donnie&quot;, &quot;donnie@email.com&quot;)\nhash.put(&quot;Ana&quot;, &quot;ana@email.com&quot;)\nhash.put(&quot;Jamie&quot;, &quot;jamie@email.com&quot;)\nhash.put(&quot;Sue&quot;, &quot;sue@email.com&quot;)\nhash.put(&quot;Mindy&quot;, &quot;mindy@email.com&quot;)\nhash.put(&quot;Paul&quot;, &quot;paul@email.com&quot;)\nhash.put(&quot;Nathan&quot;, &quot;nathan@email.com&quot;)</code></pre><p id=\"u3cd834a5\" class=\"ne-p\"><br></p><p id=\"u05417d56\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368595446-4d8db671-fdd7-42d2-9815-827750bba9f4.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u5cd5ea63&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=217&amp;originalType=url&amp;ratio=1&amp;size=12348&amp;status=done&amp;style=none&amp;taskId=u208e6fcd-a64f-42f2-b685-9bd3444dd97\" width=\"217\" id=\"IzjET\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">从结果中可以看到，尽管有些 keys 不同，但是通过我们提供的散列函数居然得到了相同的 hash 值，这显然违背了我们的设计原则。在哈希表中，这个叫做散列冲突，为了得到一个可靠的哈希表，我们必须尽可能地避免散列冲突。那如何避免这种冲突呢？这里介绍两种解决冲突的方法：分离链接和线性探查。</span></p><p id=\"uebdfafa0\" class=\"ne-p\"><br></p><h4 id=\"2afa3875\"><span class=\"ne-text\">分离链接</span></h4><p id=\"ua50af096\" class=\"ne-p\"><br></p><p id=\"ub436d0ca\" class=\"ne-p\"><span class=\"ne-text\">所谓分离链接，就是将原本存储在哈希表中的值改成链表，这样在哈希表的同一个位置上，就可以存储多个不同的值。链表中的每一个元素，同时存储了 key 和 value。示意图如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368603606-2893c36d-392a-498a-9715-0a6483b9d997.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u9dd6e4e0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=624&amp;originWidth=817&amp;originalType=url&amp;ratio=1&amp;size=44528&amp;status=done&amp;style=none&amp;taskId=ud2372fb7-ef28-4f56-a190-8dc43b1853e\" width=\"817\" id=\"CK3Vn\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">这样，当不同的 key 通过散列函数计算出相同的 hash 值时，我们只需要找到数组中对应的位置，然后往其中的链表添加新的节点即可，从而有效地避免了散列冲突。为了实现这种数据结构，我们需要定义一个新的辅助类 ValuePair，它的内容如下：</span></p><p id=\"u69583c1c\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3e132302\" class=\"ne-codeblock language-javascript\"><code>let ValuePair = function (key, value) {\n    this.key = key\n    this.value = value\n\n    this.toString = function () {\n        // 提供toString()方法以方便我们测试\n        return `[${this.key} - ${this.value}]`\n    }\n}</code></pre><p id=\"ue14c050f\" class=\"ne-p\"><br></p><p id=\"u7c3301df\" class=\"ne-p\"><span class=\"ne-text\">ValuePair 类具有两个属性，key 和 value，用来保存我们要存入到散列表中的元素的键值对。toString()方法在这里不是必须的，该方法是为了后面我们方便测试。<br /></span><span class=\"ne-text\">新的采用了分离链接的 HashTableSeparateChaining 类可以继承自前面的 HashTable 类，完整的代码如下：</span></p><p id=\"u0c6e738c\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"62701b61\" class=\"ne-codeblock language-javascript\"><code>class HashTableSeparateChaining extends HashTable {\n    constructor() {\n        super()\n    }\n\n    put(key, value) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] === undefined) {\n            this.table[position] = new LinkedList() // 单向链表，需要引入LinkedList类\n        }\n        this.table[position].append(new ValuePair(key, value))\n    }\n\n    get(key) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] !== undefined) {\n            let current = this.table[position].getHead()\n            while (current) {\n                if (current.element.key === key) return current.element.value\n                current = current.next\n            }\n        }\n        return undefined\n    }\n\n    remove(key) {\n        let position = this.loseloseHashCode(key)\n        let hash = this.table[position]\n\n        if (hash !== undefined) {\n            let current = hash.getHead()\n            while (current) {\n                if (current.element.key === key) {\n                    hash.remove(current.element)\n                    if (hash.isEmpty()) this.table[position] = undefined\n                    return true\n                }\n                current = current.next\n            }\n        }\n\n        return false\n    }\n\n    size() {\n        let count = 0\n        this.table.forEach(item =&gt; {\n            if (item !== undefined) count += item.size()\n        })\n        return count\n    }\n\n    toString() {\n        let objString = &quot;&quot;\n        for (let i = 0; i &lt; this.table.length; i++) {\n            let ci = this.table[i]\n            if (ci === undefined) continue\n\n            objString += `${i}: `\n            let current = ci.getHead()\n            while (current) {\n                objString += current.element.toString()\n                current = current.next\n                if (current) objString += &quot;, &quot;\n            }\n            objString += &quot;\\r\\n&quot;\n        }\n        return objString\n    }\n}</code></pre><p id=\"u9a7bcdb5\" class=\"ne-p\"><br></p><p id=\"ufc2f9ed1\" class=\"ne-p\"><span class=\"ne-text\">其中的 LinkedList 类为单向链表，具体内容可以查看</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——链表的实现与应用》</span></a><span class=\"ne-text\">。注意，现在 hash 数组中的每一个元素都是一个单向链表，单向链表的所有操作我们可以借助于 LinkedList 类来完成。我们重写了 size()方法，因为现在要计算的是数组中所有链表的长度总和。<br /></span><span class=\"ne-text\">下面是 HashTableSeparateChaining 类的测试用例及结果：</span></p><p id=\"ub0a4ecdd\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"07ce9f22\" class=\"ne-codeblock language-javascript\"><code>let hash = new HashTableSeparateChaining()\n\nhash.put(&quot;Gandalf&quot;, &quot;gandalf@email.com&quot;)\nhash.put(&quot;John&quot;, &quot;john@email.com&quot;)\nhash.put(&quot;Tyrion&quot;, &quot;tyrion@email.com&quot;)\nhash.put(&quot;Aaron&quot;, &quot;aaron@email.com&quot;)\nhash.put(&quot;Donnie&quot;, &quot;donnie@email.com&quot;)\nhash.put(&quot;Ana&quot;, &quot;ana@email.com&quot;)\nhash.put(&quot;Jamie&quot;, &quot;jamie@email.com&quot;)\nhash.put(&quot;Sue&quot;, &quot;sue@email.com&quot;)\nhash.put(&quot;Mindy&quot;, &quot;mindy@email.com&quot;)\nhash.put(&quot;Paul&quot;, &quot;paul@email.com&quot;)\nhash.put(&quot;Nathan&quot;, &quot;nathan@email.com&quot;)\n\nconsole.log(hash.toString())\nconsole.log(`size: ${hash.size()}`)\nconsole.log(hash.get(&quot;John&quot;))\n\nconsole.log(hash.remove(&quot;Ana&quot;))\nconsole.log(hash.remove(&quot;John&quot;))\nconsole.log(hash.toString())</code></pre><p id=\"u396f083b\" class=\"ne-p\"><br></p><p id=\"u7f03c632\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368646270-fbd61d17-9e27-478b-a83a-70ed90b6bce8.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u2d23b493&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=340&amp;originWidth=552&amp;originalType=url&amp;ratio=1&amp;size=61098&amp;status=done&amp;style=none&amp;taskId=u6c6a702c-708f-404b-9d42-0bc24edd1af\" width=\"552\" id=\"FOP77\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">可以看到，结果和上面示意图上给出的是一致的，size()、remove()和 get()方法的执行结果也符合预期。</span></p><p id=\"u81626c4a\" class=\"ne-p\"><br></p><h4 id=\"c112812d\"><span class=\"ne-text\">线性探查</span></h4><p id=\"u3e872e71\" class=\"ne-p\"><br></p><p id=\"u38997bfd\" class=\"ne-p\"><span class=\"ne-text\">避免散列冲突的另一种方法是线性探查。当向哈希数组中添加某一个新元素时，如果该位置上已经有数据了，就继续尝试下一个位置，直到对应的位置上没有数据时，就在该位置上添加数据。我们将上面的例子改成线性探查的方式，存储结果如下图所示：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368655095-ed011a25-7207-4935-b32f-0d16faf4e827.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u51c68182&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=670&amp;originWidth=456&amp;originalType=url&amp;ratio=1&amp;size=42116&amp;status=done&amp;style=none&amp;taskId=uba6b97a5-7003-4655-9772-cec30f3a5ea\" width=\"456\" id=\"ynYbg\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">现在我们不需要单向链表 LinkedList 类了，但是 ValuePair 类仍然是需要的。同样的，我们的 HashTableLinearProbing 类继承自 HashTable 类，完整的代码如下：</span></p><p id=\"u5301a5d8\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"c06c862c\" class=\"ne-codeblock language-javascript\"><code>class HashTableLinearProbing extends HashTable {\n    constructor() {\n        super()\n    }\n\n    put(key, value) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] === undefined) {\n            this.table[position] = new ValuePair(key, value)\n        } else {\n            let index = position + 1\n            while (this.table[index] !== undefined) {\n                index++\n            }\n            this.table[index] = new ValuePair(key, value)\n        }\n    }\n\n    get(key) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] !== undefined) {\n            if (this.table[position].key === key) return this.table[position].value\n            let index = position + 1\n            while (this.table[index] !== undefined &amp;&amp; this.table[index].key !== key) {\n                index++\n            }\n            return this.table[index].value\n        }\n        return undefined\n    }\n\n    remove(key) {\n        let position = this.loseloseHashCode(key)\n\n        if (this.table[position] !== undefined) {\n            if (this.table[position].key === key) {\n                this.table[position] = undefined\n                return true\n            }\n            let index = position + 1\n            while (this.table[index] !== undefined &amp;&amp; this.table[index].key !== key) {\n                index++\n            }\n            this.table[index] = undefined\n            return true\n        }\n        return false\n    }\n\n    toString() {\n        let objString = &quot;&quot;\n        for (let i = 0; i &lt; this.table.length; i++) {\n            let ci = this.table[i]\n            if (ci === undefined) continue\n\n            objString += `${i}: ${ci}\\r\\n`\n        }\n        return objString\n    }\n}</code></pre><p id=\"u524a57fa\" class=\"ne-p\"><br></p><p id=\"u18641080\" class=\"ne-p\"><span class=\"ne-text\">使用上面和 HashTableSeparateChaining 类相同的测试用例，我们来看看测试结果：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368672669-14fd7f0a-e601-467e-86d9-cedc1477c2de.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=u808a989f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=457&amp;originWidth=317&amp;originalType=url&amp;ratio=1&amp;size=45391&amp;status=done&amp;style=none&amp;taskId=uafa43c0d-f3b8-4bef-b6f5-0a0671e67e7\" width=\"317\" id=\"db7dV\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">可以和 HashTableSeparateChaining 类的测试结果比较一下，多出来的位置 6、14、17、33，正是 HashTableSeparateChaining 类中每一个链表的剩余部分。get()和 remove()方法也能正常工作，我们不需要重写 size()方法，和基类 HashTable 中一样，hash 数组中每一个位置只保存了一个元素。另一个要注意的地方是，由于 JavaScript 中定义数组时不需要提前给出数组的长度，因此我们可以很容易地利用 JavaScript 语言的这一特性来实现线性探查。在某些编程语言中，数组的定义是必须明确给出长度的，这时我们就需要重新考虑我们的 HashLinearProbing 类的实现了。<br /></span><span class=\"ne-text\">loseloseHashCode()散列函数并不是一个表现良好的散列函数，正如你所看到的，它会很轻易地产生散列冲突。一个表现良好的散列函数必须能够尽可能低地减少散列冲突，并提高性能。我们可以在网上找一些不同的散列函数的实现方法，下面是一个比 loseloseHashCode()更好的散列函数 djb2HashCode()：</span></p><p id=\"u222465fb\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"e1f3531c\" class=\"ne-codeblock language-javascript\"><code>djb2HashCode (key) {\n    let hash = 5381;\n    for (let i = 0; i &lt; key.length; i++) {\n        hash = hash * 33 + key.charCodeAt(i);\n    }\n    return hash % 1013;\n}</code></pre><p id=\"uc8f6a2df\" class=\"ne-p\"><br></p><p id=\"ud5ad36de\" class=\"ne-p\"><span class=\"ne-text\">我们用相同的测试用例来测试 dj2HashCode()，下面是测试结果：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646368688283-0ecfeac9-87ad-4aad-baeb-b362011cc85b.png#clientId=uab33f410-eee0-4&amp;from=paste&amp;id=ueb108685&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=211&amp;originWidth=154&amp;originalType=url&amp;ratio=1&amp;size=14706&amp;status=done&amp;style=none&amp;taskId=ucc1b174c-5ba6-4308-9ddf-90d8f294e3d\" width=\"154\" id=\"uzgtb\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">这次没有冲突！然而这并不是最好的散列函数，但它是社区最推崇的散列函数之一。</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"ubb23f819\" id=\"ubb23f819\"><a href=\"https://www.cnblogs.com/jaxu/p/11302315.html\" target=\"_blank\" data-lake-id=\"ue35e13b8\" id=\"ue35e13b8\"><span data-lake-id=\"uae22b930\" id=\"uae22b930\">链接</span></a><span data-lake-id=\"ud92fa9d7\" id=\"ud92fa9d7\"><br /><br /></span></p><p data-lake-id=\"u8f37aaa1\" id=\"u8f37aaa1\"><br></p><p data-lake-id=\"ude8db97f\" id=\"ude8db97f\"><span data-lake-id=\"u47515a2b\" id=\"u47515a2b\">在</span><a href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" target=\"_blank\" data-lake-id=\"u495da1d8\" id=\"u495da1d8\"><span data-lake-id=\"u9d41ec72\" id=\"u9d41ec72\">前一篇文章</span></a><span data-lake-id=\"u40b4a952\" id=\"u40b4a952\">中，我们介绍了如何在 JavaScript 中实现集合。字典和集合的主要区别就在于，集合中数据是以</span><strong><span data-lake-id=\"u4dbb99ea\" id=\"u4dbb99ea\">[值，值]</span></strong><span data-lake-id=\"ua09d4c2b\" id=\"ua09d4c2b\">的形式保存的，我们只关心值本身；而在字典和散列表中数据是以</span><strong><span data-lake-id=\"u1bf5c23e\" id=\"u1bf5c23e\">[键，值]</span></strong><span data-lake-id=\"uf788d2e8\" id=\"uf788d2e8\">的形式保存的，键不能重复，我们不仅关心键，也关心键所对应的值。<br /></span><span data-lake-id=\"u84d98f8e\" id=\"u84d98f8e\">我们也可以把字典称之为映射表。由于字典和集合很相似，我们可以在</span><a href=\"https://www.cnblogs.com/jaxu/p/11287315.html\" target=\"_blank\" data-lake-id=\"uf040bc45\" id=\"uf040bc45\"><span data-lake-id=\"ub8a448f8\" id=\"ub8a448f8\">前一篇文章</span></a><span data-lake-id=\"u71ee2e69\" id=\"u71ee2e69\">中的集合类 Set 的基础上来实现我们的字典类 Dictionary。与 Set 类相似，ES6 的原生 Map 类已经实现了字典的全部功能，稍后我们会介绍它的用法。<br /></span><span data-lake-id=\"ud122cf85\" id=\"ud122cf85\">下面是我们的 Dictionary 字典类的实现代码：<br /></span><span data-lake-id=\"u40c1eb52\" id=\"u40c1eb52\">​</span></p><p data-lake-id=\"ud5dee9ce\" id=\"ud5dee9ce\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20Dictionary%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20this.items%20%3D%20%7B%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20set(key%2C%20value)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%90%91%E5%AD%97%E5%85%B8%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%88%96%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0%5Cn%20%20%20%20%20%20%20%20this.items%5Bkey%5D%20%3D%20value%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20get(key)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87%E9%94%AE%E5%80%BC%E6%9F%A5%E6%89%BE%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E5%80%BC%5Cn%20%20%20%20%20%20%20%20return%20this.items%5Bkey%5D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20delete(key)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8%E9%94%AE%E5%80%BC%E6%9D%A5%E4%BB%8E%E5%AD%97%E5%85%B8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%83%E7%B4%A0%5Cn%20%20%20%20%20%20%20%20if%20(this.has(key))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20delete%20this.items%5Bkey%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20true%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20false%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20has(key)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%88%A4%E6%96%AD%E7%BB%99%E5%AE%9A%E7%9A%84%E9%94%AE%E5%80%BC%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8E%E5%AD%97%E5%85%B8%E4%B8%AD%5Cn%20%20%20%20%20%20%20%20return%20this.items.hasOwnProperty(key)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20clear()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E6%B8%85%E7%A9%BA%E5%AD%97%E5%85%B8%E5%86%85%E5%AE%B9%5Cn%20%20%20%20%20%20%20%20this.items%20%3D%20%7B%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20size()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E5%AD%97%E5%85%B8%E4%B8%AD%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E9%87%8F%5Cn%20%20%20%20%20%20%20%20return%20Object.keys(this.items).length%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20keys()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E5%AD%97%E5%85%B8%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E9%94%AE%E5%80%BC%5Cn%20%20%20%20%20%20%20%20return%20Object.keys(this.items)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20values()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E5%AD%97%E5%85%B8%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%80%BC%5Cn%20%20%20%20%20%20%20%20return%20Object.values(this.items)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20getItems()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%5Cn%20%20%20%20%20%20%20%20return%20this.items%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22f89ca54c%22%7D\"></card><p data-lake-id=\"udb620664\" id=\"udb620664\"><br></p><p data-lake-id=\"u086c61fe\" id=\"u086c61fe\"><span data-lake-id=\"u9fc2ff84\" id=\"u9fc2ff84\">与 Set 类很相似，只是把其中 value 的部分替换成了 key。我们来看看一些测试用例：<br /></span><span data-lake-id=\"u555bddf3\" id=\"u555bddf3\">​</span></p><p data-lake-id=\"u79dcc862\" id=\"u79dcc862\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20Dictionary%20%3D%20require(%5C%22.%2Fdictionary%5C%22)%5Cn%5Cnlet%20dictionary%20%3D%20new%20Dictionary()%5Cndictionary.set(%5C%22Gandalf%5C%22%2C%20%5C%22gandalf%40email.com%5C%22)%5Cndictionary.set(%5C%22John%5C%22%2C%20%5C%22john%40email.com%5C%22)%5Cndictionary.set(%5C%22Tyrion%5C%22%2C%20%5C%22tyrion%40email.com%5C%22)%5Cnconsole.log(dictionary.has(%5C%22Gandalf%5C%22))%20%2F%2F%20true%5Cnconsole.log(dictionary.size())%20%2F%2F%203%5Cnconsole.log(dictionary.keys())%20%2F%2F%20%5B%20'Gandalf'%2C%20'John'%2C%20'Tyrion'%20%5D%5Cnconsole.log(dictionary.values())%20%2F%2F%20%5B%20'gandalf%40email.com'%2C%20'john%40email.com'%2C%20'tyrion%40email.com'%20%5D%5Cnconsole.log(dictionary.get(%5C%22Tyrion%5C%22))%20%2F%2F%20tyrion%40email.com%5Cn%5Cndictionary.delete(%5C%22John%5C%22)%5Cnconsole.log(dictionary.keys())%20%2F%2F%20%5B%20'Gandalf'%2C%20'Tyrion'%20%5D%5Cnconsole.log(dictionary.values())%20%2F%2F%20%5B%20'gandalf%40email.com'%2C%20'tyrion%40email.com'%20%5D%5Cnconsole.log(dictionary.getItems())%20%2F%2F%20%7B%20Gandalf%3A%20'gandalf%40email.com'%2C%20Tyrion%3A%20'tyrion%40email.com'%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2286f2b0c2%22%7D\"></card><p data-lake-id=\"u85001157\" id=\"u85001157\"><br></p><p data-lake-id=\"uc5bbf7c2\" id=\"uc5bbf7c2\"><span data-lake-id=\"ue759ab05\" id=\"ue759ab05\">相应地，下面是使用 ES6 的原生 Map 类的测试结果：</span></p><p data-lake-id=\"u8b3cc6ae\" id=\"u8b3cc6ae\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20dictionary%20%3D%20new%20Map()%5Cndictionary.set(%5C%22Gandalf%5C%22%2C%20%5C%22gandalf%40email.com%5C%22)%5Cndictionary.set(%5C%22John%5C%22%2C%20%5C%22john%40email.com%5C%22)%5Cndictionary.set(%5C%22Tyrion%5C%22%2C%20%5C%22tyrion%40email.com%5C%22)%5Cnconsole.log(dictionary.has(%5C%22Gandalf%5C%22))%20%2F%2F%20true%5Cnconsole.log(dictionary.size)%20%2F%2F%203%5Cnconsole.log(dictionary.keys())%20%2F%2F%20%5BMap%20Iterator%5D%20%7B%20'Gandalf'%2C%20'John'%2C%20'Tyrion'%20%7D%5Cnconsole.log(dictionary.values())%20%2F%2F%20%5BMap%20Iterator%5D%20%7B%20'gandalf%40email.com'%2C%20'john%40email.com'%2C%20'tyrion%40email.com'%20%7D%5Cnconsole.log(dictionary.get(%5C%22Tyrion%5C%22))%20%2F%2F%20tyrion%40email.com%5Cn%5Cndictionary.delete(%5C%22John%5C%22)%5Cnconsole.log(dictionary.keys())%20%2F%2F%20%5BMap%20Iterator%5D%20%7B%20'Gandalf'%2C%20'Tyrion'%20%7D%5Cnconsole.log(dictionary.values())%20%2F%2F%20%5BMap%20Iterator%5D%20%7B%20'gandalf%40email.com'%2C%20'tyrion%40email.com'%20%7D%5Cnconsole.log(dictionary.entries())%20%2F%2F%20%5BMap%20Iterator%5D%20%7B%20%5B%20Gandalf%3A%20'gandalf%40email.com'%20%5D%2C%20%5B%20Tyrion%3A%20'tyrion%40email.com'%20%5D%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22a3c4a3d2%22%7D\"></card><p data-lake-id=\"u6578529b\" id=\"u6578529b\"><br></p><p data-lake-id=\"uc9c56cd9\" id=\"uc9c56cd9\"><span data-lake-id=\"u932dca74\" id=\"u932dca74\">和前面我们自定义的 Dictionary 类稍微有一点不同，values()方法和 keys()方法返回的不是一个数组，而是 Iterator 迭代器。另一个就是这里的 size 是一个属性而不是方法，然后就是 Map 类没有 getItems()方法，取而代之的是 entries()方法，它返回的也是一个 Iterator。有关 Map 类的详细详细介绍可以查看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" data-lake-id=\"ubaacd7f7\" id=\"ubaacd7f7\"><span data-lake-id=\"u46aed8c4\" id=\"u46aed8c4\">这里</span></a><span data-lake-id=\"u8ba0d2a1\" id=\"u8ba0d2a1\">。<br /></span><span data-lake-id=\"u95987e5d\" id=\"u95987e5d\">在 ES6 中，除了原生的 Set 和 Map 类外，还有它们的弱化版本，分别是</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\" target=\"_blank\" data-lake-id=\"u336c807e\" id=\"u336c807e\"><span data-lake-id=\"uecf63c31\" id=\"uecf63c31\">WeakSet</span></a><span data-lake-id=\"ub552a3c3\" id=\"ub552a3c3\">和</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\" target=\"_blank\" data-lake-id=\"u22fe505b\" id=\"u22fe505b\"><span data-lake-id=\"u2e3e7356\" id=\"u2e3e7356\">WeakMap</span></a><span data-lake-id=\"ua93be20b\" id=\"ua93be20b\">，我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" data-lake-id=\"u6543cd55\" id=\"u6543cd55\"><span data-lake-id=\"u4f5e867e\" id=\"u4f5e867e\">《JavaScript 数据结构——栈的实现与应用》</span></a><span data-lake-id=\"u7370d1b7\" id=\"u7370d1b7\">一文中已经见过 WeakMap 的使用了。Map 和 Set 与它们各自的弱化版本之间的主要区别是：</span></p><p data-lake-id=\"ubb3a0258\" id=\"ubb3a0258\"><br></p><ul list=\"u82a5ae41\"><li fid=\"u0eb05157\" data-lake-id=\"u74da225b\" id=\"u74da225b\"><span data-lake-id=\"uc47d4ac3\" id=\"uc47d4ac3\">WeakSet 或 WeakMap 类没有 entries、keys 和 values 等迭代器方法，只能通过 get 和 set 方法访问和设置其中的值。这也是为什么我们在</span><a href=\"https://www.cnblogs.com/jaxu/p/11264017.html\" target=\"_blank\" data-lake-id=\"u6ebae58a\" id=\"u6ebae58a\"><span data-lake-id=\"u73ce812c\" id=\"u73ce812c\">《JavaScript 数据结构——栈的实现与应用》</span></a><span data-lake-id=\"u091fdacf\" id=\"u091fdacf\">一文中要使用 WeakMap 类来定义类的私有属性的原因。</span></li><li fid=\"u0eb05157\" data-lake-id=\"u0f0e4bf7\" id=\"u0f0e4bf7\"><span data-lake-id=\"ua00ddfa1\" id=\"ua00ddfa1\">只能用对应作为键值，或者说其中的内容只能是对象，而不能是数字、字符串、布尔值等基本数据类型。</span></li></ul><p data-lake-id=\"ud81b694b\" id=\"ud81b694b\"><br></p><p data-lake-id=\"ufa4338d7\" id=\"ufa4338d7\"><span data-lake-id=\"uc7593475\" id=\"uc7593475\">弱化的 Map 和 Set 类主要是为了提供 JavaScript 代码的性能。</span></p><p data-lake-id=\"ua79a5815\" id=\"ua79a5815\"><br></p><h3 data-lake-id=\"02d41e53\" id=\"02d41e53\"><span data-lake-id=\"u65d0e277\" id=\"u65d0e277\">散列表</span></h3><p data-lake-id=\"ua6d6b17e\" id=\"ua6d6b17e\"><br></p><p data-lake-id=\"ub4400246\" id=\"ub4400246\"><span data-lake-id=\"ude75901d\" id=\"ude75901d\">散列表（或者叫哈希表），是一种改进的 dictionary，它将 key 通过一个固定的算法（散列函数或哈希函数）得出一个数字，然后将 dictionary 中 key 所对应的 value 存放到这个数字所对应的数组下标所包含的存储空间中。在原始的 dictionary 中，如果要查找某个 key 所对应的 value，我们需要遍历整个字典。为了提高查询的效率，我们将 key 对应的 value 保存到数组里，只要 key 不变，使用相同的散列函数计算出来的数字就是固定的，于是就可以很快地在数组中找到你想要查找的 value。下面是散列表的数据结构示意图：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368542821-e21547f7-16a8-4cc5-9aaf-b804f938c10f.png%23clientId%3Duab33f410-eee0-4%26from%3Dpaste%26id%3Due683a1cd%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D414%26originWidth%3D615%26originalType%3Durl%26ratio%3D1%26size%3D25678%26status%3Ddone%26style%3Dnone%26taskId%3Du2a55325f-d9c8-446e-8a75-7d1c87ff9a8%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A615%2C%22originHeight%22%3A414%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f6f6f6%22%2C%22id%22%3A%22qfGum%22%7D\"></card><span data-lake-id=\"u8c470798\" id=\"u8c470798\"><br /></span><span data-lake-id=\"ub6a2cb38\" id=\"ub6a2cb38\">下面是我们散列函数 loseloseHashCode()的实现代码：</span></p><p data-lake-id=\"u61b157cd\" id=\"u61b157cd\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22loseloseHashCode%20(key)%20%7B%5Cn%20%20%20%20let%20hash%20%3D%200%3B%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20key.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20hash%20%2B%3D%20key.charCodeAt(i)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20hash%20%25%2037%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22a9b5b063%22%7D\"></card><p data-lake-id=\"uc1f3b72f\" id=\"uc1f3b72f\"><br></p><p data-lake-id=\"u0fc32838\" id=\"u0fc32838\"><span data-lake-id=\"u4af50436\" id=\"u4af50436\">这个散列函数的实现很简单，我们将传入的 key 中的每一个字符使用 charCodeAt()函数（有关该函数的详细内容可以查看</span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt\" target=\"_blank\" data-lake-id=\"u057dad09\" id=\"u057dad09\"><span data-lake-id=\"uafc00c26\" id=\"uafc00c26\">这里</span></a><span data-lake-id=\"u7f5791d4\" id=\"u7f5791d4\">）将其转换成 ASCII 码，然后将这些 ASCII 码相加，最后用 37 求余，得到一个数字，这个数字就是这个 key 所对应的 hash 值。接下来要做的就是将 value 存放到 hash 值所对应的数组的存储空间内。下面是我们的 HashTable 类的主要实现代码：</span></p><p data-lake-id=\"u135bf106\" id=\"u135bf106\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20HashTable%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20this.table%20%3D%20%5B%5D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20loseloseHashCode(key)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%5Cn%20%20%20%20%20%20%20%20let%20hash%20%3D%200%5Cn%20%20%20%20%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20key.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20hash%20%2B%3D%20key.charCodeAt(i)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20hash%20%25%2037%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20put(key%2C%20value)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%B0%86%E9%94%AE%E5%80%BC%E5%AF%B9%E5%AD%98%E6%94%BE%E5%88%B0%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%5Cn%20%20%20%20%20%20%20%20let%20position%20%3D%20this.loseloseHashCode(key)%5Cn%20%20%20%20%20%20%20%20console.log(%60%24%7Bposition%7D%20-%20%24%7Bkey%7D%60)%5Cn%20%20%20%20%20%20%20%20this.table%5Bposition%5D%20%3D%20value%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20get(key)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87key%E6%9F%A5%E6%89%BE%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%BC%5Cn%20%20%20%20%20%20%20%20return%20this.table%5Bthis.loseloseHashCode(key)%5D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20remove(key)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87key%E4%BB%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%5Cn%20%20%20%20%20%20%20%20this.table%5Bthis.loseloseHashCode(key)%5D%20%3D%20undefined%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20isEmpty()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%88%A4%E6%96%AD%E5%93%88%E5%B8%8C%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%5Cn%20%20%20%20%20%20%20%20return%20this.size()%20%3D%3D%3D%200%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20size()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%5Cn%20%20%20%20%20%20%20%20let%20count%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.table.forEach(item%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(item%20!%3D%3D%20undefined)%20count%2B%2B%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20%20%20return%20count%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20clear()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E6%B8%85%E7%A9%BA%E5%93%88%E5%B8%8C%E8%A1%A8%5Cn%20%20%20%20%20%20%20%20this.table%20%3D%20%5B%5D%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%221720f7ca%22%7D\"></card><p data-lake-id=\"u51026c47\" id=\"u51026c47\"><br></p><p data-lake-id=\"u5ce428ab\" id=\"u5ce428ab\"><span data-lake-id=\"ub245c8c2\" id=\"ub245c8c2\">测试一下上面的这些方法：</span></p><p data-lake-id=\"ub159cbf7\" id=\"ub159cbf7\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20HashTable%20%3D%20require(%5C%22.%2Fhashtable%5C%22)%5Cn%5Cnlet%20hash%20%3D%20new%20HashTable()%5Cnhash.put(%5C%22Gandalf%5C%22%2C%20%5C%22gandalf%40email.com%5C%22)%20%2F%2F%2019%20-%20Gandalf%5Cnhash.put(%5C%22John%5C%22%2C%20%5C%22john%40email.com%5C%22)%20%2F%2F%2029%20-%20John%5Cnhash.put(%5C%22Tyrion%5C%22%2C%20%5C%22tyrion%40email.com%5C%22)%20%2F%2F%2016%20-%20Tyrion%5Cn%5Cnconsole.log(hash.isEmpty())%20%2F%2F%20false%5Cnconsole.log(hash.size())%20%2F%2F%203%5Cnconsole.log(hash.get(%5C%22Gandalf%5C%22))%20%2F%2F%20gandalf%40email.com%5Cnconsole.log(hash.get(%5C%22Loiane%5C%22))%20%2F%2F%20undefined%5Cn%5Cnhash.remove(%5C%22Gandalf%5C%22)%5Cnconsole.log(hash.get(%5C%22Gandalf%5C%22))%20%2F%2F%20undefined%5Cnhash.clear()%5Cnconsole.log(hash.size())%20%2F%2F%200%5Cnconsole.log(hash.isEmpty())%20%2F%2F%20true%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%226e2a8e37%22%7D\"></card><p data-lake-id=\"u7e4d014b\" id=\"u7e4d014b\"><br></p><p data-lake-id=\"u3e1414e0\" id=\"u3e1414e0\"><span data-lake-id=\"u0a50e4f0\" id=\"u0a50e4f0\">为了方便查看 hash 值和 value 的对应关系，我们在 put()方法中加入了一行 console.log()，用来打印 key 的 hash 值和 value 之间的对应关系。可以看到，测试的结果和前面我们给出的示意图是一致的。<br /></span><span data-lake-id=\"u0b217f50\" id=\"u0b217f50\">散列集合的实现和散列表类似，只不过在散列集合中不再使用键值对，而是只有值没有键。这个我们在前面介绍集合和字典的时候已经讲过了，这里不再赘述。<br /></span><span data-lake-id=\"ucca708a1\" id=\"ucca708a1\">细心的同学可能已经发现了，这里我们提供的散列函数可能过于简单，以致于我们无法保证通过散列函数计算出来的 hash 值一定是唯一的。换句话说，传入不同的 key 值，我们有可能会得到相同的 hash 值。尝试一下下面这些 keys：</span></p><p data-lake-id=\"u7eb44628\" id=\"u7eb44628\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20hash%20%3D%20new%20HashTable()%5Cnhash.put(%5C%22Gandalf%5C%22%2C%20%5C%22gandalf%40email.com%5C%22)%5Cnhash.put(%5C%22John%5C%22%2C%20%5C%22john%40email.com%5C%22)%5Cnhash.put(%5C%22Tyrion%5C%22%2C%20%5C%22tyrion%40email.com%5C%22)%5Cnhash.put(%5C%22Aaron%5C%22%2C%20%5C%22aaron%40email.com%5C%22)%5Cnhash.put(%5C%22Donnie%5C%22%2C%20%5C%22donnie%40email.com%5C%22)%5Cnhash.put(%5C%22Ana%5C%22%2C%20%5C%22ana%40email.com%5C%22)%5Cnhash.put(%5C%22Jamie%5C%22%2C%20%5C%22jamie%40email.com%5C%22)%5Cnhash.put(%5C%22Sue%5C%22%2C%20%5C%22sue%40email.com%5C%22)%5Cnhash.put(%5C%22Mindy%5C%22%2C%20%5C%22mindy%40email.com%5C%22)%5Cnhash.put(%5C%22Paul%5C%22%2C%20%5C%22paul%40email.com%5C%22)%5Cnhash.put(%5C%22Nathan%5C%22%2C%20%5C%22nathan%40email.com%5C%22)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%228a25d3af%22%7D\"></card><p data-lake-id=\"u3cd834a5\" id=\"u3cd834a5\"><br></p><p data-lake-id=\"u05417d56\" id=\"u05417d56\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368595446-4d8db671-fdd7-42d2-9815-827750bba9f4.png%23clientId%3Duab33f410-eee0-4%26from%3Dpaste%26id%3Du5cd5ea63%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D200%26originWidth%3D217%26originalType%3Durl%26ratio%3D1%26size%3D12348%26status%3Ddone%26style%3Dnone%26taskId%3Du208e6fcd-a64f-42f2-b685-9bd3444dd97%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A217%2C%22originHeight%22%3A200%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%232d2d25%22%2C%22id%22%3A%22IzjET%22%7D\"></card><span data-lake-id=\"uc1ee5729\" id=\"uc1ee5729\"><br /></span><span data-lake-id=\"uf2931900\" id=\"uf2931900\">从结果中可以看到，尽管有些 keys 不同，但是通过我们提供的散列函数居然得到了相同的 hash 值，这显然违背了我们的设计原则。在哈希表中，这个叫做散列冲突，为了得到一个可靠的哈希表，我们必须尽可能地避免散列冲突。那如何避免这种冲突呢？这里介绍两种解决冲突的方法：分离链接和线性探查。</span></p><p data-lake-id=\"uebdfafa0\" id=\"uebdfafa0\"><br></p><h4 data-lake-id=\"2afa3875\" id=\"2afa3875\"><span data-lake-id=\"u7677633c\" id=\"u7677633c\">分离链接</span></h4><p data-lake-id=\"ua50af096\" id=\"ua50af096\"><br></p><p data-lake-id=\"ub436d0ca\" id=\"ub436d0ca\"><span data-lake-id=\"ub094fa69\" id=\"ub094fa69\">所谓分离链接，就是将原本存储在哈希表中的值改成链表，这样在哈希表的同一个位置上，就可以存储多个不同的值。链表中的每一个元素，同时存储了 key 和 value。示意图如下：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368603606-2893c36d-392a-498a-9715-0a6483b9d997.png%23clientId%3Duab33f410-eee0-4%26from%3Dpaste%26id%3Du9dd6e4e0%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D624%26originWidth%3D817%26originalType%3Durl%26ratio%3D1%26size%3D44528%26status%3Ddone%26style%3Dnone%26taskId%3Dud2372fb7-ef28-4f56-a190-8dc43b1853e%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A817%2C%22originHeight%22%3A624%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f2f2f2%22%2C%22id%22%3A%22CK3Vn%22%7D\"></card><span data-lake-id=\"u4ce7f561\" id=\"u4ce7f561\"><br /></span><span data-lake-id=\"u9844809a\" id=\"u9844809a\">这样，当不同的 key 通过散列函数计算出相同的 hash 值时，我们只需要找到数组中对应的位置，然后往其中的链表添加新的节点即可，从而有效地避免了散列冲突。为了实现这种数据结构，我们需要定义一个新的辅助类 ValuePair，它的内容如下：</span></p><p data-lake-id=\"u69583c1c\" id=\"u69583c1c\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20ValuePair%20%3D%20function%20(key%2C%20value)%20%7B%5Cn%20%20%20%20this.key%20%3D%20key%5Cn%20%20%20%20this.value%20%3D%20value%5Cn%5Cn%20%20%20%20this.toString%20%3D%20function%20()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E6%8F%90%E4%BE%9BtoString()%E6%96%B9%E6%B3%95%E4%BB%A5%E6%96%B9%E4%BE%BF%E6%88%91%E4%BB%AC%E6%B5%8B%E8%AF%95%5Cn%20%20%20%20%20%20%20%20return%20%60%5B%24%7Bthis.key%7D%20-%20%24%7Bthis.value%7D%5D%60%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%223e132302%22%7D\"></card><p data-lake-id=\"ue14c050f\" id=\"ue14c050f\"><br></p><p data-lake-id=\"u7c3301df\" id=\"u7c3301df\"><span data-lake-id=\"u42d087e4\" id=\"u42d087e4\">ValuePair 类具有两个属性，key 和 value，用来保存我们要存入到散列表中的元素的键值对。toString()方法在这里不是必须的，该方法是为了后面我们方便测试。<br /></span><span data-lake-id=\"u1d7a2486\" id=\"u1d7a2486\">新的采用了分离链接的 HashTableSeparateChaining 类可以继承自前面的 HashTable 类，完整的代码如下：</span></p><p data-lake-id=\"u0c6e738c\" id=\"u0c6e738c\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20HashTableSeparateChaining%20extends%20HashTable%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20super()%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20put(key%2C%20value)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20position%20%3D%20this.loseloseHashCode(key)%5Cn%5Cn%20%20%20%20%20%20%20%20if%20(this.table%5Bposition%5D%20%3D%3D%3D%20undefined)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.table%5Bposition%5D%20%3D%20new%20LinkedList()%20%2F%2F%20%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%8C%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5LinkedList%E7%B1%BB%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20this.table%5Bposition%5D.append(new%20ValuePair(key%2C%20value))%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20get(key)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20position%20%3D%20this.loseloseHashCode(key)%5Cn%5Cn%20%20%20%20%20%20%20%20if%20(this.table%5Bposition%5D%20!%3D%3D%20undefined)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20current%20%3D%20this.table%5Bposition%5D.getHead()%5Cn%20%20%20%20%20%20%20%20%20%20%20%20while%20(current)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(current.element.key%20%3D%3D%3D%20key)%20return%20current.element.value%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20current%20%3D%20current.next%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20undefined%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20remove(key)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20position%20%3D%20this.loseloseHashCode(key)%5Cn%20%20%20%20%20%20%20%20let%20hash%20%3D%20this.table%5Bposition%5D%5Cn%5Cn%20%20%20%20%20%20%20%20if%20(hash%20!%3D%3D%20undefined)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20current%20%3D%20hash.getHead()%5Cn%20%20%20%20%20%20%20%20%20%20%20%20while%20(current)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(current.element.key%20%3D%3D%3D%20key)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20hash.remove(current.element)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(hash.isEmpty())%20this.table%5Bposition%5D%20%3D%20undefined%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20true%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20current%20%3D%20current.next%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20return%20false%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20size()%20%7B%5Cn%20%20%20%20%20%20%20%20let%20count%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.table.forEach(item%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(item%20!%3D%3D%20undefined)%20count%20%2B%3D%20item.size()%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%20%20%20%20return%20count%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20toString()%20%7B%5Cn%20%20%20%20%20%20%20%20let%20objString%20%3D%20%5C%22%5C%22%5Cn%20%20%20%20%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20this.table.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20ci%20%3D%20this.table%5Bi%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(ci%20%3D%3D%3D%20undefined)%20continue%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20objString%20%2B%3D%20%60%24%7Bi%7D%3A%20%60%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20current%20%3D%20ci.getHead()%5Cn%20%20%20%20%20%20%20%20%20%20%20%20while%20(current)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20objString%20%2B%3D%20current.element.toString()%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20current%20%3D%20current.next%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(current)%20objString%20%2B%3D%20%5C%22%2C%20%5C%22%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20objString%20%2B%3D%20%5C%22%5C%5Cr%5C%5Cn%5C%22%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20objString%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2262701b61%22%7D\"></card><p data-lake-id=\"u9a7bcdb5\" id=\"u9a7bcdb5\"><br></p><p data-lake-id=\"ufc2f9ed1\" id=\"ufc2f9ed1\"><span data-lake-id=\"ue7bce571\" id=\"ue7bce571\">其中的 LinkedList 类为单向链表，具体内容可以查看</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" data-lake-id=\"u9550cf7e\" id=\"u9550cf7e\"><span data-lake-id=\"u0b09747f\" id=\"u0b09747f\">《JavaScript 数据结构——链表的实现与应用》</span></a><span data-lake-id=\"u218a1511\" id=\"u218a1511\">。注意，现在 hash 数组中的每一个元素都是一个单向链表，单向链表的所有操作我们可以借助于 LinkedList 类来完成。我们重写了 size()方法，因为现在要计算的是数组中所有链表的长度总和。<br /></span><span data-lake-id=\"u8e111454\" id=\"u8e111454\">下面是 HashTableSeparateChaining 类的测试用例及结果：</span></p><p data-lake-id=\"ub0a4ecdd\" id=\"ub0a4ecdd\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20hash%20%3D%20new%20HashTableSeparateChaining()%5Cn%5Cnhash.put(%5C%22Gandalf%5C%22%2C%20%5C%22gandalf%40email.com%5C%22)%5Cnhash.put(%5C%22John%5C%22%2C%20%5C%22john%40email.com%5C%22)%5Cnhash.put(%5C%22Tyrion%5C%22%2C%20%5C%22tyrion%40email.com%5C%22)%5Cnhash.put(%5C%22Aaron%5C%22%2C%20%5C%22aaron%40email.com%5C%22)%5Cnhash.put(%5C%22Donnie%5C%22%2C%20%5C%22donnie%40email.com%5C%22)%5Cnhash.put(%5C%22Ana%5C%22%2C%20%5C%22ana%40email.com%5C%22)%5Cnhash.put(%5C%22Jamie%5C%22%2C%20%5C%22jamie%40email.com%5C%22)%5Cnhash.put(%5C%22Sue%5C%22%2C%20%5C%22sue%40email.com%5C%22)%5Cnhash.put(%5C%22Mindy%5C%22%2C%20%5C%22mindy%40email.com%5C%22)%5Cnhash.put(%5C%22Paul%5C%22%2C%20%5C%22paul%40email.com%5C%22)%5Cnhash.put(%5C%22Nathan%5C%22%2C%20%5C%22nathan%40email.com%5C%22)%5Cn%5Cnconsole.log(hash.toString())%5Cnconsole.log(%60size%3A%20%24%7Bhash.size()%7D%60)%5Cnconsole.log(hash.get(%5C%22John%5C%22))%5Cn%5Cnconsole.log(hash.remove(%5C%22Ana%5C%22))%5Cnconsole.log(hash.remove(%5C%22John%5C%22))%5Cnconsole.log(hash.toString())%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2207ce9f22%22%7D\"></card><p data-lake-id=\"u396f083b\" id=\"u396f083b\"><br></p><p data-lake-id=\"u7f03c632\" id=\"u7f03c632\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368646270-fbd61d17-9e27-478b-a83a-70ed90b6bce8.png%23clientId%3Duab33f410-eee0-4%26from%3Dpaste%26id%3Du2d23b493%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D340%26originWidth%3D552%26originalType%3Durl%26ratio%3D1%26size%3D61098%26status%3Ddone%26style%3Dnone%26taskId%3Du6c6a702c-708f-404b-9d42-0bc24edd1af%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A552%2C%22originHeight%22%3A340%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%232f2f27%22%2C%22id%22%3A%22FOP77%22%7D\"></card><span data-lake-id=\"ua38e37c5\" id=\"ua38e37c5\"><br /></span><span data-lake-id=\"u40264d17\" id=\"u40264d17\">可以看到，结果和上面示意图上给出的是一致的，size()、remove()和 get()方法的执行结果也符合预期。</span></p><p data-lake-id=\"u81626c4a\" id=\"u81626c4a\"><br></p><h4 data-lake-id=\"c112812d\" id=\"c112812d\"><span data-lake-id=\"u994dfebb\" id=\"u994dfebb\">线性探查</span></h4><p data-lake-id=\"u3e872e71\" id=\"u3e872e71\"><br></p><p data-lake-id=\"u38997bfd\" id=\"u38997bfd\"><span data-lake-id=\"u37b52af1\" id=\"u37b52af1\">避免散列冲突的另一种方法是线性探查。当向哈希数组中添加某一个新元素时，如果该位置上已经有数据了，就继续尝试下一个位置，直到对应的位置上没有数据时，就在该位置上添加数据。我们将上面的例子改成线性探查的方式，存储结果如下图所示：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368655095-ed011a25-7207-4935-b32f-0d16faf4e827.png%23clientId%3Duab33f410-eee0-4%26from%3Dpaste%26id%3Du51c68182%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D670%26originWidth%3D456%26originalType%3Durl%26ratio%3D1%26size%3D42116%26status%3Ddone%26style%3Dnone%26taskId%3Duba6b97a5-7003-4655-9772-cec30f3a5ea%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A456%2C%22originHeight%22%3A670%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23ebebeb%22%2C%22id%22%3A%22ynYbg%22%7D\"></card><span data-lake-id=\"uc50db7c7\" id=\"uc50db7c7\"><br /></span><span data-lake-id=\"u2e0fa009\" id=\"u2e0fa009\">现在我们不需要单向链表 LinkedList 类了，但是 ValuePair 类仍然是需要的。同样的，我们的 HashTableLinearProbing 类继承自 HashTable 类，完整的代码如下：</span></p><p data-lake-id=\"u5301a5d8\" id=\"u5301a5d8\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20HashTableLinearProbing%20extends%20HashTable%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20super()%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20put(key%2C%20value)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20position%20%3D%20this.loseloseHashCode(key)%5Cn%5Cn%20%20%20%20%20%20%20%20if%20(this.table%5Bposition%5D%20%3D%3D%3D%20undefined)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.table%5Bposition%5D%20%3D%20new%20ValuePair(key%2C%20value)%5Cn%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20index%20%3D%20position%20%2B%201%5Cn%20%20%20%20%20%20%20%20%20%20%20%20while%20(this.table%5Bindex%5D%20!%3D%3D%20undefined)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20index%2B%2B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.table%5Bindex%5D%20%3D%20new%20ValuePair(key%2C%20value)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20get(key)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20position%20%3D%20this.loseloseHashCode(key)%5Cn%5Cn%20%20%20%20%20%20%20%20if%20(this.table%5Bposition%5D%20!%3D%3D%20undefined)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(this.table%5Bposition%5D.key%20%3D%3D%3D%20key)%20return%20this.table%5Bposition%5D.value%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20index%20%3D%20position%20%2B%201%5Cn%20%20%20%20%20%20%20%20%20%20%20%20while%20(this.table%5Bindex%5D%20!%3D%3D%20undefined%20%26%26%20this.table%5Bindex%5D.key%20!%3D%3D%20key)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20index%2B%2B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20this.table%5Bindex%5D.value%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20undefined%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20remove(key)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20position%20%3D%20this.loseloseHashCode(key)%5Cn%5Cn%20%20%20%20%20%20%20%20if%20(this.table%5Bposition%5D%20!%3D%3D%20undefined)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(this.table%5Bposition%5D.key%20%3D%3D%3D%20key)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.table%5Bposition%5D%20%3D%20undefined%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20true%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20index%20%3D%20position%20%2B%201%5Cn%20%20%20%20%20%20%20%20%20%20%20%20while%20(this.table%5Bindex%5D%20!%3D%3D%20undefined%20%26%26%20this.table%5Bindex%5D.key%20!%3D%3D%20key)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20index%2B%2B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.table%5Bindex%5D%20%3D%20undefined%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20true%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20false%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20toString()%20%7B%5Cn%20%20%20%20%20%20%20%20let%20objString%20%3D%20%5C%22%5C%22%5Cn%20%20%20%20%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20this.table.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20let%20ci%20%3D%20this.table%5Bi%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(ci%20%3D%3D%3D%20undefined)%20continue%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20objString%20%2B%3D%20%60%24%7Bi%7D%3A%20%24%7Bci%7D%5C%5Cr%5C%5Cn%60%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20return%20objString%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22c06c862c%22%7D\"></card><p data-lake-id=\"u524a57fa\" id=\"u524a57fa\"><br></p><p data-lake-id=\"u18641080\" id=\"u18641080\"><span data-lake-id=\"u3407425c\" id=\"u3407425c\">使用上面和 HashTableSeparateChaining 类相同的测试用例，我们来看看测试结果：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368672669-14fd7f0a-e601-467e-86d9-cedc1477c2de.png%23clientId%3Duab33f410-eee0-4%26from%3Dpaste%26id%3Du808a989f%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D457%26originWidth%3D317%26originalType%3Durl%26ratio%3D1%26size%3D45391%26status%3Ddone%26style%3Dnone%26taskId%3Duafa43c0d-f3b8-4bef-b6f5-0a0671e67e7%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A317%2C%22originHeight%22%3A457%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%232f2f27%22%2C%22id%22%3A%22db7dV%22%7D\"></card><span data-lake-id=\"udd134163\" id=\"udd134163\"><br /></span><span data-lake-id=\"u5b802435\" id=\"u5b802435\">可以和 HashTableSeparateChaining 类的测试结果比较一下，多出来的位置 6、14、17、33，正是 HashTableSeparateChaining 类中每一个链表的剩余部分。get()和 remove()方法也能正常工作，我们不需要重写 size()方法，和基类 HashTable 中一样，hash 数组中每一个位置只保存了一个元素。另一个要注意的地方是，由于 JavaScript 中定义数组时不需要提前给出数组的长度，因此我们可以很容易地利用 JavaScript 语言的这一特性来实现线性探查。在某些编程语言中，数组的定义是必须明确给出长度的，这时我们就需要重新考虑我们的 HashLinearProbing 类的实现了。<br /></span><span data-lake-id=\"u2907cfee\" id=\"u2907cfee\">loseloseHashCode()散列函数并不是一个表现良好的散列函数，正如你所看到的，它会很轻易地产生散列冲突。一个表现良好的散列函数必须能够尽可能低地减少散列冲突，并提高性能。我们可以在网上找一些不同的散列函数的实现方法，下面是一个比 loseloseHashCode()更好的散列函数 djb2HashCode()：</span></p><p data-lake-id=\"u222465fb\" id=\"u222465fb\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22djb2HashCode%20(key)%20%7B%5Cn%20%20%20%20let%20hash%20%3D%205381%3B%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20key.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20hash%20%3D%20hash%20*%2033%20%2B%20key.charCodeAt(i)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20hash%20%25%201013%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22e1f3531c%22%7D\"></card><p data-lake-id=\"uc8f6a2df\" id=\"uc8f6a2df\"><br></p><p data-lake-id=\"ud5ad36de\" id=\"ud5ad36de\"><span data-lake-id=\"u1508a806\" id=\"u1508a806\">我们用相同的测试用例来测试 dj2HashCode()，下面是测试结果：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646368688283-0ecfeac9-87ad-4aad-baeb-b362011cc85b.png%23clientId%3Duab33f410-eee0-4%26from%3Dpaste%26id%3Dueb108685%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D211%26originWidth%3D154%26originalType%3Durl%26ratio%3D1%26size%3D14706%26status%3Ddone%26style%3Dnone%26taskId%3Ducc1b174c-5ba6-4308-9ddf-90d8f294e3d%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A154%2C%22originHeight%22%3A211%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%232f2f27%22%2C%22id%22%3A%22uzgtb%22%7D\"></card><span data-lake-id=\"u8c79b0aa\" id=\"u8c79b0aa\"><br /></span><span data-lake-id=\"u779d354a\" id=\"u779d354a\">这次没有冲突！然而这并不是最好的散列函数，但它是社区最推崇的散列函数之一。</span></p>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 3429,
  "created_at": "2020-08-09T08:03:33.000Z",
  "updated_at": "2023-11-19T17:57:36.000Z",
  "content_updated_at": "2023-11-11T18:08:42.000Z",
  "published_at": "2023-11-11T18:08:42.000Z",
  "first_published_at": "2020-08-09T08:03:33.000Z",
  "book": {
    "id": 24854102,
    "type": "Book",
    "slug": "gm8h7g",
    "name": "算法 algorithm",
    "user_id": 732231,
    "description": "算法基础、leetCode",
    "toc_yml": "- type: META\n  count: 17\n  display_level: all\n  tail_type: UPDATED_AT\n  base_version_id: 372567226\n  published: true\n  max_level: 1\n  last_updated_at: 2023-11-19T18:02:44.264Z\n  version_id: 372567245\n- type: TITLE\n  title: 算法刷题索引\n  uuid: 9iuletCnX8AA1DWl\n  url: ''\n  prev_uuid: ''\n  sibling_uuid: BMR7y68MzsRsLpq6\n  child_uuid: 4IS2N309UG8zzeKG\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: LeetCode 热题 🔥 100\n  uuid: 4IS2N309UG8zzeKG\n  url: im0vt7\n  prev_uuid: 9iuletCnX8AA1DWl\n  sibling_uuid: uioHkKsczkPGgdyr\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67808056\n  level: 1\n  id: 67808056\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 剑指 offer 第二版\n  uuid: uioHkKsczkPGgdyr\n  url: dotw59\n  prev_uuid: 4IS2N309UG8zzeKG\n  sibling_uuid: syezq9xwx3badLKu\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810801\n  level: 1\n  id: 67810801\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: LeetCode 精选 TOP 面试题\n  uuid: syezq9xwx3badLKu\n  url: brcxx5\n  prev_uuid: uioHkKsczkPGgdyr\n  sibling_uuid: PKQxO_4GM33AkW__\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810529\n  level: 1\n  id: 67810529\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 剑指 offer 专项突击版\n  uuid: PKQxO_4GM33AkW__\n  url: mff6ll\n  prev_uuid: syezq9xwx3badLKu\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810920\n  level: 1\n  id: 67810920\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 数据结构\n  uuid: BMR7y68MzsRsLpq6\n  url: ''\n  prev_uuid: 9iuletCnX8AA1DWl\n  sibling_uuid: zvwUUlHnEeEhPJ9v\n  child_uuid: E-fia709YBhQtJrt\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 对象 object\n  uuid: E-fia709YBhQtJrt\n  url: aogq4f\n  prev_uuid: BMR7y68MzsRsLpq6\n  sibling_uuid: D7LcTHUXkpP6SYG4\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432408\n  level: 1\n  id: 11432408\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 数组 array\n  uuid: D7LcTHUXkpP6SYG4\n  url: oq0mk5\n  prev_uuid: E-fia709YBhQtJrt\n  sibling_uuid: LwftOZYaPeqjwhdS\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432407\n  level: 1\n  id: 11432407\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字符串 string\n  uuid: LwftOZYaPeqjwhdS\n  url: sih9mc\n  prev_uuid: D7LcTHUXkpP6SYG4\n  sibling_uuid: dj5FuaOaHSda1AbK\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432412\n  level: 1\n  id: 11432412\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 栈 stack\n  uuid: dj5FuaOaHSda1AbK\n  url: xi2mh9\n  prev_uuid: LwftOZYaPeqjwhdS\n  sibling_uuid: IOag-iKKv87hGhdm\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435979\n  level: 1\n  id: 11435979\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 队列 queue\n  uuid: IOag-iKKv87hGhdm\n  url: hroghz\n  prev_uuid: dj5FuaOaHSda1AbK\n  sibling_uuid: 778WMx0aXLZVUl9p\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435969\n  level: 1\n  id: 11435969\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 链表 Linkist\n  uuid: 778WMx0aXLZVUl9p\n  url: mo7sde\n  prev_uuid: IOag-iKKv87hGhdm\n  sibling_uuid: j9b8vxS9kTz8xa3x\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435962\n  level: 1\n  id: 11435962\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 树 tree\n  uuid: j9b8vxS9kTz8xa3x\n  url: glas5w\n  prev_uuid: 778WMx0aXLZVUl9p\n  sibling_uuid: QARpKzPBR5puFByT\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435974\n  level: 1\n  id: 11435974\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 图 graph\n  uuid: QARpKzPBR5puFByT\n  url: dgduok\n  prev_uuid: j9b8vxS9kTz8xa3x\n  sibling_uuid: kKoPgVQTytiILSgY\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435966\n  level: 1\n  id: 11435966\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 集合 set\n  uuid: kKoPgVQTytiILSgY\n  url: ub10iw\n  prev_uuid: QARpKzPBR5puFByT\n  sibling_uuid: R7qhLVPS4xKQZLD7\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435960\n  level: 1\n  id: 11435960\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字典和散列表 dictionary & hash table\n  uuid: R7qhLVPS4xKQZLD7\n  url: aq5vbp\n  prev_uuid: kKoPgVQTytiILSgY\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435958\n  level: 1\n  id: 11435958\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 动态规划\n  uuid: zvwUUlHnEeEhPJ9v\n  url: mnfkhynksc1h459r\n  prev_uuid: BMR7y68MzsRsLpq6\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147451432\n  level: 0\n  id: 147451432\n  open_window: 1\n  visible: 0\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 16,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-19T18:02:44.299Z",
    "created_at": "2022-02-21T07:49:26.000Z",
    "updated_at": "2023-11-19T18:02:44.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-23T19:11:28.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/gm8h7g",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-23T19:11:28.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 2109666708,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-23T19:11:28.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}