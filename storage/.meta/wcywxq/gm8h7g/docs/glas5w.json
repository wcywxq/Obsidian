{
  "id": 11435974,
  "slug": "glas5w",
  "title": "树 tree",
  "description": "链接在计算机科学中，树是一种十分重要的数据结构。树被描述为一种分层数据抽象模型，常用来描述数据间的层级关系和组织结构。树也是一种非顺序的数据结构。下图展示了树的定义：在介绍如何用 JavaScript 实现树之前，我们先介绍一些和树相关的术语。如上图所示，一棵完整的树包含一个位于树顶部的节点，...",
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1646366269569-5914f76c-55cf-479d-9682-fde5a1aff15a.png",
  "user_id": 732231,
  "book_id": 24854102,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><p id=\"u1b2cfe0c\" class=\"ne-p\"><a href=\"https://www.cnblogs.com/jaxu/p/11309385.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11309385.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">链接</span></a><span class=\"ne-text\"><br /></span></p><p id=\"u71efe663\" class=\"ne-p\"><br></p><p id=\"u48a6aeba\" class=\"ne-p\"><span class=\"ne-text\">在计算机科学中，树是一种十分重要的数据结构。树被描述为一种分层数据抽象模型，常用来描述数据间的层级关系和组织结构。树也是一种非顺序的数据结构。下图展示了树的定义：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366269569-5914f76c-55cf-479d-9682-fde5a1aff15a.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u04cbac7c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=543&amp;originWidth=772&amp;originalType=url&amp;ratio=1&amp;size=45229&amp;status=done&amp;style=none&amp;taskId=u0e3c43a3-4e6f-4650-a290-bab310866ca\" width=\"772\" id=\"rEjjS\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在介绍如何用 JavaScript 实现树之前，我们先介绍一些和树相关的术语。<br /></span><span class=\"ne-text\">如上图所示，一棵完整的树包含一个位于树顶部的节点，称之为根节点（11），它没有父节点。树中的每一个元素都叫做一个节点，节点分为内部节点（图中显示为黄色的节点）和外部节点（图中显示为灰色的节点），至少有一个子节点的节点称为内部节点，没有子元素的节点称为外部节点或叶子节点。一个节点可以有祖先（根节点除外）和后代。子树由节点本身和它的后代组成，如上图中三角虚框中的部分就是一棵子树。节点拥有的子树的个数称之为节点的度，如上图中除叶子节点的度为 0 外，其余节点的度都为 2。从根节点开始，根为第 1 层，第一级子节点为第 2 层，第二级子节点为第 3 层，以此类推。树的高度（深度）由树中节点的最大层级决定（上图中树的高度为 4）。<br /></span><span class=\"ne-text\">在一棵树中，具有相同父节点的一组节点称为兄弟节点，如上图中的 3 和 6、5 和 9 等都是兄弟节点。</span></p><p id=\"ue1f21414\" class=\"ne-p\"><br></p><h3 id=\"8178ad6f\"><span class=\"ne-text\">二叉树</span></h3><p id=\"u8f792453\" class=\"ne-p\"><br></p><p id=\"u4de83d74\" class=\"ne-p\"><span class=\"ne-text\">二叉树中的节点最多只能有两个子节点，一个是左子节点，一个是右子节点。左右子节点的顺序不能颠倒。因此，二叉树中不存在度大于 2 的节点。<br /></span><span class=\"ne-text\">二叉搜索树（BST——Binary Search Tree）是二叉树的一种，它规定在左子节点上存储小（比父节点）的值，在右子节点上（比父节点）存储大（或等于）的值。上图就是一个二叉搜索树。<br /></span><span class=\"ne-text\">下面我们重点来看一下二叉搜索树的实现。<br /></span><span class=\"ne-text\">根据二叉树的描述，一个节点最多只有两个子节点，我们可以使用</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——链表的实现与应用》</span></a><span class=\"ne-text\">一文中的双向链表来实现二叉搜索树中的每一个节点。下面是二叉搜索树的数据结构示意图：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366269506-0f79bff0-9217-49a5-889b-39da82b1ef61.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u73eea400&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=337&amp;originWidth=650&amp;originalType=url&amp;ratio=1&amp;size=21031&amp;status=done&amp;style=none&amp;taskId=u7e9d9fa0-fa0b-4795-a4b0-1d49a8ad7f1\" width=\"650\" id=\"rNgNh\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">以下是我们要实现的 BinarySearchTree 类的骨架部分：<br /></span><span class=\"ne-text\"></span></p><p id=\"ue60b4729\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"19ae2f58\" class=\"ne-codeblock language-javascript\">class BinarySearchTree {\n    constructor() {\n        this.root = null\n    }\n\n    // 向树中插入一个节点\n    insert(key) {}\n\n    // 在树中查找一个节点\n    search(key) {}\n\n    // 通过中序遍历方式遍历树中的所有节点\n    inOrderTraverse() {}\n\n    // 通过先序遍历方式遍历树中的所有节点\n    preOrderTraverse() {}\n\n    // 通过后序遍历方式遍历树中的所有节点\n    postOrderTraverse() {}\n\n    // 返回树中的最小节点\n    min() {}\n\n    // 返回树中的最大节点\n    max() {}\n\n    // 从树中移除一个节点\n    remove(key) {}\n}</pre><p id=\"u2f0c439d\" class=\"ne-p\"><br></p><p id=\"uf0750dae\" class=\"ne-p\"><span class=\"ne-text\">先来看看向树中添加一个节点。我们借用</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——链表的实现与应用》</span></a><span class=\"ne-text\">一文中的双向链表 DoubleLinkedList 类来模拟树中的节点，在 DoubleLinkedList 类中，每一个节点有三个属性：element、next 和 prev。我们在这里用 element 表示树中节点的 key，用 next 表示树中节点的右子节点（right），用 prev 表示树中节点的左子节点（left）。</span></p><p id=\"u8a9f0fb8\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"b651088a\" class=\"ne-codeblock language-javascript\">insert (key) {\n    let newNode = new Node(key);\n\n    if (this.root === null) this.root = newNode;\n    else insertNode(this.root, newNode);\n}</pre><p id=\"u415432ad\" class=\"ne-p\"><br></p><p id=\"u78703efe\" class=\"ne-p\"><span class=\"ne-text\">当树的 root 为 null 时，表示树为空，这时直接将新添加的节点作为树的根节点。否则，我们需要借助于私有函数 insertNode()来完成节点的添加。在 insertNode()函数中，我们需要根据新添加节点的 key 的大小来递归查找树的左侧子节点或者右侧子节点，因为根据我们的二叉搜索树的定义，值小的节点永远保存在左侧子节点上，值大的节点（包括值相等的情况）永远保存在右侧子节点上。下面是 insertNode()函数的实现代码：</span></p><p id=\"u59530ec7\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"263f076f\" class=\"ne-codeblock language-javascript\">let insertNode = function (node, newNode) {\n    if (newNode.element &lt; node.element) {\n        if (node.prev === null) node.prev = newNode\n        else insertNode(node.prev, newNode)\n    } else {\n        if (node.next === null) node.next = newNode\n        else insertNode(node.next, newNode)\n    }\n}</pre><p id=\"u35a9dcbc\" class=\"ne-p\"><br></p><p id=\"u3ea26f25\" class=\"ne-p\"><span class=\"ne-text\">所有新节点只能作为叶子节点被添加到树中。在本文一开始给出的树的结构图中，如果要添加节点 2，对应的操作步骤如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366466710-c235e8f1-3278-4e15-90ce-3a2194ab6f93.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u0f0e6dc0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=472&amp;originWidth=657&amp;originalType=url&amp;ratio=1&amp;size=36604&amp;status=done&amp;style=none&amp;taskId=u62e15592-6def-4696-9af8-54bd87ce215\" width=\"657\" id=\"v6cPo\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">我们传入树的根节点，依次进行递归，找到对应的叶子节点，然后修改节点的 prev（左子节点）或 next（右子节点）指针，使其指向新添加的节点。在上例中，如果要添加节点 4，它对应的位置应该是节点 3 的右子节点，因为 4 比 3 大。如果要添加节点 21，对应的位置应该是节点 25 的左子节点......<br /></span><span class=\"ne-text\">下面我们来看看树的三种遍历方式：</span></p><p id=\"uc3a25cf6\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ucc1ea31c\" data-lake-index-type=\"0\"><span class=\"ne-text\">前序遍历（NLR——Preorder Traversal）也叫先序遍历，访问根节点的操作发生在遍历其左右子树之前。</span></li><li id=\"uc72ff6bb\" data-lake-index-type=\"0\"><span class=\"ne-text\">中序遍历（LNR——Inorder Traversal），访问根节点的操作发生在遍历其左右子树之间。</span></li><li id=\"ue2d6d758\" data-lake-index-type=\"0\"><span class=\"ne-text\">后序遍历（LRN——Postorder Traversal），访问根节点的操作发生在遍历其左右子树之后。</span></li></ul><p id=\"uec3358a5\" class=\"ne-p\"><br></p><p id=\"u800c81d5\" class=\"ne-p\"><span class=\"ne-text\">下面的三个方法对应树的三种遍历方式：</span></p><p id=\"u25890f44\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"29b19ab6\" class=\"ne-codeblock language-javascript\">// 前序遍历\nlet preOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        callback(node.element)\n        preOrderTraverseNode(node.prev, callback)\n        preOrderTraverseNode(node.next, callback)\n    }\n}\n\n// 中序遍历\nlet inOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        inOrderTraverseNode(node.prev, callback)\n        callback(node.element)\n        inOrderTraverseNode(node.next, callback)\n    }\n}\n\n// 后续遍历\nlet postOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        postOrderTraverseNode(node.prev, callback)\n        postOrderTraverseNode(node.next, callback)\n        callback(node.element)\n    }\n}</pre><p id=\"u7a023ae2\" class=\"ne-p\"><br></p><p id=\"u40002bff\" class=\"ne-p\"><span class=\"ne-text\">可以看到，这三个函数的内容很相似，只是调整了左右子树和根节点的遍历顺序。这里的 callback 是一个回调函数，可以传入任何你想执行的函数，这里我们传入的函数内容是打印树的节点的 key 值。我们将 BinarySearchTree 类的这三个遍历方法的内容补充完整：</span></p><p id=\"u44f8333a\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"b742e38b\" class=\"ne-codeblock language-javascript\">preOrderTraverse (callback) {\n    preOrderTraverseNode(this.root, callback);\n}\n\ninOrderTraverse (callback) {\n    inOrderTraverseNode(this.root, callback);\n}\n\npostOrderTraverse (callback) {\n    postOrderTraverseNode(this.root, callback);\n}</pre><p id=\"u44572730\" class=\"ne-p\"><br></p><p id=\"u0510d4e7\" class=\"ne-p\"><span class=\"ne-text\">为了构建本文一开始的那棵树，我们执行下面的代码，然后测试 preOrderTraverse()方法：</span></p><p id=\"u3fe6e1d3\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3c42dcaa\" class=\"ne-codeblock language-javascript\">let tree = new BinarySearchTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(13)\ntree.insert(20)\ntree.insert(3)\ntree.insert(6)\ntree.insert(8)\ntree.insert(10)\ntree.insert(12)\ntree.insert(14)\ntree.insert(18)\ntree.insert(25)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u22112e7b\" class=\"ne-p\"><br></p><p id=\"uab8de858\" class=\"ne-p\"><span class=\"ne-text\">注意节点插入的顺序，顺序不同，你可能会得到不一样的树。preOrderTraverse()方法采用 ES6 的语法传入了一个匿名函数作为参数 callback 的值，这个匿名函数的主要作用就是打印树中节点的 key 值，可以对照上面三个遍历树节点的函数中的 callback(node.element)语句，这里的 callback 就是这个匿名函数，node.element 就是节点的 key 值（还记得前面我们说过，借用双向链表类 DoubleLinkedList 来模拟树的节点吗？）下面是前序遍历的执行结果：</span></p><p id=\"uf0a833a5\" class=\"ne-p\"><br></p><pre data-language=\"plain\" id=\"d13cccaf\" class=\"ne-codeblock language-plain\">11\n7\n5\n3\n6\n9\n8\n10\n15\n13\n12\n14\n20\n18\n25</pre><p id=\"uce4d13aa\" class=\"ne-p\"><br></p><p id=\"u06b21e2a\" class=\"ne-p\"><span class=\"ne-text\">我们参照前序遍历的定义，借住下面的示意图来理解整个遍历过程：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366532033-7670baed-24f5-495d-b7c2-1163e92165e7.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=uc206c787&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=429&amp;originWidth=577&amp;originalType=url&amp;ratio=1&amp;size=37165&amp;status=done&amp;style=none&amp;taskId=u162713c1-346a-4dad-93db-99c316289d6\" width=\"577\" id=\"ttKwe\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在前序遍历函数 preOrderTraverseNode()中，先执行 callback(node.element)，然后再依次递归左子树和右子树。我们将树的根节点作为第一个节点传入，首先打印的就是根节点 11，然后开始遍历左子树，这将依次打印左子树中的所有左子节点，依次是 7、5、3。当节点 3 的 prev 为 null 时，递归返回，继续查找节点 3 的右子节点，此时节点 3 的 next 值也为 null，于是继续向上返回到节点 5，开始遍历节点 5 的右子节点，于是打印节点 6......最终所有的节点就按照这个递归顺序进行遍历。<br /></span><span class=\"ne-text\">然后我们再来看看中序遍历的情况。</span></p><p id=\"u525da69f\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"018cbef7\" class=\"ne-codeblock language-javascript\">tree.inOrderTraverse(value =&gt; console.log(value))</pre><p id=\"uf2a78406\" class=\"ne-p\"><br></p><pre data-language=\"plain\" id=\"9b1fbd21\" class=\"ne-codeblock language-plain\">3\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n18\n20\n25</pre><p id=\"u60fa605a\" class=\"ne-p\"><br></p><p id=\"u7723171f\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366564412-9c53be47-814a-4b8b-a7f4-d6a615420a08.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u822fc92d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=378&amp;originWidth=576&amp;originalType=url&amp;ratio=1&amp;size=41002&amp;status=done&amp;style=none&amp;taskId=uf10780f2-9708-405c-827f-7313c533553\" width=\"576\" id=\"giB5a\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在中序遍历函数 inOrderTraverseNode()中，先递归左子树，然后执行 callback(node.element)，最后再递归右子树。同样的，我们将根节点作为第一个节点传入，递归到左子树的最后一个左子节点 3，由于节点 3 的 prev 为 null，所以递归返回，打印节点 3，然后继续查找节点 3 的右子节点，节点 3 的 next 值也为 null，递归返回到上一层节点 5，开始打印节点 5，之后再查找节点 5 的右子节点......最终整棵树按照这个顺序完成遍历。<br /></span><span class=\"ne-text\">最后再来看看后序遍历的情况。</span></p><p id=\"u54849225\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d0cdfb98\" class=\"ne-codeblock language-javascript\">tree.postOrderTraverse(value =&gt; console.log(value))</pre><p id=\"ube957c6b\" class=\"ne-p\"><br></p><pre data-language=\"plain\" id=\"a262629b\" class=\"ne-codeblock language-plain\">3\n6\n5\n8\n10\n9\n7\n12\n14\n13\n18\n25\n20\n15\n11</pre><p id=\"ud1b927c6\" class=\"ne-p\"><br></p><p id=\"u9c589b2d\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366587593-3765828a-4e1f-4317-8d89-97bd9be4dd05.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u8098666a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=368&amp;originWidth=569&amp;originalType=url&amp;ratio=1&amp;size=37799&amp;status=done&amp;style=none&amp;taskId=u1d6e4036-f261-4e57-a9f0-ad3cde9a25c\" width=\"569\" id=\"uaJXG\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在后序遍历函数 postOrderTraverseNode()中，先递归左子树，然后再递归右子树，最后执行 callback(node.element)。同样的，我们将根节点作为第一个节点传入，递归到左子树的最后一个左子节点 3，由于节点 3 的 prev 为 null，所以递归返回，此时继续查找节点 3 的右子节点，节点 3 的 next 值也为 null，递归返回并打印节点 3，之后递归返回到上一层节点 5，开始查找节点 5 的右子节点，节点 5 的右子节点是节点 6，由于节点 6 是叶子节点，所以直接打印节点 6，然后递归返回并打印节点 5。之后递归再向上返回到节点 7 并递归节点 7 的右子节点......按照这个顺序最终完成对整棵树的遍历。<br /></span><span class=\"ne-text\">接下来我们再来看看对树的搜索。有三种要经常执行的搜索方式：</span></p><p id=\"u998fa5f9\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u0caa0e6a\" data-lake-index-type=\"0\"><span class=\"ne-text\">搜索树中的最小值</span></li><li id=\"uf31666a1\" data-lake-index-type=\"0\"><span class=\"ne-text\">搜索树中的最大值</span></li><li id=\"u79c99c43\" data-lake-index-type=\"0\"><span class=\"ne-text\">搜索树中的特定值</span></li></ul><p id=\"u0e292cb9\" class=\"ne-p\"><br></p><p id=\"u7b306e85\" class=\"ne-p\"><span class=\"ne-text\">搜索树中的最小值和最大值比较简单，由于我们的二叉搜索树规定了值小的节点永远在左子树（左子节点）中，值大（或相等）的节点永远在右子树（右子节点）中，所以，搜索最大值我们只需要递归查找树的右子树直到叶子节点，就能找到值最大的节点。搜索最小值只需要递归查找树的左子树直到叶子节点，就能找到值最小的节点。下面是这两个函数的实现：</span></p><p id=\"ua7ebccb2\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"deb27f8f\" class=\"ne-codeblock language-javascript\">let minNode = function (node) {\n    if (node === null) return null\n\n    while (node &amp;&amp; node.prev !== null) {\n        node = node.prev\n    }\n    return node\n}\n\nlet maxNode = function (node) {\n    if (node === null) return null\n\n    while (node &amp;&amp; node.next !== null) {\n        node = node.next\n    }\n    return node\n}</pre><p id=\"u4666f23a\" class=\"ne-p\"><br></p><p id=\"u95db9919\" class=\"ne-p\"><span class=\"ne-text\">第三种方式是搜索特定的值，我们需要比较要搜索的值与当前节点的值，如果要搜索的值小于当前节点的值，则从当前节点开始递归查找左子数（左子节点）。如果要搜索的值大于当前节点的值，则从当前节点开始递归查找右子树（右子节点）。按照这个逻辑，我们的 searchNode()函数实现如下：</span></p><p id=\"u367532b7\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"687ff764\" class=\"ne-codeblock language-javascript\">let searchNode = function (node, key) {\n    if (node === null) return null\n\n    if (key &lt; node.element) return searchNode(node.prev, key)\n    else if (key &gt; node.element) return searchNode(node.next, key)\n    else return node\n}</pre><p id=\"ucab2a362\" class=\"ne-p\"><br></p><p id=\"uedfdfbab\" class=\"ne-p\"><span class=\"ne-text\">如果找到了对应的节点，就返回该节点，否则就返回 null。我们将 BinarySearchTree 类的这三个搜索方法的内容补充完整：</span></p><p id=\"udf150379\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"926b0f96\" class=\"ne-codeblock language-javascript\">search (key) {\n    return searchNode(this.root, key);\n}\n\nmin () {\n    return minNode(this.root);\n}\n\nmax () {\n    return maxNode(this.root);\n}</pre><p id=\"ub714861a\" class=\"ne-p\"><br></p><p id=\"ub0dec46e\" class=\"ne-p\"><span class=\"ne-text\">下面是一些测试用例及结果：</span></p><p id=\"udb0ce19d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d8119ee6\" class=\"ne-codeblock language-javascript\">console.log(tree.min().element) // 3\nconsole.log(tree.max().element) // 25\nconsole.log(tree.search(1) ? &quot;Key 1 found.&quot; : &quot;Key 1 not found.&quot;) // Key 1 not found.\nconsole.log(tree.search(8) ? &quot;Key 8 found.&quot; : &quot;Key 8 not found.&quot;) // Key 8 found.</pre><p id=\"u35f4c58f\" class=\"ne-p\"><br></p><p id=\"u1414c6fa\" class=\"ne-p\"><span class=\"ne-text\">让我们来看一下 search()方法的执行过程是怎样的。<br /></span><span class=\"ne-text\"></span></p><p id=\"ud1109014\" class=\"ne-p\"><br></p><p id=\"u81aedb98\" class=\"ne-p\"><span class=\"ne-text\">搜索 key=1 的节点，首先我们传入树的根节点和 key=1，由于 1 小于根节点的值 11，递归查找根节点的左子节点 7，1&lt;7，继续查找节点 7 的左子节点，直到找到叶子节点 3，1 仍然小于 3，但是节点 3 没有左子节点了，所以返回 false，整个递归开始向上返回，最终返回的结果是 false，表示树中没有 key=1 的节点。<br /></span><span class=\"ne-text\"></span></p><p id=\"u9c056d49\" class=\"ne-p\"><br></p><p id=\"u334b04e1\" class=\"ne-p\"><span class=\"ne-text\">相应地，对于搜索 key=8 的节点，也是先遍历根节点的左子节点 7，由于 8&gt;7，所以会遍历节点 7 的右子节点，找到节点 9，8&lt;9，遍历节点 9 的左子节点，此时找到节点 9 的左子节点正好是 8，所以返回 true，然后整个递归向上返回，最终的返回结果就是 true，表示树中找到了 key=8 的节点。<br /></span><span class=\"ne-text\"></span></p><p id=\"ub6fa1d7d\" class=\"ne-p\"><br></p><p id=\"uf6641618\" class=\"ne-p\"><span class=\"ne-text\">最后我们再来看一下从树中移除一个节点的过程，这个过程要稍微复杂一些。先来看看删除树节点的函数 removeNode()的代码，稍后我们再来详细讲解整个执行过程。<br /></span><span class=\"ne-text\"></span></p><p id=\"u059c59a1\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ac861dc1\" class=\"ne-codeblock language-javascript\">let removeNode = function (node, key) {\n    if (node === null) return null\n\n    if (key &lt; node.element) {\n        node.prev = removeNode(node.prev, key)\n        return node\n    } else if (key &gt; node.element) {\n        node.next = removeNode(node.next, key)\n        return node\n    } else {\n        // 第一种情况：一个叶子节点（没有子节点）\n        if (node.prev === null &amp;&amp; node.next === null) {\n            node = null\n            return node\n        }\n        // 第二种情况：只包含一个子节点\n        if (node.prev === null) {\n            node = node.next\n            return node\n        } else if (node.next === null) {\n            node = node.prev\n            return node\n        }\n\n        // 第三种情况：有两个子节点\n        let aux = minNode(node.next)\n        node.element = aux.element\n        node.next = removeNode(node.next, aux.element)\n        return node\n    }\n}</pre><p id=\"u86c5a928\" class=\"ne-p\"><br></p><p id=\"ua141e092\" class=\"ne-p\"><span class=\"ne-text\">首先要找到树中待删除的节点，这需要进行递归遍历，从根节点开始，如果 key 值小于当前节点的值，则遍历左子树，如果 key 值大于当前节点的值，则遍历右子树。注意，在递归遍历的过程中，我们将 node（这里的 node 传入的是树的根节点）的 prev 指针或 next 指针逐级指向下一级节点，然后返回整个 node。当找到要删除的节点后，我们要处理三种情况：</span></p><p id=\"u594b2bc1\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u68c4d68b\" data-lake-index-type=\"0\"><span class=\"ne-text\">该节点为叶子节点（没有子节点）</span></li><li id=\"u6dac2e90\" data-lake-index-type=\"0\"><span class=\"ne-text\">该节点只有一个子节点（左子节点或右子节点）</span></li><li id=\"u3dfccf2d\" data-lake-index-type=\"0\"><span class=\"ne-text\">该节点有两个子节点（左右子节点都存在）</span></li></ul><p id=\"u230407a2\" class=\"ne-p\"><br></p><p id=\"uaf93be6b\" class=\"ne-p\"><span class=\"ne-text\">我们先看第一种情况：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366703868-eb31d55e-1a9f-448a-bee3-e9df964fd888.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u78b542f4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=579&amp;originalType=url&amp;ratio=1&amp;size=31470&amp;status=done&amp;style=none&amp;taskId=u7f79a5a1-4a51-47a0-b012-b2cd584ad79\" width=\"579\" id=\"DOvnB\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">假设我们要删除节点 6，传入根节点 11，整个执行过程如下：</span></p><p id=\"u4acfd9f0\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u638422e4\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=11，key=6，6&lt;11，递归执行 removeNode(7, 6)</span></li><li id=\"u646a4e78\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=7，key=6，6&lt;7，递归执行 removeNode(5, 6)</span></li><li id=\"u68f8e5a0\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=5，key=6，6&gt;5，递归执行 removeNode(6, 6)</span></li><li id=\"ucf3c3efb\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=6，key=6，6=6，并且节点 6 的 prev 和 next 都为 null，所以我们将节点 6 设置为 null，并且返回 null</span></li><li id=\"u40021ee2\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 3，节点 5 的 next 将获取步骤 4 的返回值 null</span></li><li id=\"u05b52c57\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 2，节点 7 的 prev 依然指向节点 5，保持不变</span></li><li id=\"ua40621fe\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 1，节点 11 的 prev 依然指向节点 7，保持不变</span></li><li id=\"u11c6ce1f\" data-lake-index-type=\"0\"><span class=\"ne-text\">最后返回节点 11</span></li></ol><p id=\"u7c1ec9e0\" class=\"ne-p\"><br></p><p id=\"u97c01681\" class=\"ne-p\"><span class=\"ne-text\">然后我们来看只有一个子节点的情况：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366703877-73c0ab05-fbd6-4a87-b0f7-4fae0ebb82f3.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u858e1208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=367&amp;originWidth=574&amp;originalType=url&amp;ratio=1&amp;size=31656&amp;status=done&amp;style=none&amp;taskId=ufabadec8-dba7-459a-96b4-f8fcba3d2d0\" width=\"574\" id=\"ed7mI\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">前面已经删除了节点 6，假设我们现在要删除节点 5，它有一个左子节点 3，我们依然传入根节点 11，来看看整个执行过程：</span></p><p id=\"u043057b7\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"uc615aedf\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=11，key=5，5&lt;11，递归执行 removeNode(7, 5)</span></li><li id=\"u92ab769b\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=7，key=5，5&lt;7，递归执行 removeNode(5, 5)</span></li><li id=\"u8ab26f80\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=5，key=5，5=5，并且节点 5 的 prev=3，next=null，所以我们将节点 5 替换成它的左子节点 3，并返回节点 3</span></li><li id=\"u914be9e2\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 2，节点 7 的 next 将获取步骤 3 的返回值 3</span></li><li id=\"u0a3999dc\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 1，节点 11 的 prev 依然指向节点 7，保持不变</span></li><li id=\"u93491eca\" data-lake-index-type=\"0\"><span class=\"ne-text\">最后返回节点 11</span></li></ol><p id=\"u77bdebba\" class=\"ne-p\"><br></p><p id=\"u0d6e6c69\" class=\"ne-p\"><span class=\"ne-text\">我们不需要将节点 5 从内存中删除，它会自动被 JavaScript 的垃圾回收器清理掉，这个在</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——链表的实现与应用》</span></a><span class=\"ne-text\">一文中已经介绍过。以上步骤是针对目标节点有左子节点的情况，对于有右子节点情况，执行过程是类似的。<br /></span><span class=\"ne-text\">最后再来看第三种情况：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366703878-eabb73a8-4bb7-4a5c-bc6b-99bb8b30eff3.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=uec3c6148&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=374&amp;originWidth=554&amp;originalType=url&amp;ratio=1&amp;size=34149&amp;status=done&amp;style=none&amp;taskId=ub5b588f7-2899-4778-94d0-bbcd5d3372f\" width=\"554\" id=\"hbvNc\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">前面已经删除了节点 6 和节点 5，现在我们要删除节点 15，它有左右子树，我们传入根节点 11，来看下具体执行过程：</span></p><p id=\"u63612160\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u67f146f5\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=11，key=15，15&gt;11，递归执行 removeNode(15, 15)</span></li><li id=\"u85c1a0d1\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=15，key=15，15=15，此时我们需要找到节点 15 的右子树中的最小节点 18，将节点 15 的 key 替换成节点 18 的 key，然后将节点 15 的 next 节点（即节点 20）作为起始节点进行遍历，找到并删除节点 18，最后再将节点 15（此时它的 key 是 18）的 next 指针指向节点 20，并返回节点 15</span></li><li id=\"u3d72edeb\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 1，节点 11 的 next 依然指向节点 15，但此时节点 15 的 key 已经变成 18 了</span></li><li id=\"u4ab2d732\" data-lake-index-type=\"0\"><span class=\"ne-text\">最后返回节点 11</span></li></ol><p id=\"udc9e4a59\" class=\"ne-p\"><br></p><p id=\"u6c82ae8c\" class=\"ne-p\"><span class=\"ne-text\">试想一下，当删除节点 15 之后，为了保证我们的二叉搜索树结构稳定，必须用节点 15 的右子树中的最小节点来替换节点 15，如果直接将 11 的 next 指向 20，则 20 将会有三个子节点 13、18、25，这显然已经不符合我们二叉树的定义了。如果将节点 25 用来替换节点 15，节点 20 的值比节点 25 的值小，不应该出现在右子节点，这也不符合我们的二叉搜索树的定义。所以，只有按照上述过程才能既保证不破坏树的结构，又能删除节点。<br /></span><span class=\"ne-text\">我们已经完成了一开始我们定义的二叉搜索树 BinarySearchTree 类的所有方法，下面是它的完整代码：</span></p><p id=\"u653bbaeb\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"02819d20\" class=\"ne-codeblock language-javascript\">let insertNode = function (node, newNode) {\n    if (newNode.element &lt; node.element) {\n        if (node.prev === null) node.prev = newNode\n        else insertNode(node.prev, newNode)\n    } else {\n        if (node.next === null) node.next = newNode\n        else insertNode(node.next, newNode)\n    }\n}\n\nlet preOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        callback(node.element)\n        preOrderTraverseNode(node.prev, callback)\n        preOrderTraverseNode(node.next, callback)\n    }\n}\n\nlet inOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        inOrderTraverseNode(node.prev, callback)\n        callback(node.element)\n        inOrderTraverseNode(node.next, callback)\n    }\n}\n\nlet postOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        postOrderTraverseNode(node.prev, callback)\n        postOrderTraverseNode(node.next, callback)\n        callback(node.element)\n    }\n}\n\nlet minNode = function (node) {\n    if (node === null) return null\n\n    while (node &amp;&amp; node.prev !== null) {\n        node = node.prev\n    }\n    return node\n}\n\nlet maxNode = function (node) {\n    if (node === null) return null\n\n    while (node &amp;&amp; node.next !== null) {\n        node = node.next\n    }\n    return node\n}\n\nlet searchNode = function (node, key) {\n    if (node === null) return false\n\n    if (key &lt; node.element) return searchNode(node.prev, key)\n    else if (key &gt; node.element) return searchNode(node.next, key)\n    else return true\n}\n\nlet removeNode = function (node, key) {\n    if (node === null) return null\n\n    if (key &lt; node.element) {\n        node.prev = removeNode(node.prev, key)\n        return node\n    } else if (key &gt; node.element) {\n        node.next = removeNode(node.next, key)\n        return node\n    } else {\n        // 第一种情况：一个叶子节点（没有子节点）\n        if (node.prev === null &amp;&amp; node.next === null) {\n            node = null\n            return node\n        }\n        // 第二种情况：只包含一个子节点\n        if (node.prev === null) {\n            node = node.next\n            return node\n        } else if (node.next === null) {\n            node = node.prev\n            return node\n        }\n\n        // 第三种情况：有两个子节点\n        let aux = minNode(node.next)\n        node.element = aux.element\n        node.next = removeNode(node.next, aux.element)\n        return node\n    }\n}\n\nclass BinarySearchTree {\n    constructor() {\n        this.root = null\n    }\n\n    // 向树中插入一个节点\n    insert(key) {\n        let newNode = new Node(key)\n\n        if (this.root === null) this.root = newNode\n        else insertNode(this.root, newNode)\n    }\n\n    // 在树中查找一个节点\n    search(key) {\n        return searchNode(this.root, key)\n    }\n\n    // 通过先序遍历方式遍历树中的所有节点\n    preOrderTraverse(callback) {\n        preOrderTraverseNode(this.root, callback)\n    }\n\n    // 通过中序遍历方式遍历树中的所有节点\n    inOrderTraverse(callback) {\n        inOrderTraverseNode(this.root, callback)\n    }\n\n    // 通过后序遍历方式遍历树中的所有节点\n    postOrderTraverse(callback) {\n        postOrderTraverseNode(this.root, callback)\n    }\n\n    // 返回树中的最小节点\n    min() {\n        return minNode(this.root)\n    }\n\n    // 返回树中的最大节点\n    max() {\n        return maxNode(this.root)\n    }\n\n    // 从树中移除一个节点\n    remove(key) {\n        this.root = removeNode(this.root, key)\n    }\n}</pre><p id=\"udf3c6297\" class=\"ne-p\"><br></p><p id=\"u2c12a250\" class=\"ne-p\"><br></p><p id=\"u24ecdaa7\" class=\"ne-p\"><br></p><h3 id=\"4242da52\"><span class=\"ne-text\">自平衡树</span></h3><p id=\"ubd9be9d5\" class=\"ne-p\"><br></p><p id=\"ub9f84f4b\" class=\"ne-p\"><span class=\"ne-text\">上面的 BST 树（二叉搜索树）存在一个问题，树的一条边可能会非常深，而其它边却只有几层，这会在这条很深的分支上添加、移除和搜索节点时引起一些性能问题。如下图所示：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366726947-232e09a9-43e1-4fbf-86e4-fdcdf8427300.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u4d5fbb30&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=653&amp;originWidth=704&amp;originalType=url&amp;ratio=1&amp;size=45808&amp;status=done&amp;style=none&amp;taskId=u22b890aa-8a23-476c-b752-cad00a2716e\" width=\"704\" id=\"tppDP\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">为了解决这个问题，我们引入了自平衡二叉搜索树（AVL——Adelson-Velskii-Landi）。在 AVL 中，任何一个节点左右两棵子树的高度之差最多为 1，添加或移除节点时，AVL 树会尝试自平衡。对 AVL 树的操作和对 BST 树的操作一样，不同点在于我们还需要重新平衡 AVL 树，在讲解对 AVL 树的平衡操作之前，我们先看一下什么是 AVL 树的平衡因子。<br /></span><span class=\"ne-text\">前面我们介绍过什么是树（子树）的高度，对于 AVL 树来说，每一个节点都保存一个平衡因子。<br /></span><strong><span class=\"ne-text\">节点的平衡因子 = 左子树的高度 - 右子树的高度</span></strong><span class=\"ne-text\"><br /></span><span class=\"ne-text\">观察下面这棵树，我们在上面标注了每个节点的平衡因子的值：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366726954-d758e030-e4b2-4588-8e56-38eea7451881.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u06bf5f7a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=401&amp;originWidth=578&amp;originalType=url&amp;ratio=1&amp;size=27946&amp;status=done&amp;style=none&amp;taskId=u6bfe9e2b-e524-4a2c-a713-0eb04ae3115\" width=\"578\" id=\"j9sOd\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">所有子节点的平衡因子都为 0，因为子节点没有子树。节点 5 的左右子树的高度都为 1，所以节点 5 的平衡因子是 0。节点 9 的左子树高度为 1，右子树高度为 0，所以节点 9 的平衡因子是+1。节点 13 的左子树高度为 0，右子树高度为 1，所以节点 13 的平衡因子是-1......AVL 树的所有节点的平衡因子保持三个值：0、+1 或-1。同时，我们也注意到，当某个节点的平衡因子为+1 时，它的子树是向左倾斜的（left-heavy）；而当某个节点的平衡因子为-1 时，它的子树是向右倾斜的（right-heavy）；当节点的平衡因子为 0 时，该节点是平衡的。一颗子树的根节点的平衡因子代表了该子树的平衡性。<br /></span><span class=\"ne-text\">为了使 AVL 树重新达到平衡状态，我们需要对 AVL 树中的部分节点进行重新排列，使其既符合二叉搜索树的定义，又符合自平衡二叉树的定义，这个过程叫做 AVL 树的旋转。<br /></span><span class=\"ne-text\">AVL 树的旋转一共分为四种：</span></p><p id=\"uf818271e\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u5c5c59e9\" data-lake-index-type=\"0\"><span class=\"ne-text\">LL（left-left）旋转，新添加的节点位于树的根节点的左子树的左子树上。以非平衡因子的节点为中心将整棵树向右旋转。</span></li><li id=\"u74683476\" data-lake-index-type=\"0\"><span class=\"ne-text\">LR（left-right）旋转，新添加的节点位于树的根节点的左子树的右子树上。先执行 RR 旋转，然后再执行 LL 旋转。</span></li><li id=\"u751510d1\" data-lake-index-type=\"0\"><span class=\"ne-text\">RR（right-right）旋转，新添加的节点位于树的根节点的右子树的右子树上。以非平衡因子的节点为中心将整棵树向左旋转。</span></li><li id=\"ufa362930\" data-lake-index-type=\"0\"><span class=\"ne-text\">RL（right-left）旋转，新添加的节点位于树的根节点的右子树的左子树上。先执行 LL 旋转，然后再执行 RR 旋转。</span></li></ul><p id=\"ubd6a9f83\" class=\"ne-p\"><br></p><p id=\"u33393c16\" class=\"ne-p\"><span class=\"ne-text\">下面是这四种旋转的操作示意图，后面我们会详细介绍每一种旋转的操作过程：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366727001-4ce9f99f-916a-40e6-ad25-3d9adbb16324.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=uf989ab3a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1277&amp;originWidth=897&amp;originalType=url&amp;ratio=1&amp;size=110075&amp;status=done&amp;style=none&amp;taskId=u7e881633-f8cc-458a-9cf2-e8c5f2705ac\" width=\"897\" id=\"OshVa\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">对于 LL 旋转，在节点 5 的右子节点上添加节点 4 与在左子节点上添加节点 3 等同。对于 LR 旋转，在节点 9 的左子节点上添加节点 8 与在右子节点上添加节点 10 等同。对于 RR 旋转，在节点 20 的右子节点上添加节点 25 与在左子节点上添加节点 18 等同。对于 RL 旋转，在节点 13 的右子节点上添加节点 14 与在左子节点上添加节点 12 等同。<br /></span><span class=\"ne-text\">我们的自平衡二叉树 AVLTree 类将从 BinarySearchTree 类继承，同时我们需要新增一个方法 getNodeHeight()用来获取任意节点的高度。</span></p><p id=\"ud9c1bf97\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"975019c3\" class=\"ne-codeblock language-javascript\">class AVLTree extends BinarySearchTree {\n    constructor() {\n        super()\n    }\n\n    // 计算节点的高度\n    getNodeHeight(node) {\n        if (node === null) return 0\n        return Math.max(this.getNodeHeight(node.prev), this.getNodeHeight(node.next)) + 1\n    }\n}</pre><p id=\"u9ac62eae\" class=\"ne-p\"><br></p><p id=\"u9ae882c8\" class=\"ne-p\"><span class=\"ne-text\">测试一下 getNodeHeight()方法，我们还是以本文一开始的那棵树为例，然后看一下不同节点的高度。</span></p><p id=\"u402ea17f\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"f3f80ff5\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(13)\ntree.insert(20)\ntree.insert(3)\ntree.insert(6)\ntree.insert(8)\ntree.insert(10)\ntree.insert(12)\ntree.insert(14)\ntree.insert(18)\ntree.insert(25)\n\nconsole.log(tree.getNodeHeight(tree.root)) // 4\nconsole.log(tree.getNodeHeight(tree.search(7))) // 3\nconsole.log(tree.getNodeHeight(tree.search(5))) // 2\nconsole.log(tree.getNodeHeight(tree.min(7))) // 1</pre><p id=\"u2aea32cb\" class=\"ne-p\"><br></p><p id=\"u71d40c0f\" class=\"ne-p\"><span class=\"ne-text\">根节点的高度为 4，最小节点 3 的高度为 1，节点 5 和节点 7 的高度分别为 2 和 3。<br /></span><span class=\"ne-text\">下面是四种旋转对应的实现代码：</span></p><p id=\"uce886aea\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3753eead\" class=\"ne-codeblock language-javascript\">/**\n * LL旋转: 向右旋转\n *\n *       b                           a\n *      / \\                         / \\\n *     a   e -&gt; rotationLL(b) -&gt;   c   b\n *    / \\                         /   / \\\n *   c   d                       f   d   e\n *  /\n * f\n *\n * @param node Node&lt;T&gt;\n */\nrotationLL(node) {\n    let tmp = node.prev;\n    node.prev = tmp.next;\n    tmp.next = node;\n    return tmp;\n}\n\n/**\n * RR旋转: 向左旋转\n *\n *     a                              b\n *    / \\                            / \\\n *   c   b   -&gt; rotationRR(a) -&gt;    a   e\n *      / \\                        / \\   \\\n *     d   e                      c   d   f\n *          \\\n *           f\n *\n * @param node Node&lt;T&gt;\n */\nrotationRR(node) {\n    let tmp = node.next;\n    node.next = tmp.prev;\n    tmp.prev = node;\n    return tmp;\n}\n\n/**\n * LR旋转: 先向左旋转，然后再向右旋转\n * @param node Node&lt;T&gt;\n */\nrotationLR(node) {\n    node.prev = this.rotationRR(node.prev);\n    return this.rotationLL(node);\n}\n\n/**\n * RL旋转: 先向右旋转，然后再向左旋转\n * @param node Node&lt;T&gt;\n */\nrotationRL(node) {\n    node.next = this.rotationLL(node.next);\n    return this.rotationRR(node);\n}</pre><p id=\"ueb3f3ffc\" class=\"ne-p\"><br></p><p id=\"u0a434095\" class=\"ne-p\"><span class=\"ne-text\">对于 LL 旋转和 RR 旋转，我们可以按照上面的示意图来看下执行过程。<br /></span><span class=\"ne-text\">LL 旋转，node=11，node.prev 是 7，所以 tmp=7。然后将 node.prev 指向 tmp.next，即将 11 的 prev 指向 9。接着将 tmp.next 指向 node，即将 7 的 next 指向 11。即完成了图中所示的旋转。<br /></span><span class=\"ne-text\">RR 旋转，node=11，node.next 是 15，所以 tmp=15。然后将 node.next 指向 tmp.prev，即将 11 的 next 指向 13。接着将 tmp.prev 指向 node，即将 15 的 prev 指向 11。即完成了图中所示的旋转。<br /></span><span class=\"ne-text\">LR 旋转是 RR 旋转和 LL 旋转的组合：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366769856-ab121a06-9ed4-4b47-8edd-6f6d1e0d621c.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u538e009c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=324&amp;originWidth=1150&amp;originalType=url&amp;ratio=1&amp;size=41879&amp;status=done&amp;style=none&amp;taskId=u2e0b1abc-05ac-40b8-9183-94fb9ecfbc1\" width=\"1150\" id=\"e2d8f\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">RL 旋转是 LL 旋转和 RR 旋转的组合：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366769875-da7538c0-c022-40ac-b858-6bdb9fa4d86b.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u543e3617&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=310&amp;originWidth=1050&amp;originalType=url&amp;ratio=1&amp;size=39803&amp;status=done&amp;style=none&amp;taskId=u8e8d14e4-2b60-452c-bc98-0b61afb010b\" width=\"1050\" id=\"FDr5y\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">按照上面给出的示意图，我们的 AVLTree 类的 insert()方法的实现如下：</span></p><p id=\"u257f135d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"efd3069a\" class=\"ne-codeblock language-javascript\">insert (key) {\n    super.insert(key);\n\n    // 左子树高度大于右子树高度\n    if (this.getNodeHeight(this.root.prev) - this.getNodeHeight(this.root.next) &gt; 1) {\n        if (key &lt; this.root.prev.element) {\n            this.root = this.rotationLL(this.root);\n        }\n        else {\n            this.root = this.rotationLR(this.root);\n        }\n    }\n    // 右子树高度大于左子树高度\n    else if (this.getNodeHeight(this.root.next) - this.getNodeHeight(this.root.prev) &gt; 1) {\n        if (key &gt; this.root.next.element) {\n            this.root = this.rotationRR(this.root);\n        }\n        else {\n            this.root = this.rotationRL(this.root);\n        }\n    }\n}</pre><p id=\"u7fcbaf24\" class=\"ne-p\"><br></p><p id=\"u57ac7d55\" class=\"ne-p\"><span class=\"ne-text\">我们依次测试一下这四种情况。按照上面示意图中树的结构添加节点，然后按照前序遍历的方式打印节点的 key。<br /></span><span class=\"ne-text\">LL 旋转的结果：</span></p><p id=\"u00ff4b66\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"802f2927\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(3)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u3ef98a1d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"4f36efd5\" class=\"ne-codeblock language-javascript\">7\n5\n3\n11\n9\n15</pre><p id=\"uc61ddbe3\" class=\"ne-p\"><br></p><p id=\"ubc243f2f\" class=\"ne-p\"><span class=\"ne-text\">LR 旋转的结果：</span></p><p id=\"ufed3f2dd\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"67d475fa\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(8)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"ua6a00062\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"c678dfc1\" class=\"ne-codeblock language-javascript\">9\n7\n5\n8\n11\n15</pre><p id=\"u7afd102a\" class=\"ne-p\"><br></p><p id=\"uda228c3f\" class=\"ne-p\"><span class=\"ne-text\">RR 旋转的结果：</span></p><p id=\"u32047a98\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d7155155\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(13)\ntree.insert(20)\ntree.insert(25)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u4b8343ce\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"5cfa3f1d\" class=\"ne-codeblock language-javascript\">15\n11\n7\n13\n20\n25</pre><p id=\"u0805aef5\" class=\"ne-p\"><br></p><p id=\"u51106d6a\" class=\"ne-p\"><span class=\"ne-text\">RL 旋转的结果：</span></p><p id=\"ud1796320\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3196272b\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(13)\ntree.insert(20)\ntree.insert(14)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"ud30a2477\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"5064065c\" class=\"ne-codeblock language-javascript\">13\n11\n7\n15\n14\n20</pre><p id=\"ub8db72f4\" class=\"ne-p\"><br></p><p id=\"u00d1a8ca\" class=\"ne-p\"><span class=\"ne-text\">我们用同样的方式修改 remove()方法，然后测试下面两种情况下的节点删除：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366865115-c8cbbf63-c8f0-4ca5-be96-6373b5bc0fd5.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u1e7f4a39&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=308&amp;originWidth=704&amp;originalType=url&amp;ratio=1&amp;size=20770&amp;status=done&amp;style=none&amp;taskId=uad71c3ad-032d-4d6d-9c0f-7f568a55270\" width=\"704\" id=\"hgIxB\" class=\"ne-image\"></p><p id=\"u3b3eaaaa\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ddee005f\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\n\ntree.remove(15)\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u01af3d96\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0b72114e\" class=\"ne-codeblock language-javascript\">9\n7\n5\n11</pre><p id=\"u6a580fc2\" class=\"ne-p\"><br></p><p id=\"ufad16cc4\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366895308-5fa8c8ce-c945-4448-bf40-0bf0dc7a71cc.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u62412dfb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=280&amp;originWidth=682&amp;originalType=url&amp;ratio=1&amp;size=20738&amp;status=done&amp;style=none&amp;taskId=ue9c074e3-dc24-496c-88c2-426bfc67dbc\" width=\"682\" id=\"FvN2q\" class=\"ne-image\"></p><p id=\"u55fc6189\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3c6969d0\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(13)\ntree.insert(20)\n\ntree.remove(7)\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u9e413cc5\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0aaaba55\" class=\"ne-codeblock language-javascript\">13\n11\n15\n20</pre><p id=\"ucae72592\" class=\"ne-p\"><br></p><p id=\"u14bfb527\" class=\"ne-p\"><span class=\"ne-text\">完整的自平衡二叉搜索树 AVLTree 类的代码如下：</span></p><p id=\"uc5812851\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0f5e2de9\" class=\"ne-codeblock language-javascript\">class AVLTree extends BinarySearchTree {\n    constructor() {\n        super()\n    }\n\n    // 计算节点的高度\n    getNodeHeight(node) {\n        if (node === null) return 0\n        return Math.max(this.getNodeHeight(node.prev), this.getNodeHeight(node.next)) + 1\n    }\n\n    // 获取节点的平衡因子\n\n    /**\n     * LL旋转: 向右旋转\n     *\n     *       b                           a\n     *      / \\                         / \\\n     *     a   e -&gt; rotationLL(b) -&gt;   c   b\n     *    / \\                         /   / \\\n     *   c   d                       f   d   e\n     *  /\n     * f\n     *\n     * @param node Node&lt;T&gt;\n     */\n    rotationLL(node) {\n        let tmp = node.prev\n        node.prev = tmp.next\n        tmp.next = node\n        return tmp\n    }\n\n    /**\n     * RR旋转: 向左旋转\n     *\n     *     a                              b\n     *    / \\                            / \\\n     *   c   b   -&gt; rotationRR(a) -&gt;    a   e\n     *      / \\                        / \\   \\\n     *     d   e                      c   d   f\n     *          \\\n     *           f\n     *\n     * @param node Node&lt;T&gt;\n     */\n    rotationRR(node) {\n        let tmp = node.next\n        node.next = tmp.prev\n        tmp.prev = node\n        return tmp\n    }\n\n    /**\n     * LR旋转: 先向左旋转，然后再向右旋转\n     * @param node Node&lt;T&gt;\n     */\n    rotationLR(node) {\n        node.prev = this.rotationRR(node.prev)\n        return this.rotationLL(node)\n    }\n    /**\n     * RL旋转: 先向右旋转，然后再向左旋转\n     * @param node Node&lt;T&gt;\n     */\n    rotationRL(node) {\n        node.next = this.rotationLL(node.next)\n        return this.rotationRR(node)\n    }\n\n    insert(key) {\n        super.insert(key)\n\n        // 左子树高度大于右子树高度\n        if (this.getNodeHeight(this.root.prev) - this.getNodeHeight(this.root.next) &gt; 1) {\n            if (key &lt; this.root.prev.element) {\n                this.root = this.rotationLL(this.root)\n            } else {\n                this.root = this.rotationLR(this.root)\n            }\n        }\n        // 右子树高度大于左子树高度\n        else if (this.getNodeHeight(this.root.next) - this.getNodeHeight(this.root.prev) &gt; 1) {\n            if (key &gt; this.root.next.element) {\n                this.root = this.rotationRR(this.root)\n            } else {\n                this.root = this.rotationRL(this.root)\n            }\n        }\n    }\n\n    remove(key) {\n        super.remove(key)\n\n        // 左子树高度大于右子树高度\n        if (this.getNodeHeight(this.root.prev) - this.getNodeHeight(this.root.next) &gt; 1) {\n            if (key &lt; this.root.prev.element) {\n                this.root = this.rotationLL(this.root)\n            } else {\n                this.root = this.rotationLR(this.root)\n            }\n        }\n        // 右子树高度大于左子树高度\n        else if (this.getNodeHeight(this.root.next) - this.getNodeHeight(this.root.prev) &gt; 1) {\n            if (key &gt; this.root.next.element) {\n                this.root = this.rotationRR(this.root)\n            } else {\n                this.root = this.rotationRL(this.root)\n            }\n        }\n    }\n}</pre><p id=\"ufba80d8e\" class=\"ne-p\"><br></p><p id=\"ue4355e65\" class=\"ne-p\"><span class=\"ne-text\">尽管自平衡二叉搜索树 AVL 可以很有效地帮助我们解决许多树节点的操作问题，但是在插入和移除节点时其性能并不是最好的。更好的选择是红黑树，红黑树也是一种自平衡二叉搜索树，但是它对其中的节点做了很多特殊的规定，使得在操作树节点的性能上要优于 AVL。</span></p></div>",
  "body": "[链接](https://www.cnblogs.com/jaxu/p/11309385.html)\n\n在计算机科学中，树是一种十分重要的数据结构。树被描述为一种分层数据抽象模型，常用来描述数据间的层级关系和组织结构。树也是一种非顺序的数据结构。下图展示了树的定义：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366269569-5914f76c-55cf-479d-9682-fde5a1aff15a.png#clientId=u6552ee0d-54a8-4&from=paste&id=u04cbac7c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=543&originWidth=772&originalType=url&ratio=1&size=45229&status=done&style=none&taskId=u0e3c43a3-4e6f-4650-a290-bab310866ca#averageHue=%23f9f9f9&id=rEjjS&originHeight=543&originWidth=772&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />在介绍如何用 JavaScript 实现树之前，我们先介绍一些和树相关的术语。<br />如上图所示，一棵完整的树包含一个位于树顶部的节点，称之为根节点（11），它没有父节点。树中的每一个元素都叫做一个节点，节点分为内部节点（图中显示为黄色的节点）和外部节点（图中显示为灰色的节点），至少有一个子节点的节点称为内部节点，没有子元素的节点称为外部节点或叶子节点。一个节点可以有祖先（根节点除外）和后代。子树由节点本身和它的后代组成，如上图中三角虚框中的部分就是一棵子树。节点拥有的子树的个数称之为节点的度，如上图中除叶子节点的度为 0 外，其余节点的度都为 2。从根节点开始，根为第 1 层，第一级子节点为第 2 层，第二级子节点为第 3 层，以此类推。树的高度（深度）由树中节点的最大层级决定（上图中树的高度为 4）。<br />在一棵树中，具有相同父节点的一组节点称为兄弟节点，如上图中的 3 和 6、5 和 9 等都是兄弟节点。\n\n<a name=\"8178ad6f\"></a>\n### 二叉树\n\n二叉树中的节点最多只能有两个子节点，一个是左子节点，一个是右子节点。左右子节点的顺序不能颠倒。因此，二叉树中不存在度大于 2 的节点。<br />二叉搜索树（BST——Binary Search Tree）是二叉树的一种，它规定在左子节点上存储小（比父节点）的值，在右子节点上（比父节点）存储大（或等于）的值。上图就是一个二叉搜索树。<br />下面我们重点来看一下二叉搜索树的实现。<br />根据二叉树的描述，一个节点最多只有两个子节点，我们可以使用[《JavaScript 数据结构——链表的实现与应用》](https://www.cnblogs.com/jaxu/p/11277732.html)一文中的双向链表来实现二叉搜索树中的每一个节点。下面是二叉搜索树的数据结构示意图：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366269506-0f79bff0-9217-49a5-889b-39da82b1ef61.png#clientId=u6552ee0d-54a8-4&from=paste&id=u73eea400&margin=%5Bobject%20Object%5D&name=image.png&originHeight=337&originWidth=650&originalType=url&ratio=1&size=21031&status=done&style=none&taskId=u7e9d9fa0-fa0b-4795-a4b0-1d49a8ad7f1#averageHue=%23f3f3f3&id=rNgNh&originHeight=337&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />以下是我们要实现的 BinarySearchTree 类的骨架部分：<br />\n\n```javascript\nclass BinarySearchTree {\n    constructor() {\n        this.root = null\n    }\n\n    // 向树中插入一个节点\n    insert(key) {}\n\n    // 在树中查找一个节点\n    search(key) {}\n\n    // 通过中序遍历方式遍历树中的所有节点\n    inOrderTraverse() {}\n\n    // 通过先序遍历方式遍历树中的所有节点\n    preOrderTraverse() {}\n\n    // 通过后序遍历方式遍历树中的所有节点\n    postOrderTraverse() {}\n\n    // 返回树中的最小节点\n    min() {}\n\n    // 返回树中的最大节点\n    max() {}\n\n    // 从树中移除一个节点\n    remove(key) {}\n}\n```\n\n先来看看向树中添加一个节点。我们借用[《JavaScript 数据结构——链表的实现与应用》](https://www.cnblogs.com/jaxu/p/11277732.html)一文中的双向链表 DoubleLinkedList 类来模拟树中的节点，在 DoubleLinkedList 类中，每一个节点有三个属性：element、next 和 prev。我们在这里用 element 表示树中节点的 key，用 next 表示树中节点的右子节点（right），用 prev 表示树中节点的左子节点（left）。\n\n```javascript\ninsert (key) {\n    let newNode = new Node(key);\n\n    if (this.root === null) this.root = newNode;\n    else insertNode(this.root, newNode);\n}\n```\n\n当树的 root 为 null 时，表示树为空，这时直接将新添加的节点作为树的根节点。否则，我们需要借助于私有函数 insertNode()来完成节点的添加。在 insertNode()函数中，我们需要根据新添加节点的 key 的大小来递归查找树的左侧子节点或者右侧子节点，因为根据我们的二叉搜索树的定义，值小的节点永远保存在左侧子节点上，值大的节点（包括值相等的情况）永远保存在右侧子节点上。下面是 insertNode()函数的实现代码：\n\n```javascript\nlet insertNode = function (node, newNode) {\n    if (newNode.element < node.element) {\n        if (node.prev === null) node.prev = newNode\n        else insertNode(node.prev, newNode)\n    } else {\n        if (node.next === null) node.next = newNode\n        else insertNode(node.next, newNode)\n    }\n}\n```\n\n所有新节点只能作为叶子节点被添加到树中。在本文一开始给出的树的结构图中，如果要添加节点 2，对应的操作步骤如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366466710-c235e8f1-3278-4e15-90ce-3a2194ab6f93.png#clientId=u6552ee0d-54a8-4&from=paste&id=u0f0e6dc0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=657&originalType=url&ratio=1&size=36604&status=done&style=none&taskId=u62e15592-6def-4696-9af8-54bd87ce215#averageHue=%23fafafa&id=v6cPo&originHeight=472&originWidth=657&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />我们传入树的根节点，依次进行递归，找到对应的叶子节点，然后修改节点的 prev（左子节点）或 next（右子节点）指针，使其指向新添加的节点。在上例中，如果要添加节点 4，它对应的位置应该是节点 3 的右子节点，因为 4 比 3 大。如果要添加节点 21，对应的位置应该是节点 25 的左子节点......<br />下面我们来看看树的三种遍历方式：\n\n- 前序遍历（NLR——Preorder Traversal）也叫先序遍历，访问根节点的操作发生在遍历其左右子树之前。\n- 中序遍历（LNR——Inorder Traversal），访问根节点的操作发生在遍历其左右子树之间。\n- 后序遍历（LRN——Postorder Traversal），访问根节点的操作发生在遍历其左右子树之后。\n\n下面的三个方法对应树的三种遍历方式：\n\n```javascript\n// 前序遍历\nlet preOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        callback(node.element)\n        preOrderTraverseNode(node.prev, callback)\n        preOrderTraverseNode(node.next, callback)\n    }\n}\n\n// 中序遍历\nlet inOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        inOrderTraverseNode(node.prev, callback)\n        callback(node.element)\n        inOrderTraverseNode(node.next, callback)\n    }\n}\n\n// 后续遍历\nlet postOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        postOrderTraverseNode(node.prev, callback)\n        postOrderTraverseNode(node.next, callback)\n        callback(node.element)\n    }\n}\n```\n\n可以看到，这三个函数的内容很相似，只是调整了左右子树和根节点的遍历顺序。这里的 callback 是一个回调函数，可以传入任何你想执行的函数，这里我们传入的函数内容是打印树的节点的 key 值。我们将 BinarySearchTree 类的这三个遍历方法的内容补充完整：\n\n```javascript\npreOrderTraverse (callback) {\n    preOrderTraverseNode(this.root, callback);\n}\n\ninOrderTraverse (callback) {\n    inOrderTraverseNode(this.root, callback);\n}\n\npostOrderTraverse (callback) {\n    postOrderTraverseNode(this.root, callback);\n}\n```\n\n为了构建本文一开始的那棵树，我们执行下面的代码，然后测试 preOrderTraverse()方法：\n\n```javascript\nlet tree = new BinarySearchTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(13)\ntree.insert(20)\ntree.insert(3)\ntree.insert(6)\ntree.insert(8)\ntree.insert(10)\ntree.insert(12)\ntree.insert(14)\ntree.insert(18)\ntree.insert(25)\n\ntree.preOrderTraverse(value => console.log(value))\n```\n\n注意节点插入的顺序，顺序不同，你可能会得到不一样的树。preOrderTraverse()方法采用 ES6 的语法传入了一个匿名函数作为参数 callback 的值，这个匿名函数的主要作用就是打印树中节点的 key 值，可以对照上面三个遍历树节点的函数中的 callback(node.element)语句，这里的 callback 就是这个匿名函数，node.element 就是节点的 key 值（还记得前面我们说过，借用双向链表类 DoubleLinkedList 来模拟树的节点吗？）下面是前序遍历的执行结果：\n\n```\n11\n7\n5\n3\n6\n9\n8\n10\n15\n13\n12\n14\n20\n18\n25\n```\n\n我们参照前序遍历的定义，借住下面的示意图来理解整个遍历过程：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366532033-7670baed-24f5-495d-b7c2-1163e92165e7.png#clientId=u6552ee0d-54a8-4&from=paste&id=uc206c787&margin=%5Bobject%20Object%5D&name=image.png&originHeight=429&originWidth=577&originalType=url&ratio=1&size=37165&status=done&style=none&taskId=u162713c1-346a-4dad-93db-99c316289d6#averageHue=%23f7f7f7&id=ttKwe&originHeight=429&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />在前序遍历函数 preOrderTraverseNode()中，先执行 callback(node.element)，然后再依次递归左子树和右子树。我们将树的根节点作为第一个节点传入，首先打印的就是根节点 11，然后开始遍历左子树，这将依次打印左子树中的所有左子节点，依次是 7、5、3。当节点 3 的 prev 为 null 时，递归返回，继续查找节点 3 的右子节点，此时节点 3 的 next 值也为 null，于是继续向上返回到节点 5，开始遍历节点 5 的右子节点，于是打印节点 6......最终所有的节点就按照这个递归顺序进行遍历。<br />然后我们再来看看中序遍历的情况。\n\n```javascript\ntree.inOrderTraverse(value => console.log(value))\n```\n\n```\n3\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n18\n20\n25\n```\n\n<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366564412-9c53be47-814a-4b8b-a7f4-d6a615420a08.png#clientId=u6552ee0d-54a8-4&from=paste&id=u822fc92d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=576&originalType=url&ratio=1&size=41002&status=done&style=none&taskId=uf10780f2-9708-405c-827f-7313c533553#averageHue=%23f5f5f5&id=giB5a&originHeight=378&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />在中序遍历函数 inOrderTraverseNode()中，先递归左子树，然后执行 callback(node.element)，最后再递归右子树。同样的，我们将根节点作为第一个节点传入，递归到左子树的最后一个左子节点 3，由于节点 3 的 prev 为 null，所以递归返回，打印节点 3，然后继续查找节点 3 的右子节点，节点 3 的 next 值也为 null，递归返回到上一层节点 5，开始打印节点 5，之后再查找节点 5 的右子节点......最终整棵树按照这个顺序完成遍历。<br />最后再来看看后序遍历的情况。\n\n```javascript\ntree.postOrderTraverse(value => console.log(value))\n```\n\n```\n3\n6\n5\n8\n10\n9\n7\n12\n14\n13\n18\n25\n20\n15\n11\n```\n\n<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366587593-3765828a-4e1f-4317-8d89-97bd9be4dd05.png#clientId=u6552ee0d-54a8-4&from=paste&id=u8098666a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=569&originalType=url&ratio=1&size=37799&status=done&style=none&taskId=u1d6e4036-f261-4e57-a9f0-ad3cde9a25c#averageHue=%23f6f6f6&id=uaJXG&originHeight=368&originWidth=569&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />在后序遍历函数 postOrderTraverseNode()中，先递归左子树，然后再递归右子树，最后执行 callback(node.element)。同样的，我们将根节点作为第一个节点传入，递归到左子树的最后一个左子节点 3，由于节点 3 的 prev 为 null，所以递归返回，此时继续查找节点 3 的右子节点，节点 3 的 next 值也为 null，递归返回并打印节点 3，之后递归返回到上一层节点 5，开始查找节点 5 的右子节点，节点 5 的右子节点是节点 6，由于节点 6 是叶子节点，所以直接打印节点 6，然后递归返回并打印节点 5。之后递归再向上返回到节点 7 并递归节点 7 的右子节点......按照这个顺序最终完成对整棵树的遍历。<br />接下来我们再来看看对树的搜索。有三种要经常执行的搜索方式：\n\n- 搜索树中的最小值\n- 搜索树中的最大值\n- 搜索树中的特定值\n\n搜索树中的最小值和最大值比较简单，由于我们的二叉搜索树规定了值小的节点永远在左子树（左子节点）中，值大（或相等）的节点永远在右子树（右子节点）中，所以，搜索最大值我们只需要递归查找树的右子树直到叶子节点，就能找到值最大的节点。搜索最小值只需要递归查找树的左子树直到叶子节点，就能找到值最小的节点。下面是这两个函数的实现：\n\n```javascript\nlet minNode = function (node) {\n    if (node === null) return null\n\n    while (node && node.prev !== null) {\n        node = node.prev\n    }\n    return node\n}\n\nlet maxNode = function (node) {\n    if (node === null) return null\n\n    while (node && node.next !== null) {\n        node = node.next\n    }\n    return node\n}\n```\n\n第三种方式是搜索特定的值，我们需要比较要搜索的值与当前节点的值，如果要搜索的值小于当前节点的值，则从当前节点开始递归查找左子数（左子节点）。如果要搜索的值大于当前节点的值，则从当前节点开始递归查找右子树（右子节点）。按照这个逻辑，我们的 searchNode()函数实现如下：\n\n```javascript\nlet searchNode = function (node, key) {\n    if (node === null) return null\n\n    if (key < node.element) return searchNode(node.prev, key)\n    else if (key > node.element) return searchNode(node.next, key)\n    else return node\n}\n```\n\n如果找到了对应的节点，就返回该节点，否则就返回 null。我们将 BinarySearchTree 类的这三个搜索方法的内容补充完整：\n\n```javascript\nsearch (key) {\n    return searchNode(this.root, key);\n}\n\nmin () {\n    return minNode(this.root);\n}\n\nmax () {\n    return maxNode(this.root);\n}\n```\n\n下面是一些测试用例及结果：\n\n```javascript\nconsole.log(tree.min().element) // 3\nconsole.log(tree.max().element) // 25\nconsole.log(tree.search(1) ? \"Key 1 found.\" : \"Key 1 not found.\") // Key 1 not found.\nconsole.log(tree.search(8) ? \"Key 8 found.\" : \"Key 8 not found.\") // Key 8 found.\n```\n\n让我们来看一下 search()方法的执行过程是怎样的。<br />\n\n搜索 key=1 的节点，首先我们传入树的根节点和 key=1，由于 1 小于根节点的值 11，递归查找根节点的左子节点 7，1<7，继续查找节点 7 的左子节点，直到找到叶子节点 3，1 仍然小于 3，但是节点 3 没有左子节点了，所以返回 false，整个递归开始向上返回，最终返回的结果是 false，表示树中没有 key=1 的节点。<br />\n\n相应地，对于搜索 key=8 的节点，也是先遍历根节点的左子节点 7，由于 8>7，所以会遍历节点 7 的右子节点，找到节点 9，8<9，遍历节点 9 的左子节点，此时找到节点 9 的左子节点正好是 8，所以返回 true，然后整个递归向上返回，最终的返回结果就是 true，表示树中找到了 key=8 的节点。<br />\n\n最后我们再来看一下从树中移除一个节点的过程，这个过程要稍微复杂一些。先来看看删除树节点的函数 removeNode()的代码，稍后我们再来详细讲解整个执行过程。<br />\n\n```javascript\nlet removeNode = function (node, key) {\n    if (node === null) return null\n\n    if (key < node.element) {\n        node.prev = removeNode(node.prev, key)\n        return node\n    } else if (key > node.element) {\n        node.next = removeNode(node.next, key)\n        return node\n    } else {\n        // 第一种情况：一个叶子节点（没有子节点）\n        if (node.prev === null && node.next === null) {\n            node = null\n            return node\n        }\n        // 第二种情况：只包含一个子节点\n        if (node.prev === null) {\n            node = node.next\n            return node\n        } else if (node.next === null) {\n            node = node.prev\n            return node\n        }\n\n        // 第三种情况：有两个子节点\n        let aux = minNode(node.next)\n        node.element = aux.element\n        node.next = removeNode(node.next, aux.element)\n        return node\n    }\n}\n```\n\n首先要找到树中待删除的节点，这需要进行递归遍历，从根节点开始，如果 key 值小于当前节点的值，则遍历左子树，如果 key 值大于当前节点的值，则遍历右子树。注意，在递归遍历的过程中，我们将 node（这里的 node 传入的是树的根节点）的 prev 指针或 next 指针逐级指向下一级节点，然后返回整个 node。当找到要删除的节点后，我们要处理三种情况：\n\n- 该节点为叶子节点（没有子节点）\n- 该节点只有一个子节点（左子节点或右子节点）\n- 该节点有两个子节点（左右子节点都存在）\n\n我们先看第一种情况：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366703868-eb31d55e-1a9f-448a-bee3-e9df964fd888.png#clientId=u6552ee0d-54a8-4&from=paste&id=u78b542f4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=369&originWidth=579&originalType=url&ratio=1&size=31470&status=done&style=none&taskId=u7f79a5a1-4a51-47a0-b012-b2cd584ad79#averageHue=%23f7f7f7&id=DOvnB&originHeight=369&originWidth=579&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />假设我们要删除节点 6，传入根节点 11，整个执行过程如下：\n\n1. node=11，key=6，6<11，递归执行 removeNode(7, 6)\n2. node=7，key=6，6<7，递归执行 removeNode(5, 6)\n3. node=5，key=6，6>5，递归执行 removeNode(6, 6)\n4. node=6，key=6，6=6，并且节点 6 的 prev 和 next 都为 null，所以我们将节点 6 设置为 null，并且返回 null\n5. 递归返回到步骤 3，节点 5 的 next 将获取步骤 4 的返回值 null\n6. 递归返回到步骤 2，节点 7 的 prev 依然指向节点 5，保持不变\n7. 递归返回到步骤 1，节点 11 的 prev 依然指向节点 7，保持不变\n8. 最后返回节点 11\n\n然后我们来看只有一个子节点的情况：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366703877-73c0ab05-fbd6-4a87-b0f7-4fae0ebb82f3.png#clientId=u6552ee0d-54a8-4&from=paste&id=u858e1208&margin=%5Bobject%20Object%5D&name=image.png&originHeight=367&originWidth=574&originalType=url&ratio=1&size=31656&status=done&style=none&taskId=ufabadec8-dba7-459a-96b4-f8fcba3d2d0#averageHue=%23f7f7f7&id=ed7mI&originHeight=367&originWidth=574&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />前面已经删除了节点 6，假设我们现在要删除节点 5，它有一个左子节点 3，我们依然传入根节点 11，来看看整个执行过程：\n\n1. node=11，key=5，5<11，递归执行 removeNode(7, 5)\n2. node=7，key=5，5<7，递归执行 removeNode(5, 5)\n3. node=5，key=5，5=5，并且节点 5 的 prev=3，next=null，所以我们将节点 5 替换成它的左子节点 3，并返回节点 3\n4. 递归返回到步骤 2，节点 7 的 next 将获取步骤 3 的返回值 3\n5. 递归返回到步骤 1，节点 11 的 prev 依然指向节点 7，保持不变\n6. 最后返回节点 11\n\n我们不需要将节点 5 从内存中删除，它会自动被 JavaScript 的垃圾回收器清理掉，这个在[《JavaScript 数据结构——链表的实现与应用》](https://www.cnblogs.com/jaxu/p/11277732.html)一文中已经介绍过。以上步骤是针对目标节点有左子节点的情况，对于有右子节点情况，执行过程是类似的。<br />最后再来看第三种情况：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366703878-eabb73a8-4bb7-4a5c-bc6b-99bb8b30eff3.png#clientId=u6552ee0d-54a8-4&from=paste&id=uec3c6148&margin=%5Bobject%20Object%5D&name=image.png&originHeight=374&originWidth=554&originalType=url&ratio=1&size=34149&status=done&style=none&taskId=ub5b588f7-2899-4778-94d0-bbcd5d3372f#averageHue=%23f6f6f6&id=hbvNc&originHeight=374&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />前面已经删除了节点 6 和节点 5，现在我们要删除节点 15，它有左右子树，我们传入根节点 11，来看下具体执行过程：\n\n1. node=11，key=15，15>11，递归执行 removeNode(15, 15)\n2. node=15，key=15，15=15，此时我们需要找到节点 15 的右子树中的最小节点 18，将节点 15 的 key 替换成节点 18 的 key，然后将节点 15 的 next 节点（即节点 20）作为起始节点进行遍历，找到并删除节点 18，最后再将节点 15（此时它的 key 是 18）的 next 指针指向节点 20，并返回节点 15\n3. 递归返回到步骤 1，节点 11 的 next 依然指向节点 15，但此时节点 15 的 key 已经变成 18 了\n4. 最后返回节点 11\n\n试想一下，当删除节点 15 之后，为了保证我们的二叉搜索树结构稳定，必须用节点 15 的右子树中的最小节点来替换节点 15，如果直接将 11 的 next 指向 20，则 20 将会有三个子节点 13、18、25，这显然已经不符合我们二叉树的定义了。如果将节点 25 用来替换节点 15，节点 20 的值比节点 25 的值小，不应该出现在右子节点，这也不符合我们的二叉搜索树的定义。所以，只有按照上述过程才能既保证不破坏树的结构，又能删除节点。<br />我们已经完成了一开始我们定义的二叉搜索树 BinarySearchTree 类的所有方法，下面是它的完整代码：\n\n```javascript\nlet insertNode = function (node, newNode) {\n    if (newNode.element < node.element) {\n        if (node.prev === null) node.prev = newNode\n        else insertNode(node.prev, newNode)\n    } else {\n        if (node.next === null) node.next = newNode\n        else insertNode(node.next, newNode)\n    }\n}\n\nlet preOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        callback(node.element)\n        preOrderTraverseNode(node.prev, callback)\n        preOrderTraverseNode(node.next, callback)\n    }\n}\n\nlet inOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        inOrderTraverseNode(node.prev, callback)\n        callback(node.element)\n        inOrderTraverseNode(node.next, callback)\n    }\n}\n\nlet postOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        postOrderTraverseNode(node.prev, callback)\n        postOrderTraverseNode(node.next, callback)\n        callback(node.element)\n    }\n}\n\nlet minNode = function (node) {\n    if (node === null) return null\n\n    while (node && node.prev !== null) {\n        node = node.prev\n    }\n    return node\n}\n\nlet maxNode = function (node) {\n    if (node === null) return null\n\n    while (node && node.next !== null) {\n        node = node.next\n    }\n    return node\n}\n\nlet searchNode = function (node, key) {\n    if (node === null) return false\n\n    if (key < node.element) return searchNode(node.prev, key)\n    else if (key > node.element) return searchNode(node.next, key)\n    else return true\n}\n\nlet removeNode = function (node, key) {\n    if (node === null) return null\n\n    if (key < node.element) {\n        node.prev = removeNode(node.prev, key)\n        return node\n    } else if (key > node.element) {\n        node.next = removeNode(node.next, key)\n        return node\n    } else {\n        // 第一种情况：一个叶子节点（没有子节点）\n        if (node.prev === null && node.next === null) {\n            node = null\n            return node\n        }\n        // 第二种情况：只包含一个子节点\n        if (node.prev === null) {\n            node = node.next\n            return node\n        } else if (node.next === null) {\n            node = node.prev\n            return node\n        }\n\n        // 第三种情况：有两个子节点\n        let aux = minNode(node.next)\n        node.element = aux.element\n        node.next = removeNode(node.next, aux.element)\n        return node\n    }\n}\n\nclass BinarySearchTree {\n    constructor() {\n        this.root = null\n    }\n\n    // 向树中插入一个节点\n    insert(key) {\n        let newNode = new Node(key)\n\n        if (this.root === null) this.root = newNode\n        else insertNode(this.root, newNode)\n    }\n\n    // 在树中查找一个节点\n    search(key) {\n        return searchNode(this.root, key)\n    }\n\n    // 通过先序遍历方式遍历树中的所有节点\n    preOrderTraverse(callback) {\n        preOrderTraverseNode(this.root, callback)\n    }\n\n    // 通过中序遍历方式遍历树中的所有节点\n    inOrderTraverse(callback) {\n        inOrderTraverseNode(this.root, callback)\n    }\n\n    // 通过后序遍历方式遍历树中的所有节点\n    postOrderTraverse(callback) {\n        postOrderTraverseNode(this.root, callback)\n    }\n\n    // 返回树中的最小节点\n    min() {\n        return minNode(this.root)\n    }\n\n    // 返回树中的最大节点\n    max() {\n        return maxNode(this.root)\n    }\n\n    // 从树中移除一个节点\n    remove(key) {\n        this.root = removeNode(this.root, key)\n    }\n}\n```\n\n\n\n<a name=\"4242da52\"></a>\n### 自平衡树\n\n上面的 BST 树（二叉搜索树）存在一个问题，树的一条边可能会非常深，而其它边却只有几层，这会在这条很深的分支上添加、移除和搜索节点时引起一些性能问题。如下图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366726947-232e09a9-43e1-4fbf-86e4-fdcdf8427300.png#clientId=u6552ee0d-54a8-4&from=paste&id=u4d5fbb30&margin=%5Bobject%20Object%5D&name=image.png&originHeight=653&originWidth=704&originalType=url&ratio=1&size=45808&status=done&style=none&taskId=u22b890aa-8a23-476c-b752-cad00a2716e#averageHue=%23fbfbfb&id=tppDP&originHeight=653&originWidth=704&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />为了解决这个问题，我们引入了自平衡二叉搜索树（AVL——Adelson-Velskii-Landi）。在 AVL 中，任何一个节点左右两棵子树的高度之差最多为 1，添加或移除节点时，AVL 树会尝试自平衡。对 AVL 树的操作和对 BST 树的操作一样，不同点在于我们还需要重新平衡 AVL 树，在讲解对 AVL 树的平衡操作之前，我们先看一下什么是 AVL 树的平衡因子。<br />前面我们介绍过什么是树（子树）的高度，对于 AVL 树来说，每一个节点都保存一个平衡因子。<br />**节点的平衡因子 = 左子树的高度 - 右子树的高度**<br />观察下面这棵树，我们在上面标注了每个节点的平衡因子的值：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366726954-d758e030-e4b2-4588-8e56-38eea7451881.png#clientId=u6552ee0d-54a8-4&from=paste&id=u06bf5f7a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=401&originWidth=578&originalType=url&ratio=1&size=27946&status=done&style=none&taskId=u6bfe9e2b-e524-4a2c-a713-0eb04ae3115#averageHue=%23fafafa&id=j9sOd&originHeight=401&originWidth=578&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />所有子节点的平衡因子都为 0，因为子节点没有子树。节点 5 的左右子树的高度都为 1，所以节点 5 的平衡因子是 0。节点 9 的左子树高度为 1，右子树高度为 0，所以节点 9 的平衡因子是+1。节点 13 的左子树高度为 0，右子树高度为 1，所以节点 13 的平衡因子是-1......AVL 树的所有节点的平衡因子保持三个值：0、+1 或-1。同时，我们也注意到，当某个节点的平衡因子为+1 时，它的子树是向左倾斜的（left-heavy）；而当某个节点的平衡因子为-1 时，它的子树是向右倾斜的（right-heavy）；当节点的平衡因子为 0 时，该节点是平衡的。一颗子树的根节点的平衡因子代表了该子树的平衡性。<br />为了使 AVL 树重新达到平衡状态，我们需要对 AVL 树中的部分节点进行重新排列，使其既符合二叉搜索树的定义，又符合自平衡二叉树的定义，这个过程叫做 AVL 树的旋转。<br />AVL 树的旋转一共分为四种：\n\n- LL（left-left）旋转，新添加的节点位于树的根节点的左子树的左子树上。以非平衡因子的节点为中心将整棵树向右旋转。\n- LR（left-right）旋转，新添加的节点位于树的根节点的左子树的右子树上。先执行 RR 旋转，然后再执行 LL 旋转。\n- RR（right-right）旋转，新添加的节点位于树的根节点的右子树的右子树上。以非平衡因子的节点为中心将整棵树向左旋转。\n- RL（right-left）旋转，新添加的节点位于树的根节点的右子树的左子树上。先执行 LL 旋转，然后再执行 RR 旋转。\n\n下面是这四种旋转的操作示意图，后面我们会详细介绍每一种旋转的操作过程：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366727001-4ce9f99f-916a-40e6-ad25-3d9adbb16324.png#clientId=u6552ee0d-54a8-4&from=paste&id=uf989ab3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1277&originWidth=897&originalType=url&ratio=1&size=110075&status=done&style=none&taskId=u7e881633-f8cc-458a-9cf2-e8c5f2705ac#averageHue=%23fbfbfb&id=OshVa&originHeight=1277&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />对于 LL 旋转，在节点 5 的右子节点上添加节点 4 与在左子节点上添加节点 3 等同。对于 LR 旋转，在节点 9 的左子节点上添加节点 8 与在右子节点上添加节点 10 等同。对于 RR 旋转，在节点 20 的右子节点上添加节点 25 与在左子节点上添加节点 18 等同。对于 RL 旋转，在节点 13 的右子节点上添加节点 14 与在左子节点上添加节点 12 等同。<br />我们的自平衡二叉树 AVLTree 类将从 BinarySearchTree 类继承，同时我们需要新增一个方法 getNodeHeight()用来获取任意节点的高度。\n\n```javascript\nclass AVLTree extends BinarySearchTree {\n    constructor() {\n        super()\n    }\n\n    // 计算节点的高度\n    getNodeHeight(node) {\n        if (node === null) return 0\n        return Math.max(this.getNodeHeight(node.prev), this.getNodeHeight(node.next)) + 1\n    }\n}\n```\n\n测试一下 getNodeHeight()方法，我们还是以本文一开始的那棵树为例，然后看一下不同节点的高度。\n\n```javascript\nlet tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(13)\ntree.insert(20)\ntree.insert(3)\ntree.insert(6)\ntree.insert(8)\ntree.insert(10)\ntree.insert(12)\ntree.insert(14)\ntree.insert(18)\ntree.insert(25)\n\nconsole.log(tree.getNodeHeight(tree.root)) // 4\nconsole.log(tree.getNodeHeight(tree.search(7))) // 3\nconsole.log(tree.getNodeHeight(tree.search(5))) // 2\nconsole.log(tree.getNodeHeight(tree.min(7))) // 1\n```\n\n根节点的高度为 4，最小节点 3 的高度为 1，节点 5 和节点 7 的高度分别为 2 和 3。<br />下面是四种旋转对应的实现代码：\n\n```javascript\n/**\n * LL旋转: 向右旋转\n *\n *       b                           a\n *      / \\                         / \\\n *     a   e -> rotationLL(b) ->   c   b\n *    / \\                         /   / \\\n *   c   d                       f   d   e\n *  /\n * f\n *\n * @param node Node<T>\n */\nrotationLL(node) {\n    let tmp = node.prev;\n    node.prev = tmp.next;\n    tmp.next = node;\n    return tmp;\n}\n\n/**\n * RR旋转: 向左旋转\n *\n *     a                              b\n *    / \\                            / \\\n *   c   b   -> rotationRR(a) ->    a   e\n *      / \\                        / \\   \\\n *     d   e                      c   d   f\n *          \\\n *           f\n *\n * @param node Node<T>\n */\nrotationRR(node) {\n    let tmp = node.next;\n    node.next = tmp.prev;\n    tmp.prev = node;\n    return tmp;\n}\n\n/**\n * LR旋转: 先向左旋转，然后再向右旋转\n * @param node Node<T>\n */\nrotationLR(node) {\n    node.prev = this.rotationRR(node.prev);\n    return this.rotationLL(node);\n}\n\n/**\n * RL旋转: 先向右旋转，然后再向左旋转\n * @param node Node<T>\n */\nrotationRL(node) {\n    node.next = this.rotationLL(node.next);\n    return this.rotationRR(node);\n}\n```\n\n对于 LL 旋转和 RR 旋转，我们可以按照上面的示意图来看下执行过程。<br />LL 旋转，node=11，node.prev 是 7，所以 tmp=7。然后将 node.prev 指向 tmp.next，即将 11 的 prev 指向 9。接着将 tmp.next 指向 node，即将 7 的 next 指向 11。即完成了图中所示的旋转。<br />RR 旋转，node=11，node.next 是 15，所以 tmp=15。然后将 node.next 指向 tmp.prev，即将 11 的 next 指向 13。接着将 tmp.prev 指向 node，即将 15 的 prev 指向 11。即完成了图中所示的旋转。<br />LR 旋转是 RR 旋转和 LL 旋转的组合：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366769856-ab121a06-9ed4-4b47-8edd-6f6d1e0d621c.png#clientId=u6552ee0d-54a8-4&from=paste&id=u538e009c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=324&originWidth=1150&originalType=url&ratio=1&size=41879&status=done&style=none&taskId=u2e0b1abc-05ac-40b8-9183-94fb9ecfbc1#averageHue=%23fafafa&id=e2d8f&originHeight=324&originWidth=1150&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />RL 旋转是 LL 旋转和 RR 旋转的组合：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366769875-da7538c0-c022-40ac-b858-6bdb9fa4d86b.png#clientId=u6552ee0d-54a8-4&from=paste&id=u543e3617&margin=%5Bobject%20Object%5D&name=image.png&originHeight=310&originWidth=1050&originalType=url&ratio=1&size=39803&status=done&style=none&taskId=u8e8d14e4-2b60-452c-bc98-0b61afb010b#averageHue=%23f9f9f9&id=FDr5y&originHeight=310&originWidth=1050&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />按照上面给出的示意图，我们的 AVLTree 类的 insert()方法的实现如下：\n\n```javascript\ninsert (key) {\n    super.insert(key);\n\n    // 左子树高度大于右子树高度\n    if (this.getNodeHeight(this.root.prev) - this.getNodeHeight(this.root.next) > 1) {\n        if (key < this.root.prev.element) {\n            this.root = this.rotationLL(this.root);\n        }\n        else {\n            this.root = this.rotationLR(this.root);\n        }\n    }\n    // 右子树高度大于左子树高度\n    else if (this.getNodeHeight(this.root.next) - this.getNodeHeight(this.root.prev) > 1) {\n        if (key > this.root.next.element) {\n            this.root = this.rotationRR(this.root);\n        }\n        else {\n            this.root = this.rotationRL(this.root);\n        }\n    }\n}\n```\n\n我们依次测试一下这四种情况。按照上面示意图中树的结构添加节点，然后按照前序遍历的方式打印节点的 key。<br />LL 旋转的结果：\n\n```javascript\nlet tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(3)\n\ntree.preOrderTraverse(value => console.log(value))\n```\n\n```javascript\n7\n5\n3\n11\n9\n15\n```\n\nLR 旋转的结果：\n\n```javascript\nlet tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(8)\n\ntree.preOrderTraverse(value => console.log(value))\n```\n\n```javascript\n9\n7\n5\n8\n11\n15\n```\n\nRR 旋转的结果：\n\n```javascript\nlet tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(13)\ntree.insert(20)\ntree.insert(25)\n\ntree.preOrderTraverse(value => console.log(value))\n```\n\n```javascript\n15\n11\n7\n13\n20\n25\n```\n\nRL 旋转的结果：\n\n```javascript\nlet tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(13)\ntree.insert(20)\ntree.insert(14)\n\ntree.preOrderTraverse(value => console.log(value))\n```\n\n```javascript\n13\n11\n7\n15\n14\n20\n```\n\n我们用同样的方式修改 remove()方法，然后测试下面两种情况下的节点删除：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366865115-c8cbbf63-c8f0-4ca5-be96-6373b5bc0fd5.png#clientId=u6552ee0d-54a8-4&from=paste&id=u1e7f4a39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=308&originWidth=704&originalType=url&ratio=1&size=20770&status=done&style=none&taskId=uad71c3ad-032d-4d6d-9c0f-7f568a55270#averageHue=%23fafafa&id=hgIxB&originHeight=308&originWidth=704&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n```javascript\nlet tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\n\ntree.remove(15)\ntree.preOrderTraverse(value => console.log(value))\n```\n\n```javascript\n9\n7\n5\n11\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646366895308-5fa8c8ce-c945-4448-bf40-0bf0dc7a71cc.png#clientId=u6552ee0d-54a8-4&from=paste&id=u62412dfb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=280&originWidth=682&originalType=url&ratio=1&size=20738&status=done&style=none&taskId=ue9c074e3-dc24-496c-88c2-426bfc67dbc#averageHue=%23fafafa&id=FvN2q&originHeight=280&originWidth=682&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n```javascript\nlet tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(13)\ntree.insert(20)\n\ntree.remove(7)\ntree.preOrderTraverse(value => console.log(value))\n```\n\n```javascript\n13\n11\n15\n20\n```\n\n完整的自平衡二叉搜索树 AVLTree 类的代码如下：\n\n```javascript\nclass AVLTree extends BinarySearchTree {\n    constructor() {\n        super()\n    }\n\n    // 计算节点的高度\n    getNodeHeight(node) {\n        if (node === null) return 0\n        return Math.max(this.getNodeHeight(node.prev), this.getNodeHeight(node.next)) + 1\n    }\n\n    // 获取节点的平衡因子\n\n    /**\n     * LL旋转: 向右旋转\n     *\n     *       b                           a\n     *      / \\                         / \\\n     *     a   e -> rotationLL(b) ->   c   b\n     *    / \\                         /   / \\\n     *   c   d                       f   d   e\n     *  /\n     * f\n     *\n     * @param node Node<T>\n     */\n    rotationLL(node) {\n        let tmp = node.prev\n        node.prev = tmp.next\n        tmp.next = node\n        return tmp\n    }\n\n    /**\n     * RR旋转: 向左旋转\n     *\n     *     a                              b\n     *    / \\                            / \\\n     *   c   b   -> rotationRR(a) ->    a   e\n     *      / \\                        / \\   \\\n     *     d   e                      c   d   f\n     *          \\\n     *           f\n     *\n     * @param node Node<T>\n     */\n    rotationRR(node) {\n        let tmp = node.next\n        node.next = tmp.prev\n        tmp.prev = node\n        return tmp\n    }\n\n    /**\n     * LR旋转: 先向左旋转，然后再向右旋转\n     * @param node Node<T>\n     */\n    rotationLR(node) {\n        node.prev = this.rotationRR(node.prev)\n        return this.rotationLL(node)\n    }\n    /**\n     * RL旋转: 先向右旋转，然后再向左旋转\n     * @param node Node<T>\n     */\n    rotationRL(node) {\n        node.next = this.rotationLL(node.next)\n        return this.rotationRR(node)\n    }\n\n    insert(key) {\n        super.insert(key)\n\n        // 左子树高度大于右子树高度\n        if (this.getNodeHeight(this.root.prev) - this.getNodeHeight(this.root.next) > 1) {\n            if (key < this.root.prev.element) {\n                this.root = this.rotationLL(this.root)\n            } else {\n                this.root = this.rotationLR(this.root)\n            }\n        }\n        // 右子树高度大于左子树高度\n        else if (this.getNodeHeight(this.root.next) - this.getNodeHeight(this.root.prev) > 1) {\n            if (key > this.root.next.element) {\n                this.root = this.rotationRR(this.root)\n            } else {\n                this.root = this.rotationRL(this.root)\n            }\n        }\n    }\n\n    remove(key) {\n        super.remove(key)\n\n        // 左子树高度大于右子树高度\n        if (this.getNodeHeight(this.root.prev) - this.getNodeHeight(this.root.next) > 1) {\n            if (key < this.root.prev.element) {\n                this.root = this.rotationLL(this.root)\n            } else {\n                this.root = this.rotationLR(this.root)\n            }\n        }\n        // 右子树高度大于左子树高度\n        else if (this.getNodeHeight(this.root.next) - this.getNodeHeight(this.root.prev) > 1) {\n            if (key > this.root.next.element) {\n                this.root = this.rotationRR(this.root)\n            } else {\n                this.root = this.rotationRL(this.root)\n            }\n        }\n    }\n}\n```\n\n尽管自平衡二叉搜索树 AVL 可以很有效地帮助我们解决许多树节点的操作问题，但是在插入和移除节点时其性能并不是最好的。更好的选择是红黑树，红黑树也是一种自平衡二叉搜索树，但是它对其中的节点做了很多特殊的规定，使得在操作树节点的性能上要优于 AVL。\n",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><p id=\"u1b2cfe0c\" class=\"ne-p\"><a href=\"https://www.cnblogs.com/jaxu/p/11309385.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11309385.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">链接</span></a><span class=\"ne-text\"><br /></span></p><p id=\"u71efe663\" class=\"ne-p\"><br></p><p id=\"u48a6aeba\" class=\"ne-p\"><span class=\"ne-text\">在计算机科学中，树是一种十分重要的数据结构。树被描述为一种分层数据抽象模型，常用来描述数据间的层级关系和组织结构。树也是一种非顺序的数据结构。下图展示了树的定义：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366269569-5914f76c-55cf-479d-9682-fde5a1aff15a.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u04cbac7c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=543&amp;originWidth=772&amp;originalType=url&amp;ratio=1&amp;size=45229&amp;status=done&amp;style=none&amp;taskId=u0e3c43a3-4e6f-4650-a290-bab310866ca\" width=\"772\" id=\"rEjjS\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在介绍如何用 JavaScript 实现树之前，我们先介绍一些和树相关的术语。<br /></span><span class=\"ne-text\">如上图所示，一棵完整的树包含一个位于树顶部的节点，称之为根节点（11），它没有父节点。树中的每一个元素都叫做一个节点，节点分为内部节点（图中显示为黄色的节点）和外部节点（图中显示为灰色的节点），至少有一个子节点的节点称为内部节点，没有子元素的节点称为外部节点或叶子节点。一个节点可以有祖先（根节点除外）和后代。子树由节点本身和它的后代组成，如上图中三角虚框中的部分就是一棵子树。节点拥有的子树的个数称之为节点的度，如上图中除叶子节点的度为 0 外，其余节点的度都为 2。从根节点开始，根为第 1 层，第一级子节点为第 2 层，第二级子节点为第 3 层，以此类推。树的高度（深度）由树中节点的最大层级决定（上图中树的高度为 4）。<br /></span><span class=\"ne-text\">在一棵树中，具有相同父节点的一组节点称为兄弟节点，如上图中的 3 和 6、5 和 9 等都是兄弟节点。</span></p><p id=\"ue1f21414\" class=\"ne-p\"><br></p><h3 id=\"8178ad6f\"><span class=\"ne-text\">二叉树</span></h3><p id=\"u8f792453\" class=\"ne-p\"><br></p><p id=\"u4de83d74\" class=\"ne-p\"><span class=\"ne-text\">二叉树中的节点最多只能有两个子节点，一个是左子节点，一个是右子节点。左右子节点的顺序不能颠倒。因此，二叉树中不存在度大于 2 的节点。<br /></span><span class=\"ne-text\">二叉搜索树（BST——Binary Search Tree）是二叉树的一种，它规定在左子节点上存储小（比父节点）的值，在右子节点上（比父节点）存储大（或等于）的值。上图就是一个二叉搜索树。<br /></span><span class=\"ne-text\">下面我们重点来看一下二叉搜索树的实现。<br /></span><span class=\"ne-text\">根据二叉树的描述，一个节点最多只有两个子节点，我们可以使用</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——链表的实现与应用》</span></a><span class=\"ne-text\">一文中的双向链表来实现二叉搜索树中的每一个节点。下面是二叉搜索树的数据结构示意图：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366269506-0f79bff0-9217-49a5-889b-39da82b1ef61.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u73eea400&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=337&amp;originWidth=650&amp;originalType=url&amp;ratio=1&amp;size=21031&amp;status=done&amp;style=none&amp;taskId=u7e9d9fa0-fa0b-4795-a4b0-1d49a8ad7f1\" width=\"650\" id=\"rNgNh\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">以下是我们要实现的 BinarySearchTree 类的骨架部分：<br /></span><span class=\"ne-text\"></span></p><p id=\"ue60b4729\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"19ae2f58\" class=\"ne-codeblock language-javascript\">class BinarySearchTree {\n    constructor() {\n        this.root = null\n    }\n\n    // 向树中插入一个节点\n    insert(key) {}\n\n    // 在树中查找一个节点\n    search(key) {}\n\n    // 通过中序遍历方式遍历树中的所有节点\n    inOrderTraverse() {}\n\n    // 通过先序遍历方式遍历树中的所有节点\n    preOrderTraverse() {}\n\n    // 通过后序遍历方式遍历树中的所有节点\n    postOrderTraverse() {}\n\n    // 返回树中的最小节点\n    min() {}\n\n    // 返回树中的最大节点\n    max() {}\n\n    // 从树中移除一个节点\n    remove(key) {}\n}</pre><p id=\"u2f0c439d\" class=\"ne-p\"><br></p><p id=\"uf0750dae\" class=\"ne-p\"><span class=\"ne-text\">先来看看向树中添加一个节点。我们借用</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——链表的实现与应用》</span></a><span class=\"ne-text\">一文中的双向链表 DoubleLinkedList 类来模拟树中的节点，在 DoubleLinkedList 类中，每一个节点有三个属性：element、next 和 prev。我们在这里用 element 表示树中节点的 key，用 next 表示树中节点的右子节点（right），用 prev 表示树中节点的左子节点（left）。</span></p><p id=\"u8a9f0fb8\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"b651088a\" class=\"ne-codeblock language-javascript\">insert (key) {\n    let newNode = new Node(key);\n\n    if (this.root === null) this.root = newNode;\n    else insertNode(this.root, newNode);\n}</pre><p id=\"u415432ad\" class=\"ne-p\"><br></p><p id=\"u78703efe\" class=\"ne-p\"><span class=\"ne-text\">当树的 root 为 null 时，表示树为空，这时直接将新添加的节点作为树的根节点。否则，我们需要借助于私有函数 insertNode()来完成节点的添加。在 insertNode()函数中，我们需要根据新添加节点的 key 的大小来递归查找树的左侧子节点或者右侧子节点，因为根据我们的二叉搜索树的定义，值小的节点永远保存在左侧子节点上，值大的节点（包括值相等的情况）永远保存在右侧子节点上。下面是 insertNode()函数的实现代码：</span></p><p id=\"u59530ec7\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"263f076f\" class=\"ne-codeblock language-javascript\">let insertNode = function (node, newNode) {\n    if (newNode.element &lt; node.element) {\n        if (node.prev === null) node.prev = newNode\n        else insertNode(node.prev, newNode)\n    } else {\n        if (node.next === null) node.next = newNode\n        else insertNode(node.next, newNode)\n    }\n}</pre><p id=\"u35a9dcbc\" class=\"ne-p\"><br></p><p id=\"u3ea26f25\" class=\"ne-p\"><span class=\"ne-text\">所有新节点只能作为叶子节点被添加到树中。在本文一开始给出的树的结构图中，如果要添加节点 2，对应的操作步骤如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366466710-c235e8f1-3278-4e15-90ce-3a2194ab6f93.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u0f0e6dc0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=472&amp;originWidth=657&amp;originalType=url&amp;ratio=1&amp;size=36604&amp;status=done&amp;style=none&amp;taskId=u62e15592-6def-4696-9af8-54bd87ce215\" width=\"657\" id=\"v6cPo\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">我们传入树的根节点，依次进行递归，找到对应的叶子节点，然后修改节点的 prev（左子节点）或 next（右子节点）指针，使其指向新添加的节点。在上例中，如果要添加节点 4，它对应的位置应该是节点 3 的右子节点，因为 4 比 3 大。如果要添加节点 21，对应的位置应该是节点 25 的左子节点......<br /></span><span class=\"ne-text\">下面我们来看看树的三种遍历方式：</span></p><p id=\"uc3a25cf6\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ucc1ea31c\" data-lake-index-type=\"0\"><span class=\"ne-text\">前序遍历（NLR——Preorder Traversal）也叫先序遍历，访问根节点的操作发生在遍历其左右子树之前。</span></li><li id=\"uc72ff6bb\" data-lake-index-type=\"0\"><span class=\"ne-text\">中序遍历（LNR——Inorder Traversal），访问根节点的操作发生在遍历其左右子树之间。</span></li><li id=\"ue2d6d758\" data-lake-index-type=\"0\"><span class=\"ne-text\">后序遍历（LRN——Postorder Traversal），访问根节点的操作发生在遍历其左右子树之后。</span></li></ul><p id=\"uec3358a5\" class=\"ne-p\"><br></p><p id=\"u800c81d5\" class=\"ne-p\"><span class=\"ne-text\">下面的三个方法对应树的三种遍历方式：</span></p><p id=\"u25890f44\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"29b19ab6\" class=\"ne-codeblock language-javascript\">// 前序遍历\nlet preOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        callback(node.element)\n        preOrderTraverseNode(node.prev, callback)\n        preOrderTraverseNode(node.next, callback)\n    }\n}\n\n// 中序遍历\nlet inOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        inOrderTraverseNode(node.prev, callback)\n        callback(node.element)\n        inOrderTraverseNode(node.next, callback)\n    }\n}\n\n// 后续遍历\nlet postOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        postOrderTraverseNode(node.prev, callback)\n        postOrderTraverseNode(node.next, callback)\n        callback(node.element)\n    }\n}</pre><p id=\"u7a023ae2\" class=\"ne-p\"><br></p><p id=\"u40002bff\" class=\"ne-p\"><span class=\"ne-text\">可以看到，这三个函数的内容很相似，只是调整了左右子树和根节点的遍历顺序。这里的 callback 是一个回调函数，可以传入任何你想执行的函数，这里我们传入的函数内容是打印树的节点的 key 值。我们将 BinarySearchTree 类的这三个遍历方法的内容补充完整：</span></p><p id=\"u44f8333a\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"b742e38b\" class=\"ne-codeblock language-javascript\">preOrderTraverse (callback) {\n    preOrderTraverseNode(this.root, callback);\n}\n\ninOrderTraverse (callback) {\n    inOrderTraverseNode(this.root, callback);\n}\n\npostOrderTraverse (callback) {\n    postOrderTraverseNode(this.root, callback);\n}</pre><p id=\"u44572730\" class=\"ne-p\"><br></p><p id=\"u0510d4e7\" class=\"ne-p\"><span class=\"ne-text\">为了构建本文一开始的那棵树，我们执行下面的代码，然后测试 preOrderTraverse()方法：</span></p><p id=\"u3fe6e1d3\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3c42dcaa\" class=\"ne-codeblock language-javascript\">let tree = new BinarySearchTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(13)\ntree.insert(20)\ntree.insert(3)\ntree.insert(6)\ntree.insert(8)\ntree.insert(10)\ntree.insert(12)\ntree.insert(14)\ntree.insert(18)\ntree.insert(25)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u22112e7b\" class=\"ne-p\"><br></p><p id=\"uab8de858\" class=\"ne-p\"><span class=\"ne-text\">注意节点插入的顺序，顺序不同，你可能会得到不一样的树。preOrderTraverse()方法采用 ES6 的语法传入了一个匿名函数作为参数 callback 的值，这个匿名函数的主要作用就是打印树中节点的 key 值，可以对照上面三个遍历树节点的函数中的 callback(node.element)语句，这里的 callback 就是这个匿名函数，node.element 就是节点的 key 值（还记得前面我们说过，借用双向链表类 DoubleLinkedList 来模拟树的节点吗？）下面是前序遍历的执行结果：</span></p><p id=\"uf0a833a5\" class=\"ne-p\"><br></p><pre data-language=\"plain\" id=\"d13cccaf\" class=\"ne-codeblock language-plain\">11\n7\n5\n3\n6\n9\n8\n10\n15\n13\n12\n14\n20\n18\n25</pre><p id=\"uce4d13aa\" class=\"ne-p\"><br></p><p id=\"u06b21e2a\" class=\"ne-p\"><span class=\"ne-text\">我们参照前序遍历的定义，借住下面的示意图来理解整个遍历过程：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366532033-7670baed-24f5-495d-b7c2-1163e92165e7.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=uc206c787&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=429&amp;originWidth=577&amp;originalType=url&amp;ratio=1&amp;size=37165&amp;status=done&amp;style=none&amp;taskId=u162713c1-346a-4dad-93db-99c316289d6\" width=\"577\" id=\"ttKwe\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在前序遍历函数 preOrderTraverseNode()中，先执行 callback(node.element)，然后再依次递归左子树和右子树。我们将树的根节点作为第一个节点传入，首先打印的就是根节点 11，然后开始遍历左子树，这将依次打印左子树中的所有左子节点，依次是 7、5、3。当节点 3 的 prev 为 null 时，递归返回，继续查找节点 3 的右子节点，此时节点 3 的 next 值也为 null，于是继续向上返回到节点 5，开始遍历节点 5 的右子节点，于是打印节点 6......最终所有的节点就按照这个递归顺序进行遍历。<br /></span><span class=\"ne-text\">然后我们再来看看中序遍历的情况。</span></p><p id=\"u525da69f\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"018cbef7\" class=\"ne-codeblock language-javascript\">tree.inOrderTraverse(value =&gt; console.log(value))</pre><p id=\"uf2a78406\" class=\"ne-p\"><br></p><pre data-language=\"plain\" id=\"9b1fbd21\" class=\"ne-codeblock language-plain\">3\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n18\n20\n25</pre><p id=\"u60fa605a\" class=\"ne-p\"><br></p><p id=\"u7723171f\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366564412-9c53be47-814a-4b8b-a7f4-d6a615420a08.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u822fc92d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=378&amp;originWidth=576&amp;originalType=url&amp;ratio=1&amp;size=41002&amp;status=done&amp;style=none&amp;taskId=uf10780f2-9708-405c-827f-7313c533553\" width=\"576\" id=\"giB5a\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在中序遍历函数 inOrderTraverseNode()中，先递归左子树，然后执行 callback(node.element)，最后再递归右子树。同样的，我们将根节点作为第一个节点传入，递归到左子树的最后一个左子节点 3，由于节点 3 的 prev 为 null，所以递归返回，打印节点 3，然后继续查找节点 3 的右子节点，节点 3 的 next 值也为 null，递归返回到上一层节点 5，开始打印节点 5，之后再查找节点 5 的右子节点......最终整棵树按照这个顺序完成遍历。<br /></span><span class=\"ne-text\">最后再来看看后序遍历的情况。</span></p><p id=\"u54849225\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d0cdfb98\" class=\"ne-codeblock language-javascript\">tree.postOrderTraverse(value =&gt; console.log(value))</pre><p id=\"ube957c6b\" class=\"ne-p\"><br></p><pre data-language=\"plain\" id=\"a262629b\" class=\"ne-codeblock language-plain\">3\n6\n5\n8\n10\n9\n7\n12\n14\n13\n18\n25\n20\n15\n11</pre><p id=\"ud1b927c6\" class=\"ne-p\"><br></p><p id=\"u9c589b2d\" class=\"ne-p\"><span class=\"ne-text\"><br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366587593-3765828a-4e1f-4317-8d89-97bd9be4dd05.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u8098666a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=368&amp;originWidth=569&amp;originalType=url&amp;ratio=1&amp;size=37799&amp;status=done&amp;style=none&amp;taskId=u1d6e4036-f261-4e57-a9f0-ad3cde9a25c\" width=\"569\" id=\"uaJXG\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">在后序遍历函数 postOrderTraverseNode()中，先递归左子树，然后再递归右子树，最后执行 callback(node.element)。同样的，我们将根节点作为第一个节点传入，递归到左子树的最后一个左子节点 3，由于节点 3 的 prev 为 null，所以递归返回，此时继续查找节点 3 的右子节点，节点 3 的 next 值也为 null，递归返回并打印节点 3，之后递归返回到上一层节点 5，开始查找节点 5 的右子节点，节点 5 的右子节点是节点 6，由于节点 6 是叶子节点，所以直接打印节点 6，然后递归返回并打印节点 5。之后递归再向上返回到节点 7 并递归节点 7 的右子节点......按照这个顺序最终完成对整棵树的遍历。<br /></span><span class=\"ne-text\">接下来我们再来看看对树的搜索。有三种要经常执行的搜索方式：</span></p><p id=\"u998fa5f9\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u0caa0e6a\" data-lake-index-type=\"0\"><span class=\"ne-text\">搜索树中的最小值</span></li><li id=\"uf31666a1\" data-lake-index-type=\"0\"><span class=\"ne-text\">搜索树中的最大值</span></li><li id=\"u79c99c43\" data-lake-index-type=\"0\"><span class=\"ne-text\">搜索树中的特定值</span></li></ul><p id=\"u0e292cb9\" class=\"ne-p\"><br></p><p id=\"u7b306e85\" class=\"ne-p\"><span class=\"ne-text\">搜索树中的最小值和最大值比较简单，由于我们的二叉搜索树规定了值小的节点永远在左子树（左子节点）中，值大（或相等）的节点永远在右子树（右子节点）中，所以，搜索最大值我们只需要递归查找树的右子树直到叶子节点，就能找到值最大的节点。搜索最小值只需要递归查找树的左子树直到叶子节点，就能找到值最小的节点。下面是这两个函数的实现：</span></p><p id=\"ua7ebccb2\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"deb27f8f\" class=\"ne-codeblock language-javascript\">let minNode = function (node) {\n    if (node === null) return null\n\n    while (node &amp;&amp; node.prev !== null) {\n        node = node.prev\n    }\n    return node\n}\n\nlet maxNode = function (node) {\n    if (node === null) return null\n\n    while (node &amp;&amp; node.next !== null) {\n        node = node.next\n    }\n    return node\n}</pre><p id=\"u4666f23a\" class=\"ne-p\"><br></p><p id=\"u95db9919\" class=\"ne-p\"><span class=\"ne-text\">第三种方式是搜索特定的值，我们需要比较要搜索的值与当前节点的值，如果要搜索的值小于当前节点的值，则从当前节点开始递归查找左子数（左子节点）。如果要搜索的值大于当前节点的值，则从当前节点开始递归查找右子树（右子节点）。按照这个逻辑，我们的 searchNode()函数实现如下：</span></p><p id=\"u367532b7\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"687ff764\" class=\"ne-codeblock language-javascript\">let searchNode = function (node, key) {\n    if (node === null) return null\n\n    if (key &lt; node.element) return searchNode(node.prev, key)\n    else if (key &gt; node.element) return searchNode(node.next, key)\n    else return node\n}</pre><p id=\"ucab2a362\" class=\"ne-p\"><br></p><p id=\"uedfdfbab\" class=\"ne-p\"><span class=\"ne-text\">如果找到了对应的节点，就返回该节点，否则就返回 null。我们将 BinarySearchTree 类的这三个搜索方法的内容补充完整：</span></p><p id=\"udf150379\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"926b0f96\" class=\"ne-codeblock language-javascript\">search (key) {\n    return searchNode(this.root, key);\n}\n\nmin () {\n    return minNode(this.root);\n}\n\nmax () {\n    return maxNode(this.root);\n}</pre><p id=\"ub714861a\" class=\"ne-p\"><br></p><p id=\"ub0dec46e\" class=\"ne-p\"><span class=\"ne-text\">下面是一些测试用例及结果：</span></p><p id=\"udb0ce19d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d8119ee6\" class=\"ne-codeblock language-javascript\">console.log(tree.min().element) // 3\nconsole.log(tree.max().element) // 25\nconsole.log(tree.search(1) ? &quot;Key 1 found.&quot; : &quot;Key 1 not found.&quot;) // Key 1 not found.\nconsole.log(tree.search(8) ? &quot;Key 8 found.&quot; : &quot;Key 8 not found.&quot;) // Key 8 found.</pre><p id=\"u35f4c58f\" class=\"ne-p\"><br></p><p id=\"u1414c6fa\" class=\"ne-p\"><span class=\"ne-text\">让我们来看一下 search()方法的执行过程是怎样的。<br /></span><span class=\"ne-text\"></span></p><p id=\"ud1109014\" class=\"ne-p\"><br></p><p id=\"u81aedb98\" class=\"ne-p\"><span class=\"ne-text\">搜索 key=1 的节点，首先我们传入树的根节点和 key=1，由于 1 小于根节点的值 11，递归查找根节点的左子节点 7，1&lt;7，继续查找节点 7 的左子节点，直到找到叶子节点 3，1 仍然小于 3，但是节点 3 没有左子节点了，所以返回 false，整个递归开始向上返回，最终返回的结果是 false，表示树中没有 key=1 的节点。<br /></span><span class=\"ne-text\"></span></p><p id=\"u9c056d49\" class=\"ne-p\"><br></p><p id=\"u334b04e1\" class=\"ne-p\"><span class=\"ne-text\">相应地，对于搜索 key=8 的节点，也是先遍历根节点的左子节点 7，由于 8&gt;7，所以会遍历节点 7 的右子节点，找到节点 9，8&lt;9，遍历节点 9 的左子节点，此时找到节点 9 的左子节点正好是 8，所以返回 true，然后整个递归向上返回，最终的返回结果就是 true，表示树中找到了 key=8 的节点。<br /></span><span class=\"ne-text\"></span></p><p id=\"ub6fa1d7d\" class=\"ne-p\"><br></p><p id=\"uf6641618\" class=\"ne-p\"><span class=\"ne-text\">最后我们再来看一下从树中移除一个节点的过程，这个过程要稍微复杂一些。先来看看删除树节点的函数 removeNode()的代码，稍后我们再来详细讲解整个执行过程。<br /></span><span class=\"ne-text\"></span></p><p id=\"u059c59a1\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ac861dc1\" class=\"ne-codeblock language-javascript\">let removeNode = function (node, key) {\n    if (node === null) return null\n\n    if (key &lt; node.element) {\n        node.prev = removeNode(node.prev, key)\n        return node\n    } else if (key &gt; node.element) {\n        node.next = removeNode(node.next, key)\n        return node\n    } else {\n        // 第一种情况：一个叶子节点（没有子节点）\n        if (node.prev === null &amp;&amp; node.next === null) {\n            node = null\n            return node\n        }\n        // 第二种情况：只包含一个子节点\n        if (node.prev === null) {\n            node = node.next\n            return node\n        } else if (node.next === null) {\n            node = node.prev\n            return node\n        }\n\n        // 第三种情况：有两个子节点\n        let aux = minNode(node.next)\n        node.element = aux.element\n        node.next = removeNode(node.next, aux.element)\n        return node\n    }\n}</pre><p id=\"u86c5a928\" class=\"ne-p\"><br></p><p id=\"ua141e092\" class=\"ne-p\"><span class=\"ne-text\">首先要找到树中待删除的节点，这需要进行递归遍历，从根节点开始，如果 key 值小于当前节点的值，则遍历左子树，如果 key 值大于当前节点的值，则遍历右子树。注意，在递归遍历的过程中，我们将 node（这里的 node 传入的是树的根节点）的 prev 指针或 next 指针逐级指向下一级节点，然后返回整个 node。当找到要删除的节点后，我们要处理三种情况：</span></p><p id=\"u594b2bc1\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u68c4d68b\" data-lake-index-type=\"0\"><span class=\"ne-text\">该节点为叶子节点（没有子节点）</span></li><li id=\"u6dac2e90\" data-lake-index-type=\"0\"><span class=\"ne-text\">该节点只有一个子节点（左子节点或右子节点）</span></li><li id=\"u3dfccf2d\" data-lake-index-type=\"0\"><span class=\"ne-text\">该节点有两个子节点（左右子节点都存在）</span></li></ul><p id=\"u230407a2\" class=\"ne-p\"><br></p><p id=\"uaf93be6b\" class=\"ne-p\"><span class=\"ne-text\">我们先看第一种情况：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366703868-eb31d55e-1a9f-448a-bee3-e9df964fd888.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u78b542f4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=579&amp;originalType=url&amp;ratio=1&amp;size=31470&amp;status=done&amp;style=none&amp;taskId=u7f79a5a1-4a51-47a0-b012-b2cd584ad79\" width=\"579\" id=\"DOvnB\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">假设我们要删除节点 6，传入根节点 11，整个执行过程如下：</span></p><p id=\"u4acfd9f0\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u638422e4\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=11，key=6，6&lt;11，递归执行 removeNode(7, 6)</span></li><li id=\"u646a4e78\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=7，key=6，6&lt;7，递归执行 removeNode(5, 6)</span></li><li id=\"u68f8e5a0\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=5，key=6，6&gt;5，递归执行 removeNode(6, 6)</span></li><li id=\"ucf3c3efb\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=6，key=6，6=6，并且节点 6 的 prev 和 next 都为 null，所以我们将节点 6 设置为 null，并且返回 null</span></li><li id=\"u40021ee2\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 3，节点 5 的 next 将获取步骤 4 的返回值 null</span></li><li id=\"u05b52c57\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 2，节点 7 的 prev 依然指向节点 5，保持不变</span></li><li id=\"ua40621fe\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 1，节点 11 的 prev 依然指向节点 7，保持不变</span></li><li id=\"u11c6ce1f\" data-lake-index-type=\"0\"><span class=\"ne-text\">最后返回节点 11</span></li></ol><p id=\"u7c1ec9e0\" class=\"ne-p\"><br></p><p id=\"u97c01681\" class=\"ne-p\"><span class=\"ne-text\">然后我们来看只有一个子节点的情况：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366703877-73c0ab05-fbd6-4a87-b0f7-4fae0ebb82f3.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u858e1208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=367&amp;originWidth=574&amp;originalType=url&amp;ratio=1&amp;size=31656&amp;status=done&amp;style=none&amp;taskId=ufabadec8-dba7-459a-96b4-f8fcba3d2d0\" width=\"574\" id=\"ed7mI\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">前面已经删除了节点 6，假设我们现在要删除节点 5，它有一个左子节点 3，我们依然传入根节点 11，来看看整个执行过程：</span></p><p id=\"u043057b7\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"uc615aedf\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=11，key=5，5&lt;11，递归执行 removeNode(7, 5)</span></li><li id=\"u92ab769b\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=7，key=5，5&lt;7，递归执行 removeNode(5, 5)</span></li><li id=\"u8ab26f80\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=5，key=5，5=5，并且节点 5 的 prev=3，next=null，所以我们将节点 5 替换成它的左子节点 3，并返回节点 3</span></li><li id=\"u914be9e2\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 2，节点 7 的 next 将获取步骤 3 的返回值 3</span></li><li id=\"u0a3999dc\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 1，节点 11 的 prev 依然指向节点 7，保持不变</span></li><li id=\"u93491eca\" data-lake-index-type=\"0\"><span class=\"ne-text\">最后返回节点 11</span></li></ol><p id=\"u77bdebba\" class=\"ne-p\"><br></p><p id=\"u0d6e6c69\" class=\"ne-p\"><span class=\"ne-text\">我们不需要将节点 5 从内存中删除，它会自动被 JavaScript 的垃圾回收器清理掉，这个在</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" data-href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《JavaScript 数据结构——链表的实现与应用》</span></a><span class=\"ne-text\">一文中已经介绍过。以上步骤是针对目标节点有左子节点的情况，对于有右子节点情况，执行过程是类似的。<br /></span><span class=\"ne-text\">最后再来看第三种情况：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366703878-eabb73a8-4bb7-4a5c-bc6b-99bb8b30eff3.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=uec3c6148&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=374&amp;originWidth=554&amp;originalType=url&amp;ratio=1&amp;size=34149&amp;status=done&amp;style=none&amp;taskId=ub5b588f7-2899-4778-94d0-bbcd5d3372f\" width=\"554\" id=\"hbvNc\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">前面已经删除了节点 6 和节点 5，现在我们要删除节点 15，它有左右子树，我们传入根节点 11，来看下具体执行过程：</span></p><p id=\"u63612160\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u67f146f5\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=11，key=15，15&gt;11，递归执行 removeNode(15, 15)</span></li><li id=\"u85c1a0d1\" data-lake-index-type=\"0\"><span class=\"ne-text\">node=15，key=15，15=15，此时我们需要找到节点 15 的右子树中的最小节点 18，将节点 15 的 key 替换成节点 18 的 key，然后将节点 15 的 next 节点（即节点 20）作为起始节点进行遍历，找到并删除节点 18，最后再将节点 15（此时它的 key 是 18）的 next 指针指向节点 20，并返回节点 15</span></li><li id=\"u3d72edeb\" data-lake-index-type=\"0\"><span class=\"ne-text\">递归返回到步骤 1，节点 11 的 next 依然指向节点 15，但此时节点 15 的 key 已经变成 18 了</span></li><li id=\"u4ab2d732\" data-lake-index-type=\"0\"><span class=\"ne-text\">最后返回节点 11</span></li></ol><p id=\"udc9e4a59\" class=\"ne-p\"><br></p><p id=\"u6c82ae8c\" class=\"ne-p\"><span class=\"ne-text\">试想一下，当删除节点 15 之后，为了保证我们的二叉搜索树结构稳定，必须用节点 15 的右子树中的最小节点来替换节点 15，如果直接将 11 的 next 指向 20，则 20 将会有三个子节点 13、18、25，这显然已经不符合我们二叉树的定义了。如果将节点 25 用来替换节点 15，节点 20 的值比节点 25 的值小，不应该出现在右子节点，这也不符合我们的二叉搜索树的定义。所以，只有按照上述过程才能既保证不破坏树的结构，又能删除节点。<br /></span><span class=\"ne-text\">我们已经完成了一开始我们定义的二叉搜索树 BinarySearchTree 类的所有方法，下面是它的完整代码：</span></p><p id=\"u653bbaeb\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"02819d20\" class=\"ne-codeblock language-javascript\">let insertNode = function (node, newNode) {\n    if (newNode.element &lt; node.element) {\n        if (node.prev === null) node.prev = newNode\n        else insertNode(node.prev, newNode)\n    } else {\n        if (node.next === null) node.next = newNode\n        else insertNode(node.next, newNode)\n    }\n}\n\nlet preOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        callback(node.element)\n        preOrderTraverseNode(node.prev, callback)\n        preOrderTraverseNode(node.next, callback)\n    }\n}\n\nlet inOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        inOrderTraverseNode(node.prev, callback)\n        callback(node.element)\n        inOrderTraverseNode(node.next, callback)\n    }\n}\n\nlet postOrderTraverseNode = function (node, callback) {\n    if (node !== null) {\n        postOrderTraverseNode(node.prev, callback)\n        postOrderTraverseNode(node.next, callback)\n        callback(node.element)\n    }\n}\n\nlet minNode = function (node) {\n    if (node === null) return null\n\n    while (node &amp;&amp; node.prev !== null) {\n        node = node.prev\n    }\n    return node\n}\n\nlet maxNode = function (node) {\n    if (node === null) return null\n\n    while (node &amp;&amp; node.next !== null) {\n        node = node.next\n    }\n    return node\n}\n\nlet searchNode = function (node, key) {\n    if (node === null) return false\n\n    if (key &lt; node.element) return searchNode(node.prev, key)\n    else if (key &gt; node.element) return searchNode(node.next, key)\n    else return true\n}\n\nlet removeNode = function (node, key) {\n    if (node === null) return null\n\n    if (key &lt; node.element) {\n        node.prev = removeNode(node.prev, key)\n        return node\n    } else if (key &gt; node.element) {\n        node.next = removeNode(node.next, key)\n        return node\n    } else {\n        // 第一种情况：一个叶子节点（没有子节点）\n        if (node.prev === null &amp;&amp; node.next === null) {\n            node = null\n            return node\n        }\n        // 第二种情况：只包含一个子节点\n        if (node.prev === null) {\n            node = node.next\n            return node\n        } else if (node.next === null) {\n            node = node.prev\n            return node\n        }\n\n        // 第三种情况：有两个子节点\n        let aux = minNode(node.next)\n        node.element = aux.element\n        node.next = removeNode(node.next, aux.element)\n        return node\n    }\n}\n\nclass BinarySearchTree {\n    constructor() {\n        this.root = null\n    }\n\n    // 向树中插入一个节点\n    insert(key) {\n        let newNode = new Node(key)\n\n        if (this.root === null) this.root = newNode\n        else insertNode(this.root, newNode)\n    }\n\n    // 在树中查找一个节点\n    search(key) {\n        return searchNode(this.root, key)\n    }\n\n    // 通过先序遍历方式遍历树中的所有节点\n    preOrderTraverse(callback) {\n        preOrderTraverseNode(this.root, callback)\n    }\n\n    // 通过中序遍历方式遍历树中的所有节点\n    inOrderTraverse(callback) {\n        inOrderTraverseNode(this.root, callback)\n    }\n\n    // 通过后序遍历方式遍历树中的所有节点\n    postOrderTraverse(callback) {\n        postOrderTraverseNode(this.root, callback)\n    }\n\n    // 返回树中的最小节点\n    min() {\n        return minNode(this.root)\n    }\n\n    // 返回树中的最大节点\n    max() {\n        return maxNode(this.root)\n    }\n\n    // 从树中移除一个节点\n    remove(key) {\n        this.root = removeNode(this.root, key)\n    }\n}</pre><p id=\"udf3c6297\" class=\"ne-p\"><br></p><p id=\"u2c12a250\" class=\"ne-p\"><br></p><p id=\"u24ecdaa7\" class=\"ne-p\"><br></p><h3 id=\"4242da52\"><span class=\"ne-text\">自平衡树</span></h3><p id=\"ubd9be9d5\" class=\"ne-p\"><br></p><p id=\"ub9f84f4b\" class=\"ne-p\"><span class=\"ne-text\">上面的 BST 树（二叉搜索树）存在一个问题，树的一条边可能会非常深，而其它边却只有几层，这会在这条很深的分支上添加、移除和搜索节点时引起一些性能问题。如下图所示：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366726947-232e09a9-43e1-4fbf-86e4-fdcdf8427300.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u4d5fbb30&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=653&amp;originWidth=704&amp;originalType=url&amp;ratio=1&amp;size=45808&amp;status=done&amp;style=none&amp;taskId=u22b890aa-8a23-476c-b752-cad00a2716e\" width=\"704\" id=\"tppDP\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">为了解决这个问题，我们引入了自平衡二叉搜索树（AVL——Adelson-Velskii-Landi）。在 AVL 中，任何一个节点左右两棵子树的高度之差最多为 1，添加或移除节点时，AVL 树会尝试自平衡。对 AVL 树的操作和对 BST 树的操作一样，不同点在于我们还需要重新平衡 AVL 树，在讲解对 AVL 树的平衡操作之前，我们先看一下什么是 AVL 树的平衡因子。<br /></span><span class=\"ne-text\">前面我们介绍过什么是树（子树）的高度，对于 AVL 树来说，每一个节点都保存一个平衡因子。<br /></span><strong><span class=\"ne-text\">节点的平衡因子 = 左子树的高度 - 右子树的高度</span></strong><span class=\"ne-text\"><br /></span><span class=\"ne-text\">观察下面这棵树，我们在上面标注了每个节点的平衡因子的值：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366726954-d758e030-e4b2-4588-8e56-38eea7451881.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u06bf5f7a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=401&amp;originWidth=578&amp;originalType=url&amp;ratio=1&amp;size=27946&amp;status=done&amp;style=none&amp;taskId=u6bfe9e2b-e524-4a2c-a713-0eb04ae3115\" width=\"578\" id=\"j9sOd\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">所有子节点的平衡因子都为 0，因为子节点没有子树。节点 5 的左右子树的高度都为 1，所以节点 5 的平衡因子是 0。节点 9 的左子树高度为 1，右子树高度为 0，所以节点 9 的平衡因子是+1。节点 13 的左子树高度为 0，右子树高度为 1，所以节点 13 的平衡因子是-1......AVL 树的所有节点的平衡因子保持三个值：0、+1 或-1。同时，我们也注意到，当某个节点的平衡因子为+1 时，它的子树是向左倾斜的（left-heavy）；而当某个节点的平衡因子为-1 时，它的子树是向右倾斜的（right-heavy）；当节点的平衡因子为 0 时，该节点是平衡的。一颗子树的根节点的平衡因子代表了该子树的平衡性。<br /></span><span class=\"ne-text\">为了使 AVL 树重新达到平衡状态，我们需要对 AVL 树中的部分节点进行重新排列，使其既符合二叉搜索树的定义，又符合自平衡二叉树的定义，这个过程叫做 AVL 树的旋转。<br /></span><span class=\"ne-text\">AVL 树的旋转一共分为四种：</span></p><p id=\"uf818271e\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u5c5c59e9\" data-lake-index-type=\"0\"><span class=\"ne-text\">LL（left-left）旋转，新添加的节点位于树的根节点的左子树的左子树上。以非平衡因子的节点为中心将整棵树向右旋转。</span></li><li id=\"u74683476\" data-lake-index-type=\"0\"><span class=\"ne-text\">LR（left-right）旋转，新添加的节点位于树的根节点的左子树的右子树上。先执行 RR 旋转，然后再执行 LL 旋转。</span></li><li id=\"u751510d1\" data-lake-index-type=\"0\"><span class=\"ne-text\">RR（right-right）旋转，新添加的节点位于树的根节点的右子树的右子树上。以非平衡因子的节点为中心将整棵树向左旋转。</span></li><li id=\"ufa362930\" data-lake-index-type=\"0\"><span class=\"ne-text\">RL（right-left）旋转，新添加的节点位于树的根节点的右子树的左子树上。先执行 LL 旋转，然后再执行 RR 旋转。</span></li></ul><p id=\"ubd6a9f83\" class=\"ne-p\"><br></p><p id=\"u33393c16\" class=\"ne-p\"><span class=\"ne-text\">下面是这四种旋转的操作示意图，后面我们会详细介绍每一种旋转的操作过程：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366727001-4ce9f99f-916a-40e6-ad25-3d9adbb16324.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=uf989ab3a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1277&amp;originWidth=897&amp;originalType=url&amp;ratio=1&amp;size=110075&amp;status=done&amp;style=none&amp;taskId=u7e881633-f8cc-458a-9cf2-e8c5f2705ac\" width=\"897\" id=\"OshVa\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">对于 LL 旋转，在节点 5 的右子节点上添加节点 4 与在左子节点上添加节点 3 等同。对于 LR 旋转，在节点 9 的左子节点上添加节点 8 与在右子节点上添加节点 10 等同。对于 RR 旋转，在节点 20 的右子节点上添加节点 25 与在左子节点上添加节点 18 等同。对于 RL 旋转，在节点 13 的右子节点上添加节点 14 与在左子节点上添加节点 12 等同。<br /></span><span class=\"ne-text\">我们的自平衡二叉树 AVLTree 类将从 BinarySearchTree 类继承，同时我们需要新增一个方法 getNodeHeight()用来获取任意节点的高度。</span></p><p id=\"ud9c1bf97\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"975019c3\" class=\"ne-codeblock language-javascript\">class AVLTree extends BinarySearchTree {\n    constructor() {\n        super()\n    }\n\n    // 计算节点的高度\n    getNodeHeight(node) {\n        if (node === null) return 0\n        return Math.max(this.getNodeHeight(node.prev), this.getNodeHeight(node.next)) + 1\n    }\n}</pre><p id=\"u9ac62eae\" class=\"ne-p\"><br></p><p id=\"u9ae882c8\" class=\"ne-p\"><span class=\"ne-text\">测试一下 getNodeHeight()方法，我们还是以本文一开始的那棵树为例，然后看一下不同节点的高度。</span></p><p id=\"u402ea17f\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"f3f80ff5\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(13)\ntree.insert(20)\ntree.insert(3)\ntree.insert(6)\ntree.insert(8)\ntree.insert(10)\ntree.insert(12)\ntree.insert(14)\ntree.insert(18)\ntree.insert(25)\n\nconsole.log(tree.getNodeHeight(tree.root)) // 4\nconsole.log(tree.getNodeHeight(tree.search(7))) // 3\nconsole.log(tree.getNodeHeight(tree.search(5))) // 2\nconsole.log(tree.getNodeHeight(tree.min(7))) // 1</pre><p id=\"u2aea32cb\" class=\"ne-p\"><br></p><p id=\"u71d40c0f\" class=\"ne-p\"><span class=\"ne-text\">根节点的高度为 4，最小节点 3 的高度为 1，节点 5 和节点 7 的高度分别为 2 和 3。<br /></span><span class=\"ne-text\">下面是四种旋转对应的实现代码：</span></p><p id=\"uce886aea\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3753eead\" class=\"ne-codeblock language-javascript\">/**\n * LL旋转: 向右旋转\n *\n *       b                           a\n *      / \\                         / \\\n *     a   e -&gt; rotationLL(b) -&gt;   c   b\n *    / \\                         /   / \\\n *   c   d                       f   d   e\n *  /\n * f\n *\n * @param node Node&lt;T&gt;\n */\nrotationLL(node) {\n    let tmp = node.prev;\n    node.prev = tmp.next;\n    tmp.next = node;\n    return tmp;\n}\n\n/**\n * RR旋转: 向左旋转\n *\n *     a                              b\n *    / \\                            / \\\n *   c   b   -&gt; rotationRR(a) -&gt;    a   e\n *      / \\                        / \\   \\\n *     d   e                      c   d   f\n *          \\\n *           f\n *\n * @param node Node&lt;T&gt;\n */\nrotationRR(node) {\n    let tmp = node.next;\n    node.next = tmp.prev;\n    tmp.prev = node;\n    return tmp;\n}\n\n/**\n * LR旋转: 先向左旋转，然后再向右旋转\n * @param node Node&lt;T&gt;\n */\nrotationLR(node) {\n    node.prev = this.rotationRR(node.prev);\n    return this.rotationLL(node);\n}\n\n/**\n * RL旋转: 先向右旋转，然后再向左旋转\n * @param node Node&lt;T&gt;\n */\nrotationRL(node) {\n    node.next = this.rotationLL(node.next);\n    return this.rotationRR(node);\n}</pre><p id=\"ueb3f3ffc\" class=\"ne-p\"><br></p><p id=\"u0a434095\" class=\"ne-p\"><span class=\"ne-text\">对于 LL 旋转和 RR 旋转，我们可以按照上面的示意图来看下执行过程。<br /></span><span class=\"ne-text\">LL 旋转，node=11，node.prev 是 7，所以 tmp=7。然后将 node.prev 指向 tmp.next，即将 11 的 prev 指向 9。接着将 tmp.next 指向 node，即将 7 的 next 指向 11。即完成了图中所示的旋转。<br /></span><span class=\"ne-text\">RR 旋转，node=11，node.next 是 15，所以 tmp=15。然后将 node.next 指向 tmp.prev，即将 11 的 next 指向 13。接着将 tmp.prev 指向 node，即将 15 的 prev 指向 11。即完成了图中所示的旋转。<br /></span><span class=\"ne-text\">LR 旋转是 RR 旋转和 LL 旋转的组合：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366769856-ab121a06-9ed4-4b47-8edd-6f6d1e0d621c.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u538e009c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=324&amp;originWidth=1150&amp;originalType=url&amp;ratio=1&amp;size=41879&amp;status=done&amp;style=none&amp;taskId=u2e0b1abc-05ac-40b8-9183-94fb9ecfbc1\" width=\"1150\" id=\"e2d8f\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">RL 旋转是 LL 旋转和 RR 旋转的组合：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366769875-da7538c0-c022-40ac-b858-6bdb9fa4d86b.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u543e3617&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=310&amp;originWidth=1050&amp;originalType=url&amp;ratio=1&amp;size=39803&amp;status=done&amp;style=none&amp;taskId=u8e8d14e4-2b60-452c-bc98-0b61afb010b\" width=\"1050\" id=\"FDr5y\" class=\"ne-image\"><span class=\"ne-text\"><br /></span><span class=\"ne-text\">按照上面给出的示意图，我们的 AVLTree 类的 insert()方法的实现如下：</span></p><p id=\"u257f135d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"efd3069a\" class=\"ne-codeblock language-javascript\">insert (key) {\n    super.insert(key);\n\n    // 左子树高度大于右子树高度\n    if (this.getNodeHeight(this.root.prev) - this.getNodeHeight(this.root.next) &gt; 1) {\n        if (key &lt; this.root.prev.element) {\n            this.root = this.rotationLL(this.root);\n        }\n        else {\n            this.root = this.rotationLR(this.root);\n        }\n    }\n    // 右子树高度大于左子树高度\n    else if (this.getNodeHeight(this.root.next) - this.getNodeHeight(this.root.prev) &gt; 1) {\n        if (key &gt; this.root.next.element) {\n            this.root = this.rotationRR(this.root);\n        }\n        else {\n            this.root = this.rotationRL(this.root);\n        }\n    }\n}</pre><p id=\"u7fcbaf24\" class=\"ne-p\"><br></p><p id=\"u57ac7d55\" class=\"ne-p\"><span class=\"ne-text\">我们依次测试一下这四种情况。按照上面示意图中树的结构添加节点，然后按照前序遍历的方式打印节点的 key。<br /></span><span class=\"ne-text\">LL 旋转的结果：</span></p><p id=\"u00ff4b66\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"802f2927\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(3)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u3ef98a1d\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"4f36efd5\" class=\"ne-codeblock language-javascript\">7\n5\n3\n11\n9\n15</pre><p id=\"uc61ddbe3\" class=\"ne-p\"><br></p><p id=\"ubc243f2f\" class=\"ne-p\"><span class=\"ne-text\">LR 旋转的结果：</span></p><p id=\"ufed3f2dd\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"67d475fa\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\ntree.insert(8)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"ua6a00062\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"c678dfc1\" class=\"ne-codeblock language-javascript\">9\n7\n5\n8\n11\n15</pre><p id=\"u7afd102a\" class=\"ne-p\"><br></p><p id=\"uda228c3f\" class=\"ne-p\"><span class=\"ne-text\">RR 旋转的结果：</span></p><p id=\"u32047a98\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"d7155155\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(13)\ntree.insert(20)\ntree.insert(25)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u4b8343ce\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"5cfa3f1d\" class=\"ne-codeblock language-javascript\">15\n11\n7\n13\n20\n25</pre><p id=\"u0805aef5\" class=\"ne-p\"><br></p><p id=\"u51106d6a\" class=\"ne-p\"><span class=\"ne-text\">RL 旋转的结果：</span></p><p id=\"ud1796320\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3196272b\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(13)\ntree.insert(20)\ntree.insert(14)\n\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"ud30a2477\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"5064065c\" class=\"ne-codeblock language-javascript\">13\n11\n7\n15\n14\n20</pre><p id=\"ub8db72f4\" class=\"ne-p\"><br></p><p id=\"u00d1a8ca\" class=\"ne-p\"><span class=\"ne-text\">我们用同样的方式修改 remove()方法，然后测试下面两种情况下的节点删除：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366865115-c8cbbf63-c8f0-4ca5-be96-6373b5bc0fd5.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u1e7f4a39&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=308&amp;originWidth=704&amp;originalType=url&amp;ratio=1&amp;size=20770&amp;status=done&amp;style=none&amp;taskId=uad71c3ad-032d-4d6d-9c0f-7f568a55270\" width=\"704\" id=\"hgIxB\" class=\"ne-image\"></p><p id=\"u3b3eaaaa\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ddee005f\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(9)\n\ntree.remove(15)\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u01af3d96\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0b72114e\" class=\"ne-codeblock language-javascript\">9\n7\n5\n11</pre><p id=\"u6a580fc2\" class=\"ne-p\"><br></p><p id=\"ufad16cc4\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646366895308-5fa8c8ce-c945-4448-bf40-0bf0dc7a71cc.png#clientId=u6552ee0d-54a8-4&amp;from=paste&amp;id=u62412dfb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=280&amp;originWidth=682&amp;originalType=url&amp;ratio=1&amp;size=20738&amp;status=done&amp;style=none&amp;taskId=ue9c074e3-dc24-496c-88c2-426bfc67dbc\" width=\"682\" id=\"FvN2q\" class=\"ne-image\"></p><p id=\"u55fc6189\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"3c6969d0\" class=\"ne-codeblock language-javascript\">let tree = new AVLTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(13)\ntree.insert(20)\n\ntree.remove(7)\ntree.preOrderTraverse(value =&gt; console.log(value))</pre><p id=\"u9e413cc5\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0aaaba55\" class=\"ne-codeblock language-javascript\">13\n11\n15\n20</pre><p id=\"ucae72592\" class=\"ne-p\"><br></p><p id=\"u14bfb527\" class=\"ne-p\"><span class=\"ne-text\">完整的自平衡二叉搜索树 AVLTree 类的代码如下：</span></p><p id=\"uc5812851\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"0f5e2de9\" class=\"ne-codeblock language-javascript\">class AVLTree extends BinarySearchTree {\n    constructor() {\n        super()\n    }\n\n    // 计算节点的高度\n    getNodeHeight(node) {\n        if (node === null) return 0\n        return Math.max(this.getNodeHeight(node.prev), this.getNodeHeight(node.next)) + 1\n    }\n\n    // 获取节点的平衡因子\n\n    /**\n     * LL旋转: 向右旋转\n     *\n     *       b                           a\n     *      / \\                         / \\\n     *     a   e -&gt; rotationLL(b) -&gt;   c   b\n     *    / \\                         /   / \\\n     *   c   d                       f   d   e\n     *  /\n     * f\n     *\n     * @param node Node&lt;T&gt;\n     */\n    rotationLL(node) {\n        let tmp = node.prev\n        node.prev = tmp.next\n        tmp.next = node\n        return tmp\n    }\n\n    /**\n     * RR旋转: 向左旋转\n     *\n     *     a                              b\n     *    / \\                            / \\\n     *   c   b   -&gt; rotationRR(a) -&gt;    a   e\n     *      / \\                        / \\   \\\n     *     d   e                      c   d   f\n     *          \\\n     *           f\n     *\n     * @param node Node&lt;T&gt;\n     */\n    rotationRR(node) {\n        let tmp = node.next\n        node.next = tmp.prev\n        tmp.prev = node\n        return tmp\n    }\n\n    /**\n     * LR旋转: 先向左旋转，然后再向右旋转\n     * @param node Node&lt;T&gt;\n     */\n    rotationLR(node) {\n        node.prev = this.rotationRR(node.prev)\n        return this.rotationLL(node)\n    }\n    /**\n     * RL旋转: 先向右旋转，然后再向左旋转\n     * @param node Node&lt;T&gt;\n     */\n    rotationRL(node) {\n        node.next = this.rotationLL(node.next)\n        return this.rotationRR(node)\n    }\n\n    insert(key) {\n        super.insert(key)\n\n        // 左子树高度大于右子树高度\n        if (this.getNodeHeight(this.root.prev) - this.getNodeHeight(this.root.next) &gt; 1) {\n            if (key &lt; this.root.prev.element) {\n                this.root = this.rotationLL(this.root)\n            } else {\n                this.root = this.rotationLR(this.root)\n            }\n        }\n        // 右子树高度大于左子树高度\n        else if (this.getNodeHeight(this.root.next) - this.getNodeHeight(this.root.prev) &gt; 1) {\n            if (key &gt; this.root.next.element) {\n                this.root = this.rotationRR(this.root)\n            } else {\n                this.root = this.rotationRL(this.root)\n            }\n        }\n    }\n\n    remove(key) {\n        super.remove(key)\n\n        // 左子树高度大于右子树高度\n        if (this.getNodeHeight(this.root.prev) - this.getNodeHeight(this.root.next) &gt; 1) {\n            if (key &lt; this.root.prev.element) {\n                this.root = this.rotationLL(this.root)\n            } else {\n                this.root = this.rotationLR(this.root)\n            }\n        }\n        // 右子树高度大于左子树高度\n        else if (this.getNodeHeight(this.root.next) - this.getNodeHeight(this.root.prev) &gt; 1) {\n            if (key &gt; this.root.next.element) {\n                this.root = this.rotationRR(this.root)\n            } else {\n                this.root = this.rotationRL(this.root)\n            }\n        }\n    }\n}</pre><p id=\"ufba80d8e\" class=\"ne-p\"><br></p><p id=\"ue4355e65\" class=\"ne-p\"><span class=\"ne-text\">尽管自平衡二叉搜索树 AVL 可以很有效地帮助我们解决许多树节点的操作问题，但是在插入和移除节点时其性能并不是最好的。更好的选择是红黑树，红黑树也是一种自平衡二叉搜索树，但是它对其中的节点做了很多特殊的规定，使得在操作树节点的性能上要优于 AVL。</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"u1b2cfe0c\" id=\"u1b2cfe0c\"><a href=\"https://www.cnblogs.com/jaxu/p/11309385.html\" target=\"_blank\" data-lake-id=\"ua492966c\" id=\"ua492966c\"><span data-lake-id=\"ueb6d63f7\" id=\"ueb6d63f7\">链接</span></a><span data-lake-id=\"ua1534a8f\" id=\"ua1534a8f\"><br /><br /></span></p><p data-lake-id=\"u71efe663\" id=\"u71efe663\"><br></p><p data-lake-id=\"u48a6aeba\" id=\"u48a6aeba\"><span data-lake-id=\"u30082a8f\" id=\"u30082a8f\">在计算机科学中，树是一种十分重要的数据结构。树被描述为一种分层数据抽象模型，常用来描述数据间的层级关系和组织结构。树也是一种非顺序的数据结构。下图展示了树的定义：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366269569-5914f76c-55cf-479d-9682-fde5a1aff15a.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du04cbac7c%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D543%26originWidth%3D772%26originalType%3Durl%26ratio%3D1%26size%3D45229%26status%3Ddone%26style%3Dnone%26taskId%3Du0e3c43a3-4e6f-4650-a290-bab310866ca%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A772%2C%22originHeight%22%3A543%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f9f9f9%22%2C%22id%22%3A%22rEjjS%22%7D\"></card><span data-lake-id=\"ue042190c\" id=\"ue042190c\"><br /></span><span data-lake-id=\"uc9efa6b6\" id=\"uc9efa6b6\">在介绍如何用 JavaScript 实现树之前，我们先介绍一些和树相关的术语。<br /></span><span data-lake-id=\"u6c418575\" id=\"u6c418575\">如上图所示，一棵完整的树包含一个位于树顶部的节点，称之为根节点（11），它没有父节点。树中的每一个元素都叫做一个节点，节点分为内部节点（图中显示为黄色的节点）和外部节点（图中显示为灰色的节点），至少有一个子节点的节点称为内部节点，没有子元素的节点称为外部节点或叶子节点。一个节点可以有祖先（根节点除外）和后代。子树由节点本身和它的后代组成，如上图中三角虚框中的部分就是一棵子树。节点拥有的子树的个数称之为节点的度，如上图中除叶子节点的度为 0 外，其余节点的度都为 2。从根节点开始，根为第 1 层，第一级子节点为第 2 层，第二级子节点为第 3 层，以此类推。树的高度（深度）由树中节点的最大层级决定（上图中树的高度为 4）。<br /></span><span data-lake-id=\"u7b2f59cf\" id=\"u7b2f59cf\">在一棵树中，具有相同父节点的一组节点称为兄弟节点，如上图中的 3 和 6、5 和 9 等都是兄弟节点。</span></p><p data-lake-id=\"ue1f21414\" id=\"ue1f21414\"><br></p><h3 data-lake-id=\"8178ad6f\" id=\"8178ad6f\"><span data-lake-id=\"uc5114d4e\" id=\"uc5114d4e\">二叉树</span></h3><p data-lake-id=\"u8f792453\" id=\"u8f792453\"><br></p><p data-lake-id=\"u4de83d74\" id=\"u4de83d74\"><span data-lake-id=\"u30c1974f\" id=\"u30c1974f\">二叉树中的节点最多只能有两个子节点，一个是左子节点，一个是右子节点。左右子节点的顺序不能颠倒。因此，二叉树中不存在度大于 2 的节点。<br /></span><span data-lake-id=\"u554dc712\" id=\"u554dc712\">二叉搜索树（BST——Binary Search Tree）是二叉树的一种，它规定在左子节点上存储小（比父节点）的值，在右子节点上（比父节点）存储大（或等于）的值。上图就是一个二叉搜索树。<br /></span><span data-lake-id=\"uc60cc3a7\" id=\"uc60cc3a7\">下面我们重点来看一下二叉搜索树的实现。<br /></span><span data-lake-id=\"u1407e9ad\" id=\"u1407e9ad\">根据二叉树的描述，一个节点最多只有两个子节点，我们可以使用</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" data-lake-id=\"uda269bf9\" id=\"uda269bf9\"><span data-lake-id=\"u30312976\" id=\"u30312976\">《JavaScript 数据结构——链表的实现与应用》</span></a><span data-lake-id=\"uee065b2c\" id=\"uee065b2c\">一文中的双向链表来实现二叉搜索树中的每一个节点。下面是二叉搜索树的数据结构示意图：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366269506-0f79bff0-9217-49a5-889b-39da82b1ef61.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du73eea400%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D337%26originWidth%3D650%26originalType%3Durl%26ratio%3D1%26size%3D21031%26status%3Ddone%26style%3Dnone%26taskId%3Du7e9d9fa0-fa0b-4795-a4b0-1d49a8ad7f1%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A650%2C%22originHeight%22%3A337%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f3f3f3%22%2C%22id%22%3A%22rNgNh%22%7D\"></card><span data-lake-id=\"ua0763310\" id=\"ua0763310\"><br /></span><span data-lake-id=\"u8ad3930d\" id=\"u8ad3930d\">以下是我们要实现的 BinarySearchTree 类的骨架部分：<br /></span><span data-lake-id=\"u2f488483\" id=\"u2f488483\">​</span></p><p data-lake-id=\"ue60b4729\" id=\"ue60b4729\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20BinarySearchTree%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20this.root%20%3D%20null%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%90%91%E6%A0%91%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%5Cn%20%20%20%20insert(key)%20%7B%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%9C%A8%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%5Cn%20%20%20%20search(key)%20%7B%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E9%81%8D%E5%8E%86%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%5Cn%20%20%20%20inOrderTraverse()%20%7B%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E9%81%8D%E5%8E%86%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%5Cn%20%20%20%20preOrderTraverse()%20%7B%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E9%81%8D%E5%8E%86%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%5Cn%20%20%20%20postOrderTraverse()%20%7B%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%8A%82%E7%82%B9%5Cn%20%20%20%20min()%20%7B%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%8A%82%E7%82%B9%5Cn%20%20%20%20max()%20%7B%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E4%BB%8E%E6%A0%91%E4%B8%AD%E7%A7%BB%E9%99%A4%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%5Cn%20%20%20%20remove(key)%20%7B%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2219ae2f58%22%7D\"></card><p data-lake-id=\"u2f0c439d\" id=\"u2f0c439d\"><br></p><p data-lake-id=\"uf0750dae\" id=\"uf0750dae\"><span data-lake-id=\"u10840c01\" id=\"u10840c01\">先来看看向树中添加一个节点。我们借用</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" data-lake-id=\"u77211d7a\" id=\"u77211d7a\"><span data-lake-id=\"u8fca6a5c\" id=\"u8fca6a5c\">《JavaScript 数据结构——链表的实现与应用》</span></a><span data-lake-id=\"u5a85b767\" id=\"u5a85b767\">一文中的双向链表 DoubleLinkedList 类来模拟树中的节点，在 DoubleLinkedList 类中，每一个节点有三个属性：element、next 和 prev。我们在这里用 element 表示树中节点的 key，用 next 表示树中节点的右子节点（right），用 prev 表示树中节点的左子节点（left）。</span></p><p data-lake-id=\"u8a9f0fb8\" id=\"u8a9f0fb8\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22insert%20(key)%20%7B%5Cn%20%20%20%20let%20newNode%20%3D%20new%20Node(key)%3B%5Cn%5Cn%20%20%20%20if%20(this.root%20%3D%3D%3D%20null)%20this.root%20%3D%20newNode%3B%5Cn%20%20%20%20else%20insertNode(this.root%2C%20newNode)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22b651088a%22%7D\"></card><p data-lake-id=\"u415432ad\" id=\"u415432ad\"><br></p><p data-lake-id=\"u78703efe\" id=\"u78703efe\"><span data-lake-id=\"u38438b0e\" id=\"u38438b0e\">当树的 root 为 null 时，表示树为空，这时直接将新添加的节点作为树的根节点。否则，我们需要借助于私有函数 insertNode()来完成节点的添加。在 insertNode()函数中，我们需要根据新添加节点的 key 的大小来递归查找树的左侧子节点或者右侧子节点，因为根据我们的二叉搜索树的定义，值小的节点永远保存在左侧子节点上，值大的节点（包括值相等的情况）永远保存在右侧子节点上。下面是 insertNode()函数的实现代码：</span></p><p data-lake-id=\"u59530ec7\" id=\"u59530ec7\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20insertNode%20%3D%20function%20(node%2C%20newNode)%20%7B%5Cn%20%20%20%20if%20(newNode.element%20%3C%20node.element)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(node.prev%20%3D%3D%3D%20null)%20node.prev%20%3D%20newNode%5Cn%20%20%20%20%20%20%20%20else%20insertNode(node.prev%2C%20newNode)%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(node.next%20%3D%3D%3D%20null)%20node.next%20%3D%20newNode%5Cn%20%20%20%20%20%20%20%20else%20insertNode(node.next%2C%20newNode)%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22263f076f%22%7D\"></card><p data-lake-id=\"u35a9dcbc\" id=\"u35a9dcbc\"><br></p><p data-lake-id=\"u3ea26f25\" id=\"u3ea26f25\"><span data-lake-id=\"u9a3a6344\" id=\"u9a3a6344\">所有新节点只能作为叶子节点被添加到树中。在本文一开始给出的树的结构图中，如果要添加节点 2，对应的操作步骤如下：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366466710-c235e8f1-3278-4e15-90ce-3a2194ab6f93.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du0f0e6dc0%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D472%26originWidth%3D657%26originalType%3Durl%26ratio%3D1%26size%3D36604%26status%3Ddone%26style%3Dnone%26taskId%3Du62e15592-6def-4696-9af8-54bd87ce215%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A657%2C%22originHeight%22%3A472%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23fafafa%22%2C%22id%22%3A%22v6cPo%22%7D\"></card><span data-lake-id=\"uffb8aa9b\" id=\"uffb8aa9b\"><br /></span><span data-lake-id=\"u1a329a96\" id=\"u1a329a96\">我们传入树的根节点，依次进行递归，找到对应的叶子节点，然后修改节点的 prev（左子节点）或 next（右子节点）指针，使其指向新添加的节点。在上例中，如果要添加节点 4，它对应的位置应该是节点 3 的右子节点，因为 4 比 3 大。如果要添加节点 21，对应的位置应该是节点 25 的左子节点......<br /></span><span data-lake-id=\"uf909c052\" id=\"uf909c052\">下面我们来看看树的三种遍历方式：</span></p><p data-lake-id=\"uc3a25cf6\" id=\"uc3a25cf6\"><br></p><ul list=\"u0e3ba00d\"><li fid=\"uf319db3f\" data-lake-id=\"ucc1ea31c\" id=\"ucc1ea31c\"><span data-lake-id=\"u2e7c3da4\" id=\"u2e7c3da4\">前序遍历（NLR——Preorder Traversal）也叫先序遍历，访问根节点的操作发生在遍历其左右子树之前。</span></li><li fid=\"uf319db3f\" data-lake-id=\"uc72ff6bb\" id=\"uc72ff6bb\"><span data-lake-id=\"u99da57d1\" id=\"u99da57d1\">中序遍历（LNR——Inorder Traversal），访问根节点的操作发生在遍历其左右子树之间。</span></li><li fid=\"uf319db3f\" data-lake-id=\"ue2d6d758\" id=\"ue2d6d758\"><span data-lake-id=\"ue87e5f34\" id=\"ue87e5f34\">后序遍历（LRN——Postorder Traversal），访问根节点的操作发生在遍历其左右子树之后。</span></li></ul><p data-lake-id=\"uec3358a5\" id=\"uec3358a5\"><br></p><p data-lake-id=\"u800c81d5\" id=\"u800c81d5\"><span data-lake-id=\"u10554c78\" id=\"u10554c78\">下面的三个方法对应树的三种遍历方式：</span></p><p data-lake-id=\"u25890f44\" id=\"u25890f44\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%5Cnlet%20preOrderTraverseNode%20%3D%20function%20(node%2C%20callback)%20%7B%5Cn%20%20%20%20if%20(node%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20callback(node.element)%5Cn%20%20%20%20%20%20%20%20preOrderTraverseNode(node.prev%2C%20callback)%5Cn%20%20%20%20%20%20%20%20preOrderTraverseNode(node.next%2C%20callback)%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%5Cnlet%20inOrderTraverseNode%20%3D%20function%20(node%2C%20callback)%20%7B%5Cn%20%20%20%20if%20(node%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20inOrderTraverseNode(node.prev%2C%20callback)%5Cn%20%20%20%20%20%20%20%20callback(node.element)%5Cn%20%20%20%20%20%20%20%20inOrderTraverseNode(node.next%2C%20callback)%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%5Cnlet%20postOrderTraverseNode%20%3D%20function%20(node%2C%20callback)%20%7B%5Cn%20%20%20%20if%20(node%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20postOrderTraverseNode(node.prev%2C%20callback)%5Cn%20%20%20%20%20%20%20%20postOrderTraverseNode(node.next%2C%20callback)%5Cn%20%20%20%20%20%20%20%20callback(node.element)%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2229b19ab6%22%7D\"></card><p data-lake-id=\"u7a023ae2\" id=\"u7a023ae2\"><br></p><p data-lake-id=\"u40002bff\" id=\"u40002bff\"><span data-lake-id=\"u2b299703\" id=\"u2b299703\">可以看到，这三个函数的内容很相似，只是调整了左右子树和根节点的遍历顺序。这里的 callback 是一个回调函数，可以传入任何你想执行的函数，这里我们传入的函数内容是打印树的节点的 key 值。我们将 BinarySearchTree 类的这三个遍历方法的内容补充完整：</span></p><p data-lake-id=\"u44f8333a\" id=\"u44f8333a\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22preOrderTraverse%20(callback)%20%7B%5Cn%20%20%20%20preOrderTraverseNode(this.root%2C%20callback)%3B%5Cn%7D%5Cn%5CninOrderTraverse%20(callback)%20%7B%5Cn%20%20%20%20inOrderTraverseNode(this.root%2C%20callback)%3B%5Cn%7D%5Cn%5CnpostOrderTraverse%20(callback)%20%7B%5Cn%20%20%20%20postOrderTraverseNode(this.root%2C%20callback)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22b742e38b%22%7D\"></card><p data-lake-id=\"u44572730\" id=\"u44572730\"><br></p><p data-lake-id=\"u0510d4e7\" id=\"u0510d4e7\"><span data-lake-id=\"ueaf340c6\" id=\"ueaf340c6\">为了构建本文一开始的那棵树，我们执行下面的代码，然后测试 preOrderTraverse()方法：</span></p><p data-lake-id=\"u3fe6e1d3\" id=\"u3fe6e1d3\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20tree%20%3D%20new%20BinarySearchTree()%5Cntree.insert(11)%5Cntree.insert(7)%5Cntree.insert(15)%5Cntree.insert(5)%5Cntree.insert(9)%5Cntree.insert(13)%5Cntree.insert(20)%5Cntree.insert(3)%5Cntree.insert(6)%5Cntree.insert(8)%5Cntree.insert(10)%5Cntree.insert(12)%5Cntree.insert(14)%5Cntree.insert(18)%5Cntree.insert(25)%5Cn%5Cntree.preOrderTraverse(value%20%3D%3E%20console.log(value))%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%223c42dcaa%22%7D\"></card><p data-lake-id=\"u22112e7b\" id=\"u22112e7b\"><br></p><p data-lake-id=\"uab8de858\" id=\"uab8de858\"><span data-lake-id=\"ue3ae1d51\" id=\"ue3ae1d51\">注意节点插入的顺序，顺序不同，你可能会得到不一样的树。preOrderTraverse()方法采用 ES6 的语法传入了一个匿名函数作为参数 callback 的值，这个匿名函数的主要作用就是打印树中节点的 key 值，可以对照上面三个遍历树节点的函数中的 callback(node.element)语句，这里的 callback 就是这个匿名函数，node.element 就是节点的 key 值（还记得前面我们说过，借用双向链表类 DoubleLinkedList 来模拟树的节点吗？）下面是前序遍历的执行结果：</span></p><p data-lake-id=\"uf0a833a5\" id=\"uf0a833a5\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22plain%22%2C%22code%22%3A%2211%5Cn7%5Cn5%5Cn3%5Cn6%5Cn9%5Cn8%5Cn10%5Cn15%5Cn13%5Cn12%5Cn14%5Cn20%5Cn18%5Cn25%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22d13cccaf%22%7D\"></card><p data-lake-id=\"uce4d13aa\" id=\"uce4d13aa\"><br></p><p data-lake-id=\"u06b21e2a\" id=\"u06b21e2a\"><span data-lake-id=\"uec6e9e0c\" id=\"uec6e9e0c\">我们参照前序遍历的定义，借住下面的示意图来理解整个遍历过程：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366532033-7670baed-24f5-495d-b7c2-1163e92165e7.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Duc206c787%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D429%26originWidth%3D577%26originalType%3Durl%26ratio%3D1%26size%3D37165%26status%3Ddone%26style%3Dnone%26taskId%3Du162713c1-346a-4dad-93db-99c316289d6%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A577%2C%22originHeight%22%3A429%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f7f7f7%22%2C%22id%22%3A%22ttKwe%22%7D\"></card><span data-lake-id=\"u0e7dc9e0\" id=\"u0e7dc9e0\"><br /></span><span data-lake-id=\"u02f40afc\" id=\"u02f40afc\">在前序遍历函数 preOrderTraverseNode()中，先执行 callback(node.element)，然后再依次递归左子树和右子树。我们将树的根节点作为第一个节点传入，首先打印的就是根节点 11，然后开始遍历左子树，这将依次打印左子树中的所有左子节点，依次是 7、5、3。当节点 3 的 prev 为 null 时，递归返回，继续查找节点 3 的右子节点，此时节点 3 的 next 值也为 null，于是继续向上返回到节点 5，开始遍历节点 5 的右子节点，于是打印节点 6......最终所有的节点就按照这个递归顺序进行遍历。<br /></span><span data-lake-id=\"ua6cb76ce\" id=\"ua6cb76ce\">然后我们再来看看中序遍历的情况。</span></p><p data-lake-id=\"u525da69f\" id=\"u525da69f\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22tree.inOrderTraverse(value%20%3D%3E%20console.log(value))%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22018cbef7%22%7D\"></card><p data-lake-id=\"uf2a78406\" id=\"uf2a78406\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22plain%22%2C%22code%22%3A%223%5Cn5%5Cn6%5Cn7%5Cn8%5Cn9%5Cn10%5Cn11%5Cn12%5Cn13%5Cn14%5Cn15%5Cn18%5Cn20%5Cn25%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%229b1fbd21%22%7D\"></card><p data-lake-id=\"u60fa605a\" id=\"u60fa605a\"><br></p><p data-lake-id=\"u7723171f\" id=\"u7723171f\"><span data-lake-id=\"u6fc0b240\" id=\"u6fc0b240\"><br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366564412-9c53be47-814a-4b8b-a7f4-d6a615420a08.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du822fc92d%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D378%26originWidth%3D576%26originalType%3Durl%26ratio%3D1%26size%3D41002%26status%3Ddone%26style%3Dnone%26taskId%3Duf10780f2-9708-405c-827f-7313c533553%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A576%2C%22originHeight%22%3A378%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f5f5f5%22%2C%22id%22%3A%22giB5a%22%7D\"></card><span data-lake-id=\"u9b38297b\" id=\"u9b38297b\"><br /></span><span data-lake-id=\"u42ee4219\" id=\"u42ee4219\">在中序遍历函数 inOrderTraverseNode()中，先递归左子树，然后执行 callback(node.element)，最后再递归右子树。同样的，我们将根节点作为第一个节点传入，递归到左子树的最后一个左子节点 3，由于节点 3 的 prev 为 null，所以递归返回，打印节点 3，然后继续查找节点 3 的右子节点，节点 3 的 next 值也为 null，递归返回到上一层节点 5，开始打印节点 5，之后再查找节点 5 的右子节点......最终整棵树按照这个顺序完成遍历。<br /></span><span data-lake-id=\"u67fa6fd2\" id=\"u67fa6fd2\">最后再来看看后序遍历的情况。</span></p><p data-lake-id=\"u54849225\" id=\"u54849225\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22tree.postOrderTraverse(value%20%3D%3E%20console.log(value))%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22d0cdfb98%22%7D\"></card><p data-lake-id=\"ube957c6b\" id=\"ube957c6b\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22plain%22%2C%22code%22%3A%223%5Cn6%5Cn5%5Cn8%5Cn10%5Cn9%5Cn7%5Cn12%5Cn14%5Cn13%5Cn18%5Cn25%5Cn20%5Cn15%5Cn11%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22a262629b%22%7D\"></card><p data-lake-id=\"ud1b927c6\" id=\"ud1b927c6\"><br></p><p data-lake-id=\"u9c589b2d\" id=\"u9c589b2d\"><span data-lake-id=\"u0e08a2bb\" id=\"u0e08a2bb\"><br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366587593-3765828a-4e1f-4317-8d89-97bd9be4dd05.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du8098666a%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D368%26originWidth%3D569%26originalType%3Durl%26ratio%3D1%26size%3D37799%26status%3Ddone%26style%3Dnone%26taskId%3Du1d6e4036-f261-4e57-a9f0-ad3cde9a25c%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A569%2C%22originHeight%22%3A368%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f6f6f6%22%2C%22id%22%3A%22uaJXG%22%7D\"></card><span data-lake-id=\"uaad727be\" id=\"uaad727be\"><br /></span><span data-lake-id=\"uedcf84e1\" id=\"uedcf84e1\">在后序遍历函数 postOrderTraverseNode()中，先递归左子树，然后再递归右子树，最后执行 callback(node.element)。同样的，我们将根节点作为第一个节点传入，递归到左子树的最后一个左子节点 3，由于节点 3 的 prev 为 null，所以递归返回，此时继续查找节点 3 的右子节点，节点 3 的 next 值也为 null，递归返回并打印节点 3，之后递归返回到上一层节点 5，开始查找节点 5 的右子节点，节点 5 的右子节点是节点 6，由于节点 6 是叶子节点，所以直接打印节点 6，然后递归返回并打印节点 5。之后递归再向上返回到节点 7 并递归节点 7 的右子节点......按照这个顺序最终完成对整棵树的遍历。<br /></span><span data-lake-id=\"ud9994dd8\" id=\"ud9994dd8\">接下来我们再来看看对树的搜索。有三种要经常执行的搜索方式：</span></p><p data-lake-id=\"u998fa5f9\" id=\"u998fa5f9\"><br></p><ul list=\"u90d11334\"><li fid=\"u82de6391\" data-lake-id=\"u0caa0e6a\" id=\"u0caa0e6a\"><span data-lake-id=\"ue1d51ab3\" id=\"ue1d51ab3\">搜索树中的最小值</span></li><li fid=\"u82de6391\" data-lake-id=\"uf31666a1\" id=\"uf31666a1\"><span data-lake-id=\"u1754e495\" id=\"u1754e495\">搜索树中的最大值</span></li><li fid=\"u82de6391\" data-lake-id=\"u79c99c43\" id=\"u79c99c43\"><span data-lake-id=\"u02929921\" id=\"u02929921\">搜索树中的特定值</span></li></ul><p data-lake-id=\"u0e292cb9\" id=\"u0e292cb9\"><br></p><p data-lake-id=\"u7b306e85\" id=\"u7b306e85\"><span data-lake-id=\"u8ca67179\" id=\"u8ca67179\">搜索树中的最小值和最大值比较简单，由于我们的二叉搜索树规定了值小的节点永远在左子树（左子节点）中，值大（或相等）的节点永远在右子树（右子节点）中，所以，搜索最大值我们只需要递归查找树的右子树直到叶子节点，就能找到值最大的节点。搜索最小值只需要递归查找树的左子树直到叶子节点，就能找到值最小的节点。下面是这两个函数的实现：</span></p><p data-lake-id=\"ua7ebccb2\" id=\"ua7ebccb2\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20minNode%20%3D%20function%20(node)%20%7B%5Cn%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%20null%5Cn%5Cn%20%20%20%20while%20(node%20%26%26%20node.prev%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20node%20%3D%20node.prev%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20node%5Cn%7D%5Cn%5Cnlet%20maxNode%20%3D%20function%20(node)%20%7B%5Cn%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%20null%5Cn%5Cn%20%20%20%20while%20(node%20%26%26%20node.next%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20node%20%3D%20node.next%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20node%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22deb27f8f%22%7D\"></card><p data-lake-id=\"u4666f23a\" id=\"u4666f23a\"><br></p><p data-lake-id=\"u95db9919\" id=\"u95db9919\"><span data-lake-id=\"u67e1fd46\" id=\"u67e1fd46\">第三种方式是搜索特定的值，我们需要比较要搜索的值与当前节点的值，如果要搜索的值小于当前节点的值，则从当前节点开始递归查找左子数（左子节点）。如果要搜索的值大于当前节点的值，则从当前节点开始递归查找右子树（右子节点）。按照这个逻辑，我们的 searchNode()函数实现如下：</span></p><p data-lake-id=\"u367532b7\" id=\"u367532b7\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20searchNode%20%3D%20function%20(node%2C%20key)%20%7B%5Cn%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%20null%5Cn%5Cn%20%20%20%20if%20(key%20%3C%20node.element)%20return%20searchNode(node.prev%2C%20key)%5Cn%20%20%20%20else%20if%20(key%20%3E%20node.element)%20return%20searchNode(node.next%2C%20key)%5Cn%20%20%20%20else%20return%20node%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22687ff764%22%7D\"></card><p data-lake-id=\"ucab2a362\" id=\"ucab2a362\"><br></p><p data-lake-id=\"uedfdfbab\" id=\"uedfdfbab\"><span data-lake-id=\"u1cb330e1\" id=\"u1cb330e1\">如果找到了对应的节点，就返回该节点，否则就返回 null。我们将 BinarySearchTree 类的这三个搜索方法的内容补充完整：</span></p><p data-lake-id=\"udf150379\" id=\"udf150379\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22search%20(key)%20%7B%5Cn%20%20%20%20return%20searchNode(this.root%2C%20key)%3B%5Cn%7D%5Cn%5Cnmin%20()%20%7B%5Cn%20%20%20%20return%20minNode(this.root)%3B%5Cn%7D%5Cn%5Cnmax%20()%20%7B%5Cn%20%20%20%20return%20maxNode(this.root)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22926b0f96%22%7D\"></card><p data-lake-id=\"ub714861a\" id=\"ub714861a\"><br></p><p data-lake-id=\"ub0dec46e\" id=\"ub0dec46e\"><span data-lake-id=\"u3f723280\" id=\"u3f723280\">下面是一些测试用例及结果：</span></p><p data-lake-id=\"udb0ce19d\" id=\"udb0ce19d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(tree.min().element)%20%2F%2F%203%5Cnconsole.log(tree.max().element)%20%2F%2F%2025%5Cnconsole.log(tree.search(1)%20%3F%20%5C%22Key%201%20found.%5C%22%20%3A%20%5C%22Key%201%20not%20found.%5C%22)%20%2F%2F%20Key%201%20not%20found.%5Cnconsole.log(tree.search(8)%20%3F%20%5C%22Key%208%20found.%5C%22%20%3A%20%5C%22Key%208%20not%20found.%5C%22)%20%2F%2F%20Key%208%20found.%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22d8119ee6%22%7D\"></card><p data-lake-id=\"u35f4c58f\" id=\"u35f4c58f\"><br></p><p data-lake-id=\"u1414c6fa\" id=\"u1414c6fa\"><span data-lake-id=\"uad32a1b6\" id=\"uad32a1b6\">让我们来看一下 search()方法的执行过程是怎样的。<br /></span><span data-lake-id=\"u3aa94c0c\" id=\"u3aa94c0c\">​</span></p><p data-lake-id=\"ud1109014\" id=\"ud1109014\"><br></p><p data-lake-id=\"u81aedb98\" id=\"u81aedb98\"><span data-lake-id=\"u810b3656\" id=\"u810b3656\">搜索 key=1 的节点，首先我们传入树的根节点和 key=1，由于 1 小于根节点的值 11，递归查找根节点的左子节点 7，1&lt;7，继续查找节点 7 的左子节点，直到找到叶子节点 3，1 仍然小于 3，但是节点 3 没有左子节点了，所以返回 false，整个递归开始向上返回，最终返回的结果是 false，表示树中没有 key=1 的节点。<br /></span><span data-lake-id=\"uc9c58c2d\" id=\"uc9c58c2d\">​</span></p><p data-lake-id=\"u9c056d49\" id=\"u9c056d49\"><br></p><p data-lake-id=\"u334b04e1\" id=\"u334b04e1\"><span data-lake-id=\"ud138dabf\" id=\"ud138dabf\">相应地，对于搜索 key=8 的节点，也是先遍历根节点的左子节点 7，由于 8&gt;7，所以会遍历节点 7 的右子节点，找到节点 9，8&lt;9，遍历节点 9 的左子节点，此时找到节点 9 的左子节点正好是 8，所以返回 true，然后整个递归向上返回，最终的返回结果就是 true，表示树中找到了 key=8 的节点。<br /></span><span data-lake-id=\"u8b740ad9\" id=\"u8b740ad9\">​</span></p><p data-lake-id=\"ub6fa1d7d\" id=\"ub6fa1d7d\"><br></p><p data-lake-id=\"uf6641618\" id=\"uf6641618\"><span data-lake-id=\"u7628645f\" id=\"u7628645f\">最后我们再来看一下从树中移除一个节点的过程，这个过程要稍微复杂一些。先来看看删除树节点的函数 removeNode()的代码，稍后我们再来详细讲解整个执行过程。<br /></span><span data-lake-id=\"u8ce811de\" id=\"u8ce811de\">​</span></p><p data-lake-id=\"u059c59a1\" id=\"u059c59a1\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20removeNode%20%3D%20function%20(node%2C%20key)%20%7B%5Cn%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%20null%5Cn%5Cn%20%20%20%20if%20(key%20%3C%20node.element)%20%7B%5Cn%20%20%20%20%20%20%20%20node.prev%20%3D%20removeNode(node.prev%2C%20key)%5Cn%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%7D%20else%20if%20(key%20%3E%20node.element)%20%7B%5Cn%20%20%20%20%20%20%20%20node.next%20%3D%20removeNode(node.next%2C%20key)%5Cn%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%88%E6%B2%A1%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%89%5Cn%20%20%20%20%20%20%20%20if%20(node.prev%20%3D%3D%3D%20null%20%26%26%20node.next%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20node%20%3D%20null%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%8F%AA%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%5Cn%20%20%20%20%20%20%20%20if%20(node.prev%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20node%20%3D%20node.next%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%20%20%20%20%7D%20else%20if%20(node.next%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20node%20%3D%20node.prev%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%5Cn%20%20%20%20%20%20%20%20let%20aux%20%3D%20minNode(node.next)%5Cn%20%20%20%20%20%20%20%20node.element%20%3D%20aux.element%5Cn%20%20%20%20%20%20%20%20node.next%20%3D%20removeNode(node.next%2C%20aux.element)%5Cn%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22ac861dc1%22%7D\"></card><p data-lake-id=\"u86c5a928\" id=\"u86c5a928\"><br></p><p data-lake-id=\"ua141e092\" id=\"ua141e092\"><span data-lake-id=\"u0a167c4e\" id=\"u0a167c4e\">首先要找到树中待删除的节点，这需要进行递归遍历，从根节点开始，如果 key 值小于当前节点的值，则遍历左子树，如果 key 值大于当前节点的值，则遍历右子树。注意，在递归遍历的过程中，我们将 node（这里的 node 传入的是树的根节点）的 prev 指针或 next 指针逐级指向下一级节点，然后返回整个 node。当找到要删除的节点后，我们要处理三种情况：</span></p><p data-lake-id=\"u594b2bc1\" id=\"u594b2bc1\"><br></p><ul list=\"u46512f7b\"><li fid=\"udfb80c22\" data-lake-id=\"u68c4d68b\" id=\"u68c4d68b\"><span data-lake-id=\"ucf8c68b3\" id=\"ucf8c68b3\">该节点为叶子节点（没有子节点）</span></li><li fid=\"udfb80c22\" data-lake-id=\"u6dac2e90\" id=\"u6dac2e90\"><span data-lake-id=\"u3e9c3e91\" id=\"u3e9c3e91\">该节点只有一个子节点（左子节点或右子节点）</span></li><li fid=\"udfb80c22\" data-lake-id=\"u3dfccf2d\" id=\"u3dfccf2d\"><span data-lake-id=\"u70905890\" id=\"u70905890\">该节点有两个子节点（左右子节点都存在）</span></li></ul><p data-lake-id=\"u230407a2\" id=\"u230407a2\"><br></p><p data-lake-id=\"uaf93be6b\" id=\"uaf93be6b\"><span data-lake-id=\"ue417fcaf\" id=\"ue417fcaf\">我们先看第一种情况：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366703868-eb31d55e-1a9f-448a-bee3-e9df964fd888.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du78b542f4%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D369%26originWidth%3D579%26originalType%3Durl%26ratio%3D1%26size%3D31470%26status%3Ddone%26style%3Dnone%26taskId%3Du7f79a5a1-4a51-47a0-b012-b2cd584ad79%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A579%2C%22originHeight%22%3A369%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f7f7f7%22%2C%22id%22%3A%22DOvnB%22%7D\"></card><span data-lake-id=\"ub35eb287\" id=\"ub35eb287\"><br /></span><span data-lake-id=\"u8edbf6fe\" id=\"u8edbf6fe\">假设我们要删除节点 6，传入根节点 11，整个执行过程如下：</span></p><p data-lake-id=\"u4acfd9f0\" id=\"u4acfd9f0\"><br></p><ol list=\"u15de3792\"><li fid=\"ua275cd4d\" data-lake-id=\"u638422e4\" id=\"u638422e4\"><span data-lake-id=\"u4694f2f3\" id=\"u4694f2f3\">node=11，key=6，6&lt;11，递归执行 removeNode(7, 6)</span></li><li fid=\"ua275cd4d\" data-lake-id=\"u646a4e78\" id=\"u646a4e78\"><span data-lake-id=\"u853ec76b\" id=\"u853ec76b\">node=7，key=6，6&lt;7，递归执行 removeNode(5, 6)</span></li><li fid=\"ua275cd4d\" data-lake-id=\"u68f8e5a0\" id=\"u68f8e5a0\"><span data-lake-id=\"ucba00dc8\" id=\"ucba00dc8\">node=5，key=6，6&gt;5，递归执行 removeNode(6, 6)</span></li><li fid=\"ua275cd4d\" data-lake-id=\"ucf3c3efb\" id=\"ucf3c3efb\"><span data-lake-id=\"u3d52283e\" id=\"u3d52283e\">node=6，key=6，6=6，并且节点 6 的 prev 和 next 都为 null，所以我们将节点 6 设置为 null，并且返回 null</span></li><li fid=\"ua275cd4d\" data-lake-id=\"u40021ee2\" id=\"u40021ee2\"><span data-lake-id=\"u604b72f4\" id=\"u604b72f4\">递归返回到步骤 3，节点 5 的 next 将获取步骤 4 的返回值 null</span></li><li fid=\"ua275cd4d\" data-lake-id=\"u05b52c57\" id=\"u05b52c57\"><span data-lake-id=\"u810ccbd4\" id=\"u810ccbd4\">递归返回到步骤 2，节点 7 的 prev 依然指向节点 5，保持不变</span></li><li fid=\"ua275cd4d\" data-lake-id=\"ua40621fe\" id=\"ua40621fe\"><span data-lake-id=\"u94717bb9\" id=\"u94717bb9\">递归返回到步骤 1，节点 11 的 prev 依然指向节点 7，保持不变</span></li><li fid=\"ua275cd4d\" data-lake-id=\"u11c6ce1f\" id=\"u11c6ce1f\"><span data-lake-id=\"u7e2e235c\" id=\"u7e2e235c\">最后返回节点 11</span></li></ol><p data-lake-id=\"u7c1ec9e0\" id=\"u7c1ec9e0\"><br></p><p data-lake-id=\"u97c01681\" id=\"u97c01681\"><span data-lake-id=\"uc0952508\" id=\"uc0952508\">然后我们来看只有一个子节点的情况：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366703877-73c0ab05-fbd6-4a87-b0f7-4fae0ebb82f3.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du858e1208%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D367%26originWidth%3D574%26originalType%3Durl%26ratio%3D1%26size%3D31656%26status%3Ddone%26style%3Dnone%26taskId%3Dufabadec8-dba7-459a-96b4-f8fcba3d2d0%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A574%2C%22originHeight%22%3A367%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f7f7f7%22%2C%22id%22%3A%22ed7mI%22%7D\"></card><span data-lake-id=\"u8facf5d9\" id=\"u8facf5d9\"><br /></span><span data-lake-id=\"u598ae6db\" id=\"u598ae6db\">前面已经删除了节点 6，假设我们现在要删除节点 5，它有一个左子节点 3，我们依然传入根节点 11，来看看整个执行过程：</span></p><p data-lake-id=\"u043057b7\" id=\"u043057b7\"><br></p><ol list=\"u67d903d5\"><li fid=\"u2fcf63e1\" data-lake-id=\"uc615aedf\" id=\"uc615aedf\"><span data-lake-id=\"u1dd1bbef\" id=\"u1dd1bbef\">node=11，key=5，5&lt;11，递归执行 removeNode(7, 5)</span></li><li fid=\"u2fcf63e1\" data-lake-id=\"u92ab769b\" id=\"u92ab769b\"><span data-lake-id=\"u580bf24a\" id=\"u580bf24a\">node=7，key=5，5&lt;7，递归执行 removeNode(5, 5)</span></li><li fid=\"u2fcf63e1\" data-lake-id=\"u8ab26f80\" id=\"u8ab26f80\"><span data-lake-id=\"u53f64cae\" id=\"u53f64cae\">node=5，key=5，5=5，并且节点 5 的 prev=3，next=null，所以我们将节点 5 替换成它的左子节点 3，并返回节点 3</span></li><li fid=\"u2fcf63e1\" data-lake-id=\"u914be9e2\" id=\"u914be9e2\"><span data-lake-id=\"ubfe5d67f\" id=\"ubfe5d67f\">递归返回到步骤 2，节点 7 的 next 将获取步骤 3 的返回值 3</span></li><li fid=\"u2fcf63e1\" data-lake-id=\"u0a3999dc\" id=\"u0a3999dc\"><span data-lake-id=\"u4f741522\" id=\"u4f741522\">递归返回到步骤 1，节点 11 的 prev 依然指向节点 7，保持不变</span></li><li fid=\"u2fcf63e1\" data-lake-id=\"u93491eca\" id=\"u93491eca\"><span data-lake-id=\"u8df2d449\" id=\"u8df2d449\">最后返回节点 11</span></li></ol><p data-lake-id=\"u77bdebba\" id=\"u77bdebba\"><br></p><p data-lake-id=\"u0d6e6c69\" id=\"u0d6e6c69\"><span data-lake-id=\"u6de5dd5a\" id=\"u6de5dd5a\">我们不需要将节点 5 从内存中删除，它会自动被 JavaScript 的垃圾回收器清理掉，这个在</span><a href=\"https://www.cnblogs.com/jaxu/p/11277732.html\" target=\"_blank\" data-lake-id=\"u8b9f5e80\" id=\"u8b9f5e80\"><span data-lake-id=\"u3feebf4e\" id=\"u3feebf4e\">《JavaScript 数据结构——链表的实现与应用》</span></a><span data-lake-id=\"u2821ccc2\" id=\"u2821ccc2\">一文中已经介绍过。以上步骤是针对目标节点有左子节点的情况，对于有右子节点情况，执行过程是类似的。<br /></span><span data-lake-id=\"u20efe331\" id=\"u20efe331\">最后再来看第三种情况：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366703878-eabb73a8-4bb7-4a5c-bc6b-99bb8b30eff3.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Duec3c6148%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D374%26originWidth%3D554%26originalType%3Durl%26ratio%3D1%26size%3D34149%26status%3Ddone%26style%3Dnone%26taskId%3Dub5b588f7-2899-4778-94d0-bbcd5d3372f%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A554%2C%22originHeight%22%3A374%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f6f6f6%22%2C%22id%22%3A%22hbvNc%22%7D\"></card><span data-lake-id=\"ucff2af60\" id=\"ucff2af60\"><br /></span><span data-lake-id=\"u603fe95e\" id=\"u603fe95e\">前面已经删除了节点 6 和节点 5，现在我们要删除节点 15，它有左右子树，我们传入根节点 11，来看下具体执行过程：</span></p><p data-lake-id=\"u63612160\" id=\"u63612160\"><br></p><ol list=\"u3ac2d7dc\"><li fid=\"u240f1511\" data-lake-id=\"u67f146f5\" id=\"u67f146f5\"><span data-lake-id=\"u8bdd0f18\" id=\"u8bdd0f18\">node=11，key=15，15&gt;11，递归执行 removeNode(15, 15)</span></li><li fid=\"u240f1511\" data-lake-id=\"u85c1a0d1\" id=\"u85c1a0d1\"><span data-lake-id=\"u75abde80\" id=\"u75abde80\">node=15，key=15，15=15，此时我们需要找到节点 15 的右子树中的最小节点 18，将节点 15 的 key 替换成节点 18 的 key，然后将节点 15 的 next 节点（即节点 20）作为起始节点进行遍历，找到并删除节点 18，最后再将节点 15（此时它的 key 是 18）的 next 指针指向节点 20，并返回节点 15</span></li><li fid=\"u240f1511\" data-lake-id=\"u3d72edeb\" id=\"u3d72edeb\"><span data-lake-id=\"u6941b8a1\" id=\"u6941b8a1\">递归返回到步骤 1，节点 11 的 next 依然指向节点 15，但此时节点 15 的 key 已经变成 18 了</span></li><li fid=\"u240f1511\" data-lake-id=\"u4ab2d732\" id=\"u4ab2d732\"><span data-lake-id=\"u1f82f3f6\" id=\"u1f82f3f6\">最后返回节点 11</span></li></ol><p data-lake-id=\"udc9e4a59\" id=\"udc9e4a59\"><br></p><p data-lake-id=\"u6c82ae8c\" id=\"u6c82ae8c\"><span data-lake-id=\"u3a41da1c\" id=\"u3a41da1c\">试想一下，当删除节点 15 之后，为了保证我们的二叉搜索树结构稳定，必须用节点 15 的右子树中的最小节点来替换节点 15，如果直接将 11 的 next 指向 20，则 20 将会有三个子节点 13、18、25，这显然已经不符合我们二叉树的定义了。如果将节点 25 用来替换节点 15，节点 20 的值比节点 25 的值小，不应该出现在右子节点，这也不符合我们的二叉搜索树的定义。所以，只有按照上述过程才能既保证不破坏树的结构，又能删除节点。<br /></span><span data-lake-id=\"u46eb678e\" id=\"u46eb678e\">我们已经完成了一开始我们定义的二叉搜索树 BinarySearchTree 类的所有方法，下面是它的完整代码：</span></p><p data-lake-id=\"u653bbaeb\" id=\"u653bbaeb\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20insertNode%20%3D%20function%20(node%2C%20newNode)%20%7B%5Cn%20%20%20%20if%20(newNode.element%20%3C%20node.element)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(node.prev%20%3D%3D%3D%20null)%20node.prev%20%3D%20newNode%5Cn%20%20%20%20%20%20%20%20else%20insertNode(node.prev%2C%20newNode)%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(node.next%20%3D%3D%3D%20null)%20node.next%20%3D%20newNode%5Cn%20%20%20%20%20%20%20%20else%20insertNode(node.next%2C%20newNode)%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnlet%20preOrderTraverseNode%20%3D%20function%20(node%2C%20callback)%20%7B%5Cn%20%20%20%20if%20(node%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20callback(node.element)%5Cn%20%20%20%20%20%20%20%20preOrderTraverseNode(node.prev%2C%20callback)%5Cn%20%20%20%20%20%20%20%20preOrderTraverseNode(node.next%2C%20callback)%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnlet%20inOrderTraverseNode%20%3D%20function%20(node%2C%20callback)%20%7B%5Cn%20%20%20%20if%20(node%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20inOrderTraverseNode(node.prev%2C%20callback)%5Cn%20%20%20%20%20%20%20%20callback(node.element)%5Cn%20%20%20%20%20%20%20%20inOrderTraverseNode(node.next%2C%20callback)%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnlet%20postOrderTraverseNode%20%3D%20function%20(node%2C%20callback)%20%7B%5Cn%20%20%20%20if%20(node%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20postOrderTraverseNode(node.prev%2C%20callback)%5Cn%20%20%20%20%20%20%20%20postOrderTraverseNode(node.next%2C%20callback)%5Cn%20%20%20%20%20%20%20%20callback(node.element)%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnlet%20minNode%20%3D%20function%20(node)%20%7B%5Cn%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%20null%5Cn%5Cn%20%20%20%20while%20(node%20%26%26%20node.prev%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20node%20%3D%20node.prev%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20node%5Cn%7D%5Cn%5Cnlet%20maxNode%20%3D%20function%20(node)%20%7B%5Cn%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%20null%5Cn%5Cn%20%20%20%20while%20(node%20%26%26%20node.next%20!%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20node%20%3D%20node.next%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20node%5Cn%7D%5Cn%5Cnlet%20searchNode%20%3D%20function%20(node%2C%20key)%20%7B%5Cn%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%20false%5Cn%5Cn%20%20%20%20if%20(key%20%3C%20node.element)%20return%20searchNode(node.prev%2C%20key)%5Cn%20%20%20%20else%20if%20(key%20%3E%20node.element)%20return%20searchNode(node.next%2C%20key)%5Cn%20%20%20%20else%20return%20true%5Cn%7D%5Cn%5Cnlet%20removeNode%20%3D%20function%20(node%2C%20key)%20%7B%5Cn%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%20null%5Cn%5Cn%20%20%20%20if%20(key%20%3C%20node.element)%20%7B%5Cn%20%20%20%20%20%20%20%20node.prev%20%3D%20removeNode(node.prev%2C%20key)%5Cn%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%7D%20else%20if%20(key%20%3E%20node.element)%20%7B%5Cn%20%20%20%20%20%20%20%20node.next%20%3D%20removeNode(node.next%2C%20key)%5Cn%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%88%E6%B2%A1%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%89%5Cn%20%20%20%20%20%20%20%20if%20(node.prev%20%3D%3D%3D%20null%20%26%26%20node.next%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20node%20%3D%20null%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%8F%AA%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%5Cn%20%20%20%20%20%20%20%20if%20(node.prev%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20node%20%3D%20node.next%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%20%20%20%20%7D%20else%20if%20(node.next%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20node%20%3D%20node.prev%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%5Cn%20%20%20%20%20%20%20%20let%20aux%20%3D%20minNode(node.next)%5Cn%20%20%20%20%20%20%20%20node.element%20%3D%20aux.element%5Cn%20%20%20%20%20%20%20%20node.next%20%3D%20removeNode(node.next%2C%20aux.element)%5Cn%20%20%20%20%20%20%20%20return%20node%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnclass%20BinarySearchTree%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20this.root%20%3D%20null%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%90%91%E6%A0%91%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%5Cn%20%20%20%20insert(key)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20newNode%20%3D%20new%20Node(key)%5Cn%5Cn%20%20%20%20%20%20%20%20if%20(this.root%20%3D%3D%3D%20null)%20this.root%20%3D%20newNode%5Cn%20%20%20%20%20%20%20%20else%20insertNode(this.root%2C%20newNode)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%9C%A8%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%5Cn%20%20%20%20search(key)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20searchNode(this.root%2C%20key)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E9%81%8D%E5%8E%86%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%5Cn%20%20%20%20preOrderTraverse(callback)%20%7B%5Cn%20%20%20%20%20%20%20%20preOrderTraverseNode(this.root%2C%20callback)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E9%81%8D%E5%8E%86%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%5Cn%20%20%20%20inOrderTraverse(callback)%20%7B%5Cn%20%20%20%20%20%20%20%20inOrderTraverseNode(this.root%2C%20callback)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E9%81%8D%E5%8E%86%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%5Cn%20%20%20%20postOrderTraverse(callback)%20%7B%5Cn%20%20%20%20%20%20%20%20postOrderTraverseNode(this.root%2C%20callback)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%8A%82%E7%82%B9%5Cn%20%20%20%20min()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20minNode(this.root)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%8A%82%E7%82%B9%5Cn%20%20%20%20max()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20maxNode(this.root)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E4%BB%8E%E6%A0%91%E4%B8%AD%E7%A7%BB%E9%99%A4%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%5Cn%20%20%20%20remove(key)%20%7B%5Cn%20%20%20%20%20%20%20%20this.root%20%3D%20removeNode(this.root%2C%20key)%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2202819d20%22%7D\"></card><p data-lake-id=\"udf3c6297\" id=\"udf3c6297\"><br></p><p data-lake-id=\"u2c12a250\" id=\"u2c12a250\"><br></p><p data-lake-id=\"u24ecdaa7\" id=\"u24ecdaa7\"><br></p><h3 data-lake-id=\"4242da52\" id=\"4242da52\"><span data-lake-id=\"uf1ff8da5\" id=\"uf1ff8da5\">自平衡树</span></h3><p data-lake-id=\"ubd9be9d5\" id=\"ubd9be9d5\"><br></p><p data-lake-id=\"ub9f84f4b\" id=\"ub9f84f4b\"><span data-lake-id=\"udc7fb71a\" id=\"udc7fb71a\">上面的 BST 树（二叉搜索树）存在一个问题，树的一条边可能会非常深，而其它边却只有几层，这会在这条很深的分支上添加、移除和搜索节点时引起一些性能问题。如下图所示：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366726947-232e09a9-43e1-4fbf-86e4-fdcdf8427300.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du4d5fbb30%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D653%26originWidth%3D704%26originalType%3Durl%26ratio%3D1%26size%3D45808%26status%3Ddone%26style%3Dnone%26taskId%3Du22b890aa-8a23-476c-b752-cad00a2716e%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A704%2C%22originHeight%22%3A653%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23fbfbfb%22%2C%22id%22%3A%22tppDP%22%7D\"></card><span data-lake-id=\"u9fe45300\" id=\"u9fe45300\"><br /></span><span data-lake-id=\"u5a43bd0f\" id=\"u5a43bd0f\">为了解决这个问题，我们引入了自平衡二叉搜索树（AVL——Adelson-Velskii-Landi）。在 AVL 中，任何一个节点左右两棵子树的高度之差最多为 1，添加或移除节点时，AVL 树会尝试自平衡。对 AVL 树的操作和对 BST 树的操作一样，不同点在于我们还需要重新平衡 AVL 树，在讲解对 AVL 树的平衡操作之前，我们先看一下什么是 AVL 树的平衡因子。<br /></span><span data-lake-id=\"u85f20b7e\" id=\"u85f20b7e\">前面我们介绍过什么是树（子树）的高度，对于 AVL 树来说，每一个节点都保存一个平衡因子。<br /></span><strong><span data-lake-id=\"ua3d049c4\" id=\"ua3d049c4\">节点的平衡因子 = 左子树的高度 - 右子树的高度</span></strong><span data-lake-id=\"ua8194834\" id=\"ua8194834\"><br /></span><span data-lake-id=\"uf86697d8\" id=\"uf86697d8\">观察下面这棵树，我们在上面标注了每个节点的平衡因子的值：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366726954-d758e030-e4b2-4588-8e56-38eea7451881.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du06bf5f7a%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D401%26originWidth%3D578%26originalType%3Durl%26ratio%3D1%26size%3D27946%26status%3Ddone%26style%3Dnone%26taskId%3Du6bfe9e2b-e524-4a2c-a713-0eb04ae3115%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A578%2C%22originHeight%22%3A401%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23fafafa%22%2C%22id%22%3A%22j9sOd%22%7D\"></card><span data-lake-id=\"ud5d3e65d\" id=\"ud5d3e65d\"><br /></span><span data-lake-id=\"u73ecb160\" id=\"u73ecb160\">所有子节点的平衡因子都为 0，因为子节点没有子树。节点 5 的左右子树的高度都为 1，所以节点 5 的平衡因子是 0。节点 9 的左子树高度为 1，右子树高度为 0，所以节点 9 的平衡因子是+1。节点 13 的左子树高度为 0，右子树高度为 1，所以节点 13 的平衡因子是-1......AVL 树的所有节点的平衡因子保持三个值：0、+1 或-1。同时，我们也注意到，当某个节点的平衡因子为+1 时，它的子树是向左倾斜的（left-heavy）；而当某个节点的平衡因子为-1 时，它的子树是向右倾斜的（right-heavy）；当节点的平衡因子为 0 时，该节点是平衡的。一颗子树的根节点的平衡因子代表了该子树的平衡性。<br /></span><span data-lake-id=\"u0496441f\" id=\"u0496441f\">为了使 AVL 树重新达到平衡状态，我们需要对 AVL 树中的部分节点进行重新排列，使其既符合二叉搜索树的定义，又符合自平衡二叉树的定义，这个过程叫做 AVL 树的旋转。<br /></span><span data-lake-id=\"u8cc61858\" id=\"u8cc61858\">AVL 树的旋转一共分为四种：</span></p><p data-lake-id=\"uf818271e\" id=\"uf818271e\"><br></p><ul list=\"u785693d2\"><li fid=\"u3d6b60c7\" data-lake-id=\"u5c5c59e9\" id=\"u5c5c59e9\"><span data-lake-id=\"u186952d8\" id=\"u186952d8\">LL（left-left）旋转，新添加的节点位于树的根节点的左子树的左子树上。以非平衡因子的节点为中心将整棵树向右旋转。</span></li><li fid=\"u3d6b60c7\" data-lake-id=\"u74683476\" id=\"u74683476\"><span data-lake-id=\"u8921b0e0\" id=\"u8921b0e0\">LR（left-right）旋转，新添加的节点位于树的根节点的左子树的右子树上。先执行 RR 旋转，然后再执行 LL 旋转。</span></li><li fid=\"u3d6b60c7\" data-lake-id=\"u751510d1\" id=\"u751510d1\"><span data-lake-id=\"u78e5c217\" id=\"u78e5c217\">RR（right-right）旋转，新添加的节点位于树的根节点的右子树的右子树上。以非平衡因子的节点为中心将整棵树向左旋转。</span></li><li fid=\"u3d6b60c7\" data-lake-id=\"ufa362930\" id=\"ufa362930\"><span data-lake-id=\"uc845837a\" id=\"uc845837a\">RL（right-left）旋转，新添加的节点位于树的根节点的右子树的左子树上。先执行 LL 旋转，然后再执行 RR 旋转。</span></li></ul><p data-lake-id=\"ubd6a9f83\" id=\"ubd6a9f83\"><br></p><p data-lake-id=\"u33393c16\" id=\"u33393c16\"><span data-lake-id=\"ucae64fd4\" id=\"ucae64fd4\">下面是这四种旋转的操作示意图，后面我们会详细介绍每一种旋转的操作过程：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366727001-4ce9f99f-916a-40e6-ad25-3d9adbb16324.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Duf989ab3a%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D1277%26originWidth%3D897%26originalType%3Durl%26ratio%3D1%26size%3D110075%26status%3Ddone%26style%3Dnone%26taskId%3Du7e881633-f8cc-458a-9cf2-e8c5f2705ac%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A897%2C%22originHeight%22%3A1277%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23fbfbfb%22%2C%22id%22%3A%22OshVa%22%7D\"></card><span data-lake-id=\"ua2105cdb\" id=\"ua2105cdb\"><br /></span><span data-lake-id=\"u3ea4a46a\" id=\"u3ea4a46a\">对于 LL 旋转，在节点 5 的右子节点上添加节点 4 与在左子节点上添加节点 3 等同。对于 LR 旋转，在节点 9 的左子节点上添加节点 8 与在右子节点上添加节点 10 等同。对于 RR 旋转，在节点 20 的右子节点上添加节点 25 与在左子节点上添加节点 18 等同。对于 RL 旋转，在节点 13 的右子节点上添加节点 14 与在左子节点上添加节点 12 等同。<br /></span><span data-lake-id=\"u040fcc2e\" id=\"u040fcc2e\">我们的自平衡二叉树 AVLTree 类将从 BinarySearchTree 类继承，同时我们需要新增一个方法 getNodeHeight()用来获取任意节点的高度。</span></p><p data-lake-id=\"ud9c1bf97\" id=\"ud9c1bf97\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20AVLTree%20extends%20BinarySearchTree%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20super()%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E7%9A%84%E9%AB%98%E5%BA%A6%5Cn%20%20%20%20getNodeHeight(node)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%200%5Cn%20%20%20%20%20%20%20%20return%20Math.max(this.getNodeHeight(node.prev)%2C%20this.getNodeHeight(node.next))%20%2B%201%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22975019c3%22%7D\"></card><p data-lake-id=\"u9ac62eae\" id=\"u9ac62eae\"><br></p><p data-lake-id=\"u9ae882c8\" id=\"u9ae882c8\"><span data-lake-id=\"u1370fa6c\" id=\"u1370fa6c\">测试一下 getNodeHeight()方法，我们还是以本文一开始的那棵树为例，然后看一下不同节点的高度。</span></p><p data-lake-id=\"u402ea17f\" id=\"u402ea17f\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20tree%20%3D%20new%20AVLTree()%5Cntree.insert(11)%5Cntree.insert(7)%5Cntree.insert(15)%5Cntree.insert(5)%5Cntree.insert(9)%5Cntree.insert(13)%5Cntree.insert(20)%5Cntree.insert(3)%5Cntree.insert(6)%5Cntree.insert(8)%5Cntree.insert(10)%5Cntree.insert(12)%5Cntree.insert(14)%5Cntree.insert(18)%5Cntree.insert(25)%5Cn%5Cnconsole.log(tree.getNodeHeight(tree.root))%20%2F%2F%204%5Cnconsole.log(tree.getNodeHeight(tree.search(7)))%20%2F%2F%203%5Cnconsole.log(tree.getNodeHeight(tree.search(5)))%20%2F%2F%202%5Cnconsole.log(tree.getNodeHeight(tree.min(7)))%20%2F%2F%201%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22f3f80ff5%22%7D\"></card><p data-lake-id=\"u2aea32cb\" id=\"u2aea32cb\"><br></p><p data-lake-id=\"u71d40c0f\" id=\"u71d40c0f\"><span data-lake-id=\"u21a3d218\" id=\"u21a3d218\">根节点的高度为 4，最小节点 3 的高度为 1，节点 5 和节点 7 的高度分别为 2 和 3。<br /></span><span data-lake-id=\"u36f9cee1\" id=\"u36f9cee1\">下面是四种旋转对应的实现代码：</span></p><p data-lake-id=\"uce886aea\" id=\"uce886aea\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F**%5Cn%20*%20LL%E6%97%8B%E8%BD%AC%3A%20%E5%90%91%E5%8F%B3%E6%97%8B%E8%BD%AC%5Cn%20*%5Cn%20*%20%20%20%20%20%20%20b%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20a%5Cn%20*%20%20%20%20%20%20%2F%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%5C%5Cn%20*%20%20%20%20%20a%20%20%20e%20-%3E%20rotationLL(b)%20-%3E%20%20%20c%20%20%20b%5Cn%20*%20%20%20%20%2F%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%20%20%2F%20%5C%5C%5Cn%20*%20%20%20c%20%20%20d%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20f%20%20%20d%20%20%20e%5Cn%20*%20%20%2F%5Cn%20*%20f%5Cn%20*%5Cn%20*%20%40param%20node%20Node%3CT%3E%5Cn%20*%2F%5CnrotationLL(node)%20%7B%5Cn%20%20%20%20let%20tmp%20%3D%20node.prev%3B%5Cn%20%20%20%20node.prev%20%3D%20tmp.next%3B%5Cn%20%20%20%20tmp.next%20%3D%20node%3B%5Cn%20%20%20%20return%20tmp%3B%5Cn%7D%5Cn%5Cn%2F**%5Cn%20*%20RR%E6%97%8B%E8%BD%AC%3A%20%E5%90%91%E5%B7%A6%E6%97%8B%E8%BD%AC%5Cn%20*%5Cn%20*%20%20%20%20%20a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20b%5Cn%20*%20%20%20%20%2F%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%5C%5Cn%20*%20%20%20c%20%20%20b%20%20%20-%3E%20rotationRR(a)%20-%3E%20%20%20%20a%20%20%20e%5Cn%20*%20%20%20%20%20%20%2F%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%5C%20%20%20%5C%5C%5Cn%20*%20%20%20%20%20d%20%20%20e%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20c%20%20%20d%20%20%20f%5Cn%20*%20%20%20%20%20%20%20%20%20%20%5C%5C%5Cn%20*%20%20%20%20%20%20%20%20%20%20%20f%5Cn%20*%5Cn%20*%20%40param%20node%20Node%3CT%3E%5Cn%20*%2F%5CnrotationRR(node)%20%7B%5Cn%20%20%20%20let%20tmp%20%3D%20node.next%3B%5Cn%20%20%20%20node.next%20%3D%20tmp.prev%3B%5Cn%20%20%20%20tmp.prev%20%3D%20node%3B%5Cn%20%20%20%20return%20tmp%3B%5Cn%7D%5Cn%5Cn%2F**%5Cn%20*%20LR%E6%97%8B%E8%BD%AC%3A%20%E5%85%88%E5%90%91%E5%B7%A6%E6%97%8B%E8%BD%AC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%90%91%E5%8F%B3%E6%97%8B%E8%BD%AC%5Cn%20*%20%40param%20node%20Node%3CT%3E%5Cn%20*%2F%5CnrotationLR(node)%20%7B%5Cn%20%20%20%20node.prev%20%3D%20this.rotationRR(node.prev)%3B%5Cn%20%20%20%20return%20this.rotationLL(node)%3B%5Cn%7D%5Cn%5Cn%2F**%5Cn%20*%20RL%E6%97%8B%E8%BD%AC%3A%20%E5%85%88%E5%90%91%E5%8F%B3%E6%97%8B%E8%BD%AC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%90%91%E5%B7%A6%E6%97%8B%E8%BD%AC%5Cn%20*%20%40param%20node%20Node%3CT%3E%5Cn%20*%2F%5CnrotationRL(node)%20%7B%5Cn%20%20%20%20node.next%20%3D%20this.rotationLL(node.next)%3B%5Cn%20%20%20%20return%20this.rotationRR(node)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%223753eead%22%7D\"></card><p data-lake-id=\"ueb3f3ffc\" id=\"ueb3f3ffc\"><br></p><p data-lake-id=\"u0a434095\" id=\"u0a434095\"><span data-lake-id=\"u23e25edb\" id=\"u23e25edb\">对于 LL 旋转和 RR 旋转，我们可以按照上面的示意图来看下执行过程。<br /></span><span data-lake-id=\"u4fde0bb8\" id=\"u4fde0bb8\">LL 旋转，node=11，node.prev 是 7，所以 tmp=7。然后将 node.prev 指向 tmp.next，即将 11 的 prev 指向 9。接着将 tmp.next 指向 node，即将 7 的 next 指向 11。即完成了图中所示的旋转。<br /></span><span data-lake-id=\"u0c80299f\" id=\"u0c80299f\">RR 旋转，node=11，node.next 是 15，所以 tmp=15。然后将 node.next 指向 tmp.prev，即将 11 的 next 指向 13。接着将 tmp.prev 指向 node，即将 15 的 prev 指向 11。即完成了图中所示的旋转。<br /></span><span data-lake-id=\"u2e6c1b9e\" id=\"u2e6c1b9e\">LR 旋转是 RR 旋转和 LL 旋转的组合：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366769856-ab121a06-9ed4-4b47-8edd-6f6d1e0d621c.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du538e009c%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D324%26originWidth%3D1150%26originalType%3Durl%26ratio%3D1%26size%3D41879%26status%3Ddone%26style%3Dnone%26taskId%3Du2e0b1abc-05ac-40b8-9183-94fb9ecfbc1%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A1150%2C%22originHeight%22%3A324%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23fafafa%22%2C%22id%22%3A%22e2d8f%22%7D\"></card><span data-lake-id=\"ud8bae77f\" id=\"ud8bae77f\"><br /></span><span data-lake-id=\"u3852429d\" id=\"u3852429d\">RL 旋转是 LL 旋转和 RR 旋转的组合：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366769875-da7538c0-c022-40ac-b858-6bdb9fa4d86b.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du543e3617%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D310%26originWidth%3D1050%26originalType%3Durl%26ratio%3D1%26size%3D39803%26status%3Ddone%26style%3Dnone%26taskId%3Du8e8d14e4-2b60-452c-bc98-0b61afb010b%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A1050%2C%22originHeight%22%3A310%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23f9f9f9%22%2C%22id%22%3A%22FDr5y%22%7D\"></card><span data-lake-id=\"u130e9bfe\" id=\"u130e9bfe\"><br /></span><span data-lake-id=\"ued36b667\" id=\"ued36b667\">按照上面给出的示意图，我们的 AVLTree 类的 insert()方法的实现如下：</span></p><p data-lake-id=\"u257f135d\" id=\"u257f135d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22insert%20(key)%20%7B%5Cn%20%20%20%20super.insert(key)%3B%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%B7%A6%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%8F%B3%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%5Cn%20%20%20%20if%20(this.getNodeHeight(this.root.prev)%20-%20this.getNodeHeight(this.root.next)%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(key%20%3C%20this.root.prev.element)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationLL(this.root)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationLR(this.root)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F%2F%20%E5%8F%B3%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%B7%A6%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%5Cn%20%20%20%20else%20if%20(this.getNodeHeight(this.root.next)%20-%20this.getNodeHeight(this.root.prev)%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(key%20%3E%20this.root.next.element)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationRR(this.root)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationRL(this.root)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22efd3069a%22%7D\"></card><p data-lake-id=\"u7fcbaf24\" id=\"u7fcbaf24\"><br></p><p data-lake-id=\"u57ac7d55\" id=\"u57ac7d55\"><span data-lake-id=\"ue6bc6380\" id=\"ue6bc6380\">我们依次测试一下这四种情况。按照上面示意图中树的结构添加节点，然后按照前序遍历的方式打印节点的 key。<br /></span><span data-lake-id=\"ubbfb95d7\" id=\"ubbfb95d7\">LL 旋转的结果：</span></p><p data-lake-id=\"u00ff4b66\" id=\"u00ff4b66\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20tree%20%3D%20new%20AVLTree()%5Cntree.insert(11)%5Cntree.insert(7)%5Cntree.insert(15)%5Cntree.insert(5)%5Cntree.insert(9)%5Cntree.insert(3)%5Cn%5Cntree.preOrderTraverse(value%20%3D%3E%20console.log(value))%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22802f2927%22%7D\"></card><p data-lake-id=\"u3ef98a1d\" id=\"u3ef98a1d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%227%5Cn5%5Cn3%5Cn11%5Cn9%5Cn15%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%224f36efd5%22%7D\"></card><p data-lake-id=\"uc61ddbe3\" id=\"uc61ddbe3\"><br></p><p data-lake-id=\"ubc243f2f\" id=\"ubc243f2f\"><span data-lake-id=\"u350620fc\" id=\"u350620fc\">LR 旋转的结果：</span></p><p data-lake-id=\"ufed3f2dd\" id=\"ufed3f2dd\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20tree%20%3D%20new%20AVLTree()%5Cntree.insert(11)%5Cntree.insert(7)%5Cntree.insert(15)%5Cntree.insert(5)%5Cntree.insert(9)%5Cntree.insert(8)%5Cn%5Cntree.preOrderTraverse(value%20%3D%3E%20console.log(value))%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2267d475fa%22%7D\"></card><p data-lake-id=\"ua6a00062\" id=\"ua6a00062\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%229%5Cn7%5Cn5%5Cn8%5Cn11%5Cn15%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22c678dfc1%22%7D\"></card><p data-lake-id=\"u7afd102a\" id=\"u7afd102a\"><br></p><p data-lake-id=\"uda228c3f\" id=\"uda228c3f\"><span data-lake-id=\"u0017046c\" id=\"u0017046c\">RR 旋转的结果：</span></p><p data-lake-id=\"u32047a98\" id=\"u32047a98\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20tree%20%3D%20new%20AVLTree()%5Cntree.insert(11)%5Cntree.insert(7)%5Cntree.insert(15)%5Cntree.insert(13)%5Cntree.insert(20)%5Cntree.insert(25)%5Cn%5Cntree.preOrderTraverse(value%20%3D%3E%20console.log(value))%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22d7155155%22%7D\"></card><p data-lake-id=\"u4b8343ce\" id=\"u4b8343ce\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%2215%5Cn11%5Cn7%5Cn13%5Cn20%5Cn25%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%225cfa3f1d%22%7D\"></card><p data-lake-id=\"u0805aef5\" id=\"u0805aef5\"><br></p><p data-lake-id=\"u51106d6a\" id=\"u51106d6a\"><span data-lake-id=\"u288a8f2c\" id=\"u288a8f2c\">RL 旋转的结果：</span></p><p data-lake-id=\"ud1796320\" id=\"ud1796320\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20tree%20%3D%20new%20AVLTree()%5Cntree.insert(11)%5Cntree.insert(7)%5Cntree.insert(15)%5Cntree.insert(13)%5Cntree.insert(20)%5Cntree.insert(14)%5Cn%5Cntree.preOrderTraverse(value%20%3D%3E%20console.log(value))%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%223196272b%22%7D\"></card><p data-lake-id=\"ud30a2477\" id=\"ud30a2477\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%2213%5Cn11%5Cn7%5Cn15%5Cn14%5Cn20%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%225064065c%22%7D\"></card><p data-lake-id=\"ub8db72f4\" id=\"ub8db72f4\"><br></p><p data-lake-id=\"u00d1a8ca\" id=\"u00d1a8ca\"><span data-lake-id=\"ua96f9740\" id=\"ua96f9740\">我们用同样的方式修改 remove()方法，然后测试下面两种情况下的节点删除：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366865115-c8cbbf63-c8f0-4ca5-be96-6373b5bc0fd5.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du1e7f4a39%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D308%26originWidth%3D704%26originalType%3Durl%26ratio%3D1%26size%3D20770%26status%3Ddone%26style%3Dnone%26taskId%3Duad71c3ad-032d-4d6d-9c0f-7f568a55270%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A704%2C%22originHeight%22%3A308%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23fafafa%22%2C%22id%22%3A%22hgIxB%22%7D\"></card></p><p data-lake-id=\"u3b3eaaaa\" id=\"u3b3eaaaa\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20tree%20%3D%20new%20AVLTree()%5Cntree.insert(11)%5Cntree.insert(7)%5Cntree.insert(15)%5Cntree.insert(5)%5Cntree.insert(9)%5Cn%5Cntree.remove(15)%5Cntree.preOrderTraverse(value%20%3D%3E%20console.log(value))%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22ddee005f%22%7D\"></card><p data-lake-id=\"u01af3d96\" id=\"u01af3d96\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%229%5Cn7%5Cn5%5Cn11%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%220b72114e%22%7D\"></card><p data-lake-id=\"u6a580fc2\" id=\"u6a580fc2\"><br></p><p data-lake-id=\"ufad16cc4\" id=\"ufad16cc4\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646366895308-5fa8c8ce-c945-4448-bf40-0bf0dc7a71cc.png%23clientId%3Du6552ee0d-54a8-4%26from%3Dpaste%26id%3Du62412dfb%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D280%26originWidth%3D682%26originalType%3Durl%26ratio%3D1%26size%3D20738%26status%3Ddone%26style%3Dnone%26taskId%3Due9c074e3-dc24-496c-88c2-426bfc67dbc%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A682%2C%22originHeight%22%3A280%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22averageHue%22%3A%22%23fafafa%22%2C%22id%22%3A%22FvN2q%22%7D\"></card></p><p data-lake-id=\"u55fc6189\" id=\"u55fc6189\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20tree%20%3D%20new%20AVLTree()%5Cntree.insert(11)%5Cntree.insert(7)%5Cntree.insert(15)%5Cntree.insert(13)%5Cntree.insert(20)%5Cn%5Cntree.remove(7)%5Cntree.preOrderTraverse(value%20%3D%3E%20console.log(value))%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%223c6969d0%22%7D\"></card><p data-lake-id=\"u9e413cc5\" id=\"u9e413cc5\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%2213%5Cn11%5Cn15%5Cn20%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%220aaaba55%22%7D\"></card><p data-lake-id=\"ucae72592\" id=\"ucae72592\"><br></p><p data-lake-id=\"u14bfb527\" id=\"u14bfb527\"><span data-lake-id=\"u6d92c59b\" id=\"u6d92c59b\">完整的自平衡二叉搜索树 AVLTree 类的代码如下：</span></p><p data-lake-id=\"uc5812851\" id=\"uc5812851\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20AVLTree%20extends%20BinarySearchTree%20%7B%5Cn%20%20%20%20constructor()%20%7B%5Cn%20%20%20%20%20%20%20%20super()%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E7%9A%84%E9%AB%98%E5%BA%A6%5Cn%20%20%20%20getNodeHeight(node)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(node%20%3D%3D%3D%20null)%20return%200%5Cn%20%20%20%20%20%20%20%20return%20Math.max(this.getNodeHeight(node.prev)%2C%20this.getNodeHeight(node.next))%20%2B%201%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E7%9A%84%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90%5Cn%5Cn%20%20%20%20%2F**%5Cn%20%20%20%20%20*%20LL%E6%97%8B%E8%BD%AC%3A%20%E5%90%91%E5%8F%B3%E6%97%8B%E8%BD%AC%5Cn%20%20%20%20%20*%5Cn%20%20%20%20%20*%20%20%20%20%20%20%20b%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20a%5Cn%20%20%20%20%20*%20%20%20%20%20%20%2F%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%5C%5Cn%20%20%20%20%20*%20%20%20%20%20a%20%20%20e%20-%3E%20rotationLL(b)%20-%3E%20%20%20c%20%20%20b%5Cn%20%20%20%20%20*%20%20%20%20%2F%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%20%20%2F%20%5C%5C%5Cn%20%20%20%20%20*%20%20%20c%20%20%20d%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20f%20%20%20d%20%20%20e%5Cn%20%20%20%20%20*%20%20%2F%5Cn%20%20%20%20%20*%20f%5Cn%20%20%20%20%20*%5Cn%20%20%20%20%20*%20%40param%20node%20Node%3CT%3E%5Cn%20%20%20%20%20*%2F%5Cn%20%20%20%20rotationLL(node)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20tmp%20%3D%20node.prev%5Cn%20%20%20%20%20%20%20%20node.prev%20%3D%20tmp.next%5Cn%20%20%20%20%20%20%20%20tmp.next%20%3D%20node%5Cn%20%20%20%20%20%20%20%20return%20tmp%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F**%5Cn%20%20%20%20%20*%20RR%E6%97%8B%E8%BD%AC%3A%20%E5%90%91%E5%B7%A6%E6%97%8B%E8%BD%AC%5Cn%20%20%20%20%20*%5Cn%20%20%20%20%20*%20%20%20%20%20a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20b%5Cn%20%20%20%20%20*%20%20%20%20%2F%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%5C%5Cn%20%20%20%20%20*%20%20%20c%20%20%20b%20%20%20-%3E%20rotationRR(a)%20-%3E%20%20%20%20a%20%20%20e%5Cn%20%20%20%20%20*%20%20%20%20%20%20%2F%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%5C%20%20%20%5C%5C%5Cn%20%20%20%20%20*%20%20%20%20%20d%20%20%20e%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20c%20%20%20d%20%20%20f%5Cn%20%20%20%20%20*%20%20%20%20%20%20%20%20%20%20%5C%5C%5Cn%20%20%20%20%20*%20%20%20%20%20%20%20%20%20%20%20f%5Cn%20%20%20%20%20*%5Cn%20%20%20%20%20*%20%40param%20node%20Node%3CT%3E%5Cn%20%20%20%20%20*%2F%5Cn%20%20%20%20rotationRR(node)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20tmp%20%3D%20node.next%5Cn%20%20%20%20%20%20%20%20node.next%20%3D%20tmp.prev%5Cn%20%20%20%20%20%20%20%20tmp.prev%20%3D%20node%5Cn%20%20%20%20%20%20%20%20return%20tmp%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F**%5Cn%20%20%20%20%20*%20LR%E6%97%8B%E8%BD%AC%3A%20%E5%85%88%E5%90%91%E5%B7%A6%E6%97%8B%E8%BD%AC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%90%91%E5%8F%B3%E6%97%8B%E8%BD%AC%5Cn%20%20%20%20%20*%20%40param%20node%20Node%3CT%3E%5Cn%20%20%20%20%20*%2F%5Cn%20%20%20%20rotationLR(node)%20%7B%5Cn%20%20%20%20%20%20%20%20node.prev%20%3D%20this.rotationRR(node.prev)%5Cn%20%20%20%20%20%20%20%20return%20this.rotationLL(node)%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F**%5Cn%20%20%20%20%20*%20RL%E6%97%8B%E8%BD%AC%3A%20%E5%85%88%E5%90%91%E5%8F%B3%E6%97%8B%E8%BD%AC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%90%91%E5%B7%A6%E6%97%8B%E8%BD%AC%5Cn%20%20%20%20%20*%20%40param%20node%20Node%3CT%3E%5Cn%20%20%20%20%20*%2F%5Cn%20%20%20%20rotationRL(node)%20%7B%5Cn%20%20%20%20%20%20%20%20node.next%20%3D%20this.rotationLL(node.next)%5Cn%20%20%20%20%20%20%20%20return%20this.rotationRR(node)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20insert(key)%20%7B%5Cn%20%20%20%20%20%20%20%20super.insert(key)%5Cn%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%B7%A6%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%8F%B3%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%5Cn%20%20%20%20%20%20%20%20if%20(this.getNodeHeight(this.root.prev)%20-%20this.getNodeHeight(this.root.next)%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(key%20%3C%20this.root.prev.element)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationLL(this.root)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationLR(this.root)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%8F%B3%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%B7%A6%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%5Cn%20%20%20%20%20%20%20%20else%20if%20(this.getNodeHeight(this.root.next)%20-%20this.getNodeHeight(this.root.prev)%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(key%20%3E%20this.root.next.element)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationRR(this.root)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationRL(this.root)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20remove(key)%20%7B%5Cn%20%20%20%20%20%20%20%20super.remove(key)%5Cn%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%B7%A6%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%8F%B3%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%5Cn%20%20%20%20%20%20%20%20if%20(this.getNodeHeight(this.root.prev)%20-%20this.getNodeHeight(this.root.next)%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(key%20%3C%20this.root.prev.element)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationLL(this.root)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationLR(this.root)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%8F%B3%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%B7%A6%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%5Cn%20%20%20%20%20%20%20%20else%20if%20(this.getNodeHeight(this.root.next)%20-%20this.getNodeHeight(this.root.prev)%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(key%20%3E%20this.root.next.element)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationRR(this.root)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.root%20%3D%20this.rotationRL(this.root)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%220f5e2de9%22%7D\"></card><p data-lake-id=\"ufba80d8e\" id=\"ufba80d8e\"><br></p><p data-lake-id=\"ue4355e65\" id=\"ue4355e65\"><span data-lake-id=\"ua6e77e6a\" id=\"ua6e77e6a\">尽管自平衡二叉搜索树 AVL 可以很有效地帮助我们解决许多树节点的操作问题，但是在插入和移除节点时其性能并不是最好的。更好的选择是红黑树，红黑树也是一种自平衡二叉搜索树，但是它对其中的节点做了很多特殊的规定，使得在操作树节点的性能上要优于 AVL。</span></p>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 7744,
  "created_at": "2020-08-09T08:03:57.000Z",
  "updated_at": "2023-11-19T17:54:44.000Z",
  "content_updated_at": "2023-07-18T06:18:50.000Z",
  "published_at": "2023-07-18T06:18:50.000Z",
  "first_published_at": "2020-08-09T08:03:57.000Z",
  "book": {
    "id": 24854102,
    "type": "Book",
    "slug": "gm8h7g",
    "name": "算法 algorithm",
    "user_id": 732231,
    "description": "算法基础、leetCode",
    "toc_yml": "- type: META\n  count: 17\n  display_level: all\n  tail_type: UPDATED_AT\n  base_version_id: 372567226\n  published: true\n  max_level: 1\n  last_updated_at: 2023-11-19T18:02:44.264Z\n  version_id: 372567245\n- type: TITLE\n  title: 算法刷题索引\n  uuid: 9iuletCnX8AA1DWl\n  url: ''\n  prev_uuid: ''\n  sibling_uuid: BMR7y68MzsRsLpq6\n  child_uuid: 4IS2N309UG8zzeKG\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: LeetCode 热题 🔥 100\n  uuid: 4IS2N309UG8zzeKG\n  url: im0vt7\n  prev_uuid: 9iuletCnX8AA1DWl\n  sibling_uuid: uioHkKsczkPGgdyr\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67808056\n  level: 1\n  id: 67808056\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 剑指 offer 第二版\n  uuid: uioHkKsczkPGgdyr\n  url: dotw59\n  prev_uuid: 4IS2N309UG8zzeKG\n  sibling_uuid: syezq9xwx3badLKu\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810801\n  level: 1\n  id: 67810801\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: LeetCode 精选 TOP 面试题\n  uuid: syezq9xwx3badLKu\n  url: brcxx5\n  prev_uuid: uioHkKsczkPGgdyr\n  sibling_uuid: PKQxO_4GM33AkW__\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810529\n  level: 1\n  id: 67810529\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 剑指 offer 专项突击版\n  uuid: PKQxO_4GM33AkW__\n  url: mff6ll\n  prev_uuid: syezq9xwx3badLKu\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 9iuletCnX8AA1DWl\n  doc_id: 67810920\n  level: 1\n  id: 67810920\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 数据结构\n  uuid: BMR7y68MzsRsLpq6\n  url: ''\n  prev_uuid: 9iuletCnX8AA1DWl\n  sibling_uuid: zvwUUlHnEeEhPJ9v\n  child_uuid: E-fia709YBhQtJrt\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 对象 object\n  uuid: E-fia709YBhQtJrt\n  url: aogq4f\n  prev_uuid: BMR7y68MzsRsLpq6\n  sibling_uuid: D7LcTHUXkpP6SYG4\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432408\n  level: 1\n  id: 11432408\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 数组 array\n  uuid: D7LcTHUXkpP6SYG4\n  url: oq0mk5\n  prev_uuid: E-fia709YBhQtJrt\n  sibling_uuid: LwftOZYaPeqjwhdS\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432407\n  level: 1\n  id: 11432407\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字符串 string\n  uuid: LwftOZYaPeqjwhdS\n  url: sih9mc\n  prev_uuid: D7LcTHUXkpP6SYG4\n  sibling_uuid: dj5FuaOaHSda1AbK\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11432412\n  level: 1\n  id: 11432412\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 栈 stack\n  uuid: dj5FuaOaHSda1AbK\n  url: xi2mh9\n  prev_uuid: LwftOZYaPeqjwhdS\n  sibling_uuid: IOag-iKKv87hGhdm\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435979\n  level: 1\n  id: 11435979\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 队列 queue\n  uuid: IOag-iKKv87hGhdm\n  url: hroghz\n  prev_uuid: dj5FuaOaHSda1AbK\n  sibling_uuid: 778WMx0aXLZVUl9p\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435969\n  level: 1\n  id: 11435969\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 链表 Linkist\n  uuid: 778WMx0aXLZVUl9p\n  url: mo7sde\n  prev_uuid: IOag-iKKv87hGhdm\n  sibling_uuid: j9b8vxS9kTz8xa3x\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435962\n  level: 1\n  id: 11435962\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 树 tree\n  uuid: j9b8vxS9kTz8xa3x\n  url: glas5w\n  prev_uuid: 778WMx0aXLZVUl9p\n  sibling_uuid: QARpKzPBR5puFByT\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435974\n  level: 1\n  id: 11435974\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 图 graph\n  uuid: QARpKzPBR5puFByT\n  url: dgduok\n  prev_uuid: j9b8vxS9kTz8xa3x\n  sibling_uuid: kKoPgVQTytiILSgY\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435966\n  level: 1\n  id: 11435966\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 集合 set\n  uuid: kKoPgVQTytiILSgY\n  url: ub10iw\n  prev_uuid: QARpKzPBR5puFByT\n  sibling_uuid: R7qhLVPS4xKQZLD7\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435960\n  level: 1\n  id: 11435960\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字典和散列表 dictionary & hash table\n  uuid: R7qhLVPS4xKQZLD7\n  url: aq5vbp\n  prev_uuid: kKoPgVQTytiILSgY\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: BMR7y68MzsRsLpq6\n  doc_id: 11435958\n  level: 1\n  id: 11435958\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 动态规划\n  uuid: zvwUUlHnEeEhPJ9v\n  url: mnfkhynksc1h459r\n  prev_uuid: BMR7y68MzsRsLpq6\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 147451432\n  level: 0\n  id: 147451432\n  open_window: 1\n  visible: 0\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 16,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-19T18:02:44.299Z",
    "created_at": "2022-02-21T07:49:26.000Z",
    "updated_at": "2023-11-19T18:02:44.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-23T19:11:28.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/gm8h7g",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-23T19:11:28.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 1866756113,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-23T19:11:28.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}