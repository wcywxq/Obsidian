{
  "id": 72212411,
  "slug": "ivvld9",
  "title": "排序",
  "description": "在计算机编程中，排序算法是最常用的算法之一，本文介绍了几种常见的排序算法以及它们之间的差异和复杂度。冒泡排序冒泡排序应该是最简单的排序算法了，在所有讲解计算机编程和数据结构的课程中，无一例外都会拿冒泡排序作为开篇来讲解排序的原理。冒泡排序理解起来也很容易，就是两个嵌套循环遍历数组，对数组中的元...",
  "cover": "",
  "user_id": 732231,
  "book_id": 26225252,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "",
  "body": "在计算机编程中，排序算法是最常用的算法之一，本文介绍了几种常见的排序算法以及它们之间的差异和复杂度。\n\n<a name=\"5d7ecc89\"></a>\n## 冒泡排序\n\n冒泡排序应该是最简单的排序算法了，在所有讲解计算机编程和数据结构的课程中，无一例外都会拿冒泡排序作为开篇来讲解排序的原理。冒泡排序理解起来也很容易，就是两个嵌套循环遍历数组，对数组中的元素两两进行比较，如果前者比后者大，则交换位置（这是针对升序排序而言，如果是降序排序，则比较的原则是前者比后者小）。\n\n在冒泡排序中，对于内层的循环而言，每一次都是把这一轮中的最大值放到最后（相对于升序排序），它的过程是这样的：第一次内层循环，找出数组中的最大值排到数组的最后；第二次内层循环，找出数组中的次大值排到数组的倒数第二位；第三次内层循环，找出数组中的第三大值排到数组的倒数第三位......以此类推。所以，对于内层循环，我们可以不用每一次都遍历到length - 1的位置，而只需要遍历到 length - 1 - i的位置就可以了，这样可以减少内层循环遍历的次数。下面是改进后的冒泡排序算法\n\n```javascript\nfunction bubbleSortArray(array) {\n    let length = array.length\n    for (let i = 0; i < length; i++) {\n        for (let j = 0; j < length - 1 - i; j++) {\n            if (array[j] > array[j + 1]) {\n                [array[j], array[j + 1]] = [array[j + 1], array[j]]\n            }\n        }\n    }\n}\n```\ni<br />在实际应用中，我们并不推荐使用冒泡排序算法，尽管它是最直观的用来讲解排序过程的算法。冒泡排序算法的复杂度为 O(n2)。\n<a name=\"cc128b01\"></a>\n## 选择排序\n\n选择排序与冒泡排序很类似，它也需要两个嵌套的循环来遍历数组，只不过在每一次循环中要找出最小的元素（这是针对升序排序而言，如果是降序排序，则需要找出最大的元素）。第一次遍历找出最小的元素排在第一位，第二次遍历找出次小的元素排在第二位，以此类推。我们来看下选择排序的的实现：\n\n```javascript\nfunction selectionSort(array) {\n    let length = nums.length\n    for (let i = 0; i < length; i++) {\n        let min = i\n        for (let j = i; j < length; j++) {\n            if (nums[min] > nums[j]) {\n                min = j\n            }\n        }\n        if (min !== i) {\n            [nums[i], nums[min]] = [nums[min], nums[i]]\n        }\n    }\n    return nums\n}\n```\n\n上面这段代码是升序选择排序，它的执行过程是这样的，首先将第一个元素作为最小元素 min，然后在内层循环中遍历数组的每一个元素，如果有元素的值比 min 小，就将该元素的值赋值给 min。内层遍历完成后，如果数组的第一个元素和 min 不相同，则将它们交换一下位置。然后再将第二个元素作为最小元素 min，重复前面的过程。直到数组的每一个元素都比较完毕。\n\n选择排序算法的复杂度与冒泡排序一样，也是 O(n2)。\n\n<a name=\"112be43e\"></a>\n## 插入排序\n\n插入排序与前两个排序算法的思路不太一样，为了便于理解，我们以[ 5, 4, 3, 2, 1 ]这个数组为例，用下图来说明插入排序的整个执行过程：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646378546689-42a16045-fc76-4332-be4a-dffe251e3728.png#clientId=ucccedb18-e7b2-4&from=paste&id=u3281e052&margin=%5Bobject%20Object%5D&name=image.png&originHeight=954&originWidth=495&originalType=url&ratio=1&size=73872&status=done&style=none&taskId=uc681d2dc-7911-4b2e-9efd-1b6bd7aaf36#id=HziOQ&originHeight=954&originWidth=495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />在插入排序中，对数组的遍历是从第二个元素开始的，tmp 是个临时变量，用来保存当前位置的元素。然后从当前位置开始，取前一个位置的元素与 tmp 进行比较，如果值大于 tmp（针对升序排序而言），则将这个元素的值插入到这个位置中，最后将 tmp 放到数组的第一个位置（索引号为 0）。反复执行这个过程，直到数组元素遍历完毕。下面是插入排序算法的实现：<br />l\n\n```javascript\nfunction insertionSort(array) {\n    let length = array.length\n    let j, tmp\n\n    for (let i = 1; i < length; i++) {\n        j = i\n        tmp = array[i]\n        while (j > 0 && array[j - 1] > tmp) {\n            array[j] = array[j - 1]\n            j--\n        }\n        array[j] = tmp\n    }\n}\n```\n\n插入排序比冒泡排序和选择排序算法的性能要好。<br />i\n<a name=\"95566613\"></a>\n## 归并排序\n\n归并排序比前面介绍的几种排序算法性能都要好，它的复杂度为O(nlogn)。<br />归并排序的基本思路是通过递归调用将给定的数组不断分割成最小的两部分（每一部分只有一个元素），对这两部分进行排序，然后向上合并成一个大数组。我们还是以[ 5, 4, 3, 2, 1 ]这个数组为例，来看下归并排序的整个执行过程：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646378583275-2b43a57b-437e-4ad3-aa9b-5d193762528e.png#clientId=ucccedb18-e7b2-4&from=paste&id=u68c1c1fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=634&originWidth=274&originalType=url&ratio=1&size=29216&status=done&style=none&taskId=u6fd3db56-a878-45fb-8b5a-13ed3d84ee8#id=TYaPT&originHeight=634&originWidth=274&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />首先要将数组分成两个部分，对于非偶数长度的数组，你可以自行决定将多的分到左边或者右边。然后按照这种方式进行递归，直到数组的左右两部分都只有一个元素。对这两部分进行排序，递归向上返回的过程中将其组成和一个完整的数组。下面是归并排序的算法的实现：\n\n```javascript\nconst dfs = (l, r) => {\n  let i = 0\n  let j = 0\n  let res = []\n  while (i < l.length && j < r.length) {\n    if (l[i] < r[j]) {\n      res.push(l[i++])\n    } else {\n      res.push(r[j++])\n    }\n  }\n  return res.concat(i < l.length ? l.slice(i) : r.slice(j))\n}\nlet length = nums.length\nif (length > 1) {\n  let midIndex = length >> 1\n  nums = dfs(sortArray(nums.slice(0, midIndex)), sortArray(nums.slice(midIndex, length)))\n}\nreturn nums\n```\n<a name=\"5ee213ee\"></a>\n## 快速排序\n\n快速排序的复杂度也是O(nlogn)，但它的性能要优于其它排序算法。快速排序与归并排序类似，其基本思路也是将一个大数组分为较小的数组，但它不像归并排序一样将它们分割开。快速排序算法比较复杂，大致过程为：\n\n1. 从给定的数组中选取一个参考元素。参考元素可以是任意元素，也可以是数组的第一个元素，我们这里选取中间位置的元素（如果数组长度为偶数，则向下取一个位置），这样在大多数情况下可以提高效率。\n2. 创建两个指针，一个指向数组的最左边，一个指向数组的最右边。移动左指针直到找到比参考元素大的元素，移动右指针直到找到比参考元素小的元素，然后交换左右指针对应的元素。重复这个过程，直到左指针超过右指针（即左指针的索引号大于右指针的索引号）。通过这一操作，比参考元素小的元素都排在参考元素之前，比参考元素大的元素都排在参考元素之后（针对升序排序而言）。\n3. 以参考元素为分隔点，对左右两个较小的数组重复上述过程，直到整个数组完成排序。\n\n下面是快速排序算法的实现：\n\n```javascript\nconst partition = (array, left, right) => {\n    const pivot = array[Math.floor((right + left) / 2)]\n    let i = left\n    let j = right\n\n    while (i <= j) {\n        while (array[i] < pivot) {\n            i++\n        }\n        while (array[j] > pivot) {\n            j--\n        }\n        if (i <= j) {\n            ;[array[i], array[j]] = [array[j], array[i]]\n            i++\n            j--\n        }\n    }\n    return i\n}\n\nconst quick = (array, left, right) => {\n    let length = array.length\n    let index\n    if (length > 1) {\n        index = partition(array, left, right)\n        if (left < index - 1) {\n            quick(array, left, index - 1)\n        }\n        if (index < right) {\n            quick(array, index, right)\n        }\n    }\n    return array\n}\n\nfunction quickSort(array) {\n    return quick(array, 0, array.length - 1)\n}\n```\n\n假定数组为[ 3, 5, 1, 6, 4, 7, 2 ]，按照上面的代码逻辑，整个排序的过程如下图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646378641900-44f261e9-43ed-42ff-994e-0b4632c2da23.png#clientId=ucccedb18-e7b2-4&from=paste&id=u371ade9f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1002&originWidth=1454&originalType=url&ratio=1&size=155423&status=done&style=none&taskId=u4193ee3c-fb39-4ce5-a8e4-276671386ca#id=dQ1Fo&originHeight=1002&originWidth=1454&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />下面是测试结果：\n\n```javascript\nlet array = [3, 5, 1, 6, 4, 7, 2]\nconsole.log(array.toString()) // 3,5,1,6,4,7,2\nconsole.log(quickSort(array).toString()) // 1,2,3,4,5,6,7\n```\n\n快速排序算法理解起来有些难度，可以按照上面给出的示意图逐步推导一遍，以帮助理解整个算法的实现原理。\n\n<a name=\"141c7256\"></a>\n## 堆排序\n\n在计算机科学中，堆是一种特殊的数据结构，它通常用树来表示数组。堆有以下特点：\n\n- 堆是一棵完全二叉树\n- 子节点的值不大于父节点的值（最大堆），或者子节点的值不小于父节点的值（最小堆）\n- 根节点的索引号为 0\n- 子节点的索引为父节点索引 × 2 + 1\n- 右子节点的索引为父节点索引 × 2 + 2\n\n堆排序是一种比较高效的排序算法。<br />在堆排序中，我们并不需要将数组元素插入到堆中，而只是通过交换来形成堆，以数组[ 3, 5, 1, 6, 4, 7, 2 ]为例，我们用下图来表示其初始状态：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646378655431-c55f3ffe-d542-4270-bd86-49b1b2df4206.png#clientId=ucccedb18-e7b2-4&from=paste&id=uf8e217b4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=201&originWidth=251&originalType=url&ratio=1&size=9332&status=done&style=none&taskId=u7c7d63f6-0410-471c-8cb6-5f28c971880#id=bKZpK&originHeight=201&originWidth=251&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />那么，如何将其转换成一个符合标准的堆结构呢？先来看看堆排序算法的实现：\n\n```javascript\nconst heapify = (array, heapSize, index) => {\n    let largest = index\n    const left = index * 2 + 1\n    const right = index * 2 + 2\n    if (left < heapSize && array[left] > array[index]) {\n        largest = left\n    }\n    if (right < heapSize && array[right] > array[largest]) {\n        largest = right\n    }\n    if (largest !== index) {\n        ;[array[index], array[largest]] = [array[largest], array[index]]\n        heapify(array, heapSize, largest)\n    }\n}\n\nconst buildHeap = array => {\n    let heapSize = array.length\n    for (let i = heapSize; i >= 0; i--) {\n        heapify(array, heapSize, i)\n    }\n}\n\nfunction heapSort(array) {\n    let heapSize = array.length\n    buildHeap(array)\n\n    while (heapSize > 1) {\n        heapSize--\n        ;[array[0], array[heapSize]] = [array[heapSize], array[0]]\n        heapify(array, heapSize, 0)\n    }\n\n    return array\n}\n```\n\n函数 buildHeap()将给定的数组转换成堆（按最大堆处理）。下面是将数组[ 3, 5, 1, 6, 4, 7, 2 ]转换成堆的过程示意图：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646378669899-26cf298f-03c0-4a19-b687-f0033d79338c.png#clientId=ucccedb18-e7b2-4&from=paste&id=u6d112035&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=578&originalType=url&ratio=1&size=38567&status=done&style=none&taskId=u831b3442-9ffc-413e-8509-da91e793209#id=xJaTM&originHeight=528&originWidth=578&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />在函数 buildHeap()中，我们从数组的尾部开始遍历去查看每个节点是否符合堆的特点。在遍历的过程中，我们发现当索引号为 6、5、4、3 时，其左右子节点的索引大小都超出了数组的长度，这意味着它们都是叶子节点。那么我们真正要做的就是从索引号为 2 的节点开始。其实从这一点考虑，结合我们利用完全二叉树来表示数组的特性，可以对 buildHeap()函数进行优化，将其中的 for 循环修改为下面这样，以去掉对子节点的操作。\n\n```javascript\nfor (let i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {\n    heapify(array, heapSize, i)\n}\n```\n\n从索引 2 开始，我们查看它的左右子节点的值是否大于自己，如果是，则将其中最大的那个值与自己交换，然后向下递归查找是否还需要对子节点继续进行操作。索引 2 处理完之后再处理索引 1，然后是索引 0，最终转换出来的堆如图中的 4 所示。你会发现，每一次堆转换完成之后，排在数组第一个位置的就是堆的根节点，也就是数组的最大元素。根据这一特点，我们可以很方便地对堆进行排序，其过程是：\n\n- 将数组的第一个元素和最后一个元素交换\n- 减少数组的长度，从索引 0 开始重新转换堆\n\n直到整个过程结束。对应的示意图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646378683805-9cefa067-fdea-4444-8b3d-8e104c0901a8.png#clientId=ucccedb18-e7b2-4&from=paste&id=u7b224e76&margin=%5Bobject%20Object%5D&name=image.png&originHeight=876&originWidth=994&originalType=url&ratio=1&size=75388&status=done&style=none&taskId=uc0b0f6df-c2a9-46f1-b443-2b09d616341#id=IRJaL&originHeight=876&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />堆排序的核心部分在于如何将数组转换成堆，也就是上面代码中 buildHeap()和 heapify()函数部分。<br />同样给出堆排序的测试结果：\n\n```javascript\nlet array = [3, 5, 1, 6, 4, 7, 2]\nconsole.log(array.toString()) // 3,5,1,6,4,7,2\nconsole.log(heapSort(array).toString()) // 1,2,3,4,5,6,7\n```\n\n<a name=\"6f407f2b\"></a>\n## 有关算法复杂度\n\n上面我们在介绍各种排序算法的时候，提到了算法的复杂度，算法复杂度用大O表示法，它是用大O表示的一个函数，如：\n\n- O(1)：常数\n- O(log(n))：对数\n- O(log(n) c)：对数多项式\n- O(n)：线性\n- O(n2)：二次\n- O(nc)：多项式\n- O(cn)：指数\n\n我们如何理解大O表示法呢？看一个例子：\n\n```javascript\nfunction increment(num) {\n    return ++num\n}\n```\n\n对于函数 increment()，无论我传入的参数 num 的值是什么数字，它的运行时间都是 X（相对于同一台机器而言）。函数 increment()的性能与参数无关，因此我们可以说它的算法复杂度是O(1)（常数）。<br />再看一个例子：\n\n```javascript\nfunction sequentialSearch(array, item) {\n    for (let i = 0; i < array.length; i++) {\n        if (item === array[i]) return i\n    }\n    return -1\n}\n```\n\n函数 sequentialSearch()的作用是在数组中搜索给定的值，并返回对应的索引号。假设 array 有 10 个元素，如果要搜索的元素排在第一个，我们说开销为 1。如果要搜索的元素排在最后一个，则开销为 10。当数组有 1000 个元素时，搜索最后一个元素的开销是 1000。所以，sequentialSearch()函数的总开销取决于数组元素的个数和要搜索的值。在最坏情况下，没有找到要搜索的元素，那么总开销就是数组的长度。因此我们得出 sequentialSearch()函数的时间复杂度是O(n)，n 是数组的长度。<br />同理，对于前面我们说的冒泡排序算法，里面有一个双层嵌套的 for 循环，因此它的复杂度为O(n2)。<br />时间复杂度O(n)的代码只有一层循环，而O(n2)的代码有双层嵌套循环。如果算法有三层嵌套循环，它的时间复杂度就是O(n3)。<br />下表展示了各种不同数据结构的时间复杂度：\n\n| 数据结构 | 一般情况 |  |  | 最差情况 |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n|  | 插入 | 删除 | 搜索 | 插入 | 删除 | 搜索 |\n| 数组/栈/队列 | O(1) | O(1) | O(n) | O(1) | O(1) | O(n) |\n| 链表 | O(1) | O(1) | O(n) | O(1) | O(1) | O(n) |\n| 双向链表 | O(1) | O(1) | O(n) | O(1) | O(1) | O(n) |\n| 散列表 | O(1) | O(1) | O(1) | O(n) | O(n) | O(n) |\n| BST 树 | O(log(n)) | O(log(n)) | O(log(n)) | O(n) | O(n) | O(n) |\n| AVL 树 | O(log(n)) | O(log(n)) | O(log(n)) | O(log(n)) | O(log(n)) | O(log(n)) |\n\n\n数据结构的时间复杂度<br />\n\n| 节点/边的管理方式 | 存储空间 | 增加顶点 | 增加边 | 删除顶点 | 删除边 | 轮询 |\n| --- | --- | --- | --- | --- | --- | --- |\n| 领接表 | O(&#124; V &#124; + &#124; E &#124;) | O(1) | O(1) | O(&#124; V &#124; + &#124; E &#124;) | O(&#124; E &#124;) | O(&#124; V &#124;) |\n| 邻接矩阵 | O(&#124; V &#124;2) | O(&#124; V &#124;2) | O(1) | O(&#124; V &#124;2) | O(1) | O(1) |\n\n\n图的时间复杂度<br />\n\n| 算法（用于数组） | 时间复杂度 |  |  |\n| --- | --- | --- | --- |\n|  | 最好情况 | 一般情况 | 最差情况 |\n| 冒泡排序 | O(n) | O(n2) | O(n3) |\n| 选择排序 | O(n2) | O(n2) | O(n2) |\n| 插入排序 | O(n) | O(n2) | O(n2) |\n| 归并排序 | O(log(n)) | O(log(n)) | O(log(n)) |\n| 快速排序 | O(log(n)) | O(log(n)) | O(n2) |\n| 堆排序 | O(log(n)) | O(log(n)) | O(log(n)) |\n\n\n排序算法的时间复杂度\n\n<a name=\"cb760e4e\"></a>\n## 搜索算法\n\n顺序搜索是一种比较直观的搜索算法，上面介绍算法复杂度一小节中的 sequentialSearch()函数就是顺序搜索算法，就是按顺序对数组中的元素逐一比较，直到找到匹配的元素。顺序搜索算法的效率比较低。<br />还有一种常见的搜索算法是二分搜索算法。它的执行过程是：\n\n1. 将待搜索数组排序。\n2. 选择数组的中间值。\n3. 如果中间值正好是要搜索的值，则完成搜索。\n4. 如果要搜索的值比中间值小，则选择中间值左边的部分，重新执行步骤 2。\n5. 如果要搜索的值比中间值大，则选择中间值右边的部分，重新执行步骤 2。\n\n下面是二分搜索算法的具体实现：\n\n```javascript\nfunction binarySearch(array, item) {\n    quickSort(array) // 首先用快速排序法对array进行排序\n\n    let low = 0\n    let high = array.length - 1\n\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2) // 选取中间位置的元素\n        const element = array[mid]\n\n        // 待搜索的值大于中间值\n        if (element < item) low = mid + 1\n        // 待搜索的值小于中间值\n        else if (element > item) high = mid - 1\n        // 待搜索的值就是中间值\n        else return true\n    }\n\n    return false\n}\n```\n\n对应的测试结果：\n\n```javascript\nconst array = [8, 7, 6, 5, 4, 3, 2, 1]\nconsole.log(binarySearch(array, 2)) // true\n```\n\n这个算法的基本思路有点类似于猜数字大小，每当你说出一个数字，我都会告诉你是大了还是小了，经过几轮之后，你就可以很准确地确定数字的大小了。\n",
  "body_html": "<!doctype html><p data-lake-id=\"u309342e9\"><span>在计算机编程中，排序算法是最常用的算法之一，本文介绍了几种常见的排序算法以及它们之间的差异和复杂度。</span></p><p data-lake-id=\"u6912e1d4\"><br /></p><h2 id=\"5d7ecc89\"><span>冒泡排序</span></h2><p data-lake-id=\"ua0a2cfd8\"><br /></p><p data-lake-id=\"uf081633d\"><span>冒泡排序应该是最简单的排序算法了，在所有讲解计算机编程和数据结构的课程中，无一例外都会拿冒泡排序作为开篇来讲解排序的原理。冒泡排序理解起来也很容易，就是两个嵌套循环遍历数组，对数组中的元素两两进行比较，如果前者比后者大，则交换位置（这是针对升序排序而言，如果是降序排序，则比较的原则是前者比后者小）。</span></p><p data-lake-id=\"u13c2b12d\"><span>​</span><br /></p><p data-lake-id=\"u4535d477\"><span>在冒泡排序中，对于内层的循环而言，每一次都是把这一轮中的最大值放到最后（相对于升序排序），它的过程是这样的：第一次内层循环，找出数组中的最大值排到数组的最后；第二次内层循环，找出数组中的次大值排到数组的倒数第二位；第三次内层循环，找出数组中的第三大值排到数组的倒数第三位......以此类推。所以，对于内层循环，我们可以不用每一次都遍历到</span><span>length - 1</span><span>的位置，而只需要遍历到 </span><span>length - 1 - i</span><span>的位置就可以了，这样可以减少内层循环遍历的次数。下面是改进后的冒泡排序算法</span></p><p data-lake-id=\"u752bedca\"><br /></p><pre data-lang=\"javascript\"><code>function bubbleSortArray(array) {\n    let length = array.length\n    for (let i = 0; i &lt; length; i++) {\n        for (let j = 0; j &lt; length - 1 - i; j++) {\n            if (array[j] &gt; array[j + 1]) {\n                [array[j], array[j + 1]] = [array[j + 1], array[j]]\n            }\n        }\n    }\n}</code></pre><p data-lake-id=\"u987cdb3b\"><span>i</span></p><p data-lake-id=\"u07306dd0\"><span>在实际应用中，我们并不推荐使用冒泡排序算法，尽管它是最直观的用来讲解排序过程的算法。冒泡排序算法的复杂度为 O(n2)。</span></p><h2 id=\"cc128b01\"><span>选择排序</span></h2><p data-lake-id=\"u29717314\"><br /></p><p data-lake-id=\"ua419053c\"><span>选择排序与冒泡排序很类似，它也需要两个嵌套的循环来遍历数组，只不过在每一次循环中要找出最小的元素（这是针对升序排序而言，如果是降序排序，则需要找出最大的元素）。第一次遍历找出最小的元素排在第一位，第二次遍历找出次小的元素排在第二位，以此类推。我们来看下选择排序的的实现：</span></p><p data-lake-id=\"u03e8c67d\"><br /></p><pre data-lang=\"javascript\"><code>function selectionSort(array) {\n    let length = nums.length\n    for (let i = 0; i &lt; length; i++) {\n        let min = i\n        for (let j = i; j &lt; length; j++) {\n            if (nums[min] &gt; nums[j]) {\n                min = j\n            }\n        }\n        if (min !== i) {\n            [nums[i], nums[min]] = [nums[min], nums[i]]\n        }\n    }\n    return nums\n}</code></pre><p data-lake-id=\"u5ffea1c3\"><br /></p><p data-lake-id=\"u002256bd\"><span>上面这段代码是升序选择排序，它的执行过程是这样的，首先将第一个元素作为最小元素 min，然后在内层循环中遍历数组的每一个元素，如果有元素的值比 min 小，就将该元素的值赋值给 min。内层遍历完成后，如果数组的第一个元素和 min 不相同，则将它们交换一下位置。然后再将第二个元素作为最小元素 min，重复前面的过程。直到数组的每一个元素都比较完毕。</span></p><p data-lake-id=\"u0ff8c52f\"><br /></p><p data-lake-id=\"u4d33280e\"><span>选择排序算法的复杂度与冒泡排序一样，也是 O(n2)。</span></p><p data-lake-id=\"u03471389\"><br /></p><h2 id=\"112be43e\"><span>插入排序</span></h2><p data-lake-id=\"ucbd43de7\"><br /></p><p data-lake-id=\"u5e55f4f9\"><span>插入排序与前两个排序算法的思路不太一样，为了便于理解，我们以[ 5, 4, 3, 2, 1 ]这个数组为例，用下图来说明插入排序的整个执行过程：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646378546689-42a16045-fc76-4332-be4a-dffe251e3728.png#clientId=ucccedb18-e7b2-4&amp;from=paste&amp;id=u3281e052&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=954&amp;originWidth=495&amp;originalType=url&amp;ratio=1&amp;size=73872&amp;status=done&amp;style=none&amp;taskId=uc681d2dc-7911-4b2e-9efd-1b6bd7aaf36#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=HziOQ&amp;originHeight=954&amp;originWidth=495&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>在插入排序中，对数组的遍历是从第二个元素开始的，tmp 是个临时变量，用来保存当前位置的元素。然后从当前位置开始，取前一个位置的元素与 tmp 进行比较，如果值大于 tmp（针对升序排序而言），则将这个元素的值插入到这个位置中，最后将 tmp 放到数组的第一个位置（索引号为 0）。反复执行这个过程，直到数组元素遍历完毕。下面是插入排序算法的实现：<br /></span><span>l</span></p><p data-lake-id=\"u12b1ff04\"><br /></p><pre data-lang=\"javascript\"><code>function insertionSort(array) {\n    let length = array.length\n    let j, tmp\n\n    for (let i = 1; i &lt; length; i++) {\n        j = i\n        tmp = array[i]\n        while (j &gt; 0 &amp;&amp; array[j - 1] &gt; tmp) {\n            array[j] = array[j - 1]\n            j--\n        }\n        array[j] = tmp\n    }\n}</code></pre><p data-lake-id=\"ud55bacbb\"><br /></p><p data-lake-id=\"u3a7d512e\"><span>插入排序比冒泡排序和选择排序算法的性能要好。</span></p><p data-lake-id=\"u8a18e877\"><span>i</span></p><h2 id=\"95566613\"><span>归并排序</span></h2><p data-lake-id=\"uc5d0e252\"><br /></p><p data-lake-id=\"u477fd5ac\"><span>归并排序比前面介绍的几种排序算法性能都要好，它的复杂度为</span><span>O(nlogn)</span><span>。<br /></span><span>归并排序的基本思路是通过递归调用将给定的数组不断分割成最小的两部分（每一部分只有一个元素），对这两部分进行排序，然后向上合并成一个大数组。我们还是以[ 5, 4, 3, 2, 1 ]这个数组为例，来看下归并排序的整个执行过程：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646378583275-2b43a57b-437e-4ad3-aa9b-5d193762528e.png#clientId=ucccedb18-e7b2-4&amp;from=paste&amp;id=u68c1c1fc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=634&amp;originWidth=274&amp;originalType=url&amp;ratio=1&amp;size=29216&amp;status=done&amp;style=none&amp;taskId=u6fd3db56-a878-45fb-8b5a-13ed3d84ee8#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=TYaPT&amp;originHeight=634&amp;originWidth=274&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>首先要将数组分成两个部分，对于非偶数长度的数组，你可以自行决定将多的分到左边或者右边。然后按照这种方式进行递归，直到数组的左右两部分都只有一个元素。对这两部分进行排序，递归向上返回的过程中将其组成和一个完整的数组。下面是归并排序的算法的实现：</span></p><p data-lake-id=\"u710b06ce\"><br /></p><pre data-lang=\"javascript\"><code>const dfs = (l, r) =&gt; {\n  let i = 0\n  let j = 0\n  let res = []\n  while (i &lt; l.length &amp;&amp; j &lt; r.length) {\n    if (l[i] &lt; r[j]) {\n      res.push(l[i++])\n    } else {\n      res.push(r[j++])\n    }\n  }\n  return res.concat(i &lt; l.length ? l.slice(i) : r.slice(j))\n}\nlet length = nums.length\nif (length &gt; 1) {\n  let midIndex = length &gt;&gt; 1\n  nums = dfs(sortArray(nums.slice(0, midIndex)), sortArray(nums.slice(midIndex, length)))\n}\nreturn nums</code></pre><h2 id=\"5ee213ee\"><span>快速排序</span></h2><p data-lake-id=\"u7e05a195\"><br /></p><p data-lake-id=\"ub23a9dd8\"><span>快速排序的复杂度也是</span><span>O(nlogn)</span><span>，但它的性能要优于其它排序算法。快速排序与归并排序类似，其基本思路也是将一个大数组分为较小的数组，但它不像归并排序一样将它们分割开。快速排序算法比较复杂，大致过程为：</span></p><p data-lake-id=\"u74c38e91\"><br /></p><ol><li><span>从给定的数组中选取一个参考元素。参考元素可以是任意元素，也可以是数组的第一个元素，我们这里选取中间位置的元素（如果数组长度为偶数，则向下取一个位置），这样在大多数情况下可以提高效率。</span></li><li><span>创建两个指针，一个指向数组的最左边，一个指向数组的最右边。移动左指针直到找到比参考元素大的元素，移动右指针直到找到比参考元素小的元素，然后交换左右指针对应的元素。重复这个过程，直到左指针超过右指针（即左指针的索引号大于右指针的索引号）。通过这一操作，比参考元素小的元素都排在参考元素之前，比参考元素大的元素都排在参考元素之后（针对升序排序而言）。</span></li><li><span>以参考元素为分隔点，对左右两个较小的数组重复上述过程，直到整个数组完成排序。</span></li></ol><p data-lake-id=\"u2f781561\"><br /></p><p data-lake-id=\"u3d0b52cc\"><span>下面是快速排序算法的实现：</span></p><p data-lake-id=\"uf280d7d3\"><br /></p><pre data-lang=\"javascript\"><code>const partition = (array, left, right) =&gt; {\n    const pivot = array[Math.floor((right + left) / 2)]\n    let i = left\n    let j = right\n\n    while (i &lt;= j) {\n        while (array[i] &lt; pivot) {\n            i++\n        }\n        while (array[j] &gt; pivot) {\n            j--\n        }\n        if (i &lt;= j) {\n            ;[array[i], array[j]] = [array[j], array[i]]\n            i++\n            j--\n        }\n    }\n    return i\n}\n\nconst quick = (array, left, right) =&gt; {\n    let length = array.length\n    let index\n    if (length &gt; 1) {\n        index = partition(array, left, right)\n        if (left &lt; index - 1) {\n            quick(array, left, index - 1)\n        }\n        if (index &lt; right) {\n            quick(array, index, right)\n        }\n    }\n    return array\n}\n\nfunction quickSort(array) {\n    return quick(array, 0, array.length - 1)\n}</code></pre><p data-lake-id=\"u4ae3613f\"><br /></p><p data-lake-id=\"u94e85d7b\"><span>假定数组为[ 3, 5, 1, 6, 4, 7, 2 ]，按照上面的代码逻辑，整个排序的过程如下图所示：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646378641900-44f261e9-43ed-42ff-994e-0b4632c2da23.png#clientId=ucccedb18-e7b2-4&amp;from=paste&amp;id=u371ade9f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1002&amp;originWidth=1454&amp;originalType=url&amp;ratio=1&amp;size=155423&amp;status=done&amp;style=none&amp;taskId=u4193ee3c-fb39-4ce5-a8e4-276671386ca#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=dQ1Fo&amp;originHeight=1002&amp;originWidth=1454&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>下面是测试结果：</span></p><p data-lake-id=\"uc2bcabbd\"><br /></p><pre data-lang=\"javascript\"><code>let array = [3, 5, 1, 6, 4, 7, 2]\nconsole.log(array.toString()) // 3,5,1,6,4,7,2\nconsole.log(quickSort(array).toString()) // 1,2,3,4,5,6,7</code></pre><p data-lake-id=\"ubdb7e9d5\"><br /></p><p data-lake-id=\"u9f988c8a\"><span>快速排序算法理解起来有些难度，可以按照上面给出的示意图逐步推导一遍，以帮助理解整个算法的实现原理。</span></p><p data-lake-id=\"u8be5816e\"><br /></p><h2 id=\"141c7256\"><span>堆排序</span></h2><p data-lake-id=\"u41c55b6f\"><br /></p><p data-lake-id=\"uc0395365\"><span>在计算机科学中，堆是一种特殊的数据结构，它通常用树来表示数组。堆有以下特点：</span></p><p data-lake-id=\"u89b0a7c3\"><br /></p><ul><li><span>堆是一棵完全二叉树</span></li><li><span>子节点的值不大于父节点的值（最大堆），或者子节点的值不小于父节点的值（最小堆）</span></li><li><span>根节点的索引号为 0</span></li><li><span>子节点的索引为父节点索引 × 2 + 1</span></li><li><span>右子节点的索引为父节点索引 × 2 + 2</span></li></ul><p data-lake-id=\"ued93905b\"><br /></p><p data-lake-id=\"u91be1c76\"><span>堆排序是一种比较高效的排序算法。<br /></span><span>在堆排序中，我们并不需要将数组元素插入到堆中，而只是通过交换来形成堆，以数组[ 3, 5, 1, 6, 4, 7, 2 ]为例，我们用下图来表示其初始状态：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646378655431-c55f3ffe-d542-4270-bd86-49b1b2df4206.png#clientId=ucccedb18-e7b2-4&amp;from=paste&amp;id=uf8e217b4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=201&amp;originWidth=251&amp;originalType=url&amp;ratio=1&amp;size=9332&amp;status=done&amp;style=none&amp;taskId=u7c7d63f6-0410-471c-8cb6-5f28c971880#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=bKZpK&amp;originHeight=201&amp;originWidth=251&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>那么，如何将其转换成一个符合标准的堆结构呢？先来看看堆排序算法的实现：</span></p><p data-lake-id=\"u0c83a158\"><br /></p><pre data-lang=\"javascript\"><code>const heapify = (array, heapSize, index) =&gt; {\n    let largest = index\n    const left = index * 2 + 1\n    const right = index * 2 + 2\n    if (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) {\n        largest = left\n    }\n    if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) {\n        largest = right\n    }\n    if (largest !== index) {\n        ;[array[index], array[largest]] = [array[largest], array[index]]\n        heapify(array, heapSize, largest)\n    }\n}\n\nconst buildHeap = array =&gt; {\n    let heapSize = array.length\n    for (let i = heapSize; i &gt;= 0; i--) {\n        heapify(array, heapSize, i)\n    }\n}\n\nfunction heapSort(array) {\n    let heapSize = array.length\n    buildHeap(array)\n\n    while (heapSize &gt; 1) {\n        heapSize--\n        ;[array[0], array[heapSize]] = [array[heapSize], array[0]]\n        heapify(array, heapSize, 0)\n    }\n\n    return array\n}</code></pre><p data-lake-id=\"u7b875cbd\"><br /></p><p data-lake-id=\"u685c072d\"><span>函数 buildHeap()将给定的数组转换成堆（按最大堆处理）。下面是将数组[ 3, 5, 1, 6, 4, 7, 2 ]转换成堆的过程示意图：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646378669899-26cf298f-03c0-4a19-b687-f0033d79338c.png#clientId=ucccedb18-e7b2-4&amp;from=paste&amp;id=u6d112035&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=528&amp;originWidth=578&amp;originalType=url&amp;ratio=1&amp;size=38567&amp;status=done&amp;style=none&amp;taskId=u831b3442-9ffc-413e-8509-da91e793209#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=xJaTM&amp;originHeight=528&amp;originWidth=578&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>在函数 buildHeap()中，我们从数组的尾部开始遍历去查看每个节点是否符合堆的特点。在遍历的过程中，我们发现当索引号为 6、5、4、3 时，其左右子节点的索引大小都超出了数组的长度，这意味着它们都是叶子节点。那么我们真正要做的就是从索引号为 2 的节点开始。其实从这一点考虑，结合我们利用完全二叉树来表示数组的特性，可以对 buildHeap()函数进行优化，将其中的 for 循环修改为下面这样，以去掉对子节点的操作。</span></p><p data-lake-id=\"u1895c467\"><br /></p><pre data-lang=\"javascript\"><code>for (let i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) {\n    heapify(array, heapSize, i)\n}</code></pre><p data-lake-id=\"u674a8c68\"><br /></p><p data-lake-id=\"u168aa2c0\"><span>从索引 2 开始，我们查看它的左右子节点的值是否大于自己，如果是，则将其中最大的那个值与自己交换，然后向下递归查找是否还需要对子节点继续进行操作。索引 2 处理完之后再处理索引 1，然后是索引 0，最终转换出来的堆如图中的 4 所示。你会发现，每一次堆转换完成之后，排在数组第一个位置的就是堆的根节点，也就是数组的最大元素。根据这一特点，我们可以很方便地对堆进行排序，其过程是：</span></p><p data-lake-id=\"u5c25d9a1\"><br /></p><ul><li><span>将数组的第一个元素和最后一个元素交换</span></li><li><span>减少数组的长度，从索引 0 开始重新转换堆</span></li></ul><p data-lake-id=\"u070c0fe3\"><br /></p><p data-lake-id=\"u795b7765\"><span>直到整个过程结束。对应的示意图如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646378683805-9cefa067-fdea-4444-8b3d-8e104c0901a8.png#clientId=ucccedb18-e7b2-4&amp;from=paste&amp;id=u7b224e76&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=876&amp;originWidth=994&amp;originalType=url&amp;ratio=1&amp;size=75388&amp;status=done&amp;style=none&amp;taskId=uc0b0f6df-c2a9-46f1-b443-2b09d616341#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=IRJaL&amp;originHeight=876&amp;originWidth=994&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>堆排序的核心部分在于如何将数组转换成堆，也就是上面代码中 buildHeap()和 heapify()函数部分。<br /></span><span>同样给出堆排序的测试结果：</span></p><p data-lake-id=\"u275841a2\"><br /></p><pre data-lang=\"javascript\"><code>let array = [3, 5, 1, 6, 4, 7, 2]\nconsole.log(array.toString()) // 3,5,1,6,4,7,2\nconsole.log(heapSort(array).toString()) // 1,2,3,4,5,6,7</code></pre><p data-lake-id=\"u9d3e6481\"><br /></p><h2 id=\"6f407f2b\"><span>有关算法复杂度</span></h2><p data-lake-id=\"ue9648272\"><br /></p><p data-lake-id=\"u43289b4e\"><span>上面我们在介绍各种排序算法的时候，提到了算法的复杂度，算法复杂度用大</span><span>O</span><span>表示法，它是用大</span><span>O</span><span>表示的一个函数，如：</span></p><p data-lake-id=\"udfc9b01d\"><br /></p><ul><li><span>O</span><span>(1)：常数</span></li><li><span>O</span><span>(log(n))：对数</span></li><li><span>O</span><span>(log(n) c)：对数多项式</span></li><li><span>O</span><span>(n)：线性</span></li><li><span>O</span><span>(n2)：二次</span></li><li><span>O</span><span>(nc)：多项式</span></li><li><span>O</span><span>(cn)：指数</span></li></ul><p data-lake-id=\"ud179bdd5\"><br /></p><p data-lake-id=\"u9d817ee0\"><span>我们如何理解大</span><span>O</span><span>表示法呢？看一个例子：</span></p><p data-lake-id=\"ubf2b74d8\"><br /></p><pre data-lang=\"javascript\"><code>function increment(num) {\n    return ++num\n}</code></pre><p data-lake-id=\"ua3052ab6\"><br /></p><p data-lake-id=\"u02268f16\"><span>对于函数 increment()，无论我传入的参数 num 的值是什么数字，它的运行时间都是 X（相对于同一台机器而言）。函数 increment()的性能与参数无关，因此我们可以说它的算法复杂度是</span><span>O</span><span>(1)（常数）。<br /></span><span>再看一个例子：</span></p><p data-lake-id=\"u06a80b0f\"><br /></p><pre data-lang=\"javascript\"><code>function sequentialSearch(array, item) {\n    for (let i = 0; i &lt; array.length; i++) {\n        if (item === array[i]) return i\n    }\n    return -1\n}</code></pre><p data-lake-id=\"u72983383\"><br /></p><p data-lake-id=\"u3845abca\"><span>函数 sequentialSearch()的作用是在数组中搜索给定的值，并返回对应的索引号。假设 array 有 10 个元素，如果要搜索的元素排在第一个，我们说开销为 1。如果要搜索的元素排在最后一个，则开销为 10。当数组有 1000 个元素时，搜索最后一个元素的开销是 1000。所以，sequentialSearch()函数的总开销取决于数组元素的个数和要搜索的值。在最坏情况下，没有找到要搜索的元素，那么总开销就是数组的长度。因此我们得出 sequentialSearch()函数的时间复杂度是</span><span>O</span><span>(n)，n 是数组的长度。<br /></span><span>同理，对于前面我们说的冒泡排序算法，里面有一个双层嵌套的 for 循环，因此它的复杂度为</span><span>O</span><span>(n2)。<br /></span><span>时间复杂度</span><span>O</span><span>(n)的代码只有一层循环，而</span><span>O</span><span>(n2)的代码有双层嵌套循环。如果算法有三层嵌套循环，它的时间复杂度就是</span><span>O</span><span>(n3)。<br /></span><span>下表展示了各种不同数据结构的时间复杂度：</span></p><table class=\"lake-table\" style=\"width: 749px;\"><colgroup><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col></colgroup><tbody><tr><td><p data-lake-id=\"u660e2f43\"><span>数据结构</span></p></td><td><p data-lake-id=\"uf8293c5d\"><span>一般情况</span></p></td><td><p data-lake-id=\"u6fbd257b\"><br /></p></td><td><p data-lake-id=\"uc9312dc8\"><br /></p></td><td><p data-lake-id=\"ua90573af\"><span>最差情况</span></p></td><td><p data-lake-id=\"u39a238c9\"><br /></p></td><td><p data-lake-id=\"udf03df76\"><br /></p></td></tr><tr><td><p data-lake-id=\"u6436b5bc\"><br /></p></td><td><p data-lake-id=\"u83233973\"><span>插入</span></p></td><td><p data-lake-id=\"u27e51b54\"><span>删除</span></p></td><td><p data-lake-id=\"u2e909e01\"><span>搜索</span></p></td><td><p data-lake-id=\"u9cc224a7\"><span>插入</span></p></td><td><p data-lake-id=\"uf18668a4\"><span>删除</span></p></td><td><p data-lake-id=\"u123f6cef\"><span>搜索</span></p></td></tr><tr><td><p data-lake-id=\"u170c1272\"><span>数组/栈/队列</span></p></td><td><p data-lake-id=\"u1167af4e\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u3df23437\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u54a1a33d\"><span>O</span><span>(n)</span></p></td><td><p data-lake-id=\"ub089bfb6\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"uf8550af3\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u31da261b\"><span>O</span><span>(n)</span></p></td></tr><tr><td><p data-lake-id=\"u9b563086\"><span>链表</span></p></td><td><p data-lake-id=\"u94512141\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u6f1c1d83\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u85667a6f\"><span>O</span><span>(n)</span></p></td><td><p data-lake-id=\"ub1e627a4\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u06697ebd\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"ue3f856ce\"><span>O</span><span>(n)</span></p></td></tr><tr><td><p data-lake-id=\"uf5bd04a8\"><span>双向链表</span></p></td><td><p data-lake-id=\"u0f4178ff\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"uca41f358\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u0de91640\"><span>O</span><span>(n)</span></p></td><td><p data-lake-id=\"u14f69f67\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u743f6626\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"ua4241591\"><span>O</span><span>(n)</span></p></td></tr><tr><td><p data-lake-id=\"ud90a5923\"><span>散列表</span></p></td><td><p data-lake-id=\"u88f7fa0c\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"uefc31805\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"ued88abc8\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u75abf8b1\"><span>O</span><span>(n)</span></p></td><td><p data-lake-id=\"u9d79e6a0\"><span>O</span><span>(n)</span></p></td><td><p data-lake-id=\"u26e5289d\"><span>O</span><span>(n)</span></p></td></tr><tr><td><p data-lake-id=\"u08ffc110\"><span>BST 树</span></p></td><td><p data-lake-id=\"u18e54920\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u64ff164b\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u0f6e589e\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u59f2ea6e\"><span>O</span><span>(n)</span></p></td><td><p data-lake-id=\"uf450d318\"><span>O</span><span>(n)</span></p></td><td><p data-lake-id=\"u664c0dc6\"><span>O</span><span>(n)</span></p></td></tr><tr><td><p data-lake-id=\"u3cf96b05\"><span>AVL 树</span></p></td><td><p data-lake-id=\"uecadebde\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u0e3da67d\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u97810984\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u8ff4648b\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"uab0f1114\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u6d45f53d\"><span>O</span><span>(log(n))</span></p></td></tr></tbody></table><p data-lake-id=\"u8cd51b10\"><br /></p><p data-lake-id=\"ude01f3cb\"><span>数据结构的时间复杂度<br /></span><span>​</span></p><table class=\"lake-table\" style=\"width: 752px;\"><colgroup><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"110\"></col></colgroup><tbody><tr><td><p data-lake-id=\"u1a06b61c\"><span>节点/边的管理方式</span></p></td><td><p data-lake-id=\"ud9c2beeb\"><span>存储空间</span></p></td><td><p data-lake-id=\"u48c2cb57\"><span>增加顶点</span></p></td><td><p data-lake-id=\"u5fddc22e\"><span>增加边</span></p></td><td><p data-lake-id=\"ue967eb42\"><span>删除顶点</span></p></td><td><p data-lake-id=\"uecb8c382\"><span>删除边</span></p></td><td><p data-lake-id=\"u73b6ae55\"><span>轮询</span></p></td></tr><tr><td><p data-lake-id=\"ud9c8ac99\"><span>领接表</span></p></td><td><p data-lake-id=\"u97bbb1ac\"><span>O</span><span>(| V | + | E |)</span></p></td><td><p data-lake-id=\"u7e3a7ded\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u4047e46e\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u692be258\"><span>O</span><span>(| V | + | E |)</span></p></td><td><p data-lake-id=\"uca8cb42c\"><span>O</span><span>(| E |)</span></p></td><td><p data-lake-id=\"u22befa9e\"><span>O</span><span>(| V |)</span></p></td></tr><tr><td><p data-lake-id=\"u350ab06f\"><span>邻接矩阵</span></p></td><td><p data-lake-id=\"u0a9960db\"><span>O</span><span>(| V |2)</span></p></td><td><p data-lake-id=\"u38a03faa\"><span>O</span><span>(| V |2)</span></p></td><td><p data-lake-id=\"uf5010889\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"ue0304472\"><span>O</span><span>(| V |2)</span></p></td><td><p data-lake-id=\"u13a71d8f\"><span>O</span><span>(1)</span></p></td><td><p data-lake-id=\"u3a2a2ed8\"><span>O</span><span>(1)</span></p></td></tr></tbody></table><p data-lake-id=\"u0d7e9227\"><br /></p><p data-lake-id=\"u4e5a18f3\"><span>图的时间复杂度<br /></span><span>​</span></p><table class=\"lake-table\" style=\"width: 748px;\"><colgroup><col width=\"187\"></col><col width=\"187\"></col><col width=\"187\"></col><col width=\"187\"></col></colgroup><tbody><tr><td><p data-lake-id=\"u4051f389\"><span>算法（用于数组）</span></p></td><td><p data-lake-id=\"u3df68483\"><span>时间复杂度</span></p></td><td><p data-lake-id=\"ueec0e884\"><br /></p></td><td><p data-lake-id=\"uf77a4ef9\"><br /></p></td></tr><tr><td><p data-lake-id=\"u088b7c03\"><br /></p></td><td><p data-lake-id=\"u14ec94ec\"><span>最好情况</span></p></td><td><p data-lake-id=\"u08a8adf5\"><span>一般情况</span></p></td><td><p data-lake-id=\"u768ad8eb\"><span>最差情况</span></p></td></tr><tr><td><p data-lake-id=\"udc8ca96c\"><span>冒泡排序</span></p></td><td><p data-lake-id=\"u8a529225\"><span>O</span><span>(n)</span></p></td><td><p data-lake-id=\"u790a1a75\"><span>O</span><span>(n2)</span></p></td><td><p data-lake-id=\"ua559c929\"><span>O</span><span>(n3)</span></p></td></tr><tr><td><p data-lake-id=\"u80cc8d94\"><span>选择排序</span></p></td><td><p data-lake-id=\"u08739a3b\"><span>O</span><span>(n2)</span></p></td><td><p data-lake-id=\"u13528fe5\"><span>O</span><span>(n2)</span></p></td><td><p data-lake-id=\"u0f089912\"><span>O</span><span>(n2)</span></p></td></tr><tr><td><p data-lake-id=\"uaf55f260\"><span>插入排序</span></p></td><td><p data-lake-id=\"uc8af4a3b\"><span>O</span><span>(n)</span></p></td><td><p data-lake-id=\"uc6f81fda\"><span>O</span><span>(n2)</span></p></td><td><p data-lake-id=\"u933885ad\"><span>O</span><span>(n2)</span></p></td></tr><tr><td><p data-lake-id=\"ufc1a9d5d\"><span>归并排序</span></p></td><td><p data-lake-id=\"u84256a16\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"uf2991479\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u65c5d00b\"><span>O</span><span>(log(n))</span></p></td></tr><tr><td><p data-lake-id=\"uafa03142\"><span>快速排序</span></p></td><td><p data-lake-id=\"ub43e066b\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u3ef7e503\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u08b0f82b\"><span>O</span><span>(n2)</span></p></td></tr><tr><td><p data-lake-id=\"u888857e2\"><span>堆排序</span></p></td><td><p data-lake-id=\"udc7bcce9\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u34280ea0\"><span>O</span><span>(log(n))</span></p></td><td><p data-lake-id=\"u124e5590\"><span>O</span><span>(log(n))</span></p></td></tr></tbody></table><p data-lake-id=\"u33292f98\"><br /></p><p data-lake-id=\"u058d6fcd\"><span>排序算法的时间复杂度</span></p><p data-lake-id=\"uc27f4f11\"><br /></p><h2 id=\"cb760e4e\"><span>搜索算法</span></h2><p data-lake-id=\"u5b24383b\"><br /></p><p data-lake-id=\"u08537899\"><span>顺序搜索是一种比较直观的搜索算法，上面介绍算法复杂度一小节中的 sequentialSearch()函数就是顺序搜索算法，就是按顺序对数组中的元素逐一比较，直到找到匹配的元素。顺序搜索算法的效率比较低。<br /></span><span>还有一种常见的搜索算法是二分搜索算法。它的执行过程是：</span></p><p data-lake-id=\"uecaa2171\"><br /></p><ol><li><span>将待搜索数组排序。</span></li><li><span>选择数组的中间值。</span></li><li><span>如果中间值正好是要搜索的值，则完成搜索。</span></li><li><span>如果要搜索的值比中间值小，则选择中间值左边的部分，重新执行步骤 2。</span></li><li><span>如果要搜索的值比中间值大，则选择中间值右边的部分，重新执行步骤 2。</span></li></ol><p data-lake-id=\"ue978fabd\"><br /></p><p data-lake-id=\"u31991bb5\"><span>下面是二分搜索算法的具体实现：</span></p><p data-lake-id=\"u12792c27\"><br /></p><pre data-lang=\"javascript\"><code>function binarySearch(array, item) {\n    quickSort(array) // 首先用快速排序法对array进行排序\n\n    let low = 0\n    let high = array.length - 1\n\n    while (low &lt;= high) {\n        const mid = Math.floor((low + high) / 2) // 选取中间位置的元素\n        const element = array[mid]\n\n        // 待搜索的值大于中间值\n        if (element &lt; item) low = mid + 1\n        // 待搜索的值小于中间值\n        else if (element &gt; item) high = mid - 1\n        // 待搜索的值就是中间值\n        else return true\n    }\n\n    return false\n}</code></pre><p data-lake-id=\"ua5255710\"><br /></p><p data-lake-id=\"ud5d99ce5\"><span>对应的测试结果：</span></p><p data-lake-id=\"u74479c28\"><br /></p><pre data-lang=\"javascript\"><code>const array = [8, 7, 6, 5, 4, 3, 2, 1]\nconsole.log(binarySearch(array, 2)) // true</code></pre><p data-lake-id=\"ud4cf9863\"><br /></p><p data-lake-id=\"uea58cbb6\"><span>这个算法的基本思路有点类似于猜数字大小，每当你说出一个数字，我都会告诉你是大了还是小了，经过几轮之后，你就可以很准确地确定数字的大小了。</span></p>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u309342e9\" id=\"u309342e9\"><span data-lake-id=\"u5ec41684\" id=\"u5ec41684\">在计算机编程中，排序算法是最常用的算法之一，本文介绍了几种常见的排序算法以及它们之间的差异和复杂度。</span></p><p data-lake-id=\"u6912e1d4\" id=\"u6912e1d4\"><br></p><h2 data-lake-id=\"5d7ecc89\" id=\"5d7ecc89\"><span data-lake-id=\"u3cb197c8\" id=\"u3cb197c8\">冒泡排序</span></h2><p data-lake-id=\"ua0a2cfd8\" id=\"ua0a2cfd8\"><br></p><p data-lake-id=\"uf081633d\" id=\"uf081633d\"><span data-lake-id=\"ud43e9821\" id=\"ud43e9821\">冒泡排序应该是最简单的排序算法了，在所有讲解计算机编程和数据结构的课程中，无一例外都会拿冒泡排序作为开篇来讲解排序的原理。冒泡排序理解起来也很容易，就是两个嵌套循环遍历数组，对数组中的元素两两进行比较，如果前者比后者大，则交换位置（这是针对升序排序而言，如果是降序排序，则比较的原则是前者比后者小）。</span></p><p data-lake-id=\"u13c2b12d\" id=\"u13c2b12d\"><span data-lake-id=\"u76f55a46\" id=\"u76f55a46\">​</span><br></p><p data-lake-id=\"u4535d477\" id=\"u4535d477\"><span data-lake-id=\"u7639cdc5\" id=\"u7639cdc5\">在冒泡排序中，对于内层的循环而言，每一次都是把这一轮中的最大值放到最后（相对于升序排序），它的过程是这样的：第一次内层循环，找出数组中的最大值排到数组的最后；第二次内层循环，找出数组中的次大值排到数组的倒数第二位；第三次内层循环，找出数组中的第三大值排到数组的倒数第三位......以此类推。所以，对于内层循环，我们可以不用每一次都遍历到</span><span data-lake-id=\"u79809ce2\" id=\"u79809ce2\">length - 1</span><span data-lake-id=\"u0a00fdd4\" id=\"u0a00fdd4\">的位置，而只需要遍历到 </span><span data-lake-id=\"u9607d90c\" id=\"u9607d90c\">length - 1 - i</span><span data-lake-id=\"u7c8bd4c3\" id=\"u7c8bd4c3\">的位置就可以了，这样可以减少内层循环遍历的次数。下面是改进后的冒泡排序算法</span></p><p data-lake-id=\"u752bedca\" id=\"u752bedca\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20bubbleSortArray(array)%20%7B%5Cn%20%20%20%20let%20length%20%3D%20array.length%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20for%20(let%20j%20%3D%200%3B%20j%20%3C%20length%20-%201%20-%20i%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(array%5Bj%5D%20%3E%20array%5Bj%20%2B%201%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Barray%5Bj%5D%2C%20array%5Bj%20%2B%201%5D%5D%20%3D%20%5Barray%5Bj%20%2B%201%5D%2C%20array%5Bj%5D%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22One%20Dark%20Pro%22%2C%22id%22%3A%22a43e27e3%22%7D\"></card><p data-lake-id=\"u987cdb3b\" id=\"u987cdb3b\"><span data-lake-id=\"uebd8d061\" id=\"uebd8d061\">i</span></p><p data-lake-id=\"u07306dd0\" id=\"u07306dd0\"><span data-lake-id=\"u3d6fd185\" id=\"u3d6fd185\">在实际应用中，我们并不推荐使用冒泡排序算法，尽管它是最直观的用来讲解排序过程的算法。冒泡排序算法的复杂度为 O(n2)。</span></p><h2 data-lake-id=\"cc128b01\" id=\"cc128b01\"><span data-lake-id=\"u269d30e6\" id=\"u269d30e6\">选择排序</span></h2><p data-lake-id=\"u29717314\" id=\"u29717314\"><br></p><p data-lake-id=\"ua419053c\" id=\"ua419053c\"><span data-lake-id=\"u1acb0e59\" id=\"u1acb0e59\">选择排序与冒泡排序很类似，它也需要两个嵌套的循环来遍历数组，只不过在每一次循环中要找出最小的元素（这是针对升序排序而言，如果是降序排序，则需要找出最大的元素）。第一次遍历找出最小的元素排在第一位，第二次遍历找出次小的元素排在第二位，以此类推。我们来看下选择排序的的实现：</span></p><p data-lake-id=\"u03e8c67d\" id=\"u03e8c67d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20selectionSort(array)%20%7B%5Cn%20%20%20%20let%20length%20%3D%20nums.length%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20let%20min%20%3D%20i%5Cn%20%20%20%20%20%20%20%20for%20(let%20j%20%3D%20i%3B%20j%20%3C%20length%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(nums%5Bmin%5D%20%3E%20nums%5Bj%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20min%20%3D%20j%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20if%20(min%20!%3D%3D%20i)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5Bnums%5Bi%5D%2C%20nums%5Bmin%5D%5D%20%3D%20%5Bnums%5Bmin%5D%2C%20nums%5Bi%5D%5D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20nums%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22One%20Dark%20Pro%22%2C%22id%22%3A%22b6453210%22%7D\"></card><p data-lake-id=\"u5ffea1c3\" id=\"u5ffea1c3\"><br></p><p data-lake-id=\"u002256bd\" id=\"u002256bd\"><span data-lake-id=\"uc6264a30\" id=\"uc6264a30\">上面这段代码是升序选择排序，它的执行过程是这样的，首先将第一个元素作为最小元素 min，然后在内层循环中遍历数组的每一个元素，如果有元素的值比 min 小，就将该元素的值赋值给 min。内层遍历完成后，如果数组的第一个元素和 min 不相同，则将它们交换一下位置。然后再将第二个元素作为最小元素 min，重复前面的过程。直到数组的每一个元素都比较完毕。</span></p><p data-lake-id=\"u0ff8c52f\" id=\"u0ff8c52f\"><br></p><p data-lake-id=\"u4d33280e\" id=\"u4d33280e\"><span data-lake-id=\"u23a240ed\" id=\"u23a240ed\">选择排序算法的复杂度与冒泡排序一样，也是 O(n2)。</span></p><p data-lake-id=\"u03471389\" id=\"u03471389\"><br></p><h2 data-lake-id=\"112be43e\" id=\"112be43e\"><span data-lake-id=\"u10d6e19a\" id=\"u10d6e19a\">插入排序</span></h2><p data-lake-id=\"ucbd43de7\" id=\"ucbd43de7\"><br></p><p data-lake-id=\"u5e55f4f9\" id=\"u5e55f4f9\"><span data-lake-id=\"u93be45ae\" id=\"u93be45ae\">插入排序与前两个排序算法的思路不太一样，为了便于理解，我们以[ 5, 4, 3, 2, 1 ]这个数组为例，用下图来说明插入排序的整个执行过程：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646378546689-42a16045-fc76-4332-be4a-dffe251e3728.png%23clientId%3Ducccedb18-e7b2-4%26from%3Dpaste%26id%3Du3281e052%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D954%26originWidth%3D495%26originalType%3Durl%26ratio%3D1%26size%3D73872%26status%3Ddone%26style%3Dnone%26taskId%3Duc681d2dc-7911-4b2e-9efd-1b6bd7aaf36%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A495%2C%22originHeight%22%3A954%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22HziOQ%22%7D\"></card><span data-lake-id=\"u901c1518\" id=\"u901c1518\"><br /></span><span data-lake-id=\"u515a4656\" id=\"u515a4656\">在插入排序中，对数组的遍历是从第二个元素开始的，tmp 是个临时变量，用来保存当前位置的元素。然后从当前位置开始，取前一个位置的元素与 tmp 进行比较，如果值大于 tmp（针对升序排序而言），则将这个元素的值插入到这个位置中，最后将 tmp 放到数组的第一个位置（索引号为 0）。反复执行这个过程，直到数组元素遍历完毕。下面是插入排序算法的实现：<br /></span><span data-lake-id=\"uab48fa5d\" id=\"uab48fa5d\">l</span></p><p data-lake-id=\"u12b1ff04\" id=\"u12b1ff04\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20insertionSort(array)%20%7B%5Cn%20%20%20%20let%20length%20%3D%20array.length%5Cn%20%20%20%20let%20j%2C%20tmp%5Cn%5Cn%20%20%20%20for%20(let%20i%20%3D%201%3B%20i%20%3C%20length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20j%20%3D%20i%5Cn%20%20%20%20%20%20%20%20tmp%20%3D%20array%5Bi%5D%5Cn%20%20%20%20%20%20%20%20while%20(j%20%3E%200%20%26%26%20array%5Bj%20-%201%5D%20%3E%20tmp)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20array%5Bj%5D%20%3D%20array%5Bj%20-%201%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20j--%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20array%5Bj%5D%20%3D%20tmp%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22One%20Dark%20Pro%22%2C%22id%22%3A%2206d80eb4%22%7D\"></card><p data-lake-id=\"ud55bacbb\" id=\"ud55bacbb\"><br></p><p data-lake-id=\"u3a7d512e\" id=\"u3a7d512e\"><span data-lake-id=\"u9e245c81\" id=\"u9e245c81\">插入排序比冒泡排序和选择排序算法的性能要好。</span></p><p data-lake-id=\"u8a18e877\" id=\"u8a18e877\"><span data-lake-id=\"u2228f441\" id=\"u2228f441\">i</span></p><h2 data-lake-id=\"95566613\" id=\"95566613\"><span data-lake-id=\"uf68879a3\" id=\"uf68879a3\">归并排序</span></h2><p data-lake-id=\"uc5d0e252\" id=\"uc5d0e252\"><br></p><p data-lake-id=\"u477fd5ac\" id=\"u477fd5ac\"><span data-lake-id=\"uc46afd70\" id=\"uc46afd70\">归并排序比前面介绍的几种排序算法性能都要好，它的复杂度为</span><span data-lake-id=\"u01b1b28d\" id=\"u01b1b28d\">O(nlogn)</span><span data-lake-id=\"u928fb382\" id=\"u928fb382\">。<br /></span><span data-lake-id=\"u7eae51f4\" id=\"u7eae51f4\">归并排序的基本思路是通过递归调用将给定的数组不断分割成最小的两部分（每一部分只有一个元素），对这两部分进行排序，然后向上合并成一个大数组。我们还是以[ 5, 4, 3, 2, 1 ]这个数组为例，来看下归并排序的整个执行过程：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646378583275-2b43a57b-437e-4ad3-aa9b-5d193762528e.png%23clientId%3Ducccedb18-e7b2-4%26from%3Dpaste%26id%3Du68c1c1fc%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D634%26originWidth%3D274%26originalType%3Durl%26ratio%3D1%26size%3D29216%26status%3Ddone%26style%3Dnone%26taskId%3Du6fd3db56-a878-45fb-8b5a-13ed3d84ee8%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A274%2C%22originHeight%22%3A634%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22TYaPT%22%7D\"></card><span data-lake-id=\"u4edd22c7\" id=\"u4edd22c7\"><br /></span><span data-lake-id=\"udfb90e84\" id=\"udfb90e84\">首先要将数组分成两个部分，对于非偶数长度的数组，你可以自行决定将多的分到左边或者右边。然后按照这种方式进行递归，直到数组的左右两部分都只有一个元素。对这两部分进行排序，递归向上返回的过程中将其组成和一个完整的数组。下面是归并排序的算法的实现：</span></p><p data-lake-id=\"u710b06ce\" id=\"u710b06ce\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20dfs%20%3D%20(l%2C%20r)%20%3D%3E%20%7B%5Cn%20%20let%20i%20%3D%200%5Cn%20%20let%20j%20%3D%200%5Cn%20%20let%20res%20%3D%20%5B%5D%5Cn%20%20while%20(i%20%3C%20l.length%20%26%26%20j%20%3C%20r.length)%20%7B%5Cn%20%20%20%20if%20(l%5Bi%5D%20%3C%20r%5Bj%5D)%20%7B%5Cn%20%20%20%20%20%20res.push(l%5Bi%2B%2B%5D)%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20res.push(r%5Bj%2B%2B%5D)%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20return%20res.concat(i%20%3C%20l.length%20%3F%20l.slice(i)%20%3A%20r.slice(j))%5Cn%7D%5Cnlet%20length%20%3D%20nums.length%5Cnif%20(length%20%3E%201)%20%7B%5Cn%20%20let%20midIndex%20%3D%20length%20%3E%3E%201%5Cn%20%20nums%20%3D%20dfs(sortArray(nums.slice(0%2C%20midIndex))%2C%20sortArray(nums.slice(midIndex%2C%20length)))%5Cn%7D%5Cnreturn%20nums%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22One%20Dark%20Pro%22%2C%22id%22%3A%22f0e40989%22%7D\"></card><h2 data-lake-id=\"5ee213ee\" id=\"5ee213ee\"><span data-lake-id=\"u81b1acd0\" id=\"u81b1acd0\">快速排序</span></h2><p data-lake-id=\"u7e05a195\" id=\"u7e05a195\"><br></p><p data-lake-id=\"ub23a9dd8\" id=\"ub23a9dd8\"><span data-lake-id=\"u4ab6cf32\" id=\"u4ab6cf32\">快速排序的复杂度也是</span><span data-lake-id=\"ufbbf77bc\" id=\"ufbbf77bc\">O(nlogn)</span><span data-lake-id=\"u3a915168\" id=\"u3a915168\">，但它的性能要优于其它排序算法。快速排序与归并排序类似，其基本思路也是将一个大数组分为较小的数组，但它不像归并排序一样将它们分割开。快速排序算法比较复杂，大致过程为：</span></p><p data-lake-id=\"u74c38e91\" id=\"u74c38e91\"><br></p><ol list=\"u3100754d\"><li fid=\"u7d2802d3\" data-lake-id=\"u6956f7b0\" id=\"u6956f7b0\"><span data-lake-id=\"ucff4f3c8\" id=\"ucff4f3c8\">从给定的数组中选取一个参考元素。参考元素可以是任意元素，也可以是数组的第一个元素，我们这里选取中间位置的元素（如果数组长度为偶数，则向下取一个位置），这样在大多数情况下可以提高效率。</span></li><li fid=\"u7d2802d3\" data-lake-id=\"u3e8b9a07\" id=\"u3e8b9a07\"><span data-lake-id=\"u99012d03\" id=\"u99012d03\">创建两个指针，一个指向数组的最左边，一个指向数组的最右边。移动左指针直到找到比参考元素大的元素，移动右指针直到找到比参考元素小的元素，然后交换左右指针对应的元素。重复这个过程，直到左指针超过右指针（即左指针的索引号大于右指针的索引号）。通过这一操作，比参考元素小的元素都排在参考元素之前，比参考元素大的元素都排在参考元素之后（针对升序排序而言）。</span></li><li fid=\"u7d2802d3\" data-lake-id=\"u9d978f27\" id=\"u9d978f27\"><span data-lake-id=\"u0c852a46\" id=\"u0c852a46\">以参考元素为分隔点，对左右两个较小的数组重复上述过程，直到整个数组完成排序。</span></li></ol><p data-lake-id=\"u2f781561\" id=\"u2f781561\"><br></p><p data-lake-id=\"u3d0b52cc\" id=\"u3d0b52cc\"><span data-lake-id=\"ubb460a68\" id=\"ubb460a68\">下面是快速排序算法的实现：</span></p><p data-lake-id=\"uf280d7d3\" id=\"uf280d7d3\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20partition%20%3D%20(array%2C%20left%2C%20right)%20%3D%3E%20%7B%5Cn%20%20%20%20const%20pivot%20%3D%20array%5BMath.floor((right%20%2B%20left)%20%2F%202)%5D%5Cn%20%20%20%20let%20i%20%3D%20left%5Cn%20%20%20%20let%20j%20%3D%20right%5Cn%5Cn%20%20%20%20while%20(i%20%3C%3D%20j)%20%7B%5Cn%20%20%20%20%20%20%20%20while%20(array%5Bi%5D%20%3C%20pivot)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20i%2B%2B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20while%20(array%5Bj%5D%20%3E%20pivot)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20j--%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20if%20(i%20%3C%3D%20j)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3B%5Barray%5Bi%5D%2C%20array%5Bj%5D%5D%20%3D%20%5Barray%5Bj%5D%2C%20array%5Bi%5D%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20i%2B%2B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20j--%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20i%5Cn%7D%5Cn%5Cnconst%20quick%20%3D%20(array%2C%20left%2C%20right)%20%3D%3E%20%7B%5Cn%20%20%20%20let%20length%20%3D%20array.length%5Cn%20%20%20%20let%20index%5Cn%20%20%20%20if%20(length%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20%20%20index%20%3D%20partition(array%2C%20left%2C%20right)%5Cn%20%20%20%20%20%20%20%20if%20(left%20%3C%20index%20-%201)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20quick(array%2C%20left%2C%20index%20-%201)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20if%20(index%20%3C%20right)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20quick(array%2C%20index%2C%20right)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20array%5Cn%7D%5Cn%5Cnfunction%20quickSort(array)%20%7B%5Cn%20%20%20%20return%20quick(array%2C%200%2C%20array.length%20-%201)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22de654073%22%7D\"></card><p data-lake-id=\"u4ae3613f\" id=\"u4ae3613f\"><br></p><p data-lake-id=\"u94e85d7b\" id=\"u94e85d7b\"><span data-lake-id=\"u0a1814cf\" id=\"u0a1814cf\">假定数组为[ 3, 5, 1, 6, 4, 7, 2 ]，按照上面的代码逻辑，整个排序的过程如下图所示：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646378641900-44f261e9-43ed-42ff-994e-0b4632c2da23.png%23clientId%3Ducccedb18-e7b2-4%26from%3Dpaste%26id%3Du371ade9f%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D1002%26originWidth%3D1454%26originalType%3Durl%26ratio%3D1%26size%3D155423%26status%3Ddone%26style%3Dnone%26taskId%3Du4193ee3c-fb39-4ce5-a8e4-276671386ca%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A1454%2C%22originHeight%22%3A1002%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22dQ1Fo%22%7D\"></card><span data-lake-id=\"ue58c6582\" id=\"ue58c6582\"><br /></span><span data-lake-id=\"uf9a273b7\" id=\"uf9a273b7\">下面是测试结果：</span></p><p data-lake-id=\"uc2bcabbd\" id=\"uc2bcabbd\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20array%20%3D%20%5B3%2C%205%2C%201%2C%206%2C%204%2C%207%2C%202%5D%5Cnconsole.log(array.toString())%20%2F%2F%203%2C5%2C1%2C6%2C4%2C7%2C2%5Cnconsole.log(quickSort(array).toString())%20%2F%2F%201%2C2%2C3%2C4%2C5%2C6%2C7%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2276e4ab4b%22%7D\"></card><p data-lake-id=\"ubdb7e9d5\" id=\"ubdb7e9d5\"><br></p><p data-lake-id=\"u9f988c8a\" id=\"u9f988c8a\"><span data-lake-id=\"uf5b7a99a\" id=\"uf5b7a99a\">快速排序算法理解起来有些难度，可以按照上面给出的示意图逐步推导一遍，以帮助理解整个算法的实现原理。</span></p><p data-lake-id=\"u8be5816e\" id=\"u8be5816e\"><br></p><h2 data-lake-id=\"141c7256\" id=\"141c7256\"><span data-lake-id=\"ue7391fa1\" id=\"ue7391fa1\">堆排序</span></h2><p data-lake-id=\"u41c55b6f\" id=\"u41c55b6f\"><br></p><p data-lake-id=\"uc0395365\" id=\"uc0395365\"><span data-lake-id=\"u4d7b16b1\" id=\"u4d7b16b1\">在计算机科学中，堆是一种特殊的数据结构，它通常用树来表示数组。堆有以下特点：</span></p><p data-lake-id=\"u89b0a7c3\" id=\"u89b0a7c3\"><br></p><ul list=\"u2a00ca02\"><li fid=\"udf99f3c2\" data-lake-id=\"ub182e0a2\" id=\"ub182e0a2\"><span data-lake-id=\"u811b6c1b\" id=\"u811b6c1b\">堆是一棵完全二叉树</span></li><li fid=\"udf99f3c2\" data-lake-id=\"u61ecd145\" id=\"u61ecd145\"><span data-lake-id=\"uafcee37a\" id=\"uafcee37a\">子节点的值不大于父节点的值（最大堆），或者子节点的值不小于父节点的值（最小堆）</span></li><li fid=\"udf99f3c2\" data-lake-id=\"ua8fee45b\" id=\"ua8fee45b\"><span data-lake-id=\"u620cb5dc\" id=\"u620cb5dc\">根节点的索引号为 0</span></li><li fid=\"udf99f3c2\" data-lake-id=\"ue5957c8d\" id=\"ue5957c8d\"><span data-lake-id=\"u57d4684c\" id=\"u57d4684c\">子节点的索引为父节点索引 × 2 + 1</span></li><li fid=\"udf99f3c2\" data-lake-id=\"u03f4fc4e\" id=\"u03f4fc4e\"><span data-lake-id=\"u5045a568\" id=\"u5045a568\">右子节点的索引为父节点索引 × 2 + 2</span></li></ul><p data-lake-id=\"ued93905b\" id=\"ued93905b\"><br></p><p data-lake-id=\"u91be1c76\" id=\"u91be1c76\"><span data-lake-id=\"u42247adb\" id=\"u42247adb\">堆排序是一种比较高效的排序算法。<br /></span><span data-lake-id=\"u8bb81b62\" id=\"u8bb81b62\">在堆排序中，我们并不需要将数组元素插入到堆中，而只是通过交换来形成堆，以数组[ 3, 5, 1, 6, 4, 7, 2 ]为例，我们用下图来表示其初始状态：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646378655431-c55f3ffe-d542-4270-bd86-49b1b2df4206.png%23clientId%3Ducccedb18-e7b2-4%26from%3Dpaste%26id%3Duf8e217b4%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D201%26originWidth%3D251%26originalType%3Durl%26ratio%3D1%26size%3D9332%26status%3Ddone%26style%3Dnone%26taskId%3Du7c7d63f6-0410-471c-8cb6-5f28c971880%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A251%2C%22originHeight%22%3A201%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22bKZpK%22%7D\"></card><span data-lake-id=\"uc8ecb847\" id=\"uc8ecb847\"><br /></span><span data-lake-id=\"u82a72cfa\" id=\"u82a72cfa\">那么，如何将其转换成一个符合标准的堆结构呢？先来看看堆排序算法的实现：</span></p><p data-lake-id=\"u0c83a158\" id=\"u0c83a158\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20heapify%20%3D%20(array%2C%20heapSize%2C%20index)%20%3D%3E%20%7B%5Cn%20%20%20%20let%20largest%20%3D%20index%5Cn%20%20%20%20const%20left%20%3D%20index%20*%202%20%2B%201%5Cn%20%20%20%20const%20right%20%3D%20index%20*%202%20%2B%202%5Cn%20%20%20%20if%20(left%20%3C%20heapSize%20%26%26%20array%5Bleft%5D%20%3E%20array%5Bindex%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20largest%20%3D%20left%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if%20(right%20%3C%20heapSize%20%26%26%20array%5Bright%5D%20%3E%20array%5Blargest%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20largest%20%3D%20right%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if%20(largest%20!%3D%3D%20index)%20%7B%5Cn%20%20%20%20%20%20%20%20%3B%5Barray%5Bindex%5D%2C%20array%5Blargest%5D%5D%20%3D%20%5Barray%5Blargest%5D%2C%20array%5Bindex%5D%5D%5Cn%20%20%20%20%20%20%20%20heapify(array%2C%20heapSize%2C%20largest)%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnconst%20buildHeap%20%3D%20array%20%3D%3E%20%7B%5Cn%20%20%20%20let%20heapSize%20%3D%20array.length%5Cn%20%20%20%20for%20(let%20i%20%3D%20heapSize%3B%20i%20%3E%3D%200%3B%20i--)%20%7B%5Cn%20%20%20%20%20%20%20%20heapify(array%2C%20heapSize%2C%20i)%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnfunction%20heapSort(array)%20%7B%5Cn%20%20%20%20let%20heapSize%20%3D%20array.length%5Cn%20%20%20%20buildHeap(array)%5Cn%5Cn%20%20%20%20while%20(heapSize%20%3E%201)%20%7B%5Cn%20%20%20%20%20%20%20%20heapSize--%5Cn%20%20%20%20%20%20%20%20%3B%5Barray%5B0%5D%2C%20array%5BheapSize%5D%5D%20%3D%20%5Barray%5BheapSize%5D%2C%20array%5B0%5D%5D%5Cn%20%20%20%20%20%20%20%20heapify(array%2C%20heapSize%2C%200)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20return%20array%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2273076e7d%22%7D\"></card><p data-lake-id=\"u7b875cbd\" id=\"u7b875cbd\"><br></p><p data-lake-id=\"u685c072d\" id=\"u685c072d\"><span data-lake-id=\"uabb20ba4\" id=\"uabb20ba4\">函数 buildHeap()将给定的数组转换成堆（按最大堆处理）。下面是将数组[ 3, 5, 1, 6, 4, 7, 2 ]转换成堆的过程示意图：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646378669899-26cf298f-03c0-4a19-b687-f0033d79338c.png%23clientId%3Ducccedb18-e7b2-4%26from%3Dpaste%26id%3Du6d112035%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D528%26originWidth%3D578%26originalType%3Durl%26ratio%3D1%26size%3D38567%26status%3Ddone%26style%3Dnone%26taskId%3Du831b3442-9ffc-413e-8509-da91e793209%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A578%2C%22originHeight%22%3A528%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22xJaTM%22%7D\"></card><span data-lake-id=\"ud010e656\" id=\"ud010e656\"><br /></span><span data-lake-id=\"uad13df8b\" id=\"uad13df8b\">在函数 buildHeap()中，我们从数组的尾部开始遍历去查看每个节点是否符合堆的特点。在遍历的过程中，我们发现当索引号为 6、5、4、3 时，其左右子节点的索引大小都超出了数组的长度，这意味着它们都是叶子节点。那么我们真正要做的就是从索引号为 2 的节点开始。其实从这一点考虑，结合我们利用完全二叉树来表示数组的特性，可以对 buildHeap()函数进行优化，将其中的 for 循环修改为下面这样，以去掉对子节点的操作。</span></p><p data-lake-id=\"u1895c467\" id=\"u1895c467\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22for%20(let%20i%20%3D%20Math.floor(heapSize%20%2F%202)%20-%201%3B%20i%20%3E%3D%200%3B%20i--)%20%7B%5Cn%20%20%20%20heapify(array%2C%20heapSize%2C%20i)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22f8f1c143%22%7D\"></card><p data-lake-id=\"u674a8c68\" id=\"u674a8c68\"><br></p><p data-lake-id=\"u168aa2c0\" id=\"u168aa2c0\"><span data-lake-id=\"u39023ccf\" id=\"u39023ccf\">从索引 2 开始，我们查看它的左右子节点的值是否大于自己，如果是，则将其中最大的那个值与自己交换，然后向下递归查找是否还需要对子节点继续进行操作。索引 2 处理完之后再处理索引 1，然后是索引 0，最终转换出来的堆如图中的 4 所示。你会发现，每一次堆转换完成之后，排在数组第一个位置的就是堆的根节点，也就是数组的最大元素。根据这一特点，我们可以很方便地对堆进行排序，其过程是：</span></p><p data-lake-id=\"u5c25d9a1\" id=\"u5c25d9a1\"><br></p><ul list=\"ude9e89aa\"><li fid=\"u36ebf7ec\" data-lake-id=\"u8703e9f7\" id=\"u8703e9f7\"><span data-lake-id=\"u1ea9dde7\" id=\"u1ea9dde7\">将数组的第一个元素和最后一个元素交换</span></li><li fid=\"u36ebf7ec\" data-lake-id=\"u3423b11d\" id=\"u3423b11d\"><span data-lake-id=\"u17c8a2e6\" id=\"u17c8a2e6\">减少数组的长度，从索引 0 开始重新转换堆</span></li></ul><p data-lake-id=\"u070c0fe3\" id=\"u070c0fe3\"><br></p><p data-lake-id=\"u795b7765\" id=\"u795b7765\"><span data-lake-id=\"u596e6b02\" id=\"u596e6b02\">直到整个过程结束。对应的示意图如下：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646378683805-9cefa067-fdea-4444-8b3d-8e104c0901a8.png%23clientId%3Ducccedb18-e7b2-4%26from%3Dpaste%26id%3Du7b224e76%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D876%26originWidth%3D994%26originalType%3Durl%26ratio%3D1%26size%3D75388%26status%3Ddone%26style%3Dnone%26taskId%3Duc0b0f6df-c2a9-46f1-b443-2b09d616341%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A994%2C%22originHeight%22%3A876%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22IRJaL%22%7D\"></card><span data-lake-id=\"u0ca66b24\" id=\"u0ca66b24\"><br /></span><span data-lake-id=\"ued2fe223\" id=\"ued2fe223\">堆排序的核心部分在于如何将数组转换成堆，也就是上面代码中 buildHeap()和 heapify()函数部分。<br /></span><span data-lake-id=\"u048bed36\" id=\"u048bed36\">同样给出堆排序的测试结果：</span></p><p data-lake-id=\"u275841a2\" id=\"u275841a2\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20array%20%3D%20%5B3%2C%205%2C%201%2C%206%2C%204%2C%207%2C%202%5D%5Cnconsole.log(array.toString())%20%2F%2F%203%2C5%2C1%2C6%2C4%2C7%2C2%5Cnconsole.log(heapSort(array).toString())%20%2F%2F%201%2C2%2C3%2C4%2C5%2C6%2C7%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%221cb7a704%22%7D\"></card><p data-lake-id=\"u9d3e6481\" id=\"u9d3e6481\"><br></p><h2 data-lake-id=\"6f407f2b\" id=\"6f407f2b\"><span data-lake-id=\"u03710cba\" id=\"u03710cba\">有关算法复杂度</span></h2><p data-lake-id=\"ue9648272\" id=\"ue9648272\"><br></p><p data-lake-id=\"u43289b4e\" id=\"u43289b4e\"><span data-lake-id=\"u415941ca\" id=\"u415941ca\">上面我们在介绍各种排序算法的时候，提到了算法的复杂度，算法复杂度用大</span><span data-lake-id=\"u4e7a91d6\" id=\"u4e7a91d6\">O</span><span data-lake-id=\"u4abbe026\" id=\"u4abbe026\">表示法，它是用大</span><span data-lake-id=\"u283ee476\" id=\"u283ee476\">O</span><span data-lake-id=\"u948cb3d4\" id=\"u948cb3d4\">表示的一个函数，如：</span></p><p data-lake-id=\"udfc9b01d\" id=\"udfc9b01d\"><br></p><ul list=\"ua52bc37e\"><li fid=\"ua643b4e1\" data-lake-id=\"ufe2107cb\" id=\"ufe2107cb\"><span data-lake-id=\"u36c13b9f\" id=\"u36c13b9f\">O</span><span data-lake-id=\"uaedf5949\" id=\"uaedf5949\">(1)：常数</span></li><li fid=\"ua643b4e1\" data-lake-id=\"u1e501415\" id=\"u1e501415\"><span data-lake-id=\"u13bc3b4c\" id=\"u13bc3b4c\">O</span><span data-lake-id=\"uffe58063\" id=\"uffe58063\">(log(n))：对数</span></li><li fid=\"ua643b4e1\" data-lake-id=\"u4143b607\" id=\"u4143b607\"><span data-lake-id=\"u10bc0fd3\" id=\"u10bc0fd3\">O</span><span data-lake-id=\"uf49b2263\" id=\"uf49b2263\">(log(n) c)：对数多项式</span></li><li fid=\"ua643b4e1\" data-lake-id=\"u08fa5996\" id=\"u08fa5996\"><span data-lake-id=\"u40914d8d\" id=\"u40914d8d\">O</span><span data-lake-id=\"ud6b7675c\" id=\"ud6b7675c\">(n)：线性</span></li><li fid=\"ua643b4e1\" data-lake-id=\"ub99db999\" id=\"ub99db999\"><span data-lake-id=\"ua027c331\" id=\"ua027c331\">O</span><span data-lake-id=\"u03f0d017\" id=\"u03f0d017\">(n2)：二次</span></li><li fid=\"ua643b4e1\" data-lake-id=\"u58476a1f\" id=\"u58476a1f\"><span data-lake-id=\"u2ab41253\" id=\"u2ab41253\">O</span><span data-lake-id=\"u07307f73\" id=\"u07307f73\">(nc)：多项式</span></li><li fid=\"ua643b4e1\" data-lake-id=\"ud8c1f9a4\" id=\"ud8c1f9a4\"><span data-lake-id=\"u83d71f65\" id=\"u83d71f65\">O</span><span data-lake-id=\"u606658e6\" id=\"u606658e6\">(cn)：指数</span></li></ul><p data-lake-id=\"ud179bdd5\" id=\"ud179bdd5\"><br></p><p data-lake-id=\"u9d817ee0\" id=\"u9d817ee0\"><span data-lake-id=\"uf976a8fa\" id=\"uf976a8fa\">我们如何理解大</span><span data-lake-id=\"ua7023ccc\" id=\"ua7023ccc\">O</span><span data-lake-id=\"u59327b77\" id=\"u59327b77\">表示法呢？看一个例子：</span></p><p data-lake-id=\"ubf2b74d8\" id=\"ubf2b74d8\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20increment(num)%20%7B%5Cn%20%20%20%20return%20%2B%2Bnum%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22a6e410e5%22%7D\"></card><p data-lake-id=\"ua3052ab6\" id=\"ua3052ab6\"><br></p><p data-lake-id=\"u02268f16\" id=\"u02268f16\"><span data-lake-id=\"u73126840\" id=\"u73126840\">对于函数 increment()，无论我传入的参数 num 的值是什么数字，它的运行时间都是 X（相对于同一台机器而言）。函数 increment()的性能与参数无关，因此我们可以说它的算法复杂度是</span><span data-lake-id=\"u922dd3b9\" id=\"u922dd3b9\">O</span><span data-lake-id=\"u51c0d5d8\" id=\"u51c0d5d8\">(1)（常数）。<br /></span><span data-lake-id=\"ue9ac3d7f\" id=\"ue9ac3d7f\">再看一个例子：</span></p><p data-lake-id=\"u06a80b0f\" id=\"u06a80b0f\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20sequentialSearch(array%2C%20item)%20%7B%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20array.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(item%20%3D%3D%3D%20array%5Bi%5D)%20return%20i%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20-1%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2250be3ded%22%7D\"></card><p data-lake-id=\"u72983383\" id=\"u72983383\"><br></p><p data-lake-id=\"u3845abca\" id=\"u3845abca\"><span data-lake-id=\"u64a4b95f\" id=\"u64a4b95f\">函数 sequentialSearch()的作用是在数组中搜索给定的值，并返回对应的索引号。假设 array 有 10 个元素，如果要搜索的元素排在第一个，我们说开销为 1。如果要搜索的元素排在最后一个，则开销为 10。当数组有 1000 个元素时，搜索最后一个元素的开销是 1000。所以，sequentialSearch()函数的总开销取决于数组元素的个数和要搜索的值。在最坏情况下，没有找到要搜索的元素，那么总开销就是数组的长度。因此我们得出 sequentialSearch()函数的时间复杂度是</span><span data-lake-id=\"ud4b2be8c\" id=\"ud4b2be8c\">O</span><span data-lake-id=\"u4dfefb28\" id=\"u4dfefb28\">(n)，n 是数组的长度。<br /></span><span data-lake-id=\"u6386fd15\" id=\"u6386fd15\">同理，对于前面我们说的冒泡排序算法，里面有一个双层嵌套的 for 循环，因此它的复杂度为</span><span data-lake-id=\"u39aae5c5\" id=\"u39aae5c5\">O</span><span data-lake-id=\"ub1bc8624\" id=\"ub1bc8624\">(n2)。<br /></span><span data-lake-id=\"u0c63c79a\" id=\"u0c63c79a\">时间复杂度</span><span data-lake-id=\"uaf0804c4\" id=\"uaf0804c4\">O</span><span data-lake-id=\"u25229c20\" id=\"u25229c20\">(n)的代码只有一层循环，而</span><span data-lake-id=\"u353963ca\" id=\"u353963ca\">O</span><span data-lake-id=\"uc9897e19\" id=\"uc9897e19\">(n2)的代码有双层嵌套循环。如果算法有三层嵌套循环，它的时间复杂度就是</span><span data-lake-id=\"ue9440671\" id=\"ue9440671\">O</span><span data-lake-id=\"ua2d2b588\" id=\"ua2d2b588\">(n3)。<br /></span><span data-lake-id=\"u9d830ef6\" id=\"u9d830ef6\">下表展示了各种不同数据结构的时间复杂度：</span></p><card type=\"block\" name=\"table\" value=\"data:%7B%22id%22%3A%2287be05b4%22%2C%22rows%22%3A8%2C%22cols%22%3A7%2C%22html%22%3A%22%3Ctable%20data-lake-id%3D%5C%2287be05b4%5C%22%20id%3D%5C%2287be05b4%5C%22%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20749px%5C%22%3E%3Ccolgroup%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20data-lake-id%3D%5C%22uff01cbc0%5C%22%20id%3D%5C%22uff01cbc0%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22uc27bfc98%5C%22%20id%3D%5C%22uc27bfc98%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u660e2f43%5C%22%20id%3D%5C%22u660e2f43%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uaf8a2076%5C%22%20id%3D%5C%22uaf8a2076%5C%22%3E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u0fa7c1b3%5C%22%20id%3D%5C%22u0fa7c1b3%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf8293c5d%5C%22%20id%3D%5C%22uf8293c5d%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u0da8159e%5C%22%20id%3D%5C%22u0da8159e%5C%22%3E%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u70fa57f1%5C%22%20id%3D%5C%22u70fa57f1%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u6fbd257b%5C%22%20id%3D%5C%22u6fbd257b%5C%22%3E%3Cbr%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uad90a461%5C%22%20id%3D%5C%22uad90a461%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uc9312dc8%5C%22%20id%3D%5C%22uc9312dc8%5C%22%3E%3Cbr%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ucac954b7%5C%22%20id%3D%5C%22ucac954b7%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ua90573af%5C%22%20id%3D%5C%22ua90573af%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u83fd9f4e%5C%22%20id%3D%5C%22u83fd9f4e%5C%22%3E%E6%9C%80%E5%B7%AE%E6%83%85%E5%86%B5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc09b273a%5C%22%20id%3D%5C%22uc09b273a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u39a238c9%5C%22%20id%3D%5C%22u39a238c9%5C%22%3E%3Cbr%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ubd6f48cb%5C%22%20id%3D%5C%22ubd6f48cb%5C%22%3E%3Cp%20data-lake-id%3D%5C%22udf03df76%5C%22%20id%3D%5C%22udf03df76%5C%22%3E%3Cbr%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u46e00103%5C%22%20id%3D%5C%22u46e00103%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u1a550eb5%5C%22%20id%3D%5C%22u1a550eb5%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u6436b5bc%5C%22%20id%3D%5C%22u6436b5bc%5C%22%3E%3Cbr%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u8931fd3b%5C%22%20id%3D%5C%22u8931fd3b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u83233973%5C%22%20id%3D%5C%22u83233973%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u8377d85b%5C%22%20id%3D%5C%22u8377d85b%5C%22%3E%E6%8F%92%E5%85%A5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5d00562d%5C%22%20id%3D%5C%22u5d00562d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u27e51b54%5C%22%20id%3D%5C%22u27e51b54%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ua1e48a9c%5C%22%20id%3D%5C%22ua1e48a9c%5C%22%3E%E5%88%A0%E9%99%A4%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u2ea01379%5C%22%20id%3D%5C%22u2ea01379%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u2e909e01%5C%22%20id%3D%5C%22u2e909e01%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u97d39f05%5C%22%20id%3D%5C%22u97d39f05%5C%22%3E%E6%90%9C%E7%B4%A2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ua6857acf%5C%22%20id%3D%5C%22ua6857acf%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u9cc224a7%5C%22%20id%3D%5C%22u9cc224a7%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u856254df%5C%22%20id%3D%5C%22u856254df%5C%22%3E%E6%8F%92%E5%85%A5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u3db4d4c5%5C%22%20id%3D%5C%22u3db4d4c5%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf18668a4%5C%22%20id%3D%5C%22uf18668a4%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u97372b80%5C%22%20id%3D%5C%22u97372b80%5C%22%3E%E5%88%A0%E9%99%A4%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ua7cd7a03%5C%22%20id%3D%5C%22ua7cd7a03%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u123f6cef%5C%22%20id%3D%5C%22u123f6cef%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u42ce86c6%5C%22%20id%3D%5C%22u42ce86c6%5C%22%3E%E6%90%9C%E7%B4%A2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u597b793f%5C%22%20id%3D%5C%22u597b793f%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u3aa96b80%5C%22%20id%3D%5C%22u3aa96b80%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u170c1272%5C%22%20id%3D%5C%22u170c1272%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ube007439%5C%22%20id%3D%5C%22ube007439%5C%22%3E%E6%95%B0%E7%BB%84%2F%E6%A0%88%2F%E9%98%9F%E5%88%97%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u18d33067%5C%22%20id%3D%5C%22u18d33067%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u1167af4e%5C%22%20id%3D%5C%22u1167af4e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ubdc6eed2%5C%22%20id%3D%5C%22ubdc6eed2%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u2fd5cf5d%5C%22%20id%3D%5C%22u2fd5cf5d%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ue046ee5d%5C%22%20id%3D%5C%22ue046ee5d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u3df23437%5C%22%20id%3D%5C%22u3df23437%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u28837481%5C%22%20id%3D%5C%22u28837481%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22udbc99225%5C%22%20id%3D%5C%22udbc99225%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ub9e010e7%5C%22%20id%3D%5C%22ub9e010e7%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u54a1a33d%5C%22%20id%3D%5C%22u54a1a33d%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u3756d1b5%5C%22%20id%3D%5C%22u3756d1b5%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ud976b0d9%5C%22%20id%3D%5C%22ud976b0d9%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ueacd1afe%5C%22%20id%3D%5C%22ueacd1afe%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ub089bfb6%5C%22%20id%3D%5C%22ub089bfb6%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ued07cd55%5C%22%20id%3D%5C%22ued07cd55%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u2c6621e3%5C%22%20id%3D%5C%22u2c6621e3%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ubeb1694d%5C%22%20id%3D%5C%22ubeb1694d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf8550af3%5C%22%20id%3D%5C%22uf8550af3%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uf98df7c4%5C%22%20id%3D%5C%22uf98df7c4%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u9f4b4d65%5C%22%20id%3D%5C%22u9f4b4d65%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc939a6e8%5C%22%20id%3D%5C%22uc939a6e8%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u31da261b%5C%22%20id%3D%5C%22u31da261b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ud46c2ab9%5C%22%20id%3D%5C%22ud46c2ab9%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u8ee3a531%5C%22%20id%3D%5C%22u8ee3a531%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u2f66aa64%5C%22%20id%3D%5C%22u2f66aa64%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22uc2fd1a2f%5C%22%20id%3D%5C%22uc2fd1a2f%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u9b563086%5C%22%20id%3D%5C%22u9b563086%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u6bfcfd6c%5C%22%20id%3D%5C%22u6bfcfd6c%5C%22%3E%E9%93%BE%E8%A1%A8%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uec23b32b%5C%22%20id%3D%5C%22uec23b32b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u94512141%5C%22%20id%3D%5C%22u94512141%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u66ac44e8%5C%22%20id%3D%5C%22u66ac44e8%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22uc252735a%5C%22%20id%3D%5C%22uc252735a%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ufab6122e%5C%22%20id%3D%5C%22ufab6122e%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u6f1c1d83%5C%22%20id%3D%5C%22u6f1c1d83%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u146fe8ae%5C%22%20id%3D%5C%22u146fe8ae%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ub41f91ef%5C%22%20id%3D%5C%22ub41f91ef%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uab6dbec2%5C%22%20id%3D%5C%22uab6dbec2%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u85667a6f%5C%22%20id%3D%5C%22u85667a6f%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u0c176fa7%5C%22%20id%3D%5C%22u0c176fa7%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u2fb99bfa%5C%22%20id%3D%5C%22u2fb99bfa%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uf08e472b%5C%22%20id%3D%5C%22uf08e472b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ub1e627a4%5C%22%20id%3D%5C%22ub1e627a4%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u52ac0c94%5C%22%20id%3D%5C%22u52ac0c94%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u999fe1dc%5C%22%20id%3D%5C%22u999fe1dc%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uf43b16c7%5C%22%20id%3D%5C%22uf43b16c7%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u06697ebd%5C%22%20id%3D%5C%22u06697ebd%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u8c86d8e4%5C%22%20id%3D%5C%22u8c86d8e4%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22uc55e2d0e%5C%22%20id%3D%5C%22uc55e2d0e%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u0d542c30%5C%22%20id%3D%5C%22u0d542c30%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ue3f856ce%5C%22%20id%3D%5C%22ue3f856ce%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u1dffb49e%5C%22%20id%3D%5C%22u1dffb49e%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u41038b65%5C%22%20id%3D%5C%22u41038b65%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u8e45719e%5C%22%20id%3D%5C%22u8e45719e%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u8e7b7f18%5C%22%20id%3D%5C%22u8e7b7f18%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf5bd04a8%5C%22%20id%3D%5C%22uf5bd04a8%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u2e52b985%5C%22%20id%3D%5C%22u2e52b985%5C%22%3E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u1befee5d%5C%22%20id%3D%5C%22u1befee5d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u0f4178ff%5C%22%20id%3D%5C%22u0f4178ff%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ua16addf5%5C%22%20id%3D%5C%22ua16addf5%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u1d4bb1dc%5C%22%20id%3D%5C%22u1d4bb1dc%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u23c2db44%5C%22%20id%3D%5C%22u23c2db44%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uca41f358%5C%22%20id%3D%5C%22uca41f358%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uae121a00%5C%22%20id%3D%5C%22uae121a00%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ub1e2097d%5C%22%20id%3D%5C%22ub1e2097d%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u8c26cad8%5C%22%20id%3D%5C%22u8c26cad8%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u0de91640%5C%22%20id%3D%5C%22u0de91640%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u9aa3160a%5C%22%20id%3D%5C%22u9aa3160a%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u164a02da%5C%22%20id%3D%5C%22u164a02da%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u737c26e4%5C%22%20id%3D%5C%22u737c26e4%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u14f69f67%5C%22%20id%3D%5C%22u14f69f67%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u443a7fb0%5C%22%20id%3D%5C%22u443a7fb0%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u250ebb4b%5C%22%20id%3D%5C%22u250ebb4b%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uaf4b067f%5C%22%20id%3D%5C%22uaf4b067f%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u743f6626%5C%22%20id%3D%5C%22u743f6626%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uc8b3b242%5C%22%20id%3D%5C%22uc8b3b242%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u2a9fdbec%5C%22%20id%3D%5C%22u2a9fdbec%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc42d80ab%5C%22%20id%3D%5C%22uc42d80ab%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ua4241591%5C%22%20id%3D%5C%22ua4241591%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u4b0b63b8%5C%22%20id%3D%5C%22u4b0b63b8%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ub92618ab%5C%22%20id%3D%5C%22ub92618ab%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22uaf15d289%5C%22%20id%3D%5C%22uaf15d289%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u78c2071d%5C%22%20id%3D%5C%22u78c2071d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ud90a5923%5C%22%20id%3D%5C%22ud90a5923%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u7009d2c6%5C%22%20id%3D%5C%22u7009d2c6%5C%22%3E%E6%95%A3%E5%88%97%E8%A1%A8%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9814289a%5C%22%20id%3D%5C%22u9814289a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u88f7fa0c%5C%22%20id%3D%5C%22u88f7fa0c%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u84fbc9ce%5C%22%20id%3D%5C%22u84fbc9ce%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u5d256c39%5C%22%20id%3D%5C%22u5d256c39%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u7570b9eb%5C%22%20id%3D%5C%22u7570b9eb%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uefc31805%5C%22%20id%3D%5C%22uefc31805%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u94f1d130%5C%22%20id%3D%5C%22u94f1d130%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u3cdd9dbb%5C%22%20id%3D%5C%22u3cdd9dbb%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5b5e71b9%5C%22%20id%3D%5C%22u5b5e71b9%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ued88abc8%5C%22%20id%3D%5C%22ued88abc8%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ud3c0fd42%5C%22%20id%3D%5C%22ud3c0fd42%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u31ad0f33%5C%22%20id%3D%5C%22u31ad0f33%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u64aee8f0%5C%22%20id%3D%5C%22u64aee8f0%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u75abf8b1%5C%22%20id%3D%5C%22u75abf8b1%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u41dc6ddb%5C%22%20id%3D%5C%22u41dc6ddb%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22uff285214%5C%22%20id%3D%5C%22uff285214%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u564cccd9%5C%22%20id%3D%5C%22u564cccd9%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u9d79e6a0%5C%22%20id%3D%5C%22u9d79e6a0%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u4bcc10f5%5C%22%20id%3D%5C%22u4bcc10f5%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22uc4f29262%5C%22%20id%3D%5C%22uc4f29262%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u04d353e9%5C%22%20id%3D%5C%22u04d353e9%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u26e5289d%5C%22%20id%3D%5C%22u26e5289d%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u03f65a31%5C%22%20id%3D%5C%22u03f65a31%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ud0c05edf%5C%22%20id%3D%5C%22ud0c05edf%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u6661b4b0%5C%22%20id%3D%5C%22u6661b4b0%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ub329268c%5C%22%20id%3D%5C%22ub329268c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u08ffc110%5C%22%20id%3D%5C%22u08ffc110%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u6fa37933%5C%22%20id%3D%5C%22u6fa37933%5C%22%3EBST%20%E6%A0%91%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ue1b49a02%5C%22%20id%3D%5C%22ue1b49a02%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u18e54920%5C%22%20id%3D%5C%22u18e54920%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ud7e3d458%5C%22%20id%3D%5C%22ud7e3d458%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u32f3b5e4%5C%22%20id%3D%5C%22u32f3b5e4%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uda456dc5%5C%22%20id%3D%5C%22uda456dc5%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u64ff164b%5C%22%20id%3D%5C%22u64ff164b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uc0e836a1%5C%22%20id%3D%5C%22uc0e836a1%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u9630bca3%5C%22%20id%3D%5C%22u9630bca3%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u1bed887a%5C%22%20id%3D%5C%22u1bed887a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u0f6e589e%5C%22%20id%3D%5C%22u0f6e589e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u64ba5cd4%5C%22%20id%3D%5C%22u64ba5cd4%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u2fab1801%5C%22%20id%3D%5C%22u2fab1801%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u456974d0%5C%22%20id%3D%5C%22u456974d0%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u59f2ea6e%5C%22%20id%3D%5C%22u59f2ea6e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uc30029eb%5C%22%20id%3D%5C%22uc30029eb%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u1ab04b51%5C%22%20id%3D%5C%22u1ab04b51%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ufcc71e3c%5C%22%20id%3D%5C%22ufcc71e3c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf450d318%5C%22%20id%3D%5C%22uf450d318%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u0eb45b90%5C%22%20id%3D%5C%22u0eb45b90%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u74394d57%5C%22%20id%3D%5C%22u74394d57%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u87a6fd32%5C%22%20id%3D%5C%22u87a6fd32%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u664c0dc6%5C%22%20id%3D%5C%22u664c0dc6%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22udbadb2b3%5C%22%20id%3D%5C%22udbadb2b3%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ue3c57ad9%5C%22%20id%3D%5C%22ue3c57ad9%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22ud40be647%5C%22%20id%3D%5C%22ud40be647%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u4043bc2d%5C%22%20id%3D%5C%22u4043bc2d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u3cf96b05%5C%22%20id%3D%5C%22u3cf96b05%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u7b880c65%5C%22%20id%3D%5C%22u7b880c65%5C%22%3EAVL%20%E6%A0%91%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u3c463815%5C%22%20id%3D%5C%22u3c463815%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uecadebde%5C%22%20id%3D%5C%22uecadebde%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ub64266b5%5C%22%20id%3D%5C%22ub64266b5%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ua6624c5b%5C%22%20id%3D%5C%22ua6624c5b%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uf3aa6635%5C%22%20id%3D%5C%22uf3aa6635%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u0e3da67d%5C%22%20id%3D%5C%22u0e3da67d%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u85c197b3%5C%22%20id%3D%5C%22u85c197b3%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22uee335a56%5C%22%20id%3D%5C%22uee335a56%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ud4661490%5C%22%20id%3D%5C%22ud4661490%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u97810984%5C%22%20id%3D%5C%22u97810984%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u6364775c%5C%22%20id%3D%5C%22u6364775c%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u7a402546%5C%22%20id%3D%5C%22u7a402546%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9dc4fe39%5C%22%20id%3D%5C%22u9dc4fe39%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u8ff4648b%5C%22%20id%3D%5C%22u8ff4648b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uff60d869%5C%22%20id%3D%5C%22uff60d869%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u8d6e96da%5C%22%20id%3D%5C%22u8d6e96da%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22udf52c25f%5C%22%20id%3D%5C%22udf52c25f%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uab0f1114%5C%22%20id%3D%5C%22uab0f1114%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u9c05bb31%5C%22%20id%3D%5C%22u9c05bb31%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ua39753ed%5C%22%20id%3D%5C%22ua39753ed%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u2e7ce897%5C%22%20id%3D%5C%22u2e7ce897%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u6d45f53d%5C%22%20id%3D%5C%22u6d45f53d%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u14696614%5C%22%20id%3D%5C%22u14696614%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ucba45c22%5C%22%20id%3D%5C%22ucba45c22%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%2C%22margin%22%3Atrue%7D\"></card><p data-lake-id=\"u8cd51b10\" id=\"u8cd51b10\"><br></p><p data-lake-id=\"ude01f3cb\" id=\"ude01f3cb\"><span data-lake-id=\"u97702b1a\" id=\"u97702b1a\">数据结构的时间复杂度<br /></span><span data-lake-id=\"u898bec93\" id=\"u898bec93\">​</span></p><card type=\"block\" name=\"table\" value=\"data:%7B%22id%22%3A%225617c9e0%22%2C%22rows%22%3A3%2C%22cols%22%3A7%2C%22html%22%3A%22%3Ctable%20data-lake-id%3D%5C%225617c9e0%5C%22%20id%3D%5C%225617c9e0%5C%22%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20752px%5C%22%3E%3Ccolgroup%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22110%5C%22%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20data-lake-id%3D%5C%22ub3e72598%5C%22%20id%3D%5C%22ub3e72598%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ub3b084be%5C%22%20id%3D%5C%22ub3b084be%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u1a06b61c%5C%22%20id%3D%5C%22u1a06b61c%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u8c34c695%5C%22%20id%3D%5C%22u8c34c695%5C%22%3E%E8%8A%82%E7%82%B9%2F%E8%BE%B9%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u98d27a3a%5C%22%20id%3D%5C%22u98d27a3a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ud9c2beeb%5C%22%20id%3D%5C%22ud9c2beeb%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u88563b33%5C%22%20id%3D%5C%22u88563b33%5C%22%3E%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u4971d7d1%5C%22%20id%3D%5C%22u4971d7d1%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u48c2cb57%5C%22%20id%3D%5C%22u48c2cb57%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u5629c7ba%5C%22%20id%3D%5C%22u5629c7ba%5C%22%3E%E5%A2%9E%E5%8A%A0%E9%A1%B6%E7%82%B9%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9d5a438b%5C%22%20id%3D%5C%22u9d5a438b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u5fddc22e%5C%22%20id%3D%5C%22u5fddc22e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u864a20a0%5C%22%20id%3D%5C%22u864a20a0%5C%22%3E%E5%A2%9E%E5%8A%A0%E8%BE%B9%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u77f1b195%5C%22%20id%3D%5C%22u77f1b195%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ue967eb42%5C%22%20id%3D%5C%22ue967eb42%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u71e23450%5C%22%20id%3D%5C%22u71e23450%5C%22%3E%E5%88%A0%E9%99%A4%E9%A1%B6%E7%82%B9%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u73c13fac%5C%22%20id%3D%5C%22u73c13fac%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uecb8c382%5C%22%20id%3D%5C%22uecb8c382%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u5de6be64%5C%22%20id%3D%5C%22u5de6be64%5C%22%3E%E5%88%A0%E9%99%A4%E8%BE%B9%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u8f39852e%5C%22%20id%3D%5C%22u8f39852e%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u73b6ae55%5C%22%20id%3D%5C%22u73b6ae55%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u26d57f68%5C%22%20id%3D%5C%22u26d57f68%5C%22%3E%E8%BD%AE%E8%AF%A2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u63e2e11c%5C%22%20id%3D%5C%22u63e2e11c%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u1e812890%5C%22%20id%3D%5C%22u1e812890%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ud9c8ac99%5C%22%20id%3D%5C%22ud9c8ac99%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uaee95e36%5C%22%20id%3D%5C%22uaee95e36%5C%22%3E%E9%A2%86%E6%8E%A5%E8%A1%A8%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc3434def%5C%22%20id%3D%5C%22uc3434def%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u97bbb1ac%5C%22%20id%3D%5C%22u97bbb1ac%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ua34f4ea0%5C%22%20id%3D%5C%22ua34f4ea0%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ue6fdc88f%5C%22%20id%3D%5C%22ue6fdc88f%5C%22%3E(%7C%20V%20%7C%20%2B%20%7C%20E%20%7C)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u72e01a4b%5C%22%20id%3D%5C%22u72e01a4b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u7e3a7ded%5C%22%20id%3D%5C%22u7e3a7ded%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uf674c541%5C%22%20id%3D%5C%22uf674c541%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u151e46d5%5C%22%20id%3D%5C%22u151e46d5%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u17393ddf%5C%22%20id%3D%5C%22u17393ddf%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u4047e46e%5C%22%20id%3D%5C%22u4047e46e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u360d9a88%5C%22%20id%3D%5C%22u360d9a88%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ufd8dcd10%5C%22%20id%3D%5C%22ufd8dcd10%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc14077d8%5C%22%20id%3D%5C%22uc14077d8%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u692be258%5C%22%20id%3D%5C%22u692be258%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uefcd1aa4%5C%22%20id%3D%5C%22uefcd1aa4%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u5279f4ee%5C%22%20id%3D%5C%22u5279f4ee%5C%22%3E(%7C%20V%20%7C%20%2B%20%7C%20E%20%7C)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u8ffdfc19%5C%22%20id%3D%5C%22u8ffdfc19%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uca8cb42c%5C%22%20id%3D%5C%22uca8cb42c%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uc26fb24b%5C%22%20id%3D%5C%22uc26fb24b%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u46c06841%5C%22%20id%3D%5C%22u46c06841%5C%22%3E(%7C%20E%20%7C)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u1a3d6835%5C%22%20id%3D%5C%22u1a3d6835%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u22befa9e%5C%22%20id%3D%5C%22u22befa9e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uf0d68679%5C%22%20id%3D%5C%22uf0d68679%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u763ce1ec%5C%22%20id%3D%5C%22u763ce1ec%5C%22%3E(%7C%20V%20%7C)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22ua3ae10c9%5C%22%20id%3D%5C%22ua3ae10c9%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u44f64d2b%5C%22%20id%3D%5C%22u44f64d2b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u350ab06f%5C%22%20id%3D%5C%22u350ab06f%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u217d6535%5C%22%20id%3D%5C%22u217d6535%5C%22%3E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u46d52bf1%5C%22%20id%3D%5C%22u46d52bf1%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u0a9960db%5C%22%20id%3D%5C%22u0a9960db%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u905e770e%5C%22%20id%3D%5C%22u905e770e%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u2c69b9ba%5C%22%20id%3D%5C%22u2c69b9ba%5C%22%3E(%7C%20V%20%7C2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ucfb3db5e%5C%22%20id%3D%5C%22ucfb3db5e%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u38a03faa%5C%22%20id%3D%5C%22u38a03faa%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u018fbdcf%5C%22%20id%3D%5C%22u018fbdcf%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u9c2a88d1%5C%22%20id%3D%5C%22u9c2a88d1%5C%22%3E(%7C%20V%20%7C2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ue8341f7b%5C%22%20id%3D%5C%22ue8341f7b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf5010889%5C%22%20id%3D%5C%22uf5010889%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u2b838977%5C%22%20id%3D%5C%22u2b838977%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u1c69e417%5C%22%20id%3D%5C%22u1c69e417%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ud8628041%5C%22%20id%3D%5C%22ud8628041%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ue0304472%5C%22%20id%3D%5C%22ue0304472%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u75efb9ff%5C%22%20id%3D%5C%22u75efb9ff%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ua6620f9e%5C%22%20id%3D%5C%22ua6620f9e%5C%22%3E(%7C%20V%20%7C2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u7975fb32%5C%22%20id%3D%5C%22u7975fb32%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u13a71d8f%5C%22%20id%3D%5C%22u13a71d8f%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uebd3d4fd%5C%22%20id%3D%5C%22uebd3d4fd%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u0f582805%5C%22%20id%3D%5C%22u0f582805%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ud822e0fb%5C%22%20id%3D%5C%22ud822e0fb%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u3a2a2ed8%5C%22%20id%3D%5C%22u3a2a2ed8%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u82b6edbb%5C%22%20id%3D%5C%22u82b6edbb%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u750697f3%5C%22%20id%3D%5C%22u750697f3%5C%22%3E(1)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%2C%22margin%22%3Atrue%7D\"></card><p data-lake-id=\"u0d7e9227\" id=\"u0d7e9227\"><br></p><p data-lake-id=\"u4e5a18f3\" id=\"u4e5a18f3\"><span data-lake-id=\"u85f6d792\" id=\"u85f6d792\">图的时间复杂度<br /></span><span data-lake-id=\"u317f8b75\" id=\"u317f8b75\">​</span></p><card type=\"block\" name=\"table\" value=\"data:%7B%22id%22%3A%22dffd625f%22%2C%22rows%22%3A8%2C%22cols%22%3A4%2C%22html%22%3A%22%3Ctable%20data-lake-id%3D%5C%22dffd625f%5C%22%20id%3D%5C%22dffd625f%5C%22%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20748px%5C%22%3E%3Ccolgroup%3E%3Ccol%20width%3D%5C%22187%5C%22%3E%3Ccol%20width%3D%5C%22187%5C%22%3E%3Ccol%20width%3D%5C%22187%5C%22%3E%3Ccol%20width%3D%5C%22187%5C%22%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20data-lake-id%3D%5C%22u95ad486a%5C%22%20id%3D%5C%22u95ad486a%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ub86d146c%5C%22%20id%3D%5C%22ub86d146c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u4051f389%5C%22%20id%3D%5C%22u4051f389%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22udbef02be%5C%22%20id%3D%5C%22udbef02be%5C%22%3E%E7%AE%97%E6%B3%95%EF%BC%88%E7%94%A8%E4%BA%8E%E6%95%B0%E7%BB%84%EF%BC%89%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u153f3a95%5C%22%20id%3D%5C%22u153f3a95%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u3df68483%5C%22%20id%3D%5C%22u3df68483%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u667df621%5C%22%20id%3D%5C%22u667df621%5C%22%3E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc5154442%5C%22%20id%3D%5C%22uc5154442%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ueec0e884%5C%22%20id%3D%5C%22ueec0e884%5C%22%3E%3Cbr%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u62588c33%5C%22%20id%3D%5C%22u62588c33%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf77a4ef9%5C%22%20id%3D%5C%22uf77a4ef9%5C%22%3E%3Cbr%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u62883004%5C%22%20id%3D%5C%22u62883004%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u2d150df6%5C%22%20id%3D%5C%22u2d150df6%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u088b7c03%5C%22%20id%3D%5C%22u088b7c03%5C%22%3E%3Cbr%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u3e46ce53%5C%22%20id%3D%5C%22u3e46ce53%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u14ec94ec%5C%22%20id%3D%5C%22u14ec94ec%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u673a163a%5C%22%20id%3D%5C%22u673a163a%5C%22%3E%E6%9C%80%E5%A5%BD%E6%83%85%E5%86%B5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u4fb301e4%5C%22%20id%3D%5C%22u4fb301e4%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u08a8adf5%5C%22%20id%3D%5C%22u08a8adf5%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ua92963ff%5C%22%20id%3D%5C%22ua92963ff%5C%22%3E%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9cd3d84d%5C%22%20id%3D%5C%22u9cd3d84d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u768ad8eb%5C%22%20id%3D%5C%22u768ad8eb%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u1d499d6d%5C%22%20id%3D%5C%22u1d499d6d%5C%22%3E%E6%9C%80%E5%B7%AE%E6%83%85%E5%86%B5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u60ac8cf9%5C%22%20id%3D%5C%22u60ac8cf9%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u9605949a%5C%22%20id%3D%5C%22u9605949a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22udc8ca96c%5C%22%20id%3D%5C%22udc8ca96c%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u4b87d43a%5C%22%20id%3D%5C%22u4b87d43a%5C%22%3E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u8e52a75b%5C%22%20id%3D%5C%22u8e52a75b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u8a529225%5C%22%20id%3D%5C%22u8a529225%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u3a8b0718%5C%22%20id%3D%5C%22u3a8b0718%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u89d3976c%5C%22%20id%3D%5C%22u89d3976c%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u3279ed1c%5C%22%20id%3D%5C%22u3279ed1c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u790a1a75%5C%22%20id%3D%5C%22u790a1a75%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u74e06473%5C%22%20id%3D%5C%22u74e06473%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u71de4566%5C%22%20id%3D%5C%22u71de4566%5C%22%3E(n2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u3036b1eb%5C%22%20id%3D%5C%22u3036b1eb%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ua559c929%5C%22%20id%3D%5C%22ua559c929%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uc933a895%5C%22%20id%3D%5C%22uc933a895%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u6a328ddd%5C%22%20id%3D%5C%22u6a328ddd%5C%22%3E(n3)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u51ef7aca%5C%22%20id%3D%5C%22u51ef7aca%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u7a3136b6%5C%22%20id%3D%5C%22u7a3136b6%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u80cc8d94%5C%22%20id%3D%5C%22u80cc8d94%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u8fb9c937%5C%22%20id%3D%5C%22u8fb9c937%5C%22%3E%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uabef9a9c%5C%22%20id%3D%5C%22uabef9a9c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u08739a3b%5C%22%20id%3D%5C%22u08739a3b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ufecd3d67%5C%22%20id%3D%5C%22ufecd3d67%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ue4afe027%5C%22%20id%3D%5C%22ue4afe027%5C%22%3E(n2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9d4a0e4e%5C%22%20id%3D%5C%22u9d4a0e4e%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u13528fe5%5C%22%20id%3D%5C%22u13528fe5%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ue1aeeefe%5C%22%20id%3D%5C%22ue1aeeefe%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u2da0e04f%5C%22%20id%3D%5C%22u2da0e04f%5C%22%3E(n2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uae9631b5%5C%22%20id%3D%5C%22uae9631b5%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u0f089912%5C%22%20id%3D%5C%22u0f089912%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ue08a8c1b%5C%22%20id%3D%5C%22ue08a8c1b%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u00e27ca4%5C%22%20id%3D%5C%22u00e27ca4%5C%22%3E(n2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22ud774e925%5C%22%20id%3D%5C%22ud774e925%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u52b6f804%5C%22%20id%3D%5C%22u52b6f804%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uaf55f260%5C%22%20id%3D%5C%22uaf55f260%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ud878e231%5C%22%20id%3D%5C%22ud878e231%5C%22%3E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5d660521%5C%22%20id%3D%5C%22u5d660521%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uc8af4a3b%5C%22%20id%3D%5C%22uc8af4a3b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u5a4d7b00%5C%22%20id%3D%5C%22u5a4d7b00%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22uecee6d16%5C%22%20id%3D%5C%22uecee6d16%5C%22%3E(n)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u60a09d0f%5C%22%20id%3D%5C%22u60a09d0f%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uc6f81fda%5C%22%20id%3D%5C%22uc6f81fda%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u762ecb57%5C%22%20id%3D%5C%22u762ecb57%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u195c3407%5C%22%20id%3D%5C%22u195c3407%5C%22%3E(n2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uaa17277f%5C%22%20id%3D%5C%22uaa17277f%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u933885ad%5C%22%20id%3D%5C%22u933885ad%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u9622500b%5C%22%20id%3D%5C%22u9622500b%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ubae201fe%5C%22%20id%3D%5C%22ubae201fe%5C%22%3E(n2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u3752862f%5C%22%20id%3D%5C%22u3752862f%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u13131e67%5C%22%20id%3D%5C%22u13131e67%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ufc1a9d5d%5C%22%20id%3D%5C%22ufc1a9d5d%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ue497f307%5C%22%20id%3D%5C%22ue497f307%5C%22%3E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ud21b15ed%5C%22%20id%3D%5C%22ud21b15ed%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u84256a16%5C%22%20id%3D%5C%22u84256a16%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u77aee192%5C%22%20id%3D%5C%22u77aee192%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22uf1f9eee4%5C%22%20id%3D%5C%22uf1f9eee4%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ube420508%5C%22%20id%3D%5C%22ube420508%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf2991479%5C%22%20id%3D%5C%22uf2991479%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uc4de2c04%5C%22%20id%3D%5C%22uc4de2c04%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u87c37054%5C%22%20id%3D%5C%22u87c37054%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ua97eaa01%5C%22%20id%3D%5C%22ua97eaa01%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u65c5d00b%5C%22%20id%3D%5C%22u65c5d00b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u037ea35d%5C%22%20id%3D%5C%22u037ea35d%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u9227e868%5C%22%20id%3D%5C%22u9227e868%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22ua87d021a%5C%22%20id%3D%5C%22ua87d021a%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u686d9a4d%5C%22%20id%3D%5C%22u686d9a4d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uafa03142%5C%22%20id%3D%5C%22uafa03142%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u7c6e1939%5C%22%20id%3D%5C%22u7c6e1939%5C%22%3E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u236749d0%5C%22%20id%3D%5C%22u236749d0%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ub43e066b%5C%22%20id%3D%5C%22ub43e066b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uced32237%5C%22%20id%3D%5C%22uced32237%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ud8896ac8%5C%22%20id%3D%5C%22ud8896ac8%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u1520a5ba%5C%22%20id%3D%5C%22u1520a5ba%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u3ef7e503%5C%22%20id%3D%5C%22u3ef7e503%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u6e2c00c7%5C%22%20id%3D%5C%22u6e2c00c7%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u4ac793bf%5C%22%20id%3D%5C%22u4ac793bf%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9b1a7cb2%5C%22%20id%3D%5C%22u9b1a7cb2%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u08b0f82b%5C%22%20id%3D%5C%22u08b0f82b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uf0f3ce65%5C%22%20id%3D%5C%22uf0f3ce65%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ubb4d0d13%5C%22%20id%3D%5C%22ubb4d0d13%5C%22%3E(n2)%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22ue4a3a9ca%5C%22%20id%3D%5C%22ue4a3a9ca%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ue7c2ec33%5C%22%20id%3D%5C%22ue7c2ec33%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u888857e2%5C%22%20id%3D%5C%22u888857e2%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u85c570c6%5C%22%20id%3D%5C%22u85c570c6%5C%22%3E%E5%A0%86%E6%8E%92%E5%BA%8F%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ub2c30217%5C%22%20id%3D%5C%22ub2c30217%5C%22%3E%3Cp%20data-lake-id%3D%5C%22udc7bcce9%5C%22%20id%3D%5C%22udc7bcce9%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u357c54d1%5C%22%20id%3D%5C%22u357c54d1%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u0597cb28%5C%22%20id%3D%5C%22u0597cb28%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u19aca01e%5C%22%20id%3D%5C%22u19aca01e%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u34280ea0%5C%22%20id%3D%5C%22u34280ea0%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u0ff423d4%5C%22%20id%3D%5C%22u0ff423d4%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22ud7e7018f%5C%22%20id%3D%5C%22ud7e7018f%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u26aa569a%5C%22%20id%3D%5C%22u26aa569a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u124e5590%5C%22%20id%3D%5C%22u124e5590%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u3f525cc1%5C%22%20id%3D%5C%22u3f525cc1%5C%22%3EO%3C%2Fspan%3E%3Cspan%20data-lake-id%3D%5C%22u1720642d%5C%22%20id%3D%5C%22u1720642d%5C%22%3E(log(n))%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%2C%22margin%22%3Atrue%7D\"></card><p data-lake-id=\"u33292f98\" id=\"u33292f98\"><br></p><p data-lake-id=\"u058d6fcd\" id=\"u058d6fcd\"><span data-lake-id=\"uf49b8d80\" id=\"uf49b8d80\">排序算法的时间复杂度</span></p><p data-lake-id=\"uc27f4f11\" id=\"uc27f4f11\"><br></p><h2 data-lake-id=\"cb760e4e\" id=\"cb760e4e\"><span data-lake-id=\"u042ba5b7\" id=\"u042ba5b7\">搜索算法</span></h2><p data-lake-id=\"u5b24383b\" id=\"u5b24383b\"><br></p><p data-lake-id=\"u08537899\" id=\"u08537899\"><span data-lake-id=\"uf5a10e49\" id=\"uf5a10e49\">顺序搜索是一种比较直观的搜索算法，上面介绍算法复杂度一小节中的 sequentialSearch()函数就是顺序搜索算法，就是按顺序对数组中的元素逐一比较，直到找到匹配的元素。顺序搜索算法的效率比较低。<br /></span><span data-lake-id=\"u3df3304e\" id=\"u3df3304e\">还有一种常见的搜索算法是二分搜索算法。它的执行过程是：</span></p><p data-lake-id=\"uecaa2171\" id=\"uecaa2171\"><br></p><ol list=\"u3110418f\"><li fid=\"u47a596f0\" data-lake-id=\"u002a3095\" id=\"u002a3095\"><span data-lake-id=\"u038d90f5\" id=\"u038d90f5\">将待搜索数组排序。</span></li><li fid=\"u47a596f0\" data-lake-id=\"u794562bf\" id=\"u794562bf\"><span data-lake-id=\"ue591a807\" id=\"ue591a807\">选择数组的中间值。</span></li><li fid=\"u47a596f0\" data-lake-id=\"u54dd35dc\" id=\"u54dd35dc\"><span data-lake-id=\"u91669dcf\" id=\"u91669dcf\">如果中间值正好是要搜索的值，则完成搜索。</span></li><li fid=\"u47a596f0\" data-lake-id=\"udaaf055a\" id=\"udaaf055a\"><span data-lake-id=\"u4349362b\" id=\"u4349362b\">如果要搜索的值比中间值小，则选择中间值左边的部分，重新执行步骤 2。</span></li><li fid=\"u47a596f0\" data-lake-id=\"ufff01cfb\" id=\"ufff01cfb\"><span data-lake-id=\"ua21b9643\" id=\"ua21b9643\">如果要搜索的值比中间值大，则选择中间值右边的部分，重新执行步骤 2。</span></li></ol><p data-lake-id=\"ue978fabd\" id=\"ue978fabd\"><br></p><p data-lake-id=\"u31991bb5\" id=\"u31991bb5\"><span data-lake-id=\"ub6cf3630\" id=\"ub6cf3630\">下面是二分搜索算法的具体实现：</span></p><p data-lake-id=\"u12792c27\" id=\"u12792c27\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20binarySearch(array%2C%20item)%20%7B%5Cn%20%20%20%20quickSort(array)%20%2F%2F%20%E9%A6%96%E5%85%88%E7%94%A8%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95%E5%AF%B9array%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%5Cn%5Cn%20%20%20%20let%20low%20%3D%200%5Cn%20%20%20%20let%20high%20%3D%20array.length%20-%201%5Cn%5Cn%20%20%20%20while%20(low%20%3C%3D%20high)%20%7B%5Cn%20%20%20%20%20%20%20%20const%20mid%20%3D%20Math.floor((low%20%2B%20high)%20%2F%202)%20%2F%2F%20%E9%80%89%E5%8F%96%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%5Cn%20%20%20%20%20%20%20%20const%20element%20%3D%20array%5Bmid%5D%5Cn%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%BE%85%E6%90%9C%E7%B4%A2%E7%9A%84%E5%80%BC%E5%A4%A7%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%80%BC%5Cn%20%20%20%20%20%20%20%20if%20(element%20%3C%20item)%20low%20%3D%20mid%20%2B%201%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%BE%85%E6%90%9C%E7%B4%A2%E7%9A%84%E5%80%BC%E5%B0%8F%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%80%BC%5Cn%20%20%20%20%20%20%20%20else%20if%20(element%20%3E%20item)%20high%20%3D%20mid%20-%201%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%BE%85%E6%90%9C%E7%B4%A2%E7%9A%84%E5%80%BC%E5%B0%B1%E6%98%AF%E4%B8%AD%E9%97%B4%E5%80%BC%5Cn%20%20%20%20%20%20%20%20else%20return%20true%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20return%20false%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22c64c6953%22%7D\"></card><p data-lake-id=\"ua5255710\" id=\"ua5255710\"><br></p><p data-lake-id=\"ud5d99ce5\" id=\"ud5d99ce5\"><span data-lake-id=\"ue626770d\" id=\"ue626770d\">对应的测试结果：</span></p><p data-lake-id=\"u74479c28\" id=\"u74479c28\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20array%20%3D%20%5B8%2C%207%2C%206%2C%205%2C%204%2C%203%2C%202%2C%201%5D%5Cnconsole.log(binarySearch(array%2C%202))%20%2F%2F%20true%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%220ed3b7a0%22%7D\"></card><p data-lake-id=\"ud4cf9863\" id=\"ud4cf9863\"><br></p><p data-lake-id=\"uea58cbb6\" id=\"uea58cbb6\"><span data-lake-id=\"u767b316b\" id=\"u767b316b\">这个算法的基本思路有点类似于猜数字大小，每当你说出一个数字，我都会告诉你是大了还是小了，经过几轮之后，你就可以很准确地确定数字的大小了。</span></p>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 4390,
  "created_at": "2022-04-04T11:35:12.000Z",
  "updated_at": "2022-05-10T15:16:49.000Z",
  "content_updated_at": "2022-04-04T11:35:12.000Z",
  "published_at": "2022-04-04T11:35:12.000Z",
  "first_published_at": "2022-04-04T11:35:12.186Z",
  "book": {
    "id": 26225252,
    "type": "Book",
    "slug": "sd8kbc",
    "name": "笔试 written test",
    "user_id": 732231,
    "description": "笔试相关题目\n1. 原生 API 实现\n2. 业务场景相关问题\n3. LeetCode 算法相关问题",
    "toc_yml": "- type: META\n  count: 84\n  display_level: 1\n  tail_type: UPDATED_AT\n  base_version_id: 370014828\n  published: true\n  max_level: 1\n  last_updated_at: 2023-11-11T18:03:16.908Z\n  version_id: 370014838\n- type: TITLE\n  title: 原生 API\n  uuid: _1yNZniU22OymJlp\n  url: ''\n  prev_uuid: ''\n  sibling_uuid: zxe2MJsSU5MOefDb\n  child_uuid: EMyfauRyhp-lOYYB\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: extends 关键字\n  uuid: EMyfauRyhp-lOYYB\n  url: vtqbgk\n  prev_uuid: _1yNZniU22OymJlp\n  sibling_uuid: XEsl8fffffuSCTSI\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 76186529\n  level: 1\n  id: 76186529\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: ajax\n  uuid: XEsl8fffffuSCTSI\n  url: cq5ws4\n  prev_uuid: EMyfauRyhp-lOYYB\n  sibling_uuid: EaDc9LInXSSLEeXZ\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212428\n  level: 1\n  id: 72212428\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: call & apply & bind\n  uuid: EaDc9LInXSSLEeXZ\n  url: ybrsyw\n  prev_uuid: XEsl8fffffuSCTSI\n  sibling_uuid: wqGQXgEjeQAf0Bxq\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212433\n  level: 1\n  id: 72212433\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: new 关键字\n  uuid: wqGQXgEjeQAf0Bxq\n  url: pldu2b\n  prev_uuid: EaDc9LInXSSLEeXZ\n  sibling_uuid: EbpTwwxFd9JXJyoY\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212430\n  level: 1\n  id: 72212430\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 函数柯理化\n  uuid: EbpTwwxFd9JXJyoY\n  url: yo9cx5\n  prev_uuid: wqGQXgEjeQAf0Bxq\n  sibling_uuid: g-W6FKTBoxb36HhI\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212393\n  level: 1\n  id: 72212393\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 浅拷贝和深拷贝\n  uuid: g-W6FKTBoxb36HhI\n  url: ufks1z\n  prev_uuid: EbpTwwxFd9JXJyoY\n  sibling_uuid: 7u5E_Hw98pbzQ4Yj\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212395\n  level: 1\n  id: 72212395\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现 instanceof\n  uuid: 7u5E_Hw98pbzQ4Yj\n  url: ba4wuo\n  prev_uuid: g-W6FKTBoxb36HhI\n  sibling_uuid: lFcmsu4tBdKMPIkR\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212424\n  level: 1\n  id: 72212424\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 手动实现定时器\n  uuid: lFcmsu4tBdKMPIkR\n  url: wf9bwg\n  prev_uuid: 7u5E_Hw98pbzQ4Yj\n  sibling_uuid: mjNFEVKWs-_1yZyS\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212397\n  level: 1\n  id: 72212397\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: sleep 函数实现\n  uuid: mjNFEVKWs-_1yZyS\n  url: ngwrak\n  prev_uuid: lFcmsu4tBdKMPIkR\n  sibling_uuid: Zo-bldWs1dUYUcA5\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212460\n  level: 1\n  id: 72212460\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现 JSON.stringify\n  uuid: Zo-bldWs1dUYUcA5\n  url: mtoe2n\n  prev_uuid: mjNFEVKWs-_1yZyS\n  sibling_uuid: LR_aI8-ZIoVBksK7\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212459\n  level: 1\n  id: 72212459\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: js 通用类型获取\n  uuid: LR_aI8-ZIoVBksK7\n  url: tll6lm\n  prev_uuid: Zo-bldWs1dUYUcA5\n  sibling_uuid: fjrB0qhIJpH89FjS\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212464\n  level: 1\n  id: 72212464\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现 iterator\n  uuid: fjrB0qhIJpH89FjS\n  url: ir252g\n  prev_uuid: LR_aI8-ZIoVBksK7\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 81930561\n  level: 1\n  id: 81930561\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: TypeScript\n  uuid: zxe2MJsSU5MOefDb\n  url: ''\n  prev_uuid: _1yNZniU22OymJlp\n  sibling_uuid: KRfqr5yKeh6GNv5y\n  child_uuid: CdOrh3hFdbuZevZ-\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: '#10 元组转联合类型'\n  uuid: CdOrh3hFdbuZevZ-\n  url: wwribz\n  prev_uuid: zxe2MJsSU5MOefDb\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: zxe2MJsSU5MOefDb\n  doc_id: 81961244\n  level: 1\n  id: 81961244\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 防抖和节流\n  uuid: KRfqr5yKeh6GNv5y\n  url: ''\n  prev_uuid: zxe2MJsSU5MOefDb\n  sibling_uuid: 84qjgn-j0_zJVLF7\n  child_uuid: eLdwpvS_6r5inI_p\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 防抖\n  uuid: eLdwpvS_6r5inI_p\n  url: enlngv\n  prev_uuid: KRfqr5yKeh6GNv5y\n  sibling_uuid: z32U-o38tB2Yzwns\n  child_uuid: ''\n  parent_uuid: KRfqr5yKeh6GNv5y\n  doc_id: 72212387\n  level: 1\n  id: 72212387\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 节流\n  uuid: z32U-o38tB2Yzwns\n  url: griz0t\n  prev_uuid: eLdwpvS_6r5inI_p\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: KRfqr5yKeh6GNv5y\n  doc_id: 72212392\n  level: 1\n  id: 72212392\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 数组相关\n  uuid: 84qjgn-j0_zJVLF7\n  url: ''\n  prev_uuid: KRfqr5yKeh6GNv5y\n  sibling_uuid: 0efRPOUXCUn3VmH-\n  child_uuid: E8-yClCfd2GHBfld\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 数组交集、差集、并集\n  uuid: E8-yClCfd2GHBfld\n  url: yl18rs\n  prev_uuid: 84qjgn-j0_zJVLF7\n  sibling_uuid: Ot36XWP1DAdhhxL8\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 77996894\n  level: 1\n  id: 77996894\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数组转树\n  uuid: Ot36XWP1DAdhhxL8\n  url: bzgequ\n  prev_uuid: E8-yClCfd2GHBfld\n  sibling_uuid: LUZSQT4XixZ6lRVn\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 77015210\n  level: 1\n  id: 77015210\n  open_window: 0\n  visible: 0\n- type: DOC\n  title: 树转数组\n  uuid: LUZSQT4XixZ6lRVn\n  url: xycpzl\n  prev_uuid: Ot36XWP1DAdhhxL8\n  sibling_uuid: KSjaO3MJIdM_aUoi\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 77015236\n  level: 1\n  id: 77015236\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数组常用方法\n  uuid: KSjaO3MJIdM_aUoi\n  url: owtewn\n  prev_uuid: LUZSQT4XixZ6lRVn\n  sibling_uuid: 1PhmaFWLSwH7eqUK\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212436\n  level: 1\n  id: 72212436\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数组去重实现\n  uuid: 1PhmaFWLSwH7eqUK\n  url: gq2z9n\n  prev_uuid: KSjaO3MJIdM_aUoi\n  sibling_uuid: bnM3r0-enDa6563Q\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212390\n  level: 1\n  id: 72212390\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数组扁平化实现\n  uuid: bnM3r0-enDa6563Q\n  url: doeryg\n  prev_uuid: 1PhmaFWLSwH7eqUK\n  sibling_uuid: 4NBfYxOcirIHYRrY\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212385\n  level: 1\n  id: 72212385\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 类数组转换为数组\n  uuid: 4NBfYxOcirIHYRrY\n  url: csgagn\n  prev_uuid: bnM3r0-enDa6563Q\n  sibling_uuid: SRwtHRX7f61VIFq6\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212445\n  level: 1\n  id: 72212445\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现数组乱序输出\n  uuid: SRwtHRX7f61VIFq6\n  url: xlrgnu\n  prev_uuid: 4NBfYxOcirIHYRrY\n  sibling_uuid: eARzwOBdjHS0A35l\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212437\n  level: 1\n  id: 72212437\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 查找二维数组的目标值\n  uuid: eARzwOBdjHS0A35l\n  url: tmw2ny\n  prev_uuid: SRwtHRX7f61VIFq6\n  sibling_uuid: C2gvlSUA6P7bZEpi\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212461\n  level: 1\n  id: 72212461\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 二维数组斜向打印\n  uuid: C2gvlSUA6P7bZEpi\n  url: aqw6my\n  prev_uuid: eARzwOBdjHS0A35l\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212457\n  level: 1\n  id: 72212457\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 字符串相关\n  uuid: 0efRPOUXCUn3VmH-\n  url: ''\n  prev_uuid: 84qjgn-j0_zJVLF7\n  sibling_uuid: A5NJiZ0GxiVUBJHd\n  child_uuid: oZ_CUVcv3_hOp7zN\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 实现字符串的 repeat 方法\n  uuid: oZ_CUVcv3_hOp7zN\n  url: hxelqc\n  prev_uuid: 0efRPOUXCUn3VmH-\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 0efRPOUXCUn3VmH-\n  doc_id: 72212440\n  level: 1\n  id: 72212440\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: promise相关\n  uuid: A5NJiZ0GxiVUBJHd\n  url: ''\n  prev_uuid: 0efRPOUXCUn3VmH-\n  sibling_uuid: sT-U-4fs90PlHvSI\n  child_uuid: 78Mu2RhGBL340hYq\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 实现 Promise A+\n  uuid: 78Mu2RhGBL340hYq\n  url: fl6cgx\n  prev_uuid: A5NJiZ0GxiVUBJHd\n  sibling_uuid: 9ahjbOcDVnGRzHTW\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212388\n  level: 1\n  id: 72212388\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise  常用方法实现\n  uuid: 9ahjbOcDVnGRzHTW\n  url: vd2h4l\n  prev_uuid: 78Mu2RhGBL340hYq\n  sibling_uuid: QLrR0jESJ8AEjFPl\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212389\n  level: 1\n  id: 72212389\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise 并发控制\n  uuid: QLrR0jESJ8AEjFPl\n  url: gd3193\n  prev_uuid: 9ahjbOcDVnGRzHTW\n  sibling_uuid: UKGjwSlV9BFG8i8n\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212405\n  level: 1\n  id: 72212405\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise 顺序串行输出\n  uuid: UKGjwSlV9BFG8i8n\n  url: wtr4cf\n  prev_uuid: QLrR0jESJ8AEjFPl\n  sibling_uuid: upU7a9yZR3aRjCSo\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 83089974\n  level: 1\n  id: 83089974\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise 缓存\n  uuid: upU7a9yZR3aRjCSo\n  url: sgcusf\n  prev_uuid: UKGjwSlV9BFG8i8n\n  sibling_uuid: ZLRJdeGl0jA3kFgL\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212417\n  level: 1\n  id: 72212417\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 异步串行输出\n  uuid: ZLRJdeGl0jA3kFgL\n  url: um4g6z\n  prev_uuid: upU7a9yZR3aRjCSo\n  sibling_uuid: D2SERgWeggDq9efi\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212401\n  level: 1\n  id: 72212401\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 带并发的异步调度器 Scheduler\n  uuid: D2SERgWeggDq9efi\n  url: kbkc8e\n  prev_uuid: ZLRJdeGl0jA3kFgL\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212425\n  level: 1\n  id: 72212425\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 数据处理\n  uuid: sT-U-4fs90PlHvSI\n  url: ''\n  prev_uuid: A5NJiZ0GxiVUBJHd\n  sibling_uuid: 0STVwRWnDq8ksDkB\n  child_uuid: ywzD1rPOOunEfIdw\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 解析 url 参数对象\n  uuid: ywzD1rPOOunEfIdw\n  url: rxw8qp\n  prev_uuid: sT-U-4fs90PlHvSI\n  sibling_uuid: VCJiqjW4GSrpavsh\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212449\n  level: 1\n  id: 72212449\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现日期格式化函数\n  uuid: VCJiqjW4GSrpavsh\n  url: shzfyg\n  prev_uuid: ywzD1rPOOunEfIdw\n  sibling_uuid: 5AdCGi5sbOD2oqbH\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212432\n  level: 1\n  id: 72212432\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 交换 a、b 的值，不使用临时变量\n  uuid: 5AdCGi5sbOD2oqbH\n  url: xw17tv\n  prev_uuid: VCJiqjW4GSrpavsh\n  sibling_uuid: BQMERO8CCr9JPHQn\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212439\n  level: 1\n  id: 72212439\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 获取两个数之间的任意随机数\n  uuid: BQMERO8CCr9JPHQn\n  url: vhngph\n  prev_uuid: 5AdCGi5sbOD2oqbH\n  sibling_uuid: dWB6aCZMOqRTPIrm\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212419\n  level: 1\n  id: 72212419\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 将数字千分位用逗号隔开\n  uuid: dWB6aCZMOqRTPIrm\n  url: vphpea\n  prev_uuid: BQMERO8CCr9JPHQn\n  sibling_uuid: ZSnQ_Z4XjCp_uMbl\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212441\n  level: 1\n  id: 72212441\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现非负大整数相加\n  uuid: ZSnQ_Z4XjCp_uMbl\n  url: xlvd0g\n  prev_uuid: dWB6aCZMOqRTPIrm\n  sibling_uuid: 5AKa5DXyQbLxzDGt\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212442\n  level: 1\n  id: 72212442\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 判断对象是否存在循环引用\n  uuid: 5AKa5DXyQbLxzDGt\n  url: phqdmd\n  prev_uuid: ZSnQ_Z4XjCp_uMbl\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212452\n  level: 1\n  id: 72212452\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 框架\n  uuid: 0STVwRWnDq8ksDkB\n  url: ''\n  prev_uuid: sT-U-4fs90PlHvSI\n  sibling_uuid: 1mqH8VqzmT3IEIjz\n  child_uuid: G3kHPA-b8ubrHNI6\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 发布订阅模式\n  uuid: G3kHPA-b8ubrHNI6\n  url: ezcdgo\n  prev_uuid: 0STVwRWnDq8ksDkB\n  sibling_uuid: hJ7Pi5oOpo-U_yTy\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212386\n  level: 1\n  id: 72212386\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 观察者模式\n  uuid: hJ7Pi5oOpo-U_yTy\n  url: dwziom\n  prev_uuid: G3kHPA-b8ubrHNI6\n  sibling_uuid: alPkG8HdrSx35fzk\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212465\n  level: 1\n  id: 72212465\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 简易版 vue2\n  uuid: alPkG8HdrSx35fzk\n  url: indxog\n  prev_uuid: hJ7Pi5oOpo-U_yTy\n  sibling_uuid: Kd-bfMBdhRM3cQXO\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212394\n  level: 1\n  id: 72212394\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 简易版 vue3\n  uuid: Kd-bfMBdhRM3cQXO\n  url: an017i\n  prev_uuid: alPkG8HdrSx35fzk\n  sibling_uuid: UvkBS5W479slO2Um\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212469\n  level: 1\n  id: 72212469\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 简易版 vuex\n  uuid: UvkBS5W479slO2Um\n  url: myzomg\n  prev_uuid: Kd-bfMBdhRM3cQXO\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212426\n  level: 1\n  id: 72212426\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 应用场景问题\n  uuid: 1mqH8VqzmT3IEIjz\n  url: ''\n  prev_uuid: 0STVwRWnDq8ksDkB\n  sibling_uuid: ahwD4hLemj7wd4n_\n  child_uuid: AALpnq0Se9gaVsKQ\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 可缓存的请求函数\n  uuid: AALpnq0Se9gaVsKQ\n  url: gftlci\n  prev_uuid: 1mqH8VqzmT3IEIjz\n  sibling_uuid: 6jYfdo5kqYOTtify\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 81939471\n  level: 1\n  id: 81939471\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 上传100个文件，同时并发上传数量为5名如何最快完成上传\n  uuid: 6jYfdo5kqYOTtify\n  url: dsbtur\n  prev_uuid: AALpnq0Se9gaVsKQ\n  sibling_uuid: M9i07wHKfkwMbNRG\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 81939230\n  level: 1\n  id: 81939230\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 图片加载数量限制\n  uuid: M9i07wHKfkwMbNRG\n  url: xz2gy5\n  prev_uuid: 6jYfdo5kqYOTtify\n  sibling_uuid: pjmLSWnYJNZT6pBi\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212402\n  level: 1\n  id: 72212402\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: AC数量\n  uuid: pjmLSWnYJNZT6pBi\n  url: kyaq59\n  prev_uuid: M9i07wHKfkwMbNRG\n  sibling_uuid: UA7U6Ie8Lym3w5HB\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 81933729\n  level: 1\n  id: 81933729\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 通过调用 addRemote 实现 add\n  uuid: UA7U6Ie8Lym3w5HB\n  url: edff3s\n  prev_uuid: pjmLSWnYJNZT6pBi\n  sibling_uuid: A1qKsOUEtCFXe_UJ\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 73623506\n  level: 1\n  id: 73623506\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 倒计时\n  uuid: A1qKsOUEtCFXe_UJ\n  url: uwleof\n  prev_uuid: UA7U6Ie8Lym3w5HB\n  sibling_uuid: V5rnG_Fh1uLT3tYz\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212468\n  level: 1\n  id: 72212468\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 版本号比较\n  uuid: V5rnG_Fh1uLT3tYz\n  url: cynvvd\n  prev_uuid: A1qKsOUEtCFXe_UJ\n  sibling_uuid: 7kP1jNx3Jv2qtz4M\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212462\n  level: 1\n  id: 72212462\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现简单路由\n  uuid: 7kP1jNx3Jv2qtz4M\n  url: zzc9k3\n  prev_uuid: V5rnG_Fh1uLT3tYz\n  sibling_uuid: We8EXWT44v6iRohB\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212455\n  level: 1\n  id: 72212455\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 长列表虚拟滚动\n  uuid: We8EXWT44v6iRohB\n  url: wsmws7\n  prev_uuid: 7kP1jNx3Jv2qtz4M\n  sibling_uuid: Svy4yFR_RT_CSfLd\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212399\n  level: 1\n  id: 72212399\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 围圈报数问题\n  uuid: Svy4yFR_RT_CSfLd\n  url: gkoa19\n  prev_uuid: We8EXWT44v6iRohB\n  sibling_uuid: L20YHOh3AcKOC_BK\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212447\n  level: 1\n  id: 72212447\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 查找文章中出现频率最高的词\n  uuid: L20YHOh3AcKOC_BK\n  url: rln2y3\n  prev_uuid: Svy4yFR_RT_CSfLd\n  sibling_uuid: l-w9qpcLnXk3Fop6\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212453\n  level: 1\n  id: 72212453\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise 每隔 1s 输出 1、2、3\n  uuid: l-w9qpcLnXk3Fop6\n  url: yg55el\n  prev_uuid: L20YHOh3AcKOC_BK\n  sibling_uuid: bpvqYyN2Dt1OP5ba\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 74885844\n  level: 1\n  id: 74885844\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 循环打印红黄绿\n  uuid: bpvqYyN2Dt1OP5ba\n  url: wyhgfz\n  prev_uuid: l-w9qpcLnXk3Fop6\n  sibling_uuid: sYbQboe4NKOreGYz\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212451\n  level: 1\n  id: 72212451\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 封装一个异步加载图片的方法\n  uuid: sYbQboe4NKOreGYz\n  url: orxq0m\n  prev_uuid: bpvqYyN2Dt1OP5ba\n  sibling_uuid: jSGMOwTmTh-AVElI\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 74886744\n  level: 1\n  id: 74886744\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现 mergePromise 函数\n  uuid: jSGMOwTmTh-AVElI\n  url: apqplp\n  prev_uuid: sYbQboe4NKOreGYz\n  sibling_uuid: D5aX74WcvfcBK-xH\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 74885813\n  level: 1\n  id: 74885813\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 文本中识别敏感词、表情包、链接、数字、字母并高亮\n  uuid: D5aX74WcvfcBK-xH\n  url: athu4p\n  prev_uuid: jSGMOwTmTh-AVElI\n  sibling_uuid: Bt1pMK0unwRBHK0k\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212408\n  level: 1\n  id: 72212408\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 图片格式转换为 webp\n  uuid: Bt1pMK0unwRBHK0k\n  url: cwlftq\n  prev_uuid: D5aX74WcvfcBK-xH\n  sibling_uuid: I9iFwpfXRhZn1Ket\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212400\n  level: 1\n  id: 72212400\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 计算对象占用的字节数\n  uuid: I9iFwpfXRhZn1Ket\n  url: gx1y1y\n  prev_uuid: Bt1pMK0unwRBHK0k\n  sibling_uuid: UcV05ziY4TJKPu5m\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212406\n  level: 1\n  id: 72212406\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 给 xhr 添加 hook，实现在各个阶段打印日志\n  uuid: UcV05ziY4TJKPu5m\n  url: dm9n4g\n  prev_uuid: I9iFwpfXRhZn1Ket\n  sibling_uuid: 77boIDk-fFPJ9Icd\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212404\n  level: 1\n  id: 72212404\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 明信片问题\n  uuid: 77boIDk-fFPJ9Icd\n  url: mnsw3z\n  prev_uuid: UcV05ziY4TJKPu5m\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212466\n  level: 1\n  id: 72212466\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 常用算法实现\n  uuid: ahwD4hLemj7wd4n_\n  url: ''\n  prev_uuid: 1mqH8VqzmT3IEIjz\n  sibling_uuid: ''\n  child_uuid: 9pHSK6xJvBHyYfvP\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: SKU算法实现\n  uuid: 9pHSK6xJvBHyYfvP\n  url: rs9nxb\n  prev_uuid: ahwD4hLemj7wd4n_\n  sibling_uuid: '-h-CMZM_g4aYqwln'\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 81636590\n  level: 1\n  id: 81636590\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 无重复最长子串\n  uuid: '-h-CMZM_g4aYqwln'\n  url: zn78xr\n  prev_uuid: 9pHSK6xJvBHyYfvP\n  sibling_uuid: tDrBxICyXBoMgRJD\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 81636434\n  level: 1\n  id: 81636434\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 二分查找\n  uuid: tDrBxICyXBoMgRJD\n  url: pywta0\n  prev_uuid: '-h-CMZM_g4aYqwln'\n  sibling_uuid: eH5hJfGPxku_rn96\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212463\n  level: 1\n  id: 72212463\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 排序\n  uuid: eH5hJfGPxku_rn96\n  url: ivvld9\n  prev_uuid: tDrBxICyXBoMgRJD\n  sibling_uuid: 4cV9_qbBLcYidtg8\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212411\n  level: 1\n  id: 72212411\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 动态规划和贪心算法\n  uuid: 4cV9_qbBLcYidtg8\n  url: pyig7m\n  prev_uuid: eH5hJfGPxku_rn96\n  sibling_uuid: 5VMnf0-t-FXvC3K6\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212414\n  level: 1\n  id: 72212414\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 洗牌算法\n  uuid: 5VMnf0-t-FXvC3K6\n  url: tohw0k\n  prev_uuid: 4cV9_qbBLcYidtg8\n  sibling_uuid: AjOzxJ-vxxRXW6dS\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212418\n  level: 1\n  id: 72212418\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: LRU(最少置换算法)\n  uuid: AjOzxJ-vxxRXW6dS\n  url: tmwgql\n  prev_uuid: 5VMnf0-t-FXvC3K6\n  sibling_uuid: ID7sjKR9-5E_moyo\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212423\n  level: 1\n  id: 72212423\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 斐波那契数列\n  uuid: ID7sjKR9-5E_moyo\n  url: bq7f7e\n  prev_uuid: AjOzxJ-vxxRXW6dS\n  sibling_uuid: wZscOLfm_xjPFYv2\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212420\n  level: 1\n  id: 72212420\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 大数相加\n  uuid: wZscOLfm_xjPFYv2\n  url: ln6fpo\n  prev_uuid: ID7sjKR9-5E_moyo\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212421\n  level: 1\n  id: 72212421\n  open_window: 0\n  visible: 1\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 74,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:38.713Z",
    "created_at": "2022-04-04T11:34:53.000Z",
    "updated_at": "2023-11-11T18:15:39.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-22T20:13:30.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/sd8kbc",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 908499750,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}