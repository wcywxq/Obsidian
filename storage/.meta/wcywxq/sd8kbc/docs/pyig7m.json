{
  "id": 72212414,
  "slug": "pyig7m",
  "title": "动态规划和贪心算法",
  "description": "动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化算法。解题思路：明确 状态 和 选择明确 dp 数组定义状态转移方程伪代码转换为代码下面有一些用动态规划来解决实际问题的算法：最少硬币找零给定一组硬币的面额，以及要找零的钱数，计算出符合找零钱...",
  "cover": "",
  "user_id": 732231,
  "book_id": 26225252,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "",
  "body": "动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化算法。\n\n解题思路：\n\n- 明确 状态 和 选择\n- 明确 dp 数组定义\n- 状态转移方程\n- 伪代码转换为代码\n\n下面有一些用动态规划来解决实际问题的算法：\n\n<a name=\"757a1831\"></a>\n### 最少硬币找零\n\n给定一组硬币的面额，以及要找零的钱数，计算出符合找零钱数的最少硬币数量。例如，美国硬币面额有 1、5、10、25 这四种面额，如果要找 36 美分的零钱，则得出的最少硬币数应该是 1 个 25 美分、1 个 10 美分和 1 个 1 美分共三个硬币。这个算法要解决的就是诸如此类的问题。我们来看看如何用动态规划的方式来解决。<br />对于每一种面额，我们都分别计算所需要的硬币数量。具体算法如下：\n\n1. 如果全部用 1 美分的硬币，一共需要 36 个硬币\n2. 如果用 5 美分的硬币，则需要 7 个 5 美分的硬币 + 1 个 1 美分的硬币 = 8 个硬币\n3. 如果用 10 美分的硬币，则需要 3 个 10 美分的硬币 + 1 个 5 美分的硬币 + 1 个 1 美分的硬币 = 5 个硬币\n4. 如果用 25 美分的硬币，则需要 1 个 25 美分的硬币 + 1 个 10 美分的硬币 + 1 个 1 美分的硬币 = 3 个硬币\n\n对应的示意图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1646378945539-24e43e78-1a58-41a3-b484-7216935251d2.png#clientId=uefc7daca-fb68-4&from=paste&id=u31f8f0da&margin=%5Bobject%20Object%5D&name=image.png&originHeight=347&originWidth=289&originalType=url&ratio=1&size=19144&status=done&style=none&taskId=ubbd06031-a468-4f1e-904b-c894b99d48e#id=AFxVY&originHeight=347&originWidth=289&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />方案 4 的硬币总数最少，因此为最优方案。<br />具体的代码实现如下：\n\n```javascript\nfunction minCoinChange(coins, amount) {\n    let result = null\n    if (!amount) return result\n\n    const makeChange = (index, value, min) => {\n        let coin = coins[index]\n        let newAmount = Math.floor(value / coin)\n        if (newAmount) min[coin] = newAmount\n        if (value % coin !== 0) {\n            makeChange(--index, value - coin * newAmount, min)\n        }\n    }\n\n    const arr = []\n    for (let i = 0; i < coins.length; i++) {\n        const cache = {}\n        makeChange(i, amount, cache)\n        arr.push(cache)\n    }\n\n    console.log(arr)\n    let newMin = 0\n    arr.forEach(item => {\n        let min = 0\n        for (let v in item) min += item[v]\n        if (!newMin || min < newMin) {\n            newMin = min\n            result = item\n        }\n    })\n    return result\n}\n```\n\n函数 minCoinChange()接收一组硬币的面额，以及要找零的钱数。我们将上面例子中的值传入：\n\n```javascript\nconst result = minCoinChange2([1, 5, 10, 25], 36)\nconsole.log(result)\n```\n\n得到如下结果：\n\n```shell\n[\n  { '1': 36 },\n  { '1': 1, '5': 7 },\n  { '1': 1, '5': 1, '10': 3 },\n  { '1': 1, '10': 1, '25': 1 }\n]\n{ '1': 1, '10': 1, '25': 1 }\n```\n\n上面的数组是我们在代码中打印出来的 arr 的值，用来展示四种不同面额的硬币作为找零硬币时，实际所需要的硬币种类和数量。最终，我们会计算 arr 数组中硬币总数最少的那个方案，作为 minCoinChange()函数的输出。<br />当然在实际应用中，我们可以把硬币抽象成任何你需要的数字，这个算法能给出你满足结果的最小组合。\n\n<a name=\"d39a003f\"></a>\n### 背包问题\n\n背包问题是一个组合优化问题，它被描述为：给定一个具有固定容量的背包 capacity，以及一组具有价值（value）和重量（weight）的物品，找出一个最优方案，使得装入背包的物品的总重量不超过 capacity，且总价值最大。<br />假设我们有以下物品，且背包的总容量为 5：\n\n| **物品#** | **重量** | **价值** |\n| --- | --- | --- |\n| 1 | 2 | 3 |\n| 2 | 3 | 4 |\n| 3 | 4 | 5 |\n\n\n我们用矩阵来解决这个问题。首先，我们把物品和背包的容量组成如下矩阵：\n\n| **物品(i)/重量(w)** | **0** | **1** | **2** | **3** | **4** | **5** |\n| --- | --- | --- | --- | --- | --- | --- |\n| **0** | 0 | 0 | 0 | 0 | 0 | 0 |\n| **1 (w=2, v=3)** | 0 | 0 | a: 3+[0][2-2]=3+0 |  |  |  |\n\n\nb: [0][2]=0<br />max(3+0,0)=3 | a: 3+[0][3-2]=3+0<br />b: [0][3]=0<br />max(3+0,0)=3 | a: 3+[0][4-3]=3+0<br />b: [0][4]=0<br />max(3+0,0)=3 | a: 3+[0][5-3]=3+0<br />b: [0][5]=0<br />max(3+0,0)=3 |<br />| **2 (w=3, v=4)** | 0 | 0 | 3 | a: 4+[1][3-3]=4+0<br />b: [1][3]=3<br />max(4+0,3)=4 | a: 4+[1][4-3]=4+0<br />b: [1][4]=3<br />max(4+0,3)=4 | a: 4+[1][5-3]=4+3<br />b: [1][5]=3<br />max(4+3,3)=7 |<br />| **3 (w=4, v=5)** | 0 | 0 | 3 | 4 | a: 5+[2][4-4]=5+0<br />b: [2][4]=4<br />max(5+0,4)=5 | a: 5+[2][5-4]=5+0<br />b: [2][5]=7<br />max(5+0,7)=7 |\n\n为了便于理解，我们将矩阵 kS 的第一列和第一行忽略（因为它们表示的是容量 0 和第 0 个物品）。然后，按照要求往矩阵的格子里填数。如果当前的格子能放下对应的物品，存在以下两种情况：\n\n- **a - 放入当前物品，然后剩余的重量再放入前一个物品**\n- **b - 不放入当前物品，放入前一个物品**\n\n在上面的表格中，\n\n1. 当背包的重量为 1 时，没有物品能放入，所以都是 0，这个很好理解。\n2. 当背包的重量为 2 时，物品 1 可以放入，那么存在两种情况：放入物品 1（价值为 3），剩余的重量（背包的重量 2 减去物品 1 的重量 2，结果为 0）再放入前一个物品；不放入物品 1，放入前一个物品[0][2]，价值为 0。所以最大价值就是 max(3, 0)=3。\n3. ......\n4. 当背包的重量为 5 时，放入物品 2，两种情况：放入物品 2（价值为 4），剩余的重量（背包的重量 5 减去物品 2 的重量 3，结果为 2）再放入前一个物品，是[1][2]，对应的价值是 3；不放入物品 2，，放入前一个物品[1][5]，价值为 3。所以最大价值就是 max(4+3, 3)=7。\n5. ......\n\n如果当前物品不能放入背包，则忽略它，用前一个值代替。我们可以按照上面描述的过程把剩余的格子都填满，这样表格中最后一个单元格里的值就是最优方案。<br />下面是具体的实现代码：\n\n```javascript\nfunction knapSack(capacity, weights, values, n) {\n    const kS = []\n\n    // 将ks初始化为一个空的矩阵\n    for (let i = 0; i <= n; i++) {\n        kS[i] = []\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let w = 0; w <= capacity; w++) {\n            // 忽略矩阵的第1列和第1行\n            if (i === 0 || w === 0) {\n                kS[i][w] = 0\n            } else if (weights[i - 1] <= w) {\n                const a = values[i - 1] + kS[i - 1][w - weights[i - 1]]\n                const b = kS[i - 1][w]\n                kS[i][w] = Math.max(a, b)\n            } else {\n                kS[i][w] = kS[i - 1][w]\n            }\n        }\n    }\n\n    console.log(kS)\n}\n\n// 另一种实现\n// 第 i 个物品的价值是：val[i - 1]\n// 第 i 个物品的重量是：wt[i - 1]\n// dp[i][w] = dp[i-1][w-wt[i-1]] + val[i-1]\nfunction knapSack(W, N, wt = [], val = []) {\n  const dp = new Array(N+1).fill(new Array(W + 1).fill(0))\n  for (let i = 1; i <= N; i++) {\n    for (let w = 1; w <= W; w++) {\n      if (w - wt[i - 1] < 0) {\n        dp[i][w] = dp[i - 1][w]\n      } else {\n        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - wt[i - 1]] - val[i - 1])\n      }\n    }\n  }\n}\n```\n\n对于 const a，其价值分为两部分，第一部分就是它自己的价值（values[i - 1]），第二部分是用背包剩余的重量（w - weights[i - 1]）装进前一个物品（kS[i - 1]）。对于 const b，就是找前一个能放入这个重量的物品（kS[i - 1][w]）。然后取这两种情况下的最大值。<br />测试一下 knapSack()函数，\n\n```javascript\nconst capacity = 5\nconst weights = [2, 3, 4]\nconst values = [3, 4, 5]\nknapSack(capacity, weights, values, weights.length)\n```\n\n下面是矩阵 kS 的输出结果：\n\n```shell\n[\n  [ 0, 0, 0, 0, 0, 0 ],\n  [ 0, 0, 3, 3, 3, 3 ],\n  [ 0, 0, 3, 4, 4, 7 ],\n  [ 0, 0, 3, 4, 5, 7 ]\n]\n```\n\n<a name=\"09793c39\"></a>\n### 最长公共子序列（LCS）\n\n找出两个字符串序列的最长子序列的长度。所谓最长子序列，是指两个字符串序列中以相同顺序出现，但不要求连续的字符串序列。例如下面两个字符串：<br />字符串 1：acbaed<br />字符串 2：abcadf<br />则 LCS 为 acad。<br />和背包问题的思路类似，我们用下面的表格来描述整个过程：\n\n|  |  | a | b | c | a | d | f |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n|  | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| a | 0 | 1 | 1 | 1 | 1 | 1 | 1 |\n| c | 0 | 1 | 1 | 2 | 2 | 2 | 2 |\n| b | 0 | 1 | 2 | 2 | 2 | 2 | 2 |\n| a | 0 | 1 | 2 | 2 | 3 | 3 | 3 |\n| e | 0 | 1 | 2 | 2 | 3 | 3 | 3 |\n| d | 0 | 1 | 2 | 2 | 3 | 4 | 4 |\n\n\n矩阵的第一行和第一列都被设置为 0，剩余的部分，遵循下面两种情况：\n\n- 如果 wordX[i - 1]和 wordY[j - 1]相等，则矩阵对应的单元格的值为单元格[i - 1][j - 1]的值加 1。\n- 如果 wordX[i - 1]和 wordY[j - 1]不相等，则找出单元格[i - 1][j]和单元格[i][j - 1]之间的最大值。\n\n下面是具体的实现代码：\n\n```javascript\nfunction lcs(wordX, wordY) {\n    const m = wordX.length\n    const n = wordY.length\n    const l = []\n    for (let i = 0; i <= m; i++) {\n        l[i] = []\n        for (let j = 0; j <= n; j++) {\n            l[i][j] = 0\n        }\n    }\n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            if (i === 0 || j === 0) {\n                l[i][j] = 0\n            } else if (wordX[i - 1] === wordY[j - 1]) {\n                l[i][j] = l[i - 1][j - 1] + 1\n            } else {\n                const a = l[i - 1][j]\n                const b = l[i][j - 1]\n                l[i][j] = Math.max(a, b)\n            }\n        }\n    }\n    console.log(l)\n    console.log(l[m][n])\n}\n```\n\n我们将矩阵打印出来，结果如下：\n\n```javascript\nconst wordX = [\"a\", \"c\", \"b\", \"a\", \"e\", \"d\"]\nconst wordY = [\"a\", \"b\", \"c\", \"a\", \"d\", \"f\"]\nlcs(wordX, wordY)\n```\n\n```shell\n[\n  [ 0, 0, 0, 0, 0, 0, 0 ],\n  [ 0, 1, 1, 1, 1, 1, 1 ],\n  [ 0, 1, 1, 2, 2, 2, 2 ],\n  [ 0, 1, 2, 2, 2, 2, 2 ],\n  [ 0, 1, 2, 2, 3, 3, 3 ],\n  [ 0, 1, 2, 2, 3, 3, 3 ],\n  [ 0, 1, 2, 2, 3, 4, 4 ]\n]\n4\n```\n\n矩阵中最后一个单元格的值为 LCS 的长度。那如何计算出 LCS 的具体内容呢？我们可以设计一个相同的 solution 矩阵，用来做标记，如果 wordX[i - 1]和 wordY[j - 1]相等，则将 solution 矩阵中对应的值设置为'diagonal'，即上面表格中背景为灰色的单元格。否则，根据[i][j]和[i - 1][j]是否相等标记为'top'或'left'。然后通过 printSolution()方法来找出 LCS 的内容。修改之后的代码如下：\n\n```javascript\nfunction printSolution(solution, wordX, m, n) {\n    let a = m\n    let b = n\n    let x = solution[a][b]\n    let answer = \"\"\n    while (x !== \"0\") {\n        if (solution[a][b] === \"diagonal\") {\n            answer = wordX[a - 1] + answer\n            a--\n            b--\n        } else if (solution[a][b] === \"left\") {\n            b--\n        } else if (solution[a][b] === \"top\") {\n            a--\n        }\n        x = solution[a][b]\n    }\n    return answer\n}\n\nfunction lcs(wordX, wordY) {\n    const m = wordX.length\n    const n = wordY.length\n    const l = []\n    const solution = []\n    for (let i = 0; i <= m; i++) {\n        l[i] = []\n        solution[i] = []\n        for (let j = 0; j <= n; j++) {\n            l[i][j] = 0\n            solution[i][j] = \"0\"\n        }\n    }\n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            if (i === 0 || j === 0) {\n                l[i][j] = 0\n            } else if (wordX[i - 1] === wordY[j - 1]) {\n                l[i][j] = l[i - 1][j - 1] + 1\n                solution[i][j] = \"diagonal\"\n            } else {\n                const a = l[i - 1][j]\n                const b = l[i][j - 1]\n                l[i][j] = Math.max(a, b)\n                solution[i][j] = l[i][j] === l[i - 1][j] ? \"top\" : \"left\"\n            }\n        }\n    }\n\n    return printSolution(solution, wordX, m, n)\n}\n```\n\n测试结果：\n\n```javascript\nconst wordX = [\"a\", \"c\", \"b\", \"a\", \"e\", \"d\"]\nconst wordY = [\"a\", \"b\", \"c\", \"a\", \"d\", \"f\"]\nconsole.log(lcs(wordX, wordY)) // acad\n```\n\n<a name=\"f609d9e1\"></a>\n# 贪心算法\n\n贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择，从而达到全局的最优。它不像动态规划算法那样计算更大的格局。\n\n<a name=\"757a1831-1\"></a>\n### 最少硬币找零\n\n我们来看看如何用贪心算法解决前面提到过的最少硬币找零问题。\n\n```javascript\nfunction minCoinChange(coins, amount) {\n    const change = []\n    let total = 0\n    for (let i = coins.length - 1; i >= 0; i--) {\n        const coin = coins[i]\n        while (total + coin <= amount) {\n            change.push(coin)\n            total += coin\n        }\n    }\n    return change\n}\n\nconst result = minCoinChange([1, 5, 10, 25], 36)\nconsole.log(result) // [ 25, 10, 1 ]\n```\n\n前提是 coins 数组已经按从小到大排好序了，贪心算法从最大值开始尝试，如果该值不满足条件（要找零的钱数），则继续向下找，直到找到满足条件的所有值。以上算法并不能满足所有情况下找出最优方案，例如下面这种情况：\n\n```javascript\nconst result = minCoinChange([1, 2, 5, 9, 10], 18)\nconsole.log(result) // [ 10, 5, 2, 1 ]\n```\n\n给出的结果[10, 5, 2, 1]并不是最优方案，最优方案应该是[9, 9]。<br />与动态规划相比，贪心算法更简单、效率更高。但是其结果并不总是最理想的。但是综合看来，它相对执行时间来说，输出一个可以接受的结果。\n\n<a name=\"d39a003f-1\"></a>\n### 背包问题\n\n\n| **物品#** | **重量** | **价值** |\n| --- | --- | --- |\n| 1 | 2 | 3 |\n| 2 | 3 | 4 |\n| 3 | 4 | 5 |\n\n\n在动态规划的例子里，假定背包的容量为 5，最佳方案是往背包里装入物品 1 和物品 2，总价值为 7。在贪心算法中，我们需要考虑分数的情况，假定背包的容量为 6，装入物品 1 和物品 2 之后，剩余容量为 1，可以装入 1/4 的物品 3，总价值为 3+4+0.25×5=8.25。我们来看看具体的实现代码：\n\n```javascript\nfunction knapSack(capacity, weights, values) {\n    const n = values.length\n    let load = 0\n    let val = 0\n    for (let i = 0; i < n && load < capacity; i++) {\n        if (weights[i] <= capacity - load) {\n            val += values[i]\n            load += weights[i]\n            console.log(`物品${i + 1}，重量：${weights[i]}，价值：${values[i]}`)\n        } else {\n            const r = (capacity - load) / weights[i]\n            val += r * values[i]\n            load += weights[i]\n            console.log(`物品${i + 1}的${r}，重量：${r * weights[i]}，价值：${val}`)\n        }\n    }\n\n    return val\n}\n```\n\n从第一个物品开始遍历，如果总重量小于背包的容量，则继续迭代，装入物品。如果物品可以完整地装入背包，则将其价值和重量分别计入到变量 val 和 load 中，同时打印装入物品的信息。如果物品不能完整地装入背包，计算能够装入的比例 r，然后将这个比例所对应的价值和重量分别计入到变量 val 和 load 中，同时打印物品的信息。最终输出总的价值 val。下面是测试结果：\n\n```javascript\nconst capacity = 6\nconst weights = [2, 3, 4]\nconst values = [3, 4, 5]\nconsole.log(knapSack(capacity, weights, values))\n```\n\n```\n物品1，重量：2，价值：3\n物品2，重量：3，价值：4\n物品3的0.25，重量：1，价值：8.25\n8.25\n```\n\n在动态规划算法中，如果将背包的容量也设定为 6，计算结果则为 8。\n\n<a name=\"09793c39-1\"></a>\n### 最长公共子序列（LCS）\n\n最后我们再来看看如何用贪心算法解决 LCS 的问题。下面的代码返回了两个给定数组中的 LCS 的长度：\n\n```javascript\nfunction lcs(wordX, wordY, m = wordX.length, n = wordY.length) {\n    if (m === 0 || n === 0) {\n        return 0\n    }\n    if (wordX[m - 1] === wordY[n - 1]) {\n        return 1 + lcs(wordX, wordY, m - 1, n - 1)\n    }\n    const a = lcs(wordX, wordY, m, n - 1)\n    const b = lcs(wordX, wordY, m - 1, n)\n    return a > b ? a : b\n}\n\nconst wordX = [\"a\", \"c\", \"b\", \"a\", \"e\", \"d\"]\nconst wordY = [\"a\", \"b\", \"c\", \"a\", \"d\", \"f\"]\nconsole.log(lcs(wordX, wordY)) // 4\n```\n",
  "body_html": "<!doctype html><p data-lake-id=\"u5c863770\"><span>动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化算法。</span></p><p data-lake-id=\"ue1a514e8\"><span>​</span><br /></p><p data-lake-id=\"u09ed6e1b\"><span>解题思路：</span></p><ul><li><span>明确 状态 和 选择</span></li><li><span>明确 dp 数组定义</span></li><li><span>状态转移方程</span></li><li><span>伪代码转换为代码</span></li></ul><p data-lake-id=\"ub82d487e\"><span>​</span><br /></p><p data-lake-id=\"u6ab2588c\"><span>下面有一些用动态规划来解决实际问题的算法：</span></p><p data-lake-id=\"u33af6455\"><br /></p><h3 id=\"757a1831\"><span>最少硬币找零</span></h3><p data-lake-id=\"u81e46160\"><br /></p><p data-lake-id=\"ud3b04d2d\"><span>给定一组硬币的面额，以及要找零的钱数，计算出符合找零钱数的最少硬币数量。例如，美国硬币面额有 1、5、10、25 这四种面额，如果要找 36 美分的零钱，则得出的最少硬币数应该是 1 个 25 美分、1 个 10 美分和 1 个 1 美分共三个硬币。这个算法要解决的就是诸如此类的问题。我们来看看如何用动态规划的方式来解决。<br /></span><span>对于每一种面额，我们都分别计算所需要的硬币数量。具体算法如下：</span></p><p data-lake-id=\"u96cfb005\"><br /></p><ol><li><span>如果全部用 1 美分的硬币，一共需要 36 个硬币</span></li><li><span>如果用 5 美分的硬币，则需要 7 个 5 美分的硬币 + 1 个 1 美分的硬币 = 8 个硬币</span></li><li><span>如果用 10 美分的硬币，则需要 3 个 10 美分的硬币 + 1 个 5 美分的硬币 + 1 个 1 美分的硬币 = 5 个硬币</span></li><li><span>如果用 25 美分的硬币，则需要 1 个 25 美分的硬币 + 1 个 10 美分的硬币 + 1 个 1 美分的硬币 = 3 个硬币</span></li></ol><p data-lake-id=\"u565d922c\"><br /></p><p data-lake-id=\"u1b2868cc\"><span>对应的示意图如下：<br /></span><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1646378945539-24e43e78-1a58-41a3-b484-7216935251d2.png#clientId=uefc7daca-fb68-4&amp;from=paste&amp;id=u31f8f0da&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=347&amp;originWidth=289&amp;originalType=url&amp;ratio=1&amp;size=19144&amp;status=done&amp;style=none&amp;taskId=ubbd06031-a468-4f1e-904b-c894b99d48e#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=AFxVY&amp;originHeight=347&amp;originWidth=289&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" style=\"max-width: 600px;\" /><span><br /></span><span>方案 4 的硬币总数最少，因此为最优方案。<br /></span><span>具体的代码实现如下：</span></p><p data-lake-id=\"ubfb1d2fb\"><br /></p><pre data-lang=\"javascript\"><code>function minCoinChange(coins, amount) {\n    let result = null\n    if (!amount) return result\n\n    const makeChange = (index, value, min) =&gt; {\n        let coin = coins[index]\n        let newAmount = Math.floor(value / coin)\n        if (newAmount) min[coin] = newAmount\n        if (value % coin !== 0) {\n            makeChange(--index, value - coin * newAmount, min)\n        }\n    }\n\n    const arr = []\n    for (let i = 0; i &lt; coins.length; i++) {\n        const cache = {}\n        makeChange(i, amount, cache)\n        arr.push(cache)\n    }\n\n    console.log(arr)\n    let newMin = 0\n    arr.forEach(item =&gt; {\n        let min = 0\n        for (let v in item) min += item[v]\n        if (!newMin || min &lt; newMin) {\n            newMin = min\n            result = item\n        }\n    })\n    return result\n}</code></pre><p data-lake-id=\"u2d37d38f\"><br /></p><p data-lake-id=\"udcf71d50\"><span>函数 minCoinChange()接收一组硬币的面额，以及要找零的钱数。我们将上面例子中的值传入：</span></p><p data-lake-id=\"uc6bd35bf\"><br /></p><pre data-lang=\"javascript\"><code>const result = minCoinChange2([1, 5, 10, 25], 36)\nconsole.log(result)</code></pre><p data-lake-id=\"u2c045cb4\"><br /></p><p data-lake-id=\"u8f3d5222\"><span>得到如下结果：</span></p><p data-lake-id=\"u4653b235\"><br /></p><pre data-lang=\"shell\"><code>[\n  { '1': 36 },\n  { '1': 1, '5': 7 },\n  { '1': 1, '5': 1, '10': 3 },\n  { '1': 1, '10': 1, '25': 1 }\n]\n{ '1': 1, '10': 1, '25': 1 }</code></pre><p data-lake-id=\"u37dacdd8\"><br /></p><p data-lake-id=\"u95519301\"><span>上面的数组是我们在代码中打印出来的 arr 的值，用来展示四种不同面额的硬币作为找零硬币时，实际所需要的硬币种类和数量。最终，我们会计算 arr 数组中硬币总数最少的那个方案，作为 minCoinChange()函数的输出。<br /></span><span>当然在实际应用中，我们可以把硬币抽象成任何你需要的数字，这个算法能给出你满足结果的最小组合。</span></p><p data-lake-id=\"u76b2439c\"><br /></p><h3 id=\"d39a003f\"><span>背包问题</span></h3><p data-lake-id=\"u10dbcc86\"><br /></p><p data-lake-id=\"ub97ecb5f\"><span>背包问题是一个组合优化问题，它被描述为：给定一个具有固定容量的背包 capacity，以及一组具有价值（value）和重量（weight）的物品，找出一个最优方案，使得装入背包的物品的总重量不超过 capacity，且总价值最大。<br /></span><span>假设我们有以下物品，且背包的总容量为 5：</span></p><table class=\"lake-table\" style=\"width: 750px;\"><colgroup><col width=\"250\"></col><col width=\"250\"></col><col width=\"250\"></col></colgroup><tbody><tr><td><p data-lake-id=\"u3f339e5a\"><strong><span>物品#</span></strong></p></td><td><p data-lake-id=\"ua4cf0879\"><strong><span>重量</span></strong></p></td><td><p data-lake-id=\"u320d9a54\"><strong><span>价值</span></strong></p></td></tr><tr><td><p data-lake-id=\"ucd5cb5b5\"><span>1</span></p></td><td><p data-lake-id=\"u28f7fc76\"><span>2</span></p></td><td><p data-lake-id=\"uf9c5e95e\"><span>3</span></p></td></tr><tr><td><p data-lake-id=\"ua14269c1\"><span>2</span></p></td><td><p data-lake-id=\"u733f598e\"><span>3</span></p></td><td><p data-lake-id=\"ubf009b0a\"><span>4</span></p></td></tr><tr><td><p data-lake-id=\"u9c363daf\"><span>3</span></p></td><td><p data-lake-id=\"uc46f0241\"><span>4</span></p></td><td><p data-lake-id=\"u61208896\"><span>5</span></p></td></tr></tbody></table><p data-lake-id=\"u31e8758c\"><br /></p><p data-lake-id=\"u313960bd\"><span>我们用矩阵来解决这个问题。首先，我们把物品和背包的容量组成如下矩阵：</span></p><table class=\"lake-table\" style=\"width: 749px;\"><colgroup><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col><col width=\"107\"></col></colgroup><tbody><tr><td><p data-lake-id=\"u4f14b454\"><strong><span>物品(i)/重量(w)</span></strong></p></td><td><p data-lake-id=\"ubbba5c2f\"><strong><span>0</span></strong></p></td><td><p data-lake-id=\"uc6ba2a83\"><strong><span>1</span></strong></p></td><td><p data-lake-id=\"ue8a46261\"><strong><span>2</span></strong></p></td><td><p data-lake-id=\"uff20d452\"><strong><span>3</span></strong></p></td><td><p data-lake-id=\"u016aa117\"><strong><span>4</span></strong></p></td><td><p data-lake-id=\"u9d04f937\"><strong><span>5</span></strong></p></td></tr><tr><td><p data-lake-id=\"u55e14b04\"><strong><span>0</span></strong></p></td><td><p data-lake-id=\"u6b6e2127\"><span>0</span></p></td><td><p data-lake-id=\"u86e8ebf8\"><span>0</span></p></td><td><p data-lake-id=\"uc0d73089\"><span>0</span></p></td><td><p data-lake-id=\"ucfe0883b\"><span>0</span></p></td><td><p data-lake-id=\"u1ebfd608\"><span>0</span></p></td><td><p data-lake-id=\"uc78ce91c\"><span>0</span></p></td></tr><tr><td><p data-lake-id=\"ud8a158fe\"><strong><span>1 (w=2, v=3)</span></strong></p></td><td><p data-lake-id=\"u9a37f0bd\"><span>0</span></p></td><td><p data-lake-id=\"u326d26e1\"><span>0</span></p></td><td><p data-lake-id=\"ude630344\"><span>a: 3+[0][2-2]=3+0</span></p></td><td></td><td></td><td></td></tr></tbody></table><p data-lake-id=\"ufbf4f819\"><br /></p><p data-lake-id=\"ubdc512b2\"><span>b: [0][2]=0<br /></span><span>max(3+0,0)=3 | a: 3+[0][3-2]=3+0<br /></span><span>b: [0][3]=0<br /></span><span>max(3+0,0)=3 | a: 3+[0][4-3]=3+0<br /></span><span>b: [0][4]=0<br /></span><span>max(3+0,0)=3 | a: 3+[0][5-3]=3+0<br /></span><span>b: [0][5]=0<br /></span><span>max(3+0,0)=3 |<br /></span><span>| </span><strong><span>2 (w=3, v=4)</span></strong><span> | 0 | 0 | 3 | a: 4+[1][3-3]=4+0<br /></span><span>b: [1][3]=3<br /></span><span>max(4+0,3)=4 | a: 4+[1][4-3]=4+0<br /></span><span>b: [1][4]=3<br /></span><span>max(4+0,3)=4 | a: 4+[1][5-3]=4+3<br /></span><span>b: [1][5]=3<br /></span><span>max(4+3,3)=7 |<br /></span><span>| </span><strong><span>3 (w=4, v=5)</span></strong><span> | 0 | 0 | 3 | 4 | a: 5+[2][4-4]=5+0<br /></span><span>b: [2][4]=4<br /></span><span>max(5+0,4)=5 | a: 5+[2][5-4]=5+0<br /></span><span>b: [2][5]=7<br /></span><span>max(5+0,7)=7 |</span></p><p data-lake-id=\"u6f1d82f4\"><br /></p><p data-lake-id=\"uee32eaef\"><span>为了便于理解，我们将矩阵 kS 的第一列和第一行忽略（因为它们表示的是容量 0 和第 0 个物品）。然后，按照要求往矩阵的格子里填数。如果当前的格子能放下对应的物品，存在以下两种情况：</span></p><p data-lake-id=\"ub618a423\"><br /></p><ul><li><strong><span>a - 放入当前物品，然后剩余的重量再放入前一个物品</span></strong></li><li><strong><span>b - 不放入当前物品，放入前一个物品</span></strong></li></ul><p data-lake-id=\"ub0fd35b2\"><br /></p><p data-lake-id=\"u4174a8ab\"><span>在上面的表格中，</span></p><p data-lake-id=\"u8ceab499\"><br /></p><ol><li><span>当背包的重量为 1 时，没有物品能放入，所以都是 0，这个很好理解。</span></li><li><span>当背包的重量为 2 时，物品 1 可以放入，那么存在两种情况：放入物品 1（价值为 3），剩余的重量（背包的重量 2 减去物品 1 的重量 2，结果为 0）再放入前一个物品；不放入物品 1，放入前一个物品[0][2]，价值为 0。所以最大价值就是 max(3, 0)=3。</span></li><li><span>......</span></li><li><span>当背包的重量为 5 时，放入物品 2，两种情况：放入物品 2（价值为 4），剩余的重量（背包的重量 5 减去物品 2 的重量 3，结果为 2）再放入前一个物品，是[1][2]，对应的价值是 3；不放入物品 2，，放入前一个物品[1][5]，价值为 3。所以最大价值就是 max(4+3, 3)=7。</span></li><li><span>......</span></li></ol><p data-lake-id=\"ub0d2697d\"><br /></p><p data-lake-id=\"ued227bc0\"><span>如果当前物品不能放入背包，则忽略它，用前一个值代替。我们可以按照上面描述的过程把剩余的格子都填满，这样表格中最后一个单元格里的值就是最优方案。<br /></span><span>下面是具体的实现代码：</span></p><p data-lake-id=\"u4591039c\"><br /></p><pre data-lang=\"javascript\"><code>function knapSack(capacity, weights, values, n) {\n    const kS = []\n\n    // 将ks初始化为一个空的矩阵\n    for (let i = 0; i &lt;= n; i++) {\n        kS[i] = []\n    }\n\n    for (let i = 0; i &lt;= n; i++) {\n        for (let w = 0; w &lt;= capacity; w++) {\n            // 忽略矩阵的第1列和第1行\n            if (i === 0 || w === 0) {\n                kS[i][w] = 0\n            } else if (weights[i - 1] &lt;= w) {\n                const a = values[i - 1] + kS[i - 1][w - weights[i - 1]]\n                const b = kS[i - 1][w]\n                kS[i][w] = Math.max(a, b)\n            } else {\n                kS[i][w] = kS[i - 1][w]\n            }\n        }\n    }\n\n    console.log(kS)\n}\n\n// 另一种实现\n// 第 i 个物品的价值是：val[i - 1]\n// 第 i 个物品的重量是：wt[i - 1]\n// dp[i][w] = dp[i-1][w-wt[i-1]] + val[i-1]\nfunction knapSack(W, N, wt = [], val = []) {\n  const dp = new Array(N+1).fill(new Array(W + 1).fill(0))\n  for (let i = 1; i &lt;= N; i++) {\n    for (let w = 1; w &lt;= W; w++) {\n      if (w - wt[i - 1] &lt; 0) {\n        dp[i][w] = dp[i - 1][w]\n      } else {\n        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - wt[i - 1]] - val[i - 1])\n      }\n    }\n  }\n}</code></pre><p data-lake-id=\"u62dec9f6\"><br /></p><p data-lake-id=\"u7dc4b70b\"><span>对于 const a，其价值分为两部分，第一部分就是它自己的价值（values[i - 1]），第二部分是用背包剩余的重量（w - weights[i - 1]）装进前一个物品（kS[i - 1]）。对于 const b，就是找前一个能放入这个重量的物品（kS[i - 1][w]）。然后取这两种情况下的最大值。<br /></span><span>测试一下 knapSack()函数，</span></p><p data-lake-id=\"u6081c8d4\"><br /></p><pre data-lang=\"javascript\"><code>const capacity = 5\nconst weights = [2, 3, 4]\nconst values = [3, 4, 5]\nknapSack(capacity, weights, values, weights.length)</code></pre><p data-lake-id=\"ua87e328e\"><br /></p><p data-lake-id=\"u1169ed74\"><span>下面是矩阵 kS 的输出结果：</span></p><p data-lake-id=\"uf7da4b0e\"><br /></p><pre data-lang=\"shell\"><code>[\n  [ 0, 0, 0, 0, 0, 0 ],\n  [ 0, 0, 3, 3, 3, 3 ],\n  [ 0, 0, 3, 4, 4, 7 ],\n  [ 0, 0, 3, 4, 5, 7 ]\n]</code></pre><p data-lake-id=\"ue97b4596\"><br /></p><h3 id=\"09793c39\"><span>最长公共子序列（LCS）</span></h3><p data-lake-id=\"u43260af1\"><br /></p><p data-lake-id=\"u28ce1f9b\"><span>找出两个字符串序列的最长子序列的长度。所谓最长子序列，是指两个字符串序列中以相同顺序出现，但不要求连续的字符串序列。例如下面两个字符串：<br /></span><span>字符串 1：acbaed<br /></span><span>字符串 2：abcadf<br /></span><span>则 LCS 为 acad。<br /></span><span>和背包问题的思路类似，我们用下面的表格来描述整个过程：</span></p><table class=\"lake-table\" style=\"width: 744px;\"><colgroup><col width=\"93\"></col><col width=\"93\"></col><col width=\"93\"></col><col width=\"93\"></col><col width=\"93\"></col><col width=\"93\"></col><col width=\"93\"></col><col width=\"93\"></col></colgroup><tbody><tr><td></td><td></td><td><p data-lake-id=\"u2907552b\"><span>a</span></p></td><td><p data-lake-id=\"uf87ba3b3\"><span>b</span></p></td><td><p data-lake-id=\"ud3e71f50\"><span>c</span></p></td><td><p data-lake-id=\"ueb2ec416\"><span>a</span></p></td><td><p data-lake-id=\"u09759090\"><span>d</span></p></td><td><p data-lake-id=\"u87a055c2\"><span>f</span></p></td></tr><tr><td></td><td><p data-lake-id=\"ucda160c2\"><span>0</span></p></td><td><p data-lake-id=\"u5bb6e137\"><span>0</span></p></td><td><p data-lake-id=\"u1a44434d\"><span>0</span></p></td><td><p data-lake-id=\"u42e6502a\"><span>0</span></p></td><td><p data-lake-id=\"u2c2e70a2\"><span>0</span></p></td><td><p data-lake-id=\"uf24c1378\"><span>0</span></p></td><td><p data-lake-id=\"uba66ae1c\"><span>0</span></p></td></tr><tr><td><p data-lake-id=\"ub855c0bc\"><span>a</span></p></td><td><p data-lake-id=\"u83322bb0\"><span>0</span></p></td><td><p data-lake-id=\"u639cd611\"><span>1</span></p></td><td><p data-lake-id=\"uc40474c2\"><span>1</span></p></td><td><p data-lake-id=\"ub08bb255\"><span>1</span></p></td><td><p data-lake-id=\"uf76cacea\"><span>1</span></p></td><td><p data-lake-id=\"u64c73878\"><span>1</span></p></td><td><p data-lake-id=\"u1f377781\"><span>1</span></p></td></tr><tr><td><p data-lake-id=\"u2c91591f\"><span>c</span></p></td><td><p data-lake-id=\"u54e5e789\"><span>0</span></p></td><td><p data-lake-id=\"u567fe964\"><span>1</span></p></td><td><p data-lake-id=\"ue6d8609e\"><span>1</span></p></td><td><p data-lake-id=\"u83ccabba\"><span>2</span></p></td><td><p data-lake-id=\"udce5e4c3\"><span>2</span></p></td><td><p data-lake-id=\"u71e9d231\"><span>2</span></p></td><td><p data-lake-id=\"u74111907\"><span>2</span></p></td></tr><tr><td><p data-lake-id=\"u598eee55\"><span>b</span></p></td><td><p data-lake-id=\"u8a8b9408\"><span>0</span></p></td><td><p data-lake-id=\"u882bf6f2\"><span>1</span></p></td><td><p data-lake-id=\"uf8c8c2fd\"><span>2</span></p></td><td><p data-lake-id=\"u2f5b0260\"><span>2</span></p></td><td><p data-lake-id=\"u39411d70\"><span>2</span></p></td><td><p data-lake-id=\"u5d1e0e4c\"><span>2</span></p></td><td><p data-lake-id=\"uf1599a72\"><span>2</span></p></td></tr><tr><td><p data-lake-id=\"u5c3bceb1\"><span>a</span></p></td><td><p data-lake-id=\"uf012866f\"><span>0</span></p></td><td><p data-lake-id=\"u53e73982\"><span>1</span></p></td><td><p data-lake-id=\"ucb0a18f8\"><span>2</span></p></td><td><p data-lake-id=\"u80e4b95c\"><span>2</span></p></td><td><p data-lake-id=\"u5e40443b\"><span>3</span></p></td><td><p data-lake-id=\"ue3b793ef\"><span>3</span></p></td><td><p data-lake-id=\"u830bad70\"><span>3</span></p></td></tr><tr><td><p data-lake-id=\"u8bef4fb6\"><span>e</span></p></td><td><p data-lake-id=\"ue369af42\"><span>0</span></p></td><td><p data-lake-id=\"u22810595\"><span>1</span></p></td><td><p data-lake-id=\"u2eaa8cf2\"><span>2</span></p></td><td><p data-lake-id=\"u724ed739\"><span>2</span></p></td><td><p data-lake-id=\"ua8530c4e\"><span>3</span></p></td><td><p data-lake-id=\"ua0f39063\"><span>3</span></p></td><td><p data-lake-id=\"u0c26c924\"><span>3</span></p></td></tr><tr><td><p data-lake-id=\"uba938abd\"><span>d</span></p></td><td><p data-lake-id=\"u8c76ff88\"><span>0</span></p></td><td><p data-lake-id=\"u384e0f43\"><span>1</span></p></td><td><p data-lake-id=\"uf73ff57d\"><span>2</span></p></td><td><p data-lake-id=\"u9bb9705b\"><span>2</span></p></td><td><p data-lake-id=\"u56f3cdde\"><span>3</span></p></td><td><p data-lake-id=\"u9d0beed3\"><span>4</span></p></td><td><p data-lake-id=\"u9f91e424\"><span>4</span></p></td></tr></tbody></table><p data-lake-id=\"u3960baa8\"><br /></p><p data-lake-id=\"u5cb36022\"><span>矩阵的第一行和第一列都被设置为 0，剩余的部分，遵循下面两种情况：</span></p><p data-lake-id=\"uc9f1b1de\"><br /></p><ul><li><span>如果 wordX[i - 1]和 wordY[j - 1]相等，则矩阵对应的单元格的值为单元格[i - 1][j - 1]的值加 1。</span></li><li><span>如果 wordX[i - 1]和 wordY[j - 1]不相等，则找出单元格[i - 1][j]和单元格[i][j - 1]之间的最大值。</span></li></ul><p data-lake-id=\"u0ba27152\"><br /></p><p data-lake-id=\"uce11b79c\"><span>下面是具体的实现代码：</span></p><p data-lake-id=\"u70475781\"><br /></p><pre data-lang=\"javascript\"><code>function lcs(wordX, wordY) {\n    const m = wordX.length\n    const n = wordY.length\n    const l = []\n    for (let i = 0; i &lt;= m; i++) {\n        l[i] = []\n        for (let j = 0; j &lt;= n; j++) {\n            l[i][j] = 0\n        }\n    }\n    for (let i = 0; i &lt;= m; i++) {\n        for (let j = 0; j &lt;= n; j++) {\n            if (i === 0 || j === 0) {\n                l[i][j] = 0\n            } else if (wordX[i - 1] === wordY[j - 1]) {\n                l[i][j] = l[i - 1][j - 1] + 1\n            } else {\n                const a = l[i - 1][j]\n                const b = l[i][j - 1]\n                l[i][j] = Math.max(a, b)\n            }\n        }\n    }\n    console.log(l)\n    console.log(l[m][n])\n}</code></pre><p data-lake-id=\"u656b0e4a\"><br /></p><p data-lake-id=\"u94abc9de\"><span>我们将矩阵打印出来，结果如下：</span></p><p data-lake-id=\"u41511b95\"><br /></p><pre data-lang=\"javascript\"><code>const wordX = [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;e&quot;, &quot;d&quot;]\nconst wordY = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;f&quot;]\nlcs(wordX, wordY)</code></pre><p data-lake-id=\"ue65bc3de\"><br /></p><pre data-lang=\"shell\"><code>[\n  [ 0, 0, 0, 0, 0, 0, 0 ],\n  [ 0, 1, 1, 1, 1, 1, 1 ],\n  [ 0, 1, 1, 2, 2, 2, 2 ],\n  [ 0, 1, 2, 2, 2, 2, 2 ],\n  [ 0, 1, 2, 2, 3, 3, 3 ],\n  [ 0, 1, 2, 2, 3, 3, 3 ],\n  [ 0, 1, 2, 2, 3, 4, 4 ]\n]\n4</code></pre><p data-lake-id=\"u81baa4dd\"><br /></p><p data-lake-id=\"u0dcf830b\"><span>矩阵中最后一个单元格的值为 LCS 的长度。那如何计算出 LCS 的具体内容呢？我们可以设计一个相同的 solution 矩阵，用来做标记，如果 wordX[i - 1]和 wordY[j - 1]相等，则将 solution 矩阵中对应的值设置为'diagonal'，即上面表格中背景为灰色的单元格。否则，根据[i][j]和[i - 1][j]是否相等标记为'top'或'left'。然后通过 printSolution()方法来找出 LCS 的内容。修改之后的代码如下：</span></p><p data-lake-id=\"uaa06cf23\"><br /></p><pre data-lang=\"javascript\"><code>function printSolution(solution, wordX, m, n) {\n    let a = m\n    let b = n\n    let x = solution[a][b]\n    let answer = &quot;&quot;\n    while (x !== &quot;0&quot;) {\n        if (solution[a][b] === &quot;diagonal&quot;) {\n            answer = wordX[a - 1] + answer\n            a--\n            b--\n        } else if (solution[a][b] === &quot;left&quot;) {\n            b--\n        } else if (solution[a][b] === &quot;top&quot;) {\n            a--\n        }\n        x = solution[a][b]\n    }\n    return answer\n}\n\nfunction lcs(wordX, wordY) {\n    const m = wordX.length\n    const n = wordY.length\n    const l = []\n    const solution = []\n    for (let i = 0; i &lt;= m; i++) {\n        l[i] = []\n        solution[i] = []\n        for (let j = 0; j &lt;= n; j++) {\n            l[i][j] = 0\n            solution[i][j] = &quot;0&quot;\n        }\n    }\n    for (let i = 0; i &lt;= m; i++) {\n        for (let j = 0; j &lt;= n; j++) {\n            if (i === 0 || j === 0) {\n                l[i][j] = 0\n            } else if (wordX[i - 1] === wordY[j - 1]) {\n                l[i][j] = l[i - 1][j - 1] + 1\n                solution[i][j] = &quot;diagonal&quot;\n            } else {\n                const a = l[i - 1][j]\n                const b = l[i][j - 1]\n                l[i][j] = Math.max(a, b)\n                solution[i][j] = l[i][j] === l[i - 1][j] ? &quot;top&quot; : &quot;left&quot;\n            }\n        }\n    }\n\n    return printSolution(solution, wordX, m, n)\n}</code></pre><p data-lake-id=\"ud620dcf6\"><br /></p><p data-lake-id=\"u3fb40d91\"><span>测试结果：</span></p><p data-lake-id=\"u35f1b423\"><br /></p><pre data-lang=\"javascript\"><code>const wordX = [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;e&quot;, &quot;d&quot;]\nconst wordY = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;f&quot;]\nconsole.log(lcs(wordX, wordY)) // acad</code></pre><p data-lake-id=\"u30aef622\"><br /></p><h1 id=\"f609d9e1\"><span>贪心算法</span></h1><p data-lake-id=\"u4a165942\"><br /></p><p data-lake-id=\"u8f98e398\"><span>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择，从而达到全局的最优。它不像动态规划算法那样计算更大的格局。</span></p><p data-lake-id=\"u6a7b462b\"><br /></p><h3 id=\"757a1831-1\"><span>最少硬币找零</span></h3><p data-lake-id=\"u43c56a85\"><br /></p><p data-lake-id=\"ue80f9888\"><span>我们来看看如何用贪心算法解决前面提到过的最少硬币找零问题。</span></p><p data-lake-id=\"u9b230f73\"><br /></p><pre data-lang=\"javascript\"><code>function minCoinChange(coins, amount) {\n    const change = []\n    let total = 0\n    for (let i = coins.length - 1; i &gt;= 0; i--) {\n        const coin = coins[i]\n        while (total + coin &lt;= amount) {\n            change.push(coin)\n            total += coin\n        }\n    }\n    return change\n}\n\nconst result = minCoinChange([1, 5, 10, 25], 36)\nconsole.log(result) // [ 25, 10, 1 ]</code></pre><p data-lake-id=\"u64aad510\"><br /></p><p data-lake-id=\"ud9d2724f\"><span>前提是 coins 数组已经按从小到大排好序了，贪心算法从最大值开始尝试，如果该值不满足条件（要找零的钱数），则继续向下找，直到找到满足条件的所有值。以上算法并不能满足所有情况下找出最优方案，例如下面这种情况：</span></p><p data-lake-id=\"u5440365a\"><br /></p><pre data-lang=\"javascript\"><code>const result = minCoinChange([1, 2, 5, 9, 10], 18)\nconsole.log(result) // [ 10, 5, 2, 1 ]</code></pre><p data-lake-id=\"u574044c7\"><br /></p><p data-lake-id=\"u36c82b76\"><span>给出的结果[10, 5, 2, 1]并不是最优方案，最优方案应该是[9, 9]。<br /></span><span>与动态规划相比，贪心算法更简单、效率更高。但是其结果并不总是最理想的。但是综合看来，它相对执行时间来说，输出一个可以接受的结果。</span></p><p data-lake-id=\"u8825ff5a\"><br /></p><h3 id=\"d39a003f-1\"><span>背包问题</span></h3><p data-lake-id=\"u7abbb734\"><br /></p><p data-lake-id=\"u993860d0\"><span>​</span><br /></p><table class=\"lake-table\" style=\"width: 750px;\"><colgroup><col width=\"250\"></col><col width=\"250\"></col><col width=\"250\"></col></colgroup><tbody><tr><td><p data-lake-id=\"u5880a9d3\"><strong><span>物品#</span></strong></p></td><td><p data-lake-id=\"u55111af8\"><strong><span>重量</span></strong></p></td><td><p data-lake-id=\"u7903f1a5\"><strong><span>价值</span></strong></p></td></tr><tr><td><p data-lake-id=\"uea29a6db\"><span>1</span></p></td><td><p data-lake-id=\"u6f04d738\"><span>2</span></p></td><td><p data-lake-id=\"u8711c4d6\"><span>3</span></p></td></tr><tr><td><p data-lake-id=\"u81bfe831\"><span>2</span></p></td><td><p data-lake-id=\"u62e20a66\"><span>3</span></p></td><td><p data-lake-id=\"u15d549d6\"><span>4</span></p></td></tr><tr><td><p data-lake-id=\"u36203a71\"><span>3</span></p></td><td><p data-lake-id=\"u225abe93\"><span>4</span></p></td><td><p data-lake-id=\"uaea4da5b\"><span>5</span></p></td></tr></tbody></table><p data-lake-id=\"u275bf463\"><br /></p><p data-lake-id=\"uf1e6c5f6\"><span>在动态规划的例子里，假定背包的容量为 5，最佳方案是往背包里装入物品 1 和物品 2，总价值为 7。在贪心算法中，我们需要考虑分数的情况，假定背包的容量为 6，装入物品 1 和物品 2 之后，剩余容量为 1，可以装入 1/4 的物品 3，总价值为 3+4+0.25×5=8.25。我们来看看具体的实现代码：</span></p><p data-lake-id=\"u02168106\"><br /></p><pre data-lang=\"javascript\"><code>function knapSack(capacity, weights, values) {\n    const n = values.length\n    let load = 0\n    let val = 0\n    for (let i = 0; i &lt; n &amp;&amp; load &lt; capacity; i++) {\n        if (weights[i] &lt;= capacity - load) {\n            val += values[i]\n            load += weights[i]\n            console.log(`物品${i + 1}，重量：${weights[i]}，价值：${values[i]}`)\n        } else {\n            const r = (capacity - load) / weights[i]\n            val += r * values[i]\n            load += weights[i]\n            console.log(`物品${i + 1}的${r}，重量：${r * weights[i]}，价值：${val}`)\n        }\n    }\n\n    return val\n}</code></pre><p data-lake-id=\"u8ab18774\"><br /></p><p data-lake-id=\"uce331fac\"><span>从第一个物品开始遍历，如果总重量小于背包的容量，则继续迭代，装入物品。如果物品可以完整地装入背包，则将其价值和重量分别计入到变量 val 和 load 中，同时打印装入物品的信息。如果物品不能完整地装入背包，计算能够装入的比例 r，然后将这个比例所对应的价值和重量分别计入到变量 val 和 load 中，同时打印物品的信息。最终输出总的价值 val。下面是测试结果：</span></p><p data-lake-id=\"uf297eb65\"><br /></p><pre data-lang=\"javascript\"><code>const capacity = 6\nconst weights = [2, 3, 4]\nconst values = [3, 4, 5]\nconsole.log(knapSack(capacity, weights, values))</code></pre><p data-lake-id=\"u6ea35a67\"><br /></p><pre><code>物品1，重量：2，价值：3\n物品2，重量：3，价值：4\n物品3的0.25，重量：1，价值：8.25\n8.25</code></pre><p data-lake-id=\"u3db63bd8\"><br /></p><p data-lake-id=\"u454c8b5e\"><span>在动态规划算法中，如果将背包的容量也设定为 6，计算结果则为 8。</span></p><p data-lake-id=\"udbdb4f65\"><br /></p><h3 id=\"09793c39-1\"><span>最长公共子序列（LCS）</span></h3><p data-lake-id=\"uad57bcfe\"><br /></p><p data-lake-id=\"u2d55beba\"><span>最后我们再来看看如何用贪心算法解决 LCS 的问题。下面的代码返回了两个给定数组中的 LCS 的长度：</span></p><p data-lake-id=\"u034ab4f4\"><br /></p><pre data-lang=\"javascript\"><code>function lcs(wordX, wordY, m = wordX.length, n = wordY.length) {\n    if (m === 0 || n === 0) {\n        return 0\n    }\n    if (wordX[m - 1] === wordY[n - 1]) {\n        return 1 + lcs(wordX, wordY, m - 1, n - 1)\n    }\n    const a = lcs(wordX, wordY, m, n - 1)\n    const b = lcs(wordX, wordY, m - 1, n)\n    return a &gt; b ? a : b\n}\n\nconst wordX = [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;e&quot;, &quot;d&quot;]\nconst wordY = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;f&quot;]\nconsole.log(lcs(wordX, wordY)) // 4</code></pre>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u5c863770\" id=\"u5c863770\"><span data-lake-id=\"ud2f804e4\" id=\"ud2f804e4\">动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化算法。</span></p><p data-lake-id=\"ue1a514e8\" id=\"ue1a514e8\"><span data-lake-id=\"u008fee0e\" id=\"u008fee0e\">​</span><br></p><p data-lake-id=\"u09ed6e1b\" id=\"u09ed6e1b\"><span data-lake-id=\"ua7319c94\" id=\"ua7319c94\">解题思路：</span></p><ul list=\"uc209cbda\"><li fid=\"u62dccf04\" data-lake-id=\"u8d1886be\" id=\"u8d1886be\"><span data-lake-id=\"u5ad1ead1\" id=\"u5ad1ead1\">明确 状态 和 选择</span></li><li fid=\"u62dccf04\" data-lake-id=\"ud5eda616\" id=\"ud5eda616\"><span data-lake-id=\"u61982623\" id=\"u61982623\">明确 dp 数组定义</span></li><li fid=\"u62dccf04\" data-lake-id=\"u1dd98894\" id=\"u1dd98894\"><span data-lake-id=\"u801b872f\" id=\"u801b872f\">状态转移方程</span></li><li fid=\"u62dccf04\" data-lake-id=\"u0526c2e2\" id=\"u0526c2e2\"><span data-lake-id=\"u5e671696\" id=\"u5e671696\">伪代码转换为代码</span></li></ul><p data-lake-id=\"ub82d487e\" id=\"ub82d487e\"><span data-lake-id=\"u51170767\" id=\"u51170767\">​</span><br></p><p data-lake-id=\"u6ab2588c\" id=\"u6ab2588c\"><span data-lake-id=\"u3114fd87\" id=\"u3114fd87\">下面有一些用动态规划来解决实际问题的算法：</span></p><p data-lake-id=\"u33af6455\" id=\"u33af6455\"><br></p><h3 data-lake-id=\"757a1831\" id=\"757a1831\"><span data-lake-id=\"uf5e9d898\" id=\"uf5e9d898\">最少硬币找零</span></h3><p data-lake-id=\"u81e46160\" id=\"u81e46160\"><br></p><p data-lake-id=\"ud3b04d2d\" id=\"ud3b04d2d\"><span data-lake-id=\"u74188fed\" id=\"u74188fed\">给定一组硬币的面额，以及要找零的钱数，计算出符合找零钱数的最少硬币数量。例如，美国硬币面额有 1、5、10、25 这四种面额，如果要找 36 美分的零钱，则得出的最少硬币数应该是 1 个 25 美分、1 个 10 美分和 1 个 1 美分共三个硬币。这个算法要解决的就是诸如此类的问题。我们来看看如何用动态规划的方式来解决。<br /></span><span data-lake-id=\"u8dc21377\" id=\"u8dc21377\">对于每一种面额，我们都分别计算所需要的硬币数量。具体算法如下：</span></p><p data-lake-id=\"u96cfb005\" id=\"u96cfb005\"><br></p><ol list=\"ub5647f60\"><li fid=\"u458bb2fe\" data-lake-id=\"uaf8047e6\" id=\"uaf8047e6\"><span data-lake-id=\"u88ac7d94\" id=\"u88ac7d94\">如果全部用 1 美分的硬币，一共需要 36 个硬币</span></li><li fid=\"u458bb2fe\" data-lake-id=\"uc97e78e2\" id=\"uc97e78e2\"><span data-lake-id=\"uf0ec7d80\" id=\"uf0ec7d80\">如果用 5 美分的硬币，则需要 7 个 5 美分的硬币 + 1 个 1 美分的硬币 = 8 个硬币</span></li><li fid=\"u458bb2fe\" data-lake-id=\"uef8c6eec\" id=\"uef8c6eec\"><span data-lake-id=\"u67da728d\" id=\"u67da728d\">如果用 10 美分的硬币，则需要 3 个 10 美分的硬币 + 1 个 5 美分的硬币 + 1 个 1 美分的硬币 = 5 个硬币</span></li><li fid=\"u458bb2fe\" data-lake-id=\"u18657f7f\" id=\"u18657f7f\"><span data-lake-id=\"u0d254f22\" id=\"u0d254f22\">如果用 25 美分的硬币，则需要 1 个 25 美分的硬币 + 1 个 10 美分的硬币 + 1 个 1 美分的硬币 = 3 个硬币</span></li></ol><p data-lake-id=\"u565d922c\" id=\"u565d922c\"><br></p><p data-lake-id=\"u1b2868cc\" id=\"u1b2868cc\"><span data-lake-id=\"ua33fcb0f\" id=\"ua33fcb0f\">对应的示意图如下：<br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1646378945539-24e43e78-1a58-41a3-b484-7216935251d2.png%23clientId%3Duefc7daca-fb68-4%26from%3Dpaste%26id%3Du31f8f0da%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D347%26originWidth%3D289%26originalType%3Durl%26ratio%3D1%26size%3D19144%26status%3Ddone%26style%3Dnone%26taskId%3Dubbd06031-a468-4f1e-904b-c894b99d48e%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A289%2C%22originHeight%22%3A347%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22AFxVY%22%7D\"></card><span data-lake-id=\"u99e91f17\" id=\"u99e91f17\"><br /></span><span data-lake-id=\"uf85f04e8\" id=\"uf85f04e8\">方案 4 的硬币总数最少，因此为最优方案。<br /></span><span data-lake-id=\"ua1f7ea8e\" id=\"ua1f7ea8e\">具体的代码实现如下：</span></p><p data-lake-id=\"ubfb1d2fb\" id=\"ubfb1d2fb\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20minCoinChange(coins%2C%20amount)%20%7B%5Cn%20%20%20%20let%20result%20%3D%20null%5Cn%20%20%20%20if%20(!amount)%20return%20result%5Cn%5Cn%20%20%20%20const%20makeChange%20%3D%20(index%2C%20value%2C%20min)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20let%20coin%20%3D%20coins%5Bindex%5D%5Cn%20%20%20%20%20%20%20%20let%20newAmount%20%3D%20Math.floor(value%20%2F%20coin)%5Cn%20%20%20%20%20%20%20%20if%20(newAmount)%20min%5Bcoin%5D%20%3D%20newAmount%5Cn%20%20%20%20%20%20%20%20if%20(value%20%25%20coin%20!%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20makeChange(--index%2C%20value%20-%20coin%20*%20newAmount%2C%20min)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20const%20arr%20%3D%20%5B%5D%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20coins.length%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20const%20cache%20%3D%20%7B%7D%5Cn%20%20%20%20%20%20%20%20makeChange(i%2C%20amount%2C%20cache)%5Cn%20%20%20%20%20%20%20%20arr.push(cache)%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20console.log(arr)%5Cn%20%20%20%20let%20newMin%20%3D%200%5Cn%20%20%20%20arr.forEach(item%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20let%20min%20%3D%200%5Cn%20%20%20%20%20%20%20%20for%20(let%20v%20in%20item)%20min%20%2B%3D%20item%5Bv%5D%5Cn%20%20%20%20%20%20%20%20if%20(!newMin%20%7C%7C%20min%20%3C%20newMin)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20newMin%20%3D%20min%5Cn%20%20%20%20%20%20%20%20%20%20%20%20result%20%3D%20item%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D)%5Cn%20%20%20%20return%20result%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22b1a6e4bb%22%7D\"></card><p data-lake-id=\"u2d37d38f\" id=\"u2d37d38f\"><br></p><p data-lake-id=\"udcf71d50\" id=\"udcf71d50\"><span data-lake-id=\"u93797139\" id=\"u93797139\">函数 minCoinChange()接收一组硬币的面额，以及要找零的钱数。我们将上面例子中的值传入：</span></p><p data-lake-id=\"uc6bd35bf\" id=\"uc6bd35bf\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20result%20%3D%20minCoinChange2(%5B1%2C%205%2C%2010%2C%2025%5D%2C%2036)%5Cnconsole.log(result)%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22a3b5184d%22%7D\"></card><p data-lake-id=\"u2c045cb4\" id=\"u2c045cb4\"><br></p><p data-lake-id=\"u8f3d5222\" id=\"u8f3d5222\"><span data-lake-id=\"u8c3f5603\" id=\"u8c3f5603\">得到如下结果：</span></p><p data-lake-id=\"u4653b235\" id=\"u4653b235\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22shell%22%2C%22code%22%3A%22%5B%5Cn%20%20%7B%20'1'%3A%2036%20%7D%2C%5Cn%20%20%7B%20'1'%3A%201%2C%20'5'%3A%207%20%7D%2C%5Cn%20%20%7B%20'1'%3A%201%2C%20'5'%3A%201%2C%20'10'%3A%203%20%7D%2C%5Cn%20%20%7B%20'1'%3A%201%2C%20'10'%3A%201%2C%20'25'%3A%201%20%7D%5Cn%5D%5Cn%7B%20'1'%3A%201%2C%20'10'%3A%201%2C%20'25'%3A%201%20%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%228f093292%22%7D\"></card><p data-lake-id=\"u37dacdd8\" id=\"u37dacdd8\"><br></p><p data-lake-id=\"u95519301\" id=\"u95519301\"><span data-lake-id=\"ue5d3a4ce\" id=\"ue5d3a4ce\">上面的数组是我们在代码中打印出来的 arr 的值，用来展示四种不同面额的硬币作为找零硬币时，实际所需要的硬币种类和数量。最终，我们会计算 arr 数组中硬币总数最少的那个方案，作为 minCoinChange()函数的输出。<br /></span><span data-lake-id=\"u571c9097\" id=\"u571c9097\">当然在实际应用中，我们可以把硬币抽象成任何你需要的数字，这个算法能给出你满足结果的最小组合。</span></p><p data-lake-id=\"u76b2439c\" id=\"u76b2439c\"><br></p><h3 data-lake-id=\"d39a003f\" id=\"d39a003f\"><span data-lake-id=\"ucbcba46d\" id=\"ucbcba46d\">背包问题</span></h3><p data-lake-id=\"u10dbcc86\" id=\"u10dbcc86\"><br></p><p data-lake-id=\"ub97ecb5f\" id=\"ub97ecb5f\"><span data-lake-id=\"uc23c0f24\" id=\"uc23c0f24\">背包问题是一个组合优化问题，它被描述为：给定一个具有固定容量的背包 capacity，以及一组具有价值（value）和重量（weight）的物品，找出一个最优方案，使得装入背包的物品的总重量不超过 capacity，且总价值最大。<br /></span><span data-lake-id=\"ucd6dda10\" id=\"ucd6dda10\">假设我们有以下物品，且背包的总容量为 5：</span></p><card type=\"block\" name=\"table\" value=\"data:%7B%22id%22%3A%223e0d7702%22%2C%22rows%22%3A4%2C%22cols%22%3A3%2C%22html%22%3A%22%3Ctable%20data-lake-id%3D%5C%223e0d7702%5C%22%20id%3D%5C%223e0d7702%5C%22%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20750px%5C%22%3E%3Ccolgroup%3E%3Ccol%20width%3D%5C%22250%5C%22%3E%3Ccol%20width%3D%5C%22250%5C%22%3E%3Ccol%20width%3D%5C%22250%5C%22%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20data-lake-id%3D%5C%22u352d9790%5C%22%20id%3D%5C%22u352d9790%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ud02e5ee2%5C%22%20id%3D%5C%22ud02e5ee2%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u3f339e5a%5C%22%20id%3D%5C%22u3f339e5a%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22ue0f4a287%5C%22%20id%3D%5C%22ue0f4a287%5C%22%3E%E7%89%A9%E5%93%81%23%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u4559b160%5C%22%20id%3D%5C%22u4559b160%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ua4cf0879%5C%22%20id%3D%5C%22ua4cf0879%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22u5b3f9de8%5C%22%20id%3D%5C%22u5b3f9de8%5C%22%3E%E9%87%8D%E9%87%8F%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ud6d4cb66%5C%22%20id%3D%5C%22ud6d4cb66%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u320d9a54%5C%22%20id%3D%5C%22u320d9a54%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22ua75ae289%5C%22%20id%3D%5C%22ua75ae289%5C%22%3E%E4%BB%B7%E5%80%BC%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u2fa795f5%5C%22%20id%3D%5C%22u2fa795f5%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ub9546b6c%5C%22%20id%3D%5C%22ub9546b6c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ucd5cb5b5%5C%22%20id%3D%5C%22ucd5cb5b5%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ub2614539%5C%22%20id%3D%5C%22ub2614539%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u902a54f3%5C%22%20id%3D%5C%22u902a54f3%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u28f7fc76%5C%22%20id%3D%5C%22u28f7fc76%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u5a4667ac%5C%22%20id%3D%5C%22u5a4667ac%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uccb6e70a%5C%22%20id%3D%5C%22uccb6e70a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf9c5e95e%5C%22%20id%3D%5C%22uf9c5e95e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uecca18db%5C%22%20id%3D%5C%22uecca18db%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u428737e6%5C%22%20id%3D%5C%22u428737e6%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u566cec40%5C%22%20id%3D%5C%22u566cec40%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ua14269c1%5C%22%20id%3D%5C%22ua14269c1%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22udd39ce06%5C%22%20id%3D%5C%22udd39ce06%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u246ca721%5C%22%20id%3D%5C%22u246ca721%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u733f598e%5C%22%20id%3D%5C%22u733f598e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u878e9ad7%5C%22%20id%3D%5C%22u878e9ad7%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5edcc3c4%5C%22%20id%3D%5C%22u5edcc3c4%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ubf009b0a%5C%22%20id%3D%5C%22ubf009b0a%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22udfaf34d7%5C%22%20id%3D%5C%22udfaf34d7%5C%22%3E4%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22uf4fb1723%5C%22%20id%3D%5C%22uf4fb1723%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u8e46658a%5C%22%20id%3D%5C%22u8e46658a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u9c363daf%5C%22%20id%3D%5C%22u9c363daf%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u2b35e980%5C%22%20id%3D%5C%22u2b35e980%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ud832253b%5C%22%20id%3D%5C%22ud832253b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uc46f0241%5C%22%20id%3D%5C%22uc46f0241%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22udb88ed40%5C%22%20id%3D%5C%22udb88ed40%5C%22%3E4%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ubd5d84d7%5C%22%20id%3D%5C%22ubd5d84d7%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u61208896%5C%22%20id%3D%5C%22u61208896%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uf3ab193a%5C%22%20id%3D%5C%22uf3ab193a%5C%22%3E5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%2C%22margin%22%3Atrue%7D\"></card><p data-lake-id=\"u31e8758c\" id=\"u31e8758c\"><br></p><p data-lake-id=\"u313960bd\" id=\"u313960bd\"><span data-lake-id=\"u7af498b8\" id=\"u7af498b8\">我们用矩阵来解决这个问题。首先，我们把物品和背包的容量组成如下矩阵：</span></p><card type=\"block\" name=\"table\" value=\"data:%7B%22id%22%3A%22b93050f9%22%2C%22rows%22%3A3%2C%22cols%22%3A7%2C%22html%22%3A%22%3Ctable%20data-lake-id%3D%5C%22b93050f9%5C%22%20id%3D%5C%22b93050f9%5C%22%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20749px%5C%22%3E%3Ccolgroup%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3Ccol%20width%3D%5C%22107%5C%22%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20data-lake-id%3D%5C%22u8767841d%5C%22%20id%3D%5C%22u8767841d%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ub349057a%5C%22%20id%3D%5C%22ub349057a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u4f14b454%5C%22%20id%3D%5C%22u4f14b454%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22u2afa1b05%5C%22%20id%3D%5C%22u2afa1b05%5C%22%3E%E7%89%A9%E5%93%81(i)%2F%E9%87%8D%E9%87%8F(w)%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ue12c2ccd%5C%22%20id%3D%5C%22ue12c2ccd%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ubbba5c2f%5C%22%20id%3D%5C%22ubbba5c2f%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22u564121de%5C%22%20id%3D%5C%22u564121de%5C%22%3E0%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5a759c28%5C%22%20id%3D%5C%22u5a759c28%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uc6ba2a83%5C%22%20id%3D%5C%22uc6ba2a83%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22uc5e5ef7b%5C%22%20id%3D%5C%22uc5e5ef7b%5C%22%3E1%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9d92bb48%5C%22%20id%3D%5C%22u9d92bb48%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ue8a46261%5C%22%20id%3D%5C%22ue8a46261%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22uc589a071%5C%22%20id%3D%5C%22uc589a071%5C%22%3E2%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u4919f3b8%5C%22%20id%3D%5C%22u4919f3b8%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uff20d452%5C%22%20id%3D%5C%22uff20d452%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22uc1942bc4%5C%22%20id%3D%5C%22uc1942bc4%5C%22%3E3%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u2e2daa5c%5C%22%20id%3D%5C%22u2e2daa5c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u016aa117%5C%22%20id%3D%5C%22u016aa117%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22ua9d1568d%5C%22%20id%3D%5C%22ua9d1568d%5C%22%3E4%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u15ed46be%5C%22%20id%3D%5C%22u15ed46be%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u9d04f937%5C%22%20id%3D%5C%22u9d04f937%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22ub86f454d%5C%22%20id%3D%5C%22ub86f454d%5C%22%3E5%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22ua7adb967%5C%22%20id%3D%5C%22ua7adb967%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ue0aa1673%5C%22%20id%3D%5C%22ue0aa1673%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u55e14b04%5C%22%20id%3D%5C%22u55e14b04%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22uca09df96%5C%22%20id%3D%5C%22uca09df96%5C%22%3E0%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u0101766c%5C%22%20id%3D%5C%22u0101766c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u6b6e2127%5C%22%20id%3D%5C%22u6b6e2127%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uea3de3e0%5C%22%20id%3D%5C%22uea3de3e0%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u7f0ac5d1%5C%22%20id%3D%5C%22u7f0ac5d1%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u86e8ebf8%5C%22%20id%3D%5C%22u86e8ebf8%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ue4602d0c%5C%22%20id%3D%5C%22ue4602d0c%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u66169cf2%5C%22%20id%3D%5C%22u66169cf2%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uc0d73089%5C%22%20id%3D%5C%22uc0d73089%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u07a7afa0%5C%22%20id%3D%5C%22u07a7afa0%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5cf79e26%5C%22%20id%3D%5C%22u5cf79e26%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ucfe0883b%5C%22%20id%3D%5C%22ucfe0883b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u43c090a1%5C%22%20id%3D%5C%22u43c090a1%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5a133883%5C%22%20id%3D%5C%22u5a133883%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u1ebfd608%5C%22%20id%3D%5C%22u1ebfd608%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ud88b7e25%5C%22%20id%3D%5C%22ud88b7e25%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ud002151c%5C%22%20id%3D%5C%22ud002151c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uc78ce91c%5C%22%20id%3D%5C%22uc78ce91c%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u89c1b344%5C%22%20id%3D%5C%22u89c1b344%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u7ddb27f3%5C%22%20id%3D%5C%22u7ddb27f3%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ud2c5b0ed%5C%22%20id%3D%5C%22ud2c5b0ed%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ud8a158fe%5C%22%20id%3D%5C%22ud8a158fe%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22ue571722c%5C%22%20id%3D%5C%22ue571722c%5C%22%3E1%20(w%3D2%2C%20v%3D3)%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ub571917e%5C%22%20id%3D%5C%22ub571917e%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u9a37f0bd%5C%22%20id%3D%5C%22u9a37f0bd%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u5446080a%5C%22%20id%3D%5C%22u5446080a%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u130261b4%5C%22%20id%3D%5C%22u130261b4%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u326d26e1%5C%22%20id%3D%5C%22u326d26e1%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u6b17e5bd%5C%22%20id%3D%5C%22u6b17e5bd%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ub2f3eb53%5C%22%20id%3D%5C%22ub2f3eb53%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ude630344%5C%22%20id%3D%5C%22ude630344%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ub44394a7%5C%22%20id%3D%5C%22ub44394a7%5C%22%3Ea%3A%203%2B%5B0%5D%5B2-2%5D%3D3%2B0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc3722afc%5C%22%20id%3D%5C%22uc3722afc%5C%22%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u0a51a212%5C%22%20id%3D%5C%22u0a51a212%5C%22%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u088c465f%5C%22%20id%3D%5C%22u088c465f%5C%22%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%2C%22margin%22%3Atrue%7D\"></card><p data-lake-id=\"ufbf4f819\" id=\"ufbf4f819\"><br></p><p data-lake-id=\"ubdc512b2\" id=\"ubdc512b2\"><span data-lake-id=\"u10d40055\" id=\"u10d40055\">b: [0][2]=0<br /></span><span data-lake-id=\"ub8505861\" id=\"ub8505861\">max(3+0,0)=3 | a: 3+[0][3-2]=3+0<br /></span><span data-lake-id=\"ue360441e\" id=\"ue360441e\">b: [0][3]=0<br /></span><span data-lake-id=\"u3f0f2c45\" id=\"u3f0f2c45\">max(3+0,0)=3 | a: 3+[0][4-3]=3+0<br /></span><span data-lake-id=\"u02cb6193\" id=\"u02cb6193\">b: [0][4]=0<br /></span><span data-lake-id=\"uf206b103\" id=\"uf206b103\">max(3+0,0)=3 | a: 3+[0][5-3]=3+0<br /></span><span data-lake-id=\"u5cc9430b\" id=\"u5cc9430b\">b: [0][5]=0<br /></span><span data-lake-id=\"u3c1d1d5c\" id=\"u3c1d1d5c\">max(3+0,0)=3 |<br /></span><span data-lake-id=\"ud8798e5b\" id=\"ud8798e5b\">| </span><strong><span data-lake-id=\"u90fade8f\" id=\"u90fade8f\">2 (w=3, v=4)</span></strong><span data-lake-id=\"u61ca36d6\" id=\"u61ca36d6\"> | 0 | 0 | 3 | a: 4+[1][3-3]=4+0<br /></span><span data-lake-id=\"ua113248e\" id=\"ua113248e\">b: [1][3]=3<br /></span><span data-lake-id=\"u29209219\" id=\"u29209219\">max(4+0,3)=4 | a: 4+[1][4-3]=4+0<br /></span><span data-lake-id=\"u981a736d\" id=\"u981a736d\">b: [1][4]=3<br /></span><span data-lake-id=\"u9fb4d6d2\" id=\"u9fb4d6d2\">max(4+0,3)=4 | a: 4+[1][5-3]=4+3<br /></span><span data-lake-id=\"u8ac8a7e3\" id=\"u8ac8a7e3\">b: [1][5]=3<br /></span><span data-lake-id=\"ue6a68396\" id=\"ue6a68396\">max(4+3,3)=7 |<br /></span><span data-lake-id=\"u896182a5\" id=\"u896182a5\">| </span><strong><span data-lake-id=\"ud3d197bc\" id=\"ud3d197bc\">3 (w=4, v=5)</span></strong><span data-lake-id=\"uc69bdeea\" id=\"uc69bdeea\"> | 0 | 0 | 3 | 4 | a: 5+[2][4-4]=5+0<br /></span><span data-lake-id=\"u9d945d1c\" id=\"u9d945d1c\">b: [2][4]=4<br /></span><span data-lake-id=\"uf41959d6\" id=\"uf41959d6\">max(5+0,4)=5 | a: 5+[2][5-4]=5+0<br /></span><span data-lake-id=\"uc813a744\" id=\"uc813a744\">b: [2][5]=7<br /></span><span data-lake-id=\"u6f8add21\" id=\"u6f8add21\">max(5+0,7)=7 |</span></p><p data-lake-id=\"u6f1d82f4\" id=\"u6f1d82f4\"><br></p><p data-lake-id=\"uee32eaef\" id=\"uee32eaef\"><span data-lake-id=\"uced900f0\" id=\"uced900f0\">为了便于理解，我们将矩阵 kS 的第一列和第一行忽略（因为它们表示的是容量 0 和第 0 个物品）。然后，按照要求往矩阵的格子里填数。如果当前的格子能放下对应的物品，存在以下两种情况：</span></p><p data-lake-id=\"ub618a423\" id=\"ub618a423\"><br></p><ul list=\"uc0a8910c\"><li fid=\"ub5fe663e\" data-lake-id=\"u38bd65b3\" id=\"u38bd65b3\"><strong><span data-lake-id=\"u84256b4c\" id=\"u84256b4c\">a - 放入当前物品，然后剩余的重量再放入前一个物品</span></strong></li><li fid=\"ub5fe663e\" data-lake-id=\"u2b3c342b\" id=\"u2b3c342b\"><strong><span data-lake-id=\"ud8f6ceb2\" id=\"ud8f6ceb2\">b - 不放入当前物品，放入前一个物品</span></strong></li></ul><p data-lake-id=\"ub0fd35b2\" id=\"ub0fd35b2\"><br></p><p data-lake-id=\"u4174a8ab\" id=\"u4174a8ab\"><span data-lake-id=\"u65326ecf\" id=\"u65326ecf\">在上面的表格中，</span></p><p data-lake-id=\"u8ceab499\" id=\"u8ceab499\"><br></p><ol list=\"u9701c9dc\"><li fid=\"u42d64b7f\" data-lake-id=\"ub58fea70\" id=\"ub58fea70\"><span data-lake-id=\"ua0084529\" id=\"ua0084529\">当背包的重量为 1 时，没有物品能放入，所以都是 0，这个很好理解。</span></li><li fid=\"u42d64b7f\" data-lake-id=\"ue00a2f04\" id=\"ue00a2f04\"><span data-lake-id=\"uf5e32911\" id=\"uf5e32911\">当背包的重量为 2 时，物品 1 可以放入，那么存在两种情况：放入物品 1（价值为 3），剩余的重量（背包的重量 2 减去物品 1 的重量 2，结果为 0）再放入前一个物品；不放入物品 1，放入前一个物品[0][2]，价值为 0。所以最大价值就是 max(3, 0)=3。</span></li><li fid=\"u42d64b7f\" data-lake-id=\"ue4331305\" id=\"ue4331305\"><span data-lake-id=\"u2e3415e8\" id=\"u2e3415e8\">......</span></li><li fid=\"u42d64b7f\" data-lake-id=\"ufa93da65\" id=\"ufa93da65\"><span data-lake-id=\"u3db2ad93\" id=\"u3db2ad93\">当背包的重量为 5 时，放入物品 2，两种情况：放入物品 2（价值为 4），剩余的重量（背包的重量 5 减去物品 2 的重量 3，结果为 2）再放入前一个物品，是[1][2]，对应的价值是 3；不放入物品 2，，放入前一个物品[1][5]，价值为 3。所以最大价值就是 max(4+3, 3)=7。</span></li><li fid=\"u42d64b7f\" data-lake-id=\"uc2cb30e5\" id=\"uc2cb30e5\"><span data-lake-id=\"uba5593d5\" id=\"uba5593d5\">......</span></li></ol><p data-lake-id=\"ub0d2697d\" id=\"ub0d2697d\"><br></p><p data-lake-id=\"ued227bc0\" id=\"ued227bc0\"><span data-lake-id=\"u791342a2\" id=\"u791342a2\">如果当前物品不能放入背包，则忽略它，用前一个值代替。我们可以按照上面描述的过程把剩余的格子都填满，这样表格中最后一个单元格里的值就是最优方案。<br /></span><span data-lake-id=\"u8fd8a9d8\" id=\"u8fd8a9d8\">下面是具体的实现代码：</span></p><p data-lake-id=\"u4591039c\" id=\"u4591039c\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20knapSack(capacity%2C%20weights%2C%20values%2C%20n)%20%7B%5Cn%20%20%20%20const%20kS%20%3D%20%5B%5D%5Cn%5Cn%20%20%20%20%2F%2F%20%E5%B0%86ks%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84%E7%9F%A9%E9%98%B5%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%3D%20n%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20kS%5Bi%5D%20%3D%20%5B%5D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%3D%20n%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20for%20(let%20w%20%3D%200%3B%20w%20%3C%3D%20capacity%3B%20w%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%BF%BD%E7%95%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E7%AC%AC1%E5%88%97%E5%92%8C%E7%AC%AC1%E8%A1%8C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(i%20%3D%3D%3D%200%20%7C%7C%20w%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kS%5Bi%5D%5Bw%5D%20%3D%200%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20if%20(weights%5Bi%20-%201%5D%20%3C%3D%20w)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20a%20%3D%20values%5Bi%20-%201%5D%20%2B%20kS%5Bi%20-%201%5D%5Bw%20-%20weights%5Bi%20-%201%5D%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20b%20%3D%20kS%5Bi%20-%201%5D%5Bw%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kS%5Bi%5D%5Bw%5D%20%3D%20Math.max(a%2C%20b)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kS%5Bi%5D%5Bw%5D%20%3D%20kS%5Bi%20-%201%5D%5Bw%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20console.log(kS)%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%5Cn%2F%2F%20%E7%AC%AC%20i%20%E4%B8%AA%E7%89%A9%E5%93%81%E7%9A%84%E4%BB%B7%E5%80%BC%E6%98%AF%EF%BC%9Aval%5Bi%20-%201%5D%5Cn%2F%2F%20%E7%AC%AC%20i%20%E4%B8%AA%E7%89%A9%E5%93%81%E7%9A%84%E9%87%8D%E9%87%8F%E6%98%AF%EF%BC%9Awt%5Bi%20-%201%5D%5Cn%2F%2F%20dp%5Bi%5D%5Bw%5D%20%3D%20dp%5Bi-1%5D%5Bw-wt%5Bi-1%5D%5D%20%2B%20val%5Bi-1%5D%5Cnfunction%20knapSack(W%2C%20N%2C%20wt%20%3D%20%5B%5D%2C%20val%20%3D%20%5B%5D)%20%7B%5Cn%20%20const%20dp%20%3D%20new%20Array(N%2B1).fill(new%20Array(W%20%2B%201).fill(0))%5Cn%20%20for%20(let%20i%20%3D%201%3B%20i%20%3C%3D%20N%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20for%20(let%20w%20%3D%201%3B%20w%20%3C%3D%20W%3B%20w%2B%2B)%20%7B%5Cn%20%20%20%20%20%20if%20(w%20-%20wt%5Bi%20-%201%5D%20%3C%200)%20%7B%5Cn%20%20%20%20%20%20%20%20dp%5Bi%5D%5Bw%5D%20%3D%20dp%5Bi%20-%201%5D%5Bw%5D%5Cn%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20dp%5Bi%5D%5Bw%5D%20%3D%20Math.max(dp%5Bi%20-%201%5D%5Bw%5D%2C%20dp%5Bi%20-%201%5D%5Bw%20-%20wt%5Bi%20-%201%5D%5D%20-%20val%5Bi%20-%201%5D)%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22e7294fc1%22%7D\"></card><p data-lake-id=\"u62dec9f6\" id=\"u62dec9f6\"><br></p><p data-lake-id=\"u7dc4b70b\" id=\"u7dc4b70b\"><span data-lake-id=\"u38f55344\" id=\"u38f55344\">对于 const a，其价值分为两部分，第一部分就是它自己的价值（values[i - 1]），第二部分是用背包剩余的重量（w - weights[i - 1]）装进前一个物品（kS[i - 1]）。对于 const b，就是找前一个能放入这个重量的物品（kS[i - 1][w]）。然后取这两种情况下的最大值。<br /></span><span data-lake-id=\"u8ef080e9\" id=\"u8ef080e9\">测试一下 knapSack()函数，</span></p><p data-lake-id=\"u6081c8d4\" id=\"u6081c8d4\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20capacity%20%3D%205%5Cnconst%20weights%20%3D%20%5B2%2C%203%2C%204%5D%5Cnconst%20values%20%3D%20%5B3%2C%204%2C%205%5D%5CnknapSack(capacity%2C%20weights%2C%20values%2C%20weights.length)%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22ae850ae4%22%7D\"></card><p data-lake-id=\"ua87e328e\" id=\"ua87e328e\"><br></p><p data-lake-id=\"u1169ed74\" id=\"u1169ed74\"><span data-lake-id=\"u1df10ea4\" id=\"u1df10ea4\">下面是矩阵 kS 的输出结果：</span></p><p data-lake-id=\"uf7da4b0e\" id=\"uf7da4b0e\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22shell%22%2C%22code%22%3A%22%5B%5Cn%20%20%5B%200%2C%200%2C%200%2C%200%2C%200%2C%200%20%5D%2C%5Cn%20%20%5B%200%2C%200%2C%203%2C%203%2C%203%2C%203%20%5D%2C%5Cn%20%20%5B%200%2C%200%2C%203%2C%204%2C%204%2C%207%20%5D%2C%5Cn%20%20%5B%200%2C%200%2C%203%2C%204%2C%205%2C%207%20%5D%5Cn%5D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%2277f76053%22%7D\"></card><p data-lake-id=\"ue97b4596\" id=\"ue97b4596\"><br></p><h3 data-lake-id=\"09793c39\" id=\"09793c39\"><span data-lake-id=\"ub54ecd13\" id=\"ub54ecd13\">最长公共子序列（LCS）</span></h3><p data-lake-id=\"u43260af1\" id=\"u43260af1\"><br></p><p data-lake-id=\"u28ce1f9b\" id=\"u28ce1f9b\"><span data-lake-id=\"udc46bf74\" id=\"udc46bf74\">找出两个字符串序列的最长子序列的长度。所谓最长子序列，是指两个字符串序列中以相同顺序出现，但不要求连续的字符串序列。例如下面两个字符串：<br /></span><span data-lake-id=\"u61a4d048\" id=\"u61a4d048\">字符串 1：acbaed<br /></span><span data-lake-id=\"uc6829993\" id=\"uc6829993\">字符串 2：abcadf<br /></span><span data-lake-id=\"ue7203e84\" id=\"ue7203e84\">则 LCS 为 acad。<br /></span><span data-lake-id=\"uc601c8be\" id=\"uc601c8be\">和背包问题的思路类似，我们用下面的表格来描述整个过程：</span></p><card type=\"block\" name=\"table\" value=\"data:%7B%22id%22%3A%224df3838b%22%2C%22rows%22%3A8%2C%22cols%22%3A8%2C%22html%22%3A%22%3Ctable%20data-lake-id%3D%5C%224df3838b%5C%22%20id%3D%5C%224df3838b%5C%22%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20744px%5C%22%3E%3Ccolgroup%3E%3Ccol%20width%3D%5C%2293%5C%22%3E%3Ccol%20width%3D%5C%2293%5C%22%3E%3Ccol%20width%3D%5C%2293%5C%22%3E%3Ccol%20width%3D%5C%2293%5C%22%3E%3Ccol%20width%3D%5C%2293%5C%22%3E%3Ccol%20width%3D%5C%2293%5C%22%3E%3Ccol%20width%3D%5C%2293%5C%22%3E%3Ccol%20width%3D%5C%2293%5C%22%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20data-lake-id%3D%5C%22u4389f403%5C%22%20id%3D%5C%22u4389f403%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ue0dae156%5C%22%20id%3D%5C%22ue0dae156%5C%22%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9c02f09f%5C%22%20id%3D%5C%22u9c02f09f%5C%22%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ubd2ee7d4%5C%22%20id%3D%5C%22ubd2ee7d4%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u2907552b%5C%22%20id%3D%5C%22u2907552b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u1bb6f270%5C%22%20id%3D%5C%22u1bb6f270%5C%22%3Ea%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u8a6ec7d5%5C%22%20id%3D%5C%22u8a6ec7d5%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf87ba3b3%5C%22%20id%3D%5C%22uf87ba3b3%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u61f83765%5C%22%20id%3D%5C%22u61f83765%5C%22%3Eb%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u268fa051%5C%22%20id%3D%5C%22u268fa051%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ud3e71f50%5C%22%20id%3D%5C%22ud3e71f50%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uf0d9337c%5C%22%20id%3D%5C%22uf0d9337c%5C%22%3Ec%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc624b5b4%5C%22%20id%3D%5C%22uc624b5b4%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ueb2ec416%5C%22%20id%3D%5C%22ueb2ec416%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uecb75c50%5C%22%20id%3D%5C%22uecb75c50%5C%22%3Ea%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9c40a9a7%5C%22%20id%3D%5C%22u9c40a9a7%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u09759090%5C%22%20id%3D%5C%22u09759090%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ucef3e420%5C%22%20id%3D%5C%22ucef3e420%5C%22%3Ed%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uece62f01%5C%22%20id%3D%5C%22uece62f01%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u87a055c2%5C%22%20id%3D%5C%22u87a055c2%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u02f077e7%5C%22%20id%3D%5C%22u02f077e7%5C%22%3Ef%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22uf4062e83%5C%22%20id%3D%5C%22uf4062e83%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ue032119e%5C%22%20id%3D%5C%22ue032119e%5C%22%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u7073f441%5C%22%20id%3D%5C%22u7073f441%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ucda160c2%5C%22%20id%3D%5C%22ucda160c2%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u985cfdf7%5C%22%20id%3D%5C%22u985cfdf7%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u9a0a543f%5C%22%20id%3D%5C%22u9a0a543f%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u5bb6e137%5C%22%20id%3D%5C%22u5bb6e137%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u78618596%5C%22%20id%3D%5C%22u78618596%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ue8452c42%5C%22%20id%3D%5C%22ue8452c42%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u1a44434d%5C%22%20id%3D%5C%22u1a44434d%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u0a60b690%5C%22%20id%3D%5C%22u0a60b690%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u682f4655%5C%22%20id%3D%5C%22u682f4655%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u42e6502a%5C%22%20id%3D%5C%22u42e6502a%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u2b595da4%5C%22%20id%3D%5C%22u2b595da4%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u63af2194%5C%22%20id%3D%5C%22u63af2194%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u2c2e70a2%5C%22%20id%3D%5C%22u2c2e70a2%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uf9c8615f%5C%22%20id%3D%5C%22uf9c8615f%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u4461fb86%5C%22%20id%3D%5C%22u4461fb86%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf24c1378%5C%22%20id%3D%5C%22uf24c1378%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u07fb757c%5C%22%20id%3D%5C%22u07fb757c%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ud56fb2a8%5C%22%20id%3D%5C%22ud56fb2a8%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uba66ae1c%5C%22%20id%3D%5C%22uba66ae1c%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uc2fec7b9%5C%22%20id%3D%5C%22uc2fec7b9%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22uec410551%5C%22%20id%3D%5C%22uec410551%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u49db9b85%5C%22%20id%3D%5C%22u49db9b85%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ub855c0bc%5C%22%20id%3D%5C%22ub855c0bc%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ud0ec3251%5C%22%20id%3D%5C%22ud0ec3251%5C%22%3Ea%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u4f33ca05%5C%22%20id%3D%5C%22u4f33ca05%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u83322bb0%5C%22%20id%3D%5C%22u83322bb0%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u3f225dec%5C%22%20id%3D%5C%22u3f225dec%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u216ff125%5C%22%20id%3D%5C%22u216ff125%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u639cd611%5C%22%20id%3D%5C%22u639cd611%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ub8b28660%5C%22%20id%3D%5C%22ub8b28660%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u29f94c12%5C%22%20id%3D%5C%22u29f94c12%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uc40474c2%5C%22%20id%3D%5C%22uc40474c2%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u9ca520aa%5C%22%20id%3D%5C%22u9ca520aa%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ua977c5f3%5C%22%20id%3D%5C%22ua977c5f3%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ub08bb255%5C%22%20id%3D%5C%22ub08bb255%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u874886d4%5C%22%20id%3D%5C%22u874886d4%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ua74f350f%5C%22%20id%3D%5C%22ua74f350f%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf76cacea%5C%22%20id%3D%5C%22uf76cacea%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u02974c50%5C%22%20id%3D%5C%22u02974c50%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u4b94f062%5C%22%20id%3D%5C%22u4b94f062%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u64c73878%5C%22%20id%3D%5C%22u64c73878%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u99c51078%5C%22%20id%3D%5C%22u99c51078%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u14f80feb%5C%22%20id%3D%5C%22u14f80feb%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u1f377781%5C%22%20id%3D%5C%22u1f377781%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ud8706886%5C%22%20id%3D%5C%22ud8706886%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22ue1fbab32%5C%22%20id%3D%5C%22ue1fbab32%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u4fdf6f34%5C%22%20id%3D%5C%22u4fdf6f34%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u2c91591f%5C%22%20id%3D%5C%22u2c91591f%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ueaa18789%5C%22%20id%3D%5C%22ueaa18789%5C%22%3Ec%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc2924235%5C%22%20id%3D%5C%22uc2924235%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u54e5e789%5C%22%20id%3D%5C%22u54e5e789%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uebca9b80%5C%22%20id%3D%5C%22uebca9b80%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u7b5da736%5C%22%20id%3D%5C%22u7b5da736%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u567fe964%5C%22%20id%3D%5C%22u567fe964%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uf9ca3941%5C%22%20id%3D%5C%22uf9ca3941%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ubac23ef5%5C%22%20id%3D%5C%22ubac23ef5%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ue6d8609e%5C%22%20id%3D%5C%22ue6d8609e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u83be67ef%5C%22%20id%3D%5C%22u83be67ef%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ueb2eef98%5C%22%20id%3D%5C%22ueb2eef98%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u83ccabba%5C%22%20id%3D%5C%22u83ccabba%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uc7964bcf%5C%22%20id%3D%5C%22uc7964bcf%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u03a669fe%5C%22%20id%3D%5C%22u03a669fe%5C%22%3E%3Cp%20data-lake-id%3D%5C%22udce5e4c3%5C%22%20id%3D%5C%22udce5e4c3%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uec1c04fb%5C%22%20id%3D%5C%22uec1c04fb%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ua484c76a%5C%22%20id%3D%5C%22ua484c76a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u71e9d231%5C%22%20id%3D%5C%22u71e9d231%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u959a37fa%5C%22%20id%3D%5C%22u959a37fa%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u70441414%5C%22%20id%3D%5C%22u70441414%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u74111907%5C%22%20id%3D%5C%22u74111907%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u95ceacf2%5C%22%20id%3D%5C%22u95ceacf2%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u62ff9351%5C%22%20id%3D%5C%22u62ff9351%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22ua293ed22%5C%22%20id%3D%5C%22ua293ed22%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u598eee55%5C%22%20id%3D%5C%22u598eee55%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ud0578850%5C%22%20id%3D%5C%22ud0578850%5C%22%3Eb%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u1b170ffb%5C%22%20id%3D%5C%22u1b170ffb%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u8a8b9408%5C%22%20id%3D%5C%22u8a8b9408%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ufe930c85%5C%22%20id%3D%5C%22ufe930c85%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u76a3e0d2%5C%22%20id%3D%5C%22u76a3e0d2%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u882bf6f2%5C%22%20id%3D%5C%22u882bf6f2%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u3fe10803%5C%22%20id%3D%5C%22u3fe10803%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u312f8fc6%5C%22%20id%3D%5C%22u312f8fc6%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf8c8c2fd%5C%22%20id%3D%5C%22uf8c8c2fd%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ub661a18f%5C%22%20id%3D%5C%22ub661a18f%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ud0a87c5b%5C%22%20id%3D%5C%22ud0a87c5b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u2f5b0260%5C%22%20id%3D%5C%22u2f5b0260%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u6ec2bca6%5C%22%20id%3D%5C%22u6ec2bca6%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u0890d3c2%5C%22%20id%3D%5C%22u0890d3c2%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u39411d70%5C%22%20id%3D%5C%22u39411d70%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u51c6528d%5C%22%20id%3D%5C%22u51c6528d%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u60289d4d%5C%22%20id%3D%5C%22u60289d4d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u5d1e0e4c%5C%22%20id%3D%5C%22u5d1e0e4c%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ubf57c78c%5C%22%20id%3D%5C%22ubf57c78c%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u0e45e267%5C%22%20id%3D%5C%22u0e45e267%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf1599a72%5C%22%20id%3D%5C%22uf1599a72%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u966c075e%5C%22%20id%3D%5C%22u966c075e%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u540d4abc%5C%22%20id%3D%5C%22u540d4abc%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u8d4a8e59%5C%22%20id%3D%5C%22u8d4a8e59%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u5c3bceb1%5C%22%20id%3D%5C%22u5c3bceb1%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u7c6ee9ba%5C%22%20id%3D%5C%22u7c6ee9ba%5C%22%3Ea%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u7af400e5%5C%22%20id%3D%5C%22u7af400e5%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf012866f%5C%22%20id%3D%5C%22uf012866f%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u67485363%5C%22%20id%3D%5C%22u67485363%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5ba75fdc%5C%22%20id%3D%5C%22u5ba75fdc%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u53e73982%5C%22%20id%3D%5C%22u53e73982%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uaa2eb193%5C%22%20id%3D%5C%22uaa2eb193%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u3ead7de8%5C%22%20id%3D%5C%22u3ead7de8%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ucb0a18f8%5C%22%20id%3D%5C%22ucb0a18f8%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u5dbce5a8%5C%22%20id%3D%5C%22u5dbce5a8%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u531b5278%5C%22%20id%3D%5C%22u531b5278%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u80e4b95c%5C%22%20id%3D%5C%22u80e4b95c%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u53975527%5C%22%20id%3D%5C%22u53975527%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ueaf08eaf%5C%22%20id%3D%5C%22ueaf08eaf%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u5e40443b%5C%22%20id%3D%5C%22u5e40443b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u574e7964%5C%22%20id%3D%5C%22u574e7964%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u445ea36e%5C%22%20id%3D%5C%22u445ea36e%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ue3b793ef%5C%22%20id%3D%5C%22ue3b793ef%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ub8a62fea%5C%22%20id%3D%5C%22ub8a62fea%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u897aef4f%5C%22%20id%3D%5C%22u897aef4f%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u830bad70%5C%22%20id%3D%5C%22u830bad70%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u4a4a7642%5C%22%20id%3D%5C%22u4a4a7642%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22uecfa2310%5C%22%20id%3D%5C%22uecfa2310%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u4a1c796a%5C%22%20id%3D%5C%22u4a1c796a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u8bef4fb6%5C%22%20id%3D%5C%22u8bef4fb6%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u4dd0a45e%5C%22%20id%3D%5C%22u4dd0a45e%5C%22%3Ee%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u83d2376b%5C%22%20id%3D%5C%22u83d2376b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ue369af42%5C%22%20id%3D%5C%22ue369af42%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ue8f180fe%5C%22%20id%3D%5C%22ue8f180fe%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u29ba7df4%5C%22%20id%3D%5C%22u29ba7df4%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u22810595%5C%22%20id%3D%5C%22u22810595%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u283c6204%5C%22%20id%3D%5C%22u283c6204%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u69f2d8fa%5C%22%20id%3D%5C%22u69f2d8fa%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u2eaa8cf2%5C%22%20id%3D%5C%22u2eaa8cf2%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u86fc6383%5C%22%20id%3D%5C%22u86fc6383%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uef531d3d%5C%22%20id%3D%5C%22uef531d3d%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u724ed739%5C%22%20id%3D%5C%22u724ed739%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uef7e8366%5C%22%20id%3D%5C%22uef7e8366%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u68037119%5C%22%20id%3D%5C%22u68037119%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ua8530c4e%5C%22%20id%3D%5C%22ua8530c4e%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u94fbaa69%5C%22%20id%3D%5C%22u94fbaa69%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5d3e3474%5C%22%20id%3D%5C%22u5d3e3474%5C%22%3E%3Cp%20data-lake-id%3D%5C%22ua0f39063%5C%22%20id%3D%5C%22ua0f39063%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u741e7c76%5C%22%20id%3D%5C%22u741e7c76%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u6988fa8c%5C%22%20id%3D%5C%22u6988fa8c%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u0c26c924%5C%22%20id%3D%5C%22u0c26c924%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uaf6839ea%5C%22%20id%3D%5C%22uaf6839ea%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u0b2afe90%5C%22%20id%3D%5C%22u0b2afe90%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u6da5479b%5C%22%20id%3D%5C%22u6da5479b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uba938abd%5C%22%20id%3D%5C%22uba938abd%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uc3f88177%5C%22%20id%3D%5C%22uc3f88177%5C%22%3Ed%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ua47f04f3%5C%22%20id%3D%5C%22ua47f04f3%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u8c76ff88%5C%22%20id%3D%5C%22u8c76ff88%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u96f32cb3%5C%22%20id%3D%5C%22u96f32cb3%5C%22%3E0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ufff05f46%5C%22%20id%3D%5C%22ufff05f46%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u384e0f43%5C%22%20id%3D%5C%22u384e0f43%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u33e3b602%5C%22%20id%3D%5C%22u33e3b602%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ubec5e2e0%5C%22%20id%3D%5C%22ubec5e2e0%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uf73ff57d%5C%22%20id%3D%5C%22uf73ff57d%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u9a40b1fb%5C%22%20id%3D%5C%22u9a40b1fb%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u13c492ac%5C%22%20id%3D%5C%22u13c492ac%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u9bb9705b%5C%22%20id%3D%5C%22u9bb9705b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u5896f496%5C%22%20id%3D%5C%22u5896f496%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u91c1d343%5C%22%20id%3D%5C%22u91c1d343%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u56f3cdde%5C%22%20id%3D%5C%22u56f3cdde%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22udb14e97b%5C%22%20id%3D%5C%22udb14e97b%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc8e972a8%5C%22%20id%3D%5C%22uc8e972a8%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u9d0beed3%5C%22%20id%3D%5C%22u9d0beed3%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u4da76076%5C%22%20id%3D%5C%22u4da76076%5C%22%3E4%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u5aa3337b%5C%22%20id%3D%5C%22u5aa3337b%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u9f91e424%5C%22%20id%3D%5C%22u9f91e424%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u4e26b13d%5C%22%20id%3D%5C%22u4e26b13d%5C%22%3E4%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%2C%22margin%22%3Atrue%7D\"></card><p data-lake-id=\"u3960baa8\" id=\"u3960baa8\"><br></p><p data-lake-id=\"u5cb36022\" id=\"u5cb36022\"><span data-lake-id=\"ua56b9c74\" id=\"ua56b9c74\">矩阵的第一行和第一列都被设置为 0，剩余的部分，遵循下面两种情况：</span></p><p data-lake-id=\"uc9f1b1de\" id=\"uc9f1b1de\"><br></p><ul list=\"u14e80e5c\"><li fid=\"u4832a8ba\" data-lake-id=\"uee100eea\" id=\"uee100eea\"><span data-lake-id=\"u3727ea10\" id=\"u3727ea10\">如果 wordX[i - 1]和 wordY[j - 1]相等，则矩阵对应的单元格的值为单元格[i - 1][j - 1]的值加 1。</span></li><li fid=\"u4832a8ba\" data-lake-id=\"ud71b0a4e\" id=\"ud71b0a4e\"><span data-lake-id=\"ue25a8c07\" id=\"ue25a8c07\">如果 wordX[i - 1]和 wordY[j - 1]不相等，则找出单元格[i - 1][j]和单元格[i][j - 1]之间的最大值。</span></li></ul><p data-lake-id=\"u0ba27152\" id=\"u0ba27152\"><br></p><p data-lake-id=\"uce11b79c\" id=\"uce11b79c\"><span data-lake-id=\"ucd01f14f\" id=\"ucd01f14f\">下面是具体的实现代码：</span></p><p data-lake-id=\"u70475781\" id=\"u70475781\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20lcs(wordX%2C%20wordY)%20%7B%5Cn%20%20%20%20const%20m%20%3D%20wordX.length%5Cn%20%20%20%20const%20n%20%3D%20wordY.length%5Cn%20%20%20%20const%20l%20%3D%20%5B%5D%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%3D%20m%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20l%5Bi%5D%20%3D%20%5B%5D%5Cn%20%20%20%20%20%20%20%20for%20(let%20j%20%3D%200%3B%20j%20%3C%3D%20n%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20l%5Bi%5D%5Bj%5D%20%3D%200%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%3D%20m%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20for%20(let%20j%20%3D%200%3B%20j%20%3C%3D%20n%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(i%20%3D%3D%3D%200%20%7C%7C%20j%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20l%5Bi%5D%5Bj%5D%20%3D%200%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20if%20(wordX%5Bi%20-%201%5D%20%3D%3D%3D%20wordY%5Bj%20-%201%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20l%5Bi%5D%5Bj%5D%20%3D%20l%5Bi%20-%201%5D%5Bj%20-%201%5D%20%2B%201%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20a%20%3D%20l%5Bi%20-%201%5D%5Bj%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20b%20%3D%20l%5Bi%5D%5Bj%20-%201%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20l%5Bi%5D%5Bj%5D%20%3D%20Math.max(a%2C%20b)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20console.log(l)%5Cn%20%20%20%20console.log(l%5Bm%5D%5Bn%5D)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%225b993f27%22%7D\"></card><p data-lake-id=\"u656b0e4a\" id=\"u656b0e4a\"><br></p><p data-lake-id=\"u94abc9de\" id=\"u94abc9de\"><span data-lake-id=\"ubc861071\" id=\"ubc861071\">我们将矩阵打印出来，结果如下：</span></p><p data-lake-id=\"u41511b95\" id=\"u41511b95\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20wordX%20%3D%20%5B%5C%22a%5C%22%2C%20%5C%22c%5C%22%2C%20%5C%22b%5C%22%2C%20%5C%22a%5C%22%2C%20%5C%22e%5C%22%2C%20%5C%22d%5C%22%5D%5Cnconst%20wordY%20%3D%20%5B%5C%22a%5C%22%2C%20%5C%22b%5C%22%2C%20%5C%22c%5C%22%2C%20%5C%22a%5C%22%2C%20%5C%22d%5C%22%2C%20%5C%22f%5C%22%5D%5Cnlcs(wordX%2C%20wordY)%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22default%22%2C%22id%22%3A%227e680c14%22%7D\"></card><p data-lake-id=\"ue65bc3de\" id=\"ue65bc3de\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22shell%22%2C%22code%22%3A%22%5B%5Cn%20%20%5B%200%2C%200%2C%200%2C%200%2C%200%2C%200%2C%200%20%5D%2C%5Cn%20%20%5B%200%2C%201%2C%201%2C%201%2C%201%2C%201%2C%201%20%5D%2C%5Cn%20%20%5B%200%2C%201%2C%201%2C%202%2C%202%2C%202%2C%202%20%5D%2C%5Cn%20%20%5B%200%2C%201%2C%202%2C%202%2C%202%2C%202%2C%202%20%5D%2C%5Cn%20%20%5B%200%2C%201%2C%202%2C%202%2C%203%2C%203%2C%203%20%5D%2C%5Cn%20%20%5B%200%2C%201%2C%202%2C%202%2C%203%2C%203%2C%203%20%5D%2C%5Cn%20%20%5B%200%2C%201%2C%202%2C%202%2C%203%2C%204%2C%204%20%5D%5Cn%5D%5Cn4%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22140ceb81%22%7D\"></card><p data-lake-id=\"u81baa4dd\" id=\"u81baa4dd\"><br></p><p data-lake-id=\"u0dcf830b\" id=\"u0dcf830b\"><span data-lake-id=\"u09d5d48e\" id=\"u09d5d48e\">矩阵中最后一个单元格的值为 LCS 的长度。那如何计算出 LCS 的具体内容呢？我们可以设计一个相同的 solution 矩阵，用来做标记，如果 wordX[i - 1]和 wordY[j - 1]相等，则将 solution 矩阵中对应的值设置为'diagonal'，即上面表格中背景为灰色的单元格。否则，根据[i][j]和[i - 1][j]是否相等标记为'top'或'left'。然后通过 printSolution()方法来找出 LCS 的内容。修改之后的代码如下：</span></p><p data-lake-id=\"uaa06cf23\" id=\"uaa06cf23\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20printSolution(solution%2C%20wordX%2C%20m%2C%20n)%20%7B%5Cn%20%20%20%20let%20a%20%3D%20m%5Cn%20%20%20%20let%20b%20%3D%20n%5Cn%20%20%20%20let%20x%20%3D%20solution%5Ba%5D%5Bb%5D%5Cn%20%20%20%20let%20answer%20%3D%20%5C%22%5C%22%5Cn%20%20%20%20while%20(x%20!%3D%3D%20%5C%220%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(solution%5Ba%5D%5Bb%5D%20%3D%3D%3D%20%5C%22diagonal%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20answer%20%3D%20wordX%5Ba%20-%201%5D%20%2B%20answer%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a--%5Cn%20%20%20%20%20%20%20%20%20%20%20%20b--%5Cn%20%20%20%20%20%20%20%20%7D%20else%20if%20(solution%5Ba%5D%5Bb%5D%20%3D%3D%3D%20%5C%22left%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20b--%5Cn%20%20%20%20%20%20%20%20%7D%20else%20if%20(solution%5Ba%5D%5Bb%5D%20%3D%3D%3D%20%5C%22top%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a--%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20x%20%3D%20solution%5Ba%5D%5Bb%5D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20answer%5Cn%7D%5Cn%5Cnfunction%20lcs(wordX%2C%20wordY)%20%7B%5Cn%20%20%20%20const%20m%20%3D%20wordX.length%5Cn%20%20%20%20const%20n%20%3D%20wordY.length%5Cn%20%20%20%20const%20l%20%3D%20%5B%5D%5Cn%20%20%20%20const%20solution%20%3D%20%5B%5D%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%3D%20m%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20l%5Bi%5D%20%3D%20%5B%5D%5Cn%20%20%20%20%20%20%20%20solution%5Bi%5D%20%3D%20%5B%5D%5Cn%20%20%20%20%20%20%20%20for%20(let%20j%20%3D%200%3B%20j%20%3C%3D%20n%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20l%5Bi%5D%5Bj%5D%20%3D%200%5Cn%20%20%20%20%20%20%20%20%20%20%20%20solution%5Bi%5D%5Bj%5D%20%3D%20%5C%220%5C%22%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%3D%20m%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20for%20(let%20j%20%3D%200%3B%20j%20%3C%3D%20n%3B%20j%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(i%20%3D%3D%3D%200%20%7C%7C%20j%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20l%5Bi%5D%5Bj%5D%20%3D%200%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20if%20(wordX%5Bi%20-%201%5D%20%3D%3D%3D%20wordY%5Bj%20-%201%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20l%5Bi%5D%5Bj%5D%20%3D%20l%5Bi%20-%201%5D%5Bj%20-%201%5D%20%2B%201%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20solution%5Bi%5D%5Bj%5D%20%3D%20%5C%22diagonal%5C%22%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20a%20%3D%20l%5Bi%20-%201%5D%5Bj%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20b%20%3D%20l%5Bi%5D%5Bj%20-%201%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20l%5Bi%5D%5Bj%5D%20%3D%20Math.max(a%2C%20b)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20solution%5Bi%5D%5Bj%5D%20%3D%20l%5Bi%5D%5Bj%5D%20%3D%3D%3D%20l%5Bi%20-%201%5D%5Bj%5D%20%3F%20%5C%22top%5C%22%20%3A%20%5C%22left%5C%22%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20return%20printSolution(solution%2C%20wordX%2C%20m%2C%20n)%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22ed5a3ec9%22%7D\"></card><p data-lake-id=\"ud620dcf6\" id=\"ud620dcf6\"><br></p><p data-lake-id=\"u3fb40d91\" id=\"u3fb40d91\"><span data-lake-id=\"u0f65bb8f\" id=\"u0f65bb8f\">测试结果：</span></p><p data-lake-id=\"u35f1b423\" id=\"u35f1b423\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20wordX%20%3D%20%5B%5C%22a%5C%22%2C%20%5C%22c%5C%22%2C%20%5C%22b%5C%22%2C%20%5C%22a%5C%22%2C%20%5C%22e%5C%22%2C%20%5C%22d%5C%22%5D%5Cnconst%20wordY%20%3D%20%5B%5C%22a%5C%22%2C%20%5C%22b%5C%22%2C%20%5C%22c%5C%22%2C%20%5C%22a%5C%22%2C%20%5C%22d%5C%22%2C%20%5C%22f%5C%22%5D%5Cnconsole.log(lcs(wordX%2C%20wordY))%20%2F%2F%20acad%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%224cf9d5eb%22%7D\"></card><p data-lake-id=\"u30aef622\" id=\"u30aef622\"><br></p><h1 data-lake-id=\"f609d9e1\" id=\"f609d9e1\"><span data-lake-id=\"u3bd3137e\" id=\"u3bd3137e\">贪心算法</span></h1><p data-lake-id=\"u4a165942\" id=\"u4a165942\"><br></p><p data-lake-id=\"u8f98e398\" id=\"u8f98e398\"><span data-lake-id=\"u4ffbe80e\" id=\"u4ffbe80e\">贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择，从而达到全局的最优。它不像动态规划算法那样计算更大的格局。</span></p><p data-lake-id=\"u6a7b462b\" id=\"u6a7b462b\"><br></p><h3 data-lake-id=\"757a1831-1\" id=\"757a1831-1\"><span data-lake-id=\"ufd656af0\" id=\"ufd656af0\">最少硬币找零</span></h3><p data-lake-id=\"u43c56a85\" id=\"u43c56a85\"><br></p><p data-lake-id=\"ue80f9888\" id=\"ue80f9888\"><span data-lake-id=\"u32ed8623\" id=\"u32ed8623\">我们来看看如何用贪心算法解决前面提到过的最少硬币找零问题。</span></p><p data-lake-id=\"u9b230f73\" id=\"u9b230f73\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20minCoinChange(coins%2C%20amount)%20%7B%5Cn%20%20%20%20const%20change%20%3D%20%5B%5D%5Cn%20%20%20%20let%20total%20%3D%200%5Cn%20%20%20%20for%20(let%20i%20%3D%20coins.length%20-%201%3B%20i%20%3E%3D%200%3B%20i--)%20%7B%5Cn%20%20%20%20%20%20%20%20const%20coin%20%3D%20coins%5Bi%5D%5Cn%20%20%20%20%20%20%20%20while%20(total%20%2B%20coin%20%3C%3D%20amount)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20change.push(coin)%5Cn%20%20%20%20%20%20%20%20%20%20%20%20total%20%2B%3D%20coin%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20change%5Cn%7D%5Cn%5Cnconst%20result%20%3D%20minCoinChange(%5B1%2C%205%2C%2010%2C%2025%5D%2C%2036)%5Cnconsole.log(result)%20%2F%2F%20%5B%2025%2C%2010%2C%201%20%5D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%2288fee103%22%7D\"></card><p data-lake-id=\"u64aad510\" id=\"u64aad510\"><br></p><p data-lake-id=\"ud9d2724f\" id=\"ud9d2724f\"><span data-lake-id=\"uf6e28de0\" id=\"uf6e28de0\">前提是 coins 数组已经按从小到大排好序了，贪心算法从最大值开始尝试，如果该值不满足条件（要找零的钱数），则继续向下找，直到找到满足条件的所有值。以上算法并不能满足所有情况下找出最优方案，例如下面这种情况：</span></p><p data-lake-id=\"u5440365a\" id=\"u5440365a\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20result%20%3D%20minCoinChange(%5B1%2C%202%2C%205%2C%209%2C%2010%5D%2C%2018)%5Cnconsole.log(result)%20%2F%2F%20%5B%2010%2C%205%2C%202%2C%201%20%5D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22570ae980%22%7D\"></card><p data-lake-id=\"u574044c7\" id=\"u574044c7\"><br></p><p data-lake-id=\"u36c82b76\" id=\"u36c82b76\"><span data-lake-id=\"u32f853cc\" id=\"u32f853cc\">给出的结果[10, 5, 2, 1]并不是最优方案，最优方案应该是[9, 9]。<br /></span><span data-lake-id=\"u358afaad\" id=\"u358afaad\">与动态规划相比，贪心算法更简单、效率更高。但是其结果并不总是最理想的。但是综合看来，它相对执行时间来说，输出一个可以接受的结果。</span></p><p data-lake-id=\"u8825ff5a\" id=\"u8825ff5a\"><br></p><h3 data-lake-id=\"d39a003f-1\" id=\"d39a003f-1\"><span data-lake-id=\"u0cd08f93\" id=\"u0cd08f93\">背包问题</span></h3><p data-lake-id=\"u7abbb734\" id=\"u7abbb734\"><br></p><p data-lake-id=\"u993860d0\" id=\"u993860d0\"><span data-lake-id=\"u00fd2580\" id=\"u00fd2580\">​</span><br></p><card type=\"block\" name=\"table\" value=\"data:%7B%22id%22%3A%223e0d7702-1%22%2C%22rows%22%3A4%2C%22cols%22%3A3%2C%22html%22%3A%22%3Ctable%20data-lake-id%3D%5C%223e0d7702-1%5C%22%20id%3D%5C%223e0d7702-1%5C%22%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20750px%5C%22%3E%3Ccolgroup%3E%3Ccol%20width%3D%5C%22250%5C%22%3E%3Ccol%20width%3D%5C%22250%5C%22%3E%3Ccol%20width%3D%5C%22250%5C%22%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20data-lake-id%3D%5C%22ue9ae5806%5C%22%20id%3D%5C%22ue9ae5806%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u2f52953f%5C%22%20id%3D%5C%22u2f52953f%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u5880a9d3%5C%22%20id%3D%5C%22u5880a9d3%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22u0985e9be%5C%22%20id%3D%5C%22u0985e9be%5C%22%3E%E7%89%A9%E5%93%81%23%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u84bc4fc0%5C%22%20id%3D%5C%22u84bc4fc0%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u55111af8%5C%22%20id%3D%5C%22u55111af8%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22u824ce850%5C%22%20id%3D%5C%22u824ce850%5C%22%3E%E9%87%8D%E9%87%8F%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u85296af5%5C%22%20id%3D%5C%22u85296af5%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u7903f1a5%5C%22%20id%3D%5C%22u7903f1a5%5C%22%3E%3Cstrong%3E%3Cspan%20data-lake-id%3D%5C%22u39659d0a%5C%22%20id%3D%5C%22u39659d0a%5C%22%3E%E4%BB%B7%E5%80%BC%3C%2Fspan%3E%3C%2Fstrong%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22uacd5bec9%5C%22%20id%3D%5C%22uacd5bec9%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u6a027058%5C%22%20id%3D%5C%22u6a027058%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uea29a6db%5C%22%20id%3D%5C%22uea29a6db%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u93cbe0a2%5C%22%20id%3D%5C%22u93cbe0a2%5C%22%3E1%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22uc353d551%5C%22%20id%3D%5C%22uc353d551%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u6f04d738%5C%22%20id%3D%5C%22u6f04d738%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u77deb1c2%5C%22%20id%3D%5C%22u77deb1c2%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ua0232d32%5C%22%20id%3D%5C%22ua0232d32%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u8711c4d6%5C%22%20id%3D%5C%22u8711c4d6%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u61b2e839%5C%22%20id%3D%5C%22u61b2e839%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22u41f01855%5C%22%20id%3D%5C%22u41f01855%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u82073cbd%5C%22%20id%3D%5C%22u82073cbd%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u81bfe831%5C%22%20id%3D%5C%22u81bfe831%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u4be2853a%5C%22%20id%3D%5C%22u4be2853a%5C%22%3E2%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ufe4126cc%5C%22%20id%3D%5C%22ufe4126cc%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u62e20a66%5C%22%20id%3D%5C%22u62e20a66%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u082ab72f%5C%22%20id%3D%5C%22u082ab72f%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u114be65e%5C%22%20id%3D%5C%22u114be65e%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u15d549d6%5C%22%20id%3D%5C%22u15d549d6%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u15e3283b%5C%22%20id%3D%5C%22u15e3283b%5C%22%3E4%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20data-lake-id%3D%5C%22ub1311429%5C%22%20id%3D%5C%22ub1311429%5C%22%3E%3Ctd%20data-lake-id%3D%5C%22u95e58c97%5C%22%20id%3D%5C%22u95e58c97%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u36203a71%5C%22%20id%3D%5C%22u36203a71%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22u76fbef07%5C%22%20id%3D%5C%22u76fbef07%5C%22%3E3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22u850b1d0a%5C%22%20id%3D%5C%22u850b1d0a%5C%22%3E%3Cp%20data-lake-id%3D%5C%22u225abe93%5C%22%20id%3D%5C%22u225abe93%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22ub96fa065%5C%22%20id%3D%5C%22ub96fa065%5C%22%3E4%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20data-lake-id%3D%5C%22ua27f4b65%5C%22%20id%3D%5C%22ua27f4b65%5C%22%3E%3Cp%20data-lake-id%3D%5C%22uaea4da5b%5C%22%20id%3D%5C%22uaea4da5b%5C%22%3E%3Cspan%20data-lake-id%3D%5C%22uf69de7a5%5C%22%20id%3D%5C%22uf69de7a5%5C%22%3E5%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%2C%22margin%22%3Atrue%7D\"></card><p data-lake-id=\"u275bf463\" id=\"u275bf463\"><br></p><p data-lake-id=\"uf1e6c5f6\" id=\"uf1e6c5f6\"><span data-lake-id=\"u1bb05c76\" id=\"u1bb05c76\">在动态规划的例子里，假定背包的容量为 5，最佳方案是往背包里装入物品 1 和物品 2，总价值为 7。在贪心算法中，我们需要考虑分数的情况，假定背包的容量为 6，装入物品 1 和物品 2 之后，剩余容量为 1，可以装入 1/4 的物品 3，总价值为 3+4+0.25×5=8.25。我们来看看具体的实现代码：</span></p><p data-lake-id=\"u02168106\" id=\"u02168106\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20knapSack(capacity%2C%20weights%2C%20values)%20%7B%5Cn%20%20%20%20const%20n%20%3D%20values.length%5Cn%20%20%20%20let%20load%20%3D%200%5Cn%20%20%20%20let%20val%20%3D%200%5Cn%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20n%20%26%26%20load%20%3C%20capacity%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(weights%5Bi%5D%20%3C%3D%20capacity%20-%20load)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20val%20%2B%3D%20values%5Bi%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20load%20%2B%3D%20weights%5Bi%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20console.log(%60%E7%89%A9%E5%93%81%24%7Bi%20%2B%201%7D%EF%BC%8C%E9%87%8D%E9%87%8F%EF%BC%9A%24%7Bweights%5Bi%5D%7D%EF%BC%8C%E4%BB%B7%E5%80%BC%EF%BC%9A%24%7Bvalues%5Bi%5D%7D%60)%5Cn%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20const%20r%20%3D%20(capacity%20-%20load)%20%2F%20weights%5Bi%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20val%20%2B%3D%20r%20*%20values%5Bi%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20load%20%2B%3D%20weights%5Bi%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20console.log(%60%E7%89%A9%E5%93%81%24%7Bi%20%2B%201%7D%E7%9A%84%24%7Br%7D%EF%BC%8C%E9%87%8D%E9%87%8F%EF%BC%9A%24%7Br%20*%20weights%5Bi%5D%7D%EF%BC%8C%E4%BB%B7%E5%80%BC%EF%BC%9A%24%7Bval%7D%60)%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20return%20val%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%2250c0c69e%22%7D\"></card><p data-lake-id=\"u8ab18774\" id=\"u8ab18774\"><br></p><p data-lake-id=\"uce331fac\" id=\"uce331fac\"><span data-lake-id=\"u61566880\" id=\"u61566880\">从第一个物品开始遍历，如果总重量小于背包的容量，则继续迭代，装入物品。如果物品可以完整地装入背包，则将其价值和重量分别计入到变量 val 和 load 中，同时打印装入物品的信息。如果物品不能完整地装入背包，计算能够装入的比例 r，然后将这个比例所对应的价值和重量分别计入到变量 val 和 load 中，同时打印物品的信息。最终输出总的价值 val。下面是测试结果：</span></p><p data-lake-id=\"uf297eb65\" id=\"uf297eb65\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20capacity%20%3D%206%5Cnconst%20weights%20%3D%20%5B2%2C%203%2C%204%5D%5Cnconst%20values%20%3D%20%5B3%2C%204%2C%205%5D%5Cnconsole.log(knapSack(capacity%2C%20weights%2C%20values))%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22fc803424%22%7D\"></card><p data-lake-id=\"u6ea35a67\" id=\"u6ea35a67\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%E7%89%A9%E5%93%811%EF%BC%8C%E9%87%8D%E9%87%8F%EF%BC%9A2%EF%BC%8C%E4%BB%B7%E5%80%BC%EF%BC%9A3%5Cn%E7%89%A9%E5%93%812%EF%BC%8C%E9%87%8D%E9%87%8F%EF%BC%9A3%EF%BC%8C%E4%BB%B7%E5%80%BC%EF%BC%9A4%5Cn%E7%89%A9%E5%93%813%E7%9A%840.25%EF%BC%8C%E9%87%8D%E9%87%8F%EF%BC%9A1%EF%BC%8C%E4%BB%B7%E5%80%BC%EF%BC%9A8.25%5Cn8.25%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22c0b17e2f%22%7D\"></card><p data-lake-id=\"u3db63bd8\" id=\"u3db63bd8\"><br></p><p data-lake-id=\"u454c8b5e\" id=\"u454c8b5e\"><span data-lake-id=\"ue91c4208\" id=\"ue91c4208\">在动态规划算法中，如果将背包的容量也设定为 6，计算结果则为 8。</span></p><p data-lake-id=\"udbdb4f65\" id=\"udbdb4f65\"><br></p><h3 data-lake-id=\"09793c39-1\" id=\"09793c39-1\"><span data-lake-id=\"ud8421777\" id=\"ud8421777\">最长公共子序列（LCS）</span></h3><p data-lake-id=\"uad57bcfe\" id=\"uad57bcfe\"><br></p><p data-lake-id=\"u2d55beba\" id=\"u2d55beba\"><span data-lake-id=\"u8486d020\" id=\"u8486d020\">最后我们再来看看如何用贪心算法解决 LCS 的问题。下面的代码返回了两个给定数组中的 LCS 的长度：</span></p><p data-lake-id=\"u034ab4f4\" id=\"u034ab4f4\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20lcs(wordX%2C%20wordY%2C%20m%20%3D%20wordX.length%2C%20n%20%3D%20wordY.length)%20%7B%5Cn%20%20%20%20if%20(m%20%3D%3D%3D%200%20%7C%7C%20n%20%3D%3D%3D%200)%20%7B%5Cn%20%20%20%20%20%20%20%20return%200%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if%20(wordX%5Bm%20-%201%5D%20%3D%3D%3D%20wordY%5Bn%20-%201%5D)%20%7B%5Cn%20%20%20%20%20%20%20%20return%201%20%2B%20lcs(wordX%2C%20wordY%2C%20m%20-%201%2C%20n%20-%201)%5Cn%20%20%20%20%7D%5Cn%20%20%20%20const%20a%20%3D%20lcs(wordX%2C%20wordY%2C%20m%2C%20n%20-%201)%5Cn%20%20%20%20const%20b%20%3D%20lcs(wordX%2C%20wordY%2C%20m%20-%201%2C%20n)%5Cn%20%20%20%20return%20a%20%3E%20b%20%3F%20a%20%3A%20b%5Cn%7D%5Cn%5Cnconst%20wordX%20%3D%20%5B%5C%22a%5C%22%2C%20%5C%22c%5C%22%2C%20%5C%22b%5C%22%2C%20%5C%22a%5C%22%2C%20%5C%22e%5C%22%2C%20%5C%22d%5C%22%5D%5Cnconst%20wordY%20%3D%20%5B%5C%22a%5C%22%2C%20%5C%22b%5C%22%2C%20%5C%22c%5C%22%2C%20%5C%22a%5C%22%2C%20%5C%22d%5C%22%2C%20%5C%22f%5C%22%5D%5Cnconsole.log(lcs(wordX%2C%20wordY))%20%2F%2F%204%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Night%20Owl%22%2C%22id%22%3A%22c442e6ca%22%7D\"></card>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 3860,
  "created_at": "2022-04-04T11:35:13.000Z",
  "updated_at": "2022-05-10T15:16:49.000Z",
  "content_updated_at": "2022-04-04T11:35:13.000Z",
  "published_at": "2022-04-04T11:35:13.000Z",
  "first_published_at": "2022-04-04T11:35:12.806Z",
  "book": {
    "id": 26225252,
    "type": "Book",
    "slug": "sd8kbc",
    "name": "笔试 written test",
    "user_id": 732231,
    "description": "笔试相关题目\n1. 原生 API 实现\n2. 业务场景相关问题\n3. LeetCode 算法相关问题",
    "toc_yml": "- type: META\n  count: 84\n  display_level: 1\n  tail_type: UPDATED_AT\n  base_version_id: 370014828\n  published: true\n  max_level: 1\n  last_updated_at: 2023-11-11T18:03:16.908Z\n  version_id: 370014838\n- type: TITLE\n  title: 原生 API\n  uuid: _1yNZniU22OymJlp\n  url: ''\n  prev_uuid: ''\n  sibling_uuid: zxe2MJsSU5MOefDb\n  child_uuid: EMyfauRyhp-lOYYB\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: extends 关键字\n  uuid: EMyfauRyhp-lOYYB\n  url: vtqbgk\n  prev_uuid: _1yNZniU22OymJlp\n  sibling_uuid: XEsl8fffffuSCTSI\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 76186529\n  level: 1\n  id: 76186529\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: ajax\n  uuid: XEsl8fffffuSCTSI\n  url: cq5ws4\n  prev_uuid: EMyfauRyhp-lOYYB\n  sibling_uuid: EaDc9LInXSSLEeXZ\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212428\n  level: 1\n  id: 72212428\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: call & apply & bind\n  uuid: EaDc9LInXSSLEeXZ\n  url: ybrsyw\n  prev_uuid: XEsl8fffffuSCTSI\n  sibling_uuid: wqGQXgEjeQAf0Bxq\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212433\n  level: 1\n  id: 72212433\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: new 关键字\n  uuid: wqGQXgEjeQAf0Bxq\n  url: pldu2b\n  prev_uuid: EaDc9LInXSSLEeXZ\n  sibling_uuid: EbpTwwxFd9JXJyoY\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212430\n  level: 1\n  id: 72212430\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 函数柯理化\n  uuid: EbpTwwxFd9JXJyoY\n  url: yo9cx5\n  prev_uuid: wqGQXgEjeQAf0Bxq\n  sibling_uuid: g-W6FKTBoxb36HhI\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212393\n  level: 1\n  id: 72212393\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 浅拷贝和深拷贝\n  uuid: g-W6FKTBoxb36HhI\n  url: ufks1z\n  prev_uuid: EbpTwwxFd9JXJyoY\n  sibling_uuid: 7u5E_Hw98pbzQ4Yj\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212395\n  level: 1\n  id: 72212395\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现 instanceof\n  uuid: 7u5E_Hw98pbzQ4Yj\n  url: ba4wuo\n  prev_uuid: g-W6FKTBoxb36HhI\n  sibling_uuid: lFcmsu4tBdKMPIkR\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212424\n  level: 1\n  id: 72212424\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 手动实现定时器\n  uuid: lFcmsu4tBdKMPIkR\n  url: wf9bwg\n  prev_uuid: 7u5E_Hw98pbzQ4Yj\n  sibling_uuid: mjNFEVKWs-_1yZyS\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212397\n  level: 1\n  id: 72212397\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: sleep 函数实现\n  uuid: mjNFEVKWs-_1yZyS\n  url: ngwrak\n  prev_uuid: lFcmsu4tBdKMPIkR\n  sibling_uuid: Zo-bldWs1dUYUcA5\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212460\n  level: 1\n  id: 72212460\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现 JSON.stringify\n  uuid: Zo-bldWs1dUYUcA5\n  url: mtoe2n\n  prev_uuid: mjNFEVKWs-_1yZyS\n  sibling_uuid: LR_aI8-ZIoVBksK7\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212459\n  level: 1\n  id: 72212459\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: js 通用类型获取\n  uuid: LR_aI8-ZIoVBksK7\n  url: tll6lm\n  prev_uuid: Zo-bldWs1dUYUcA5\n  sibling_uuid: fjrB0qhIJpH89FjS\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 72212464\n  level: 1\n  id: 72212464\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现 iterator\n  uuid: fjrB0qhIJpH89FjS\n  url: ir252g\n  prev_uuid: LR_aI8-ZIoVBksK7\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: _1yNZniU22OymJlp\n  doc_id: 81930561\n  level: 1\n  id: 81930561\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: TypeScript\n  uuid: zxe2MJsSU5MOefDb\n  url: ''\n  prev_uuid: _1yNZniU22OymJlp\n  sibling_uuid: KRfqr5yKeh6GNv5y\n  child_uuid: CdOrh3hFdbuZevZ-\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: '#10 元组转联合类型'\n  uuid: CdOrh3hFdbuZevZ-\n  url: wwribz\n  prev_uuid: zxe2MJsSU5MOefDb\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: zxe2MJsSU5MOefDb\n  doc_id: 81961244\n  level: 1\n  id: 81961244\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 防抖和节流\n  uuid: KRfqr5yKeh6GNv5y\n  url: ''\n  prev_uuid: zxe2MJsSU5MOefDb\n  sibling_uuid: 84qjgn-j0_zJVLF7\n  child_uuid: eLdwpvS_6r5inI_p\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 防抖\n  uuid: eLdwpvS_6r5inI_p\n  url: enlngv\n  prev_uuid: KRfqr5yKeh6GNv5y\n  sibling_uuid: z32U-o38tB2Yzwns\n  child_uuid: ''\n  parent_uuid: KRfqr5yKeh6GNv5y\n  doc_id: 72212387\n  level: 1\n  id: 72212387\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 节流\n  uuid: z32U-o38tB2Yzwns\n  url: griz0t\n  prev_uuid: eLdwpvS_6r5inI_p\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: KRfqr5yKeh6GNv5y\n  doc_id: 72212392\n  level: 1\n  id: 72212392\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 数组相关\n  uuid: 84qjgn-j0_zJVLF7\n  url: ''\n  prev_uuid: KRfqr5yKeh6GNv5y\n  sibling_uuid: 0efRPOUXCUn3VmH-\n  child_uuid: E8-yClCfd2GHBfld\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 数组交集、差集、并集\n  uuid: E8-yClCfd2GHBfld\n  url: yl18rs\n  prev_uuid: 84qjgn-j0_zJVLF7\n  sibling_uuid: Ot36XWP1DAdhhxL8\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 77996894\n  level: 1\n  id: 77996894\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数组转树\n  uuid: Ot36XWP1DAdhhxL8\n  url: bzgequ\n  prev_uuid: E8-yClCfd2GHBfld\n  sibling_uuid: LUZSQT4XixZ6lRVn\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 77015210\n  level: 1\n  id: 77015210\n  open_window: 0\n  visible: 0\n- type: DOC\n  title: 树转数组\n  uuid: LUZSQT4XixZ6lRVn\n  url: xycpzl\n  prev_uuid: Ot36XWP1DAdhhxL8\n  sibling_uuid: KSjaO3MJIdM_aUoi\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 77015236\n  level: 1\n  id: 77015236\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数组常用方法\n  uuid: KSjaO3MJIdM_aUoi\n  url: owtewn\n  prev_uuid: LUZSQT4XixZ6lRVn\n  sibling_uuid: 1PhmaFWLSwH7eqUK\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212436\n  level: 1\n  id: 72212436\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数组去重实现\n  uuid: 1PhmaFWLSwH7eqUK\n  url: gq2z9n\n  prev_uuid: KSjaO3MJIdM_aUoi\n  sibling_uuid: bnM3r0-enDa6563Q\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212390\n  level: 1\n  id: 72212390\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数组扁平化实现\n  uuid: bnM3r0-enDa6563Q\n  url: doeryg\n  prev_uuid: 1PhmaFWLSwH7eqUK\n  sibling_uuid: 4NBfYxOcirIHYRrY\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212385\n  level: 1\n  id: 72212385\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 类数组转换为数组\n  uuid: 4NBfYxOcirIHYRrY\n  url: csgagn\n  prev_uuid: bnM3r0-enDa6563Q\n  sibling_uuid: SRwtHRX7f61VIFq6\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212445\n  level: 1\n  id: 72212445\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现数组乱序输出\n  uuid: SRwtHRX7f61VIFq6\n  url: xlrgnu\n  prev_uuid: 4NBfYxOcirIHYRrY\n  sibling_uuid: eARzwOBdjHS0A35l\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212437\n  level: 1\n  id: 72212437\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 查找二维数组的目标值\n  uuid: eARzwOBdjHS0A35l\n  url: tmw2ny\n  prev_uuid: SRwtHRX7f61VIFq6\n  sibling_uuid: C2gvlSUA6P7bZEpi\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212461\n  level: 1\n  id: 72212461\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 二维数组斜向打印\n  uuid: C2gvlSUA6P7bZEpi\n  url: aqw6my\n  prev_uuid: eARzwOBdjHS0A35l\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 84qjgn-j0_zJVLF7\n  doc_id: 72212457\n  level: 1\n  id: 72212457\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 字符串相关\n  uuid: 0efRPOUXCUn3VmH-\n  url: ''\n  prev_uuid: 84qjgn-j0_zJVLF7\n  sibling_uuid: A5NJiZ0GxiVUBJHd\n  child_uuid: oZ_CUVcv3_hOp7zN\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 实现字符串的 repeat 方法\n  uuid: oZ_CUVcv3_hOp7zN\n  url: hxelqc\n  prev_uuid: 0efRPOUXCUn3VmH-\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 0efRPOUXCUn3VmH-\n  doc_id: 72212440\n  level: 1\n  id: 72212440\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: promise相关\n  uuid: A5NJiZ0GxiVUBJHd\n  url: ''\n  prev_uuid: 0efRPOUXCUn3VmH-\n  sibling_uuid: sT-U-4fs90PlHvSI\n  child_uuid: 78Mu2RhGBL340hYq\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 实现 Promise A+\n  uuid: 78Mu2RhGBL340hYq\n  url: fl6cgx\n  prev_uuid: A5NJiZ0GxiVUBJHd\n  sibling_uuid: 9ahjbOcDVnGRzHTW\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212388\n  level: 1\n  id: 72212388\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise  常用方法实现\n  uuid: 9ahjbOcDVnGRzHTW\n  url: vd2h4l\n  prev_uuid: 78Mu2RhGBL340hYq\n  sibling_uuid: QLrR0jESJ8AEjFPl\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212389\n  level: 1\n  id: 72212389\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise 并发控制\n  uuid: QLrR0jESJ8AEjFPl\n  url: gd3193\n  prev_uuid: 9ahjbOcDVnGRzHTW\n  sibling_uuid: UKGjwSlV9BFG8i8n\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212405\n  level: 1\n  id: 72212405\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise 顺序串行输出\n  uuid: UKGjwSlV9BFG8i8n\n  url: wtr4cf\n  prev_uuid: QLrR0jESJ8AEjFPl\n  sibling_uuid: upU7a9yZR3aRjCSo\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 83089974\n  level: 1\n  id: 83089974\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise 缓存\n  uuid: upU7a9yZR3aRjCSo\n  url: sgcusf\n  prev_uuid: UKGjwSlV9BFG8i8n\n  sibling_uuid: ZLRJdeGl0jA3kFgL\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212417\n  level: 1\n  id: 72212417\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 异步串行输出\n  uuid: ZLRJdeGl0jA3kFgL\n  url: um4g6z\n  prev_uuid: upU7a9yZR3aRjCSo\n  sibling_uuid: D2SERgWeggDq9efi\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212401\n  level: 1\n  id: 72212401\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 带并发的异步调度器 Scheduler\n  uuid: D2SERgWeggDq9efi\n  url: kbkc8e\n  prev_uuid: ZLRJdeGl0jA3kFgL\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: A5NJiZ0GxiVUBJHd\n  doc_id: 72212425\n  level: 1\n  id: 72212425\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 数据处理\n  uuid: sT-U-4fs90PlHvSI\n  url: ''\n  prev_uuid: A5NJiZ0GxiVUBJHd\n  sibling_uuid: 0STVwRWnDq8ksDkB\n  child_uuid: ywzD1rPOOunEfIdw\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 解析 url 参数对象\n  uuid: ywzD1rPOOunEfIdw\n  url: rxw8qp\n  prev_uuid: sT-U-4fs90PlHvSI\n  sibling_uuid: VCJiqjW4GSrpavsh\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212449\n  level: 1\n  id: 72212449\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现日期格式化函数\n  uuid: VCJiqjW4GSrpavsh\n  url: shzfyg\n  prev_uuid: ywzD1rPOOunEfIdw\n  sibling_uuid: 5AdCGi5sbOD2oqbH\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212432\n  level: 1\n  id: 72212432\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 交换 a、b 的值，不使用临时变量\n  uuid: 5AdCGi5sbOD2oqbH\n  url: xw17tv\n  prev_uuid: VCJiqjW4GSrpavsh\n  sibling_uuid: BQMERO8CCr9JPHQn\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212439\n  level: 1\n  id: 72212439\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 获取两个数之间的任意随机数\n  uuid: BQMERO8CCr9JPHQn\n  url: vhngph\n  prev_uuid: 5AdCGi5sbOD2oqbH\n  sibling_uuid: dWB6aCZMOqRTPIrm\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212419\n  level: 1\n  id: 72212419\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 将数字千分位用逗号隔开\n  uuid: dWB6aCZMOqRTPIrm\n  url: vphpea\n  prev_uuid: BQMERO8CCr9JPHQn\n  sibling_uuid: ZSnQ_Z4XjCp_uMbl\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212441\n  level: 1\n  id: 72212441\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现非负大整数相加\n  uuid: ZSnQ_Z4XjCp_uMbl\n  url: xlvd0g\n  prev_uuid: dWB6aCZMOqRTPIrm\n  sibling_uuid: 5AKa5DXyQbLxzDGt\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212442\n  level: 1\n  id: 72212442\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 判断对象是否存在循环引用\n  uuid: 5AKa5DXyQbLxzDGt\n  url: phqdmd\n  prev_uuid: ZSnQ_Z4XjCp_uMbl\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: sT-U-4fs90PlHvSI\n  doc_id: 72212452\n  level: 1\n  id: 72212452\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 框架\n  uuid: 0STVwRWnDq8ksDkB\n  url: ''\n  prev_uuid: sT-U-4fs90PlHvSI\n  sibling_uuid: 1mqH8VqzmT3IEIjz\n  child_uuid: G3kHPA-b8ubrHNI6\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 发布订阅模式\n  uuid: G3kHPA-b8ubrHNI6\n  url: ezcdgo\n  prev_uuid: 0STVwRWnDq8ksDkB\n  sibling_uuid: hJ7Pi5oOpo-U_yTy\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212386\n  level: 1\n  id: 72212386\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 观察者模式\n  uuid: hJ7Pi5oOpo-U_yTy\n  url: dwziom\n  prev_uuid: G3kHPA-b8ubrHNI6\n  sibling_uuid: alPkG8HdrSx35fzk\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212465\n  level: 1\n  id: 72212465\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 简易版 vue2\n  uuid: alPkG8HdrSx35fzk\n  url: indxog\n  prev_uuid: hJ7Pi5oOpo-U_yTy\n  sibling_uuid: Kd-bfMBdhRM3cQXO\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212394\n  level: 1\n  id: 72212394\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 简易版 vue3\n  uuid: Kd-bfMBdhRM3cQXO\n  url: an017i\n  prev_uuid: alPkG8HdrSx35fzk\n  sibling_uuid: UvkBS5W479slO2Um\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212469\n  level: 1\n  id: 72212469\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 简易版 vuex\n  uuid: UvkBS5W479slO2Um\n  url: myzomg\n  prev_uuid: Kd-bfMBdhRM3cQXO\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 0STVwRWnDq8ksDkB\n  doc_id: 72212426\n  level: 1\n  id: 72212426\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 应用场景问题\n  uuid: 1mqH8VqzmT3IEIjz\n  url: ''\n  prev_uuid: 0STVwRWnDq8ksDkB\n  sibling_uuid: ahwD4hLemj7wd4n_\n  child_uuid: AALpnq0Se9gaVsKQ\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 可缓存的请求函数\n  uuid: AALpnq0Se9gaVsKQ\n  url: gftlci\n  prev_uuid: 1mqH8VqzmT3IEIjz\n  sibling_uuid: 6jYfdo5kqYOTtify\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 81939471\n  level: 1\n  id: 81939471\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 上传100个文件，同时并发上传数量为5名如何最快完成上传\n  uuid: 6jYfdo5kqYOTtify\n  url: dsbtur\n  prev_uuid: AALpnq0Se9gaVsKQ\n  sibling_uuid: M9i07wHKfkwMbNRG\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 81939230\n  level: 1\n  id: 81939230\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 图片加载数量限制\n  uuid: M9i07wHKfkwMbNRG\n  url: xz2gy5\n  prev_uuid: 6jYfdo5kqYOTtify\n  sibling_uuid: pjmLSWnYJNZT6pBi\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212402\n  level: 1\n  id: 72212402\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: AC数量\n  uuid: pjmLSWnYJNZT6pBi\n  url: kyaq59\n  prev_uuid: M9i07wHKfkwMbNRG\n  sibling_uuid: UA7U6Ie8Lym3w5HB\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 81933729\n  level: 1\n  id: 81933729\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 通过调用 addRemote 实现 add\n  uuid: UA7U6Ie8Lym3w5HB\n  url: edff3s\n  prev_uuid: pjmLSWnYJNZT6pBi\n  sibling_uuid: A1qKsOUEtCFXe_UJ\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 73623506\n  level: 1\n  id: 73623506\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 倒计时\n  uuid: A1qKsOUEtCFXe_UJ\n  url: uwleof\n  prev_uuid: UA7U6Ie8Lym3w5HB\n  sibling_uuid: V5rnG_Fh1uLT3tYz\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212468\n  level: 1\n  id: 72212468\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 版本号比较\n  uuid: V5rnG_Fh1uLT3tYz\n  url: cynvvd\n  prev_uuid: A1qKsOUEtCFXe_UJ\n  sibling_uuid: 7kP1jNx3Jv2qtz4M\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212462\n  level: 1\n  id: 72212462\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现简单路由\n  uuid: 7kP1jNx3Jv2qtz4M\n  url: zzc9k3\n  prev_uuid: V5rnG_Fh1uLT3tYz\n  sibling_uuid: We8EXWT44v6iRohB\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212455\n  level: 1\n  id: 72212455\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 长列表虚拟滚动\n  uuid: We8EXWT44v6iRohB\n  url: wsmws7\n  prev_uuid: 7kP1jNx3Jv2qtz4M\n  sibling_uuid: Svy4yFR_RT_CSfLd\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212399\n  level: 1\n  id: 72212399\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 围圈报数问题\n  uuid: Svy4yFR_RT_CSfLd\n  url: gkoa19\n  prev_uuid: We8EXWT44v6iRohB\n  sibling_uuid: L20YHOh3AcKOC_BK\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212447\n  level: 1\n  id: 72212447\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 查找文章中出现频率最高的词\n  uuid: L20YHOh3AcKOC_BK\n  url: rln2y3\n  prev_uuid: Svy4yFR_RT_CSfLd\n  sibling_uuid: l-w9qpcLnXk3Fop6\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212453\n  level: 1\n  id: 72212453\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: Promise 每隔 1s 输出 1、2、3\n  uuid: l-w9qpcLnXk3Fop6\n  url: yg55el\n  prev_uuid: L20YHOh3AcKOC_BK\n  sibling_uuid: bpvqYyN2Dt1OP5ba\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 74885844\n  level: 1\n  id: 74885844\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 循环打印红黄绿\n  uuid: bpvqYyN2Dt1OP5ba\n  url: wyhgfz\n  prev_uuid: l-w9qpcLnXk3Fop6\n  sibling_uuid: sYbQboe4NKOreGYz\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212451\n  level: 1\n  id: 72212451\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 封装一个异步加载图片的方法\n  uuid: sYbQboe4NKOreGYz\n  url: orxq0m\n  prev_uuid: bpvqYyN2Dt1OP5ba\n  sibling_uuid: jSGMOwTmTh-AVElI\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 74886744\n  level: 1\n  id: 74886744\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 实现 mergePromise 函数\n  uuid: jSGMOwTmTh-AVElI\n  url: apqplp\n  prev_uuid: sYbQboe4NKOreGYz\n  sibling_uuid: D5aX74WcvfcBK-xH\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 74885813\n  level: 1\n  id: 74885813\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 文本中识别敏感词、表情包、链接、数字、字母并高亮\n  uuid: D5aX74WcvfcBK-xH\n  url: athu4p\n  prev_uuid: jSGMOwTmTh-AVElI\n  sibling_uuid: Bt1pMK0unwRBHK0k\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212408\n  level: 1\n  id: 72212408\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 图片格式转换为 webp\n  uuid: Bt1pMK0unwRBHK0k\n  url: cwlftq\n  prev_uuid: D5aX74WcvfcBK-xH\n  sibling_uuid: I9iFwpfXRhZn1Ket\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212400\n  level: 1\n  id: 72212400\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 计算对象占用的字节数\n  uuid: I9iFwpfXRhZn1Ket\n  url: gx1y1y\n  prev_uuid: Bt1pMK0unwRBHK0k\n  sibling_uuid: UcV05ziY4TJKPu5m\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212406\n  level: 1\n  id: 72212406\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 给 xhr 添加 hook，实现在各个阶段打印日志\n  uuid: UcV05ziY4TJKPu5m\n  url: dm9n4g\n  prev_uuid: I9iFwpfXRhZn1Ket\n  sibling_uuid: 77boIDk-fFPJ9Icd\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212404\n  level: 1\n  id: 72212404\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 明信片问题\n  uuid: 77boIDk-fFPJ9Icd\n  url: mnsw3z\n  prev_uuid: UcV05ziY4TJKPu5m\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: 1mqH8VqzmT3IEIjz\n  doc_id: 72212466\n  level: 1\n  id: 72212466\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 常用算法实现\n  uuid: ahwD4hLemj7wd4n_\n  url: ''\n  prev_uuid: 1mqH8VqzmT3IEIjz\n  sibling_uuid: ''\n  child_uuid: 9pHSK6xJvBHyYfvP\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: SKU算法实现\n  uuid: 9pHSK6xJvBHyYfvP\n  url: rs9nxb\n  prev_uuid: ahwD4hLemj7wd4n_\n  sibling_uuid: '-h-CMZM_g4aYqwln'\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 81636590\n  level: 1\n  id: 81636590\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 无重复最长子串\n  uuid: '-h-CMZM_g4aYqwln'\n  url: zn78xr\n  prev_uuid: 9pHSK6xJvBHyYfvP\n  sibling_uuid: tDrBxICyXBoMgRJD\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 81636434\n  level: 1\n  id: 81636434\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 二分查找\n  uuid: tDrBxICyXBoMgRJD\n  url: pywta0\n  prev_uuid: '-h-CMZM_g4aYqwln'\n  sibling_uuid: eH5hJfGPxku_rn96\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212463\n  level: 1\n  id: 72212463\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 排序\n  uuid: eH5hJfGPxku_rn96\n  url: ivvld9\n  prev_uuid: tDrBxICyXBoMgRJD\n  sibling_uuid: 4cV9_qbBLcYidtg8\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212411\n  level: 1\n  id: 72212411\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 动态规划和贪心算法\n  uuid: 4cV9_qbBLcYidtg8\n  url: pyig7m\n  prev_uuid: eH5hJfGPxku_rn96\n  sibling_uuid: 5VMnf0-t-FXvC3K6\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212414\n  level: 1\n  id: 72212414\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 洗牌算法\n  uuid: 5VMnf0-t-FXvC3K6\n  url: tohw0k\n  prev_uuid: 4cV9_qbBLcYidtg8\n  sibling_uuid: AjOzxJ-vxxRXW6dS\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212418\n  level: 1\n  id: 72212418\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: LRU(最少置换算法)\n  uuid: AjOzxJ-vxxRXW6dS\n  url: tmwgql\n  prev_uuid: 5VMnf0-t-FXvC3K6\n  sibling_uuid: ID7sjKR9-5E_moyo\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212423\n  level: 1\n  id: 72212423\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 斐波那契数列\n  uuid: ID7sjKR9-5E_moyo\n  url: bq7f7e\n  prev_uuid: AjOzxJ-vxxRXW6dS\n  sibling_uuid: wZscOLfm_xjPFYv2\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212420\n  level: 1\n  id: 72212420\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 大数相加\n  uuid: wZscOLfm_xjPFYv2\n  url: ln6fpo\n  prev_uuid: ID7sjKR9-5E_moyo\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ahwD4hLemj7wd4n_\n  doc_id: 72212421\n  level: 1\n  id: 72212421\n  open_window: 0\n  visible: 1\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 74,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2023-11-11T18:15:38.713Z",
    "created_at": "2022-04-04T11:34:53.000Z",
    "updated_at": "2023-11-11T18:15:39.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-22T20:13:30.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/sd8kbc",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 908499764,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}