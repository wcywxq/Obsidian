{
  "id": 32924996,
  "slug": "tuiqkt",
  "title": "前端自动化测试",
  "description": "",
  "cover": "",
  "user_id": 732231,
  "book_id": 25332296,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "",
  "body": "<a name=\"1cc518ba\"></a>\n# 前端自动化测试\n\n<a name=\"e06fdbee\"></a>\n## 1. 单元测试\n\n对软件中的最小可测试单元进行检查和验证，在前端一般为一个模块。\n\n<a name=\"759aac61\"></a>\n### 1.1 单元测试的优缺点\n\n1. 测试覆盖率高\n2. 业务耦合度高\n3. 代码量大\n4. 过于独立\n\n<a name=\"7b50fee4\"></a>\n### 1.2 总结\n\n在某些场景下适合适用单元测试，某些场景下不适合适用单元测试\n\n<a name=\"2f883435\"></a>\n## 2. 集成测试\n\n又叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。\n\n<a name=\"e0cc0593\"></a>\n## 3. jest 中的匹配器\n\n[jest 匹配器官网](https://jestjs.io/docs/en/expect)\n\n修改 `jest`  默认配置命令 `npx jest --init`\n\n<a name=\"e489b565\"></a>\n### 3.1 实时监听测试用例的改变\n\n`jest --watchAll` 一旦某个测试用例发生变化，所有的测试用例都将会重新执行\n\n`jest --watch`  默认进入 `o`  模式，即只对发生变化的测试用例重新执行\n\n<a name=\"9278cb4c\"></a>\n### 3.2 常用匹配器\n\n<a name=\"d21eba22\"></a>\n### 3.2.1 toBe()\n\n```jsx\ntest(\"测试toBe的匹配器\", () => {\n  const a = { name: \"张三\" };\n  expect(a).toBe({ name: \"张三\" });\n});\n// ❌ 因为引用类型使用toBe不是全等效果\n```\n\n`toBe` 匹配器类似于 `===`。\n\n---\n\n<a name=\"9ba722f8\"></a>\n### 3.2.2 toEqual()\n\n```jsx\ntest(\"测试toEqual的匹配器\", () => {\n  const a = { name: \"张三\" };\n  expect(a).toBe({ name: \"张三\" });\n});\n// ✅ 因为toEqual只是对结果的匹配，而不是全等效果\n```\n\n`toEqual` 匹配器只是对结果相等与否进行匹配\n\n---\n\n<a name=\"5b2da47a\"></a>\n### 3.2.3 toBeNull()\n\n```jsx\ntest(\"测试toBeNull的匹配器\", () => {\n  const a = null;\n  expect(a).toBeNull();\n});\n// ✅\n```\n\n`toBeNull` 是对 `null` 值的匹配\n\n---\n\n<a name=\"4f58955d\"></a>\n### 3.2.4 toBeUndefined()\n\n```jsx\ntest(\"测试toBeUndefined的匹配器\", () => {\n  const a = undefined;\n  expect(a).toBeUndefined();\n});\n// ✅\n```\n\n`toBeUndefined` 是对 `undefined` 值的匹配\n\n---\n\n<a name=\"aa717d1f\"></a>\n### 3.2.5 toBeDefined()\n\n```jsx\ntest(\"测试toBeDefined的匹配器\", () => {\n  const a = 1;\n  expect(a).toBeDefined();\n});\n// ✅\n```\n\n`toBeDefined` 是对已经定义的值的匹配，若为 `undefined` 则不通过\n\n---\n\n<a name=\"3e22cb95\"></a>\n### 3.2.6 toBeTruthy()\n\n```jsx\ntest(\"测试toBeTruthy的匹配器\", () => {\n  const a = 0;\n  expect(a).toBeTruthy();\n});\n// 0 => ❌，因为 toBeTruthy 是对 true 值的匹配\n// 1 => ✅\n```\n\n`toBeTruthy` 是对 `true` 值的匹配\n\n---\n\n<a name=\"daa53386\"></a>\n### 3.2.7 toBeFalsy()\n\n```jsx\ntest(\"测试toBeFalsy的匹配器\", () => {\n  const a = 1;\n  expect(a).toBeFalsy();\n});\n// 1 => ❌\n// 0 => ✅\n```\n\n`toBeFalsy` 是对 `false` 值的匹配\n\n---\n\n<a name=\"95777fd5\"></a>\n### 3.2.8 toBeGreaterThan()\n\n```jsx\ntest(\"测试toBeGreaterThan匹配器\", () => {\n  const count = 10;\n  expect(a).toBeGreaterThan(9);\n});\n// ✅\n```\n\n`toBeGreaterThan` 相当于 `>`\n\n---\n\n<a name=\"5ed81d3a\"></a>\n### 3.2.9 toBeLessThan()\n\n```jsx\ntest(\"测试toBeLessThan匹配器\", () => {\n  const count = 8;\n  expect(a).toBeLessThan(9);\n});\n// ✅\n```\n\n`toBeLessThan` 相当于 `<`\n\n---\n\n<a name=\"1f0e8517\"></a>\n### 3.2.10 toBeGreaterThanOrEqual()\n\n```jsx\ntest(\"测试toBeGreaterThanOrEqual匹配器\", () => {\n  const count = 10;\n  expect(a).toBeGreaterThanOrEqual(10);\n});\n// ✅\n```\n\n`toBeGreaterThanOrEqual` 相当于 `>=`\n\n---\n\n<a name=\"d137001e\"></a>\n### 3.2.11 toBeLessThanOrEqual()\n\n```jsx\ntest(\"测试toBeLessThanOrEqual匹配器\", () => {\n  const count = 10;\n  expect(a).toBeLessThanOrEqual(10);\n});\n// ✅\n```\n\n`toBeLessThanOrEqual` 相当于 `<=`\n\n---\n\n<a name=\"bb417baa\"></a>\n### 3.2.12 toBeCloseTo()\n\n```jsx\ntest(\"测试toBeCloseTo匹配器\", () => {\n  const one = 0.1;\n  const two = 0.2;\n  expect(one + two).toEqual(0.3);\n});\n// ❌ 因为浮点精度不同\n\ntest(\"测试toBeCloseTo匹配器\", () => {\n  const one = 0.1;\n  const two = 0.2;\n  expect(one + two).toBeCloseTo(0.3);\n});\n// ✅\n```\n\n`toBeCloseTo` 为了解决浮点精度不同导致的无法匹配的问题\n\n---\n\n<a name=\"3d3d7425\"></a>\n### 3.2.13 toMatch()\n\n```jsx\ntest(\"测试toMatch匹配器\", () => {\n  const str = \"张三、李四、王五\";\n  expect(str).toMatch(\"李四\");\n});\n// ✅\n\ntest(\"测试toMatch匹配器\", () => {\n  const str = \"张三、李四、王五\";\n  expect(str).toMatch(/李四/);\n});\n// ✅\n```\n\n`toMatch` 为字符串包含匹配器，用来匹配字符串中包含的内容，也可传正则表达式\n\n---\n\n<a name=\"0e7662e8\"></a>\n### 3.2.14 toContain()\n\n```jsx\ntest(\"测试toContain匹配器\", () => {\n  const arr = [\"张三\", \"李四\", \"王五\"];\n  expect(arr).toContain(\"张三\");\n});\n// ✅\n\ntest(\"测试toContain匹配器\", () => {\n  const arr = [\"张三\", \"李四\", \"王五\"];\n  const data = new Set(arr);\n  expect(data).toContain(\"张三\");\n});\n```\n\n`toContain` 为数据包含匹器，用来匹配数组中包含的项。同时可完全兼容 `Set` 测试\n\n---\n\n<a name=\"2d803288\"></a>\n### 3.2.15 toHaveLength()\n\n```jsx\n/// functions.js\nexport default {\n  getIntArray(num) {\n    if (!Number.isInteger(num)) {\n      throw Error('\"getIntArray\"只接受整数类型的参数');\n    }\n    let result = [];\n    for (let i = 0, len = num; i < len; i++) {\n      result.push(i);\n    }\n    return result;\n  }\n};\n\n/// functions.test.js\nimport { getIntArray } from \"../src/functions\";\ntest(\"getIntArray(3)返回的数组长度应该为3\", () => {\n  expect(getIntArray(3)).toHaveLength(3);\n});\n```\n\n`toHaveLength`可以很方便的用来测试字符串和数组类型的长度是否满足预期。\n\n<a name=\"c34e47a0\"></a>\n### 3.2.16 toThrow()\n\n```jsx\nconst throwNewErrorFunc = () => {\n  throw new Error(\"this is a new error\");\n};\n\ntest(\"测试toThrow匹配器\", () => {\n  expect(throwNewErrorFunc).toThrow();\n});\n```\n\n`toThrow` 是专门对异常进行处理的匹配器，可以检测一个方法会不会抛出异常\n\n```jsx\nconst throwNewErrorFunc = () => {\n  throw new Error(\"this is a new error\");\n};\n\ntest(\"测试toThrow匹配器\", () => {\n  expect(throwNewErrorFunc).toThrow(\"this is a new error\");\n});\n```\n\n我们也可以对这个匹配器中加一些字符串，意思就是抛出的异常必须和字符串相对应，如果字符串不匹配，也没办法通过异常测试。\n\n---\n\n<a name=\"764f06c9\"></a>\n### 3.2.17 not()\n\n```jsx\nconst throwNewErrorFunc = () => {\n  throw new Error(\"this is a new error\");\n};\n\ntest(\"测试not匹配器\", () => {\n  expect(throwNewErrorFunc).not.toThrow();\n});\n```\n\n`not` 匹配器是 `jest` 中比较特殊的匹配器，意思就是 “相反” 或者说 “取反” .比如上面的例子，我们不希望方法抛出异常，就可以使用`not` 匹配器。\n\n---\n\n<a name=\"3babda61\"></a>\n### 3.3 异步代码测试方法\n\n<a name=\"1891407f\"></a>\n### 3.3.1 回调函数式\n\n```jsx\n/// fetchData.js\nimport axios from \"axios\";\nexport const fetchData = fn => {\n  axios.get(\"http://a.jspang.com/jestTest.json\").then(res => {\n    fn(res.data);\n  });\n};\n\n/// fetchData.test.js\nimport { fetchData } from \"./fetchData.js\";\ntest(\"fetchData测试\", done => {\n  fetchData(data => {\n    expect(data).toEqual({ success: true });\n    done();\n  });\n});\n```\n\n必须加入一个 `done` 方法，保证我们的回调已经完成了，这时候我们表示测试完成\n\n---\n\n<a name=\"0ad6b7b2\"></a>\n### 3.3.2 直接返回 Promise\n\n```jsx\n/// fetchTwoData.js\nimport axios from \"axios\";\nexport const fetchTwoData = () => axios.get(\"http://a.jspang.com/jestTest.json\";\n\n/// fetchTwoData.test.js\nimport { fetchTwoData } from \"./fetchTwoData.js\";\ntest(\"fetchTwoData的测试用例\", () => {\n return fetchTwoData().then(res => {\n  expect(res.data).toEqual({ success: true });\n });\n});\n```\n\n注意要 `return`\n\n<a name=\"83b4fa78\"></a>\n### 3.3.3 不存在的接口\n\n```jsx\n/// fetchData.js\nexport const fetchData = () => {\n  return axios.get(\"http://a.jspang.com/jestTest_error.json\"); // 此地址并不存在\n};\n\n/// fetchData.test.js\n// 方式1\ntest(\"fetchData测试\", () => {\n  expect.assertions(1); // 断言，必须执行一次 expect\n  return fetchData().catch(err => {\n    expect(err.toString().indexOf(\"404\") > -1).toBe(true);\n  });\n});\n\n// 方式2\ntest(\"fetchData测试\", async () => {\n  return await fetchData().rejects.toThrow();\n});\n\n// 方式3\ntest(\"fetchData测试\", async () => {\n  expect().assertions(1); // 断言，必须执行一次 expect\n  try {\n    await fetchData();\n  } catch (err) {\n    expect(err.toString().indexOf(\"404\") > -1).toBe(true);\n  }\n});\n```\n\n因为测试用例使用了 `catch` 方法，也就是说只有出现异常的时候才会走这个方法，而现在没有出现异常，就不会走这个测试方法，`jest` 就默认这个用例通过了测试。因此必须要执行断言，即必须让其执行一次即可。\n\n<a name=\"001d5d5a\"></a>\n### 3.3.4 async/await\n\n```jsx\n/// fetchData.js\nexport const fetchData = () => {\n return axios.get(\"http://a.jspang.com/jestTest.json\"); // 此地址并不存在};\n\n/// fetchData.test.js\n// 方式1\ntest(\"fetchData测试\", async () => {\n await expect(fetchData()).resolves.toMatchObject({\n  data: {\n   success: true\n  }\n });\n});\n\n// 方式2\ntest(\"fetchData测试\", async () => {\n const response = await fetchData();\n expect(response.data).toEqual({ success: true });\n});\n```\n\n这时候我们的代码使用 `async....await...` 的形式，这里我们还使用了 `resolves` 用于把现有对象转换成 `Promise` 对象，然后使用 `jest` 中的 `toMatchObject` 进行匹配对象中的属性。\n\n<a name=\"9ead1173\"></a>\n## 4. jest 中的四个钩子函数\n\n<a name=\"44253391\"></a>\n### 4.1 beforeAll()\n\n`beforeAll()`钩子函数的意思是在所有测试用例之前进行执行。\n\n<a name=\"e43fb792\"></a>\n### 4.2 afterAll()\n\n`afterAll()`钩子函数是在完成所有测试用例之后才执行的函数。\n\n<a name=\"b6bb2f69\"></a>\n### 4.3 beforeEach()\n\n`beforeEach()`钩子函数，是在每个测试用例前都会执行一次的钩子函数。\n\n<a name=\"4208beab\"></a>\n### 4.4 afterEach()\n\n`afterEach()`钩子函数，是在每次测试用例完成测试之后执行一次的钩子函数。\n\n<a name=\"7c331432\"></a>\n## 5. jest 测试用例分组\n\n```jsx\n/// eat.js\nexport default class Eat {\n  setName(number) {\n    this.name = number === 1 ? \"水饺\" : \"火锅\";\n  }\n  setDesc() {\n    this.desc = this.user + \"描述\";\n  }\n  setMoney() {\n    this.money = this.name === \"水饺\" ? 80 : 300;\n  }\n}\n\n/// eat.test.js\nimport Eat from \"./eat\";\nconst eat = new Eat();\nbeforeAll(() => {\n  console.log(\"开始吃饭\");\n});\nafterAll(() => {\n  console.log(\"吃完饭了\");\n});\ndescribe(\"水饺相关内容\", () => {\n  test(\"测试水饺描述\", () => {\n    eat.setName(1);\n    eat.setDesc();\n    expect(eat.desc).toEqual(\"水饺描述\");\n  });\n  test(\"测试水饺价格\", () => {\n    eat.setName(1);\n    eat.setMoney();\n    expect(eat.money).toEqual(80);\n  });\n});\ndescribe(\"火锅相关内容\", () => {\n  test(\"测试火锅描述\", () => {\n    eat.setName(2);\n    eat.setDesc();\n    expect(eat.desc).toEqual(\"火锅描述\");\n  });\n  test(\"测试火锅价格\", () => {\n    eat.setName(2);\n    eat.setMoney();\n    expect(eat.money).toEqual(300);\n  });\n});\n```\n\n<a name=\"49e6c15a\"></a>\n## 6. 钩子函数的作用域\n\n<a name=\"45e52b93\"></a>\n### 6.1 钩子函数在父级分组可作用域子集，类似继承\n\n即父级作用域下的钩子函数在子作用域下也生效\n\n<a name=\"d71c5a3e\"></a>\n### 6.2 钩子函数同级分组作用域互不干扰，各起作用\n\n同作用域下将都会执行\n\n<a name=\"1bf8564e\"></a>\n### 6.3 先执行外部的钩子函数，再执行内部的钩子函数\n\n优先父级作用域下的钩子函数，其次执行子作用域下的钩子函数\n\n<a name=\"df16bf8c\"></a>\n### 6.4 在进行测试准备的时候，将对应逻辑写到钩子函数\n\n如果将对应逻辑写到了非钩子函数的位置，那么将会优先执行，然后才会执行钩子函数\n\n<a name=\"98129511\"></a>\n### 6.5 对单个测试用例的调试\n\n当一个测试文件中的测试用例变得越来越多的时候，假如此时我们相对其中某一个测试用例进行调试，那么我们就需要使用 `test.only`\n\n```jsx\ntest.only(\"测试用例\", () => {\n  expect(1 + 1).toBe(2);\n});\n```\n\n<a name=\"a0910c49\"></a>\n## 7. Jest 中的 Mock\n\n<a name=\"839e4d75\"></a>\n### 7.1 作用\n\n<a name=\"c2a650e9\"></a>\n### 7.1.1 捕获函数的调用和返回结果，以及 `this` 和调用顺序\n\n<a name=\"c18cc7ec\"></a>\n### 7.1.2 它可以让我们自由的设置返回结果\n\n<a name=\"1c8f5291\"></a>\n### 7.1.3 改变内部函数的实现\n\n<a name=\"bd204024\"></a>\n### 7.2 判定函数是否被调用\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback();\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  expect(func).toBeCalled(); // 测试用例被调用\n});\n```\n\n`jest.fn()`  可以帮助我们捕获函数的调用\n\n<a name=\"022d5da8\"></a>\n### 7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.calls.length).toBe(2); // 测试用例被调用2次\n  expect(func.mock.calls[0]).toEqual([\"张三\"]); // 测试用例传递的第一个参数是 \"张三\"\n});\n```\n\n此处打印 `func.mock`  将会打印一些常用的方法，可以根据需求进行相应的用例测试\n\n<a name=\"4b1d4193\"></a>\n### 7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  // func.mockReturnValue(\"Common\")\n  // 所有模拟返回值都是 \"Common\"\n  func.mockReturnValueOnce(\"A\"); // 第一次模拟返回值返回 \"A\"\n  func.mockReturnValueOnce(\"B\"); // 第二次模拟返回值返回 \"B\"\n  func.mockReturnValueOnce(\"C\"); // 第三次模拟返回值返回 \"C\"\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.results[0].value).toBe(\"A\");\n  expect(func.mock.results[1].value).toBe(\"B\");\n  expect(func.mock.results[2].value).toBe(\"C\");\n});\n```\n\n`func.mockReturnValue()`  将对所有模拟返回的值生效\n\n`func.mockReturnValueOnce()`  执行到第几次就对第几个函数的模拟返回值生效\n\n支持链式调用\n\n<a name=\"4d54342e\"></a>\n### 7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.invocationCallOrder).toEqual([1, 2, 3]);\n});\n```\n\n<a name=\"b4132e26\"></a>\n### 7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向\n\n```jsx\n// demo.js\nexport const createObject = (ClassItem) => {\n  new ClassItem();\n}\n\n// demo.test.js\nimport { createObject } from \"./demo\";\ntest(\"测试 createObject\", () => {\n  const func = jest.fn();\n  createObject(func);\n  expect(func.mock.instances).toEqual([mockConstructor{}]); // 此处的 this 就是 mockConstructor\n});\n```\n\n<a name=\"3daaf7be\"></a>\n### 7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  // func.mockImplementation(() => \"hello\"); 等价于 jest.fn(() => \"hello\")\n  // func.mockImplementation(() => this); 等价于 jest.fn().mockReturnThis()\n  func.mockImplementationOnce(() => \"dell\");\n  func.mockImplementationOnce(() => \"lee\");\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.results[0].value).toBe(\"dell\");\n  expect(func.mock.results[1].value).toBe(\"lee\");\n});\n```\n\n`mockImplementation`  比 `mockReturnValue`  更健壮，因为内部可以写一些额外的逻辑\n\n<a name=\"e5eee6bb\"></a>\n### 7.8 toBeCalledWith() 来判定每次函数调用时的参数\n\n```jsx\n// demo.js\nexport const runCallback = (callback) => {\n  callback(\"ABC\");\n}\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  expect(func.mock.results[0]).toEqual([\"ABC\");\n  expect(func).toBeCalledWith(\"ABC\");\n});\n```\n\n<a name=\"6c1b528b\"></a>\n### 7.9 模拟异步请求\n\n对于前端来说一般异步接口是测试是否发送了，而不测试后端接口返回的内容，是属于后端自动化测试的内容\n\n<a name=\"82bb8fdc\"></a>\n### 7.9.1 通过模拟库的方式来模拟异步测试\n\n```jsx\n// demo.js\nexport const getData = () => {\n  return axios.get(\"/api\").then(res => res.data);\n};\n\n// demo.test.js\nimport axios from \"axios\";\nimport { getData } from \"./demo\";\njest.mock(\"axios\"); // 对 axios 进行模拟，这样就不会请求真正数据\ntest(\"测试 getData\", async () => {\n  axios.get.mockResolvedValue({ data: \"hello\" }); // 使用 axios 请求的时候模拟成功的返回值就是 hello\n  await getData().then(data => {\n    expect(data).toBe(\"hello\");\n  });\n});\n```\n\n`mockResolvedValue` 模拟不限次数\n\n`mockResolvedValueOnce` 模拟一次，模拟两次就会报错，需再次调用\n\n<a name=\"4ad5bf63\"></a>\n### 7.9.2 通过模拟 Promise 方式模拟异步\n\n```jsx\n// demo.js\nexport const fetchData = () => {\n  return axios.get(\"/\").then(res => res.data);\n};\n\n// __mocks__/demo.js\nexport const fetchData = () => {\n  return new Promise((resolve, reject) => {\n    resolve(\"function() { return '123' }\");\n  });\n};\n\n// demo.test.js\njest.mock(\"./demo\");\nimport { fetchData } from \"./demo\";\ntest(\"测试fetchData\", () => {\n  return fetchData().then(data => {\n    expect(eval(data)).toEqual(\"123\");\n  });\n});\n\n/// 实现方式3\n// 修改jest.config.js 可以自动查找项目内部__mocks__下与要测试文件名字相同的文件做替换\n// 等同于 jest.mock(\"要测试文件名字相同的__mocks__下的文件\"){  automock: true; }\n```\n\n<a name=\"481f7bdb\"></a>\n### 7.9.3 通过修改 jest.config.js 来自动识别**mocks**下的文件\n\n修改 `jest.config.js` 可以自动查找项目内部 `__mocks__` 下与要测试文件名字相同的文件做替换\n\n等同于> `jest.mock(\"要测试文件名字相同的__mocks__下的文件\")`\n\n<a name=\"0c7a36bc\"></a>\n### 7.9.4 使用 jest.unmock() 可取消 mock 模拟\n\n<a name=\"768c0ac4\"></a>\n### 7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题\n\n```jsx\n// demo.js\nexport const fetchData = () => {\n  return axios.get(\"/\").then(res => res.data);\n};\nexport const getNumber = () => 123;\n\n// __mocks__/demo.js\nexport const fetchData = () => {\n  return new Promise((resolve, reject) => {\n    resolve(\"function() { return '123' }\");\n  });\n};\n\n// demo.test.js\njest.mock(\"./demo\");\nimport { fetchData } from \"./demo\";\nconst { getNumber } = jest.requireActual(\"./demo\"); // 引入真实文件\ntest(\"测试 fetchData\", () => {\n  return fetchData().then(data => {\n    expect(eval(data)).toEqual(\"123\");\n  });\n});\n\ntest(\"测试 getNumber\", () => {\n  expect(getNumber()).toEqual(123);\n});\n```\n\n<a name=\"65760d36\"></a>\n## 8. snapshot 快照测试\n\n常用于测试配置文件\n\n<a name=\"cd5ad64e\"></a>\n### 8.1 toMatchSnapshot()\n\n```jsx\n// demo.js\nexport const generateConfig = () => {\n  return {\n    server: \"http://localhost\",\n    port: 8080,\n    domain: \"localhost\"\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from \"./demo\";\ntest(\"测试 generateConfig\", () => {\n  expect(generateConfig()).toMatchSnapshot(); // 将会在项目里生成快照文件\n});\n```\n\n如果要确认更新快照，需要在控制台选择。 `u`  代表对所有快照进行更新， `i`  代表对单个确认的快照进行更新\n\n<a name=\"feac445e\"></a>\n### 8.2 测试部分可变变量的内容\n\n```jsx\n// demo.js\nexport const generateConfig = () => {\n  return {\n    server: \"http://localhost\",\n    port: 8080,\n    domain: \"localhost\",\n    time: new Date(),\n    // 可变变量\n    random: Math.random()\n    // 可变变量\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from \"./demo\";\ntest(\"测试 generateConfig\", () => {\n  expect(generateConfig()).toMatchSnapshot({\n    time: expect.any(Date),\n    random: expect.any(Number)\n  });\n});\n```\n\n<a name=\"9a1d84a3\"></a>\n### 8.3 行内的 snapshot\n\n`npm install prettier --save`\n\n可以快照放到行内的测试用例中\n\n```jsx\n// demo.js\nexport const generateConfig = () => {\n  return {\n    server: \"http://localhost\",\n    port: 8080,\n    domain: \"localhost\",\n    time: new Date(),\n    // 可变变量\n    random: Math.random()\n    // 可变变量\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from \"./demo\";\ntest(\"测试 generateConfig\", () => {\n  // toMatchInlineSnapshot 可以快照放到行内的测试用例中\n  expect(generateConfig()).toMatchInlineSnapshot({\n    time: expect.any(Date),\n    random: expect.any(Number)\n  });\n});\n```\n\n---\n\n<a name=\"23393306\"></a>\n## 9. Test Driven Development(TDD) 测试驱动开发\n\n<a name=\"ed6430cc\"></a>\n### 9.1 TDD 开发流程\n\n1. 编写测试用例（知道功能，先写测试用例）\n2. 运行测试，测试用例无法通过测试\n3. 编写代码，使测试用例通过测试\n4. 优化代码， 完成开发\n5. 新增功能，重复执行 1-4\n\n<a name=\"3c65ae93\"></a>\n### 9.2 TDD 的优势\n\n1. 长期减少项目的回归 bug（减少修改代码产生的 bug）\n2. 代码质量更好（组织，可维护性好）\n3. 测试覆盖率高（因为是先编写测试用例，但测试覆盖率过高会影响很大精力）\n4. 错误测试代码不容易出现\n\n<a name=\"3ecdd7a1\"></a>\n### 9.3 TDD 的适用场景\n\n1. 不适用于开发业务代码时使用（开发业务代码时会大量的与业务代码产生耦合，加大工作量）\n2. 适用于一些库的开发（开发库时代码耦合度较低，通常只处理函数等相关功能）\n\n---\n\n<a name=\"59f902bb\"></a>\n## 10. Behavior Driven Development(BDD) 行为驱动开发\n\n<a name=\"6733a7a6\"></a>\n### 10.1 BDD 开发流程\n\n1. 先编写业务代码，不关心测试\n2. 思考并描述用户行为\n3. 根据用户行为模拟测试\n\n<a name=\"f821175c\"></a>\n### 10.2 vue example\n\n```jsx\n/// testUtils.js\nexport const findTestWrapper = (wrapper, tag) => {\n  return wrapper.find(`[data-test=\"${tag}\"]`);\n};\n```\n\n```jsx\n/// __tests__/integration/TodoList.test.js\nimport { mount } from \"@vue/test-utils\";\nimport { findTestWrapper } from \"../../../../utils/testUtils\";\nimport TodoList from \"../../TodoList\";\n// import store from \"../../../../store\"\nit(`    \n 新增内容逻辑的集成测试    \n 1. 用户会在header输入框输入内容    \n 2. 用户会点击回车按钮  \n 3. 列表项应该增加用户输入内容的列表项`, () => {\n  const wrapper = mount(TodoList);\n  // const wrapper = mount(TodoList, { store })\n  // 如果使用 vuex，也几乎无改动\n  const inputElem = findTestWrapper(wrapper, \"header-input\").at(0);\n  const content = \"Dell lee\";\n  inputElem.setValue(content);\n  inputElem.trigger(\"change\");\n  inputElem.trigger(\"keyup.enter\");\n  const listItems = findTestWrapper(wrapper, \"list-item\").at(0);\n  expect(listItems.length).toBe(1);\n  expect(listItems.at(0).text()).toContain(content);\n});\n```\n\n<a name=\"9b16dd87\"></a>\n### 10.3 react example\n\n```jsx\n/// testUtils.js\nexport const findTestWrapper = (wrapper, tag) => {\n  return wrapper.find(`[data-test=\"${tag}\"]`);\n};\n```\n\n```jsx\n/// __tests__/integration/TodoList.test.js\nimport React from \"react\";\n// import { Provider } from \"react-redux\";\nimport Enzyme, { mount } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport TodoList from \"../../TodoList\";\n// import store from \"../../../../store/createStore\";\nEnzyme.configure({ adapter: new Adapter() });\n\nit(`\n    新增内容逻辑的集成测试\n    1. 用户会在header输入框输入内容\n    2. 用户会点击回车按钮\n   3. 列表项应该增加用户输入内容的列表项\n`, () => {\n  const wrapper = mount(<TodoList />);\n  /** \n  const wrapper = mount(\n   <Provider store={store}>\n    <TodoList /></Provider>\n   </Provider>\n  )  \n  // 如果使用 redux，也几乎无改动\n */\n  const inputElem = findTestWrapper(wrapper, \"header-input\");\n  const content = \"Dell lee\";\n  inputElem.simulate(\"change\", { target: { value: content } });\n  inputElem.simulate(\"keyUp\", { keyCode: 13 });\n  const listItems = findTestWrapper(wrapper, \"list-item\");\n  expect(listItems.length).toBe(1);\n  expect(listItems.text()).toContain(content);\n});\n```\n\n---\n\n<a name=\"c2aee4b0\"></a>\n## 11. TDD 和 BDD 的对比\n\n1. `TDD` 先写测试后写代码; `BDD` 先写代码后写测试\n2. `TDD` 创建的是 `unit` 单元测试文件夹，一般结合单元测试，属于白盒测试(知道实现测试代码); `BDD` 创建的是 `integration` 集成测试文件夹，一般结合集成测试，属于黑盒测试(不知道实现测试代码)\n3. `TDD` 测试重点在代码; `BDD` 测试重点在 `UI` ( `DOM`)\n4. `TDD` 安全感低(无法保证各个组件拼撞到一起是否不会有问题); `BDD` 安全感高\n5. `TDD` 速度快; `BDD` 速度慢\n\n---\n\n<a name=\"1f761f1e\"></a>\n## 12. TDD 与 BDD 混用\n\n<a name=\"11f73608\"></a>\n### 12.1 对一些工具函数的测试\n\n<a name=\"4767b160\"></a>\n### 12.2 对 vuex 的 store 进行测试\n\n```jsx\n/// __tests__/unit/store.test.js\nimport store from \"../../../../store\";\nit(\"当 store 接受 changeInputValue 的 commit 时, inputValue 发生变化\", () => {\n  const value = \"123\";\n  store.commit(\"changeInputValue\", value);\n  expect(store.state.inputValue).toBe(value);\n});\n```\n\n<a name=\"05a2b125\"></a>\n### 12.3 对 redux 的 store 进行测试\n\n```jsx\n/// __tests__/unit/store.test.js\nimport store from \"../../../../store/createStore\";\nimport { changeInputValue } from \"../../../../store/actions\";\nit(\"当 store 接受 changeInputValue 的 dispatch 时, inputValue 发生变化\", () => {\n  const value = \"123\";\n  /**   \n  const changeInputValue = (payload) => ({ \n   type: CHANGE_IMPUT_VALUE, payload \n  })   \n */\n  store.dispatch(changeInputValue(value));\n  expect(store.getState().inputValue).toBe(value);\n});\n```\n\n---\n\n<a name=\"71b9d92e\"></a>\n## 13. 异步测试\n\n注意：异步测试如果用到了异步函数，则需要调用 `done`  函数\n\n<a name=\"e3e302bb\"></a>\n### 13.1 vue 的异步测试\n\n```javascript\n/// __mocks__/axios.js\nconst undoList = {  success: true,  data: [\n { status: \"div\", value: \"dell\" },\n { status: \"div\", value: \"lee\" }\n]};\nexport default {\n get(url) {\n  if (url === \"/getUndoList.json\") {\n   return new Promise((resolve, reject) => {\n    if (this.success === true) {\n     resolve(undoList);\n    } else {\n     reject(new Error());\n    }\n   });\n  }\n }};\n\n/// __tests__/integration/TodoList.test.js\nimport { mount } from \"@vue/test-utils\";\nimport { findTestWrapper } from \"../../../../utils/testUtils\";\nimport TodoList from \"../../TodoList\";\nimport store from \"../../../../store\";\n\nbeforeEach(() => {\n axios.success = true;\n jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响});\nit(`1. 用户进入页面时，请求远程测试; 2. 列表应该显示远程返回的数据`, done => {\n  const wrapper = mount(TodoList, { store });\n  wrapper.vm.$nickTick(() => {\n   const listItems = findTestWrapper(wrapper, \"list-item\");\n   expect(listItems.length).toBe(2);\n   done();\n  });\n });\nit(`1. 用户进入页面时，等待5s; 2. 列表应该显示远程返回的数据`, done => {\n const wrapper = mount(TodoList, { store });\n expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n jest.runAllTimers();\n wrapper.vm.$nickTick(() => {\n  const listItems = findTestWrapper(wrapper, \"list-item\");\n  expect(listItems.length).toBe(2);\n  done();\n });\n});\n\nit(`1. 用户进入页面时，请求远程数据失败; 2. 列表应该显示空数据，不应该挂掉`, done => {\n axios.success = false;\n const wrapper = mount(TodoList, { store });\n expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n jest.runAllTimers();\n wrapper.vm.$nickTick(() => {\n  const listItems = findTestWrapper(wrapper, \"list-item\");\n  expect(listItems.length).toBe(0);\n  done();\n });\n});\n```\n\n<a name=\"833ac6cf\"></a>\n### 13.2 react 的异步测试\n\n```jsx\n/// __mocks__/axios.js\nconst undoList = {\n  success: true,\n  data: [\n    { status: \"div\", value: \"dell\" },\n    { status: \"div\", value: \"lee\" }\n  ]\n};\n\nexport default {\n  get(url) {\n    if (url === \"/getUndoList.json\") {\n      return new Promise((resolve, reject) => {\n        if (this.success === true) {\n          resolve(undoList);\n        } else {\n          reject(new Error());\n        }\n      });\n    }\n  }\n};\n\n/// __tests__/integration/TodoList.test.js\nimport React from \"react\";\nimport { Provider } from \"react-redux\";\nimport Enzyme, { mount } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport TodoList from \"../../TodoList\";\nimport store from \"../../../../store/createStore\";\nEnzyme.configure({ adapter: new Adapter() });\n\nbeforeEach(() => {\n  axios.success = true;\n  jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响\n});\n\nit(`\n    1. 用户进入页面时，请求远程测试\n    2. 列表应该显示远程返回的数据\n`, done => {\n  const wrapper = mount(\n    <Provider store={store}>\n      <TodoList />\n    </Provider>\n  );\n  process.nickTick(() => {\n    wrapper.update();\n    const listItems = findTestWrapper(wrapper, \"list-item\");\n    expect(listItems.length).toBe(2);\n    done();\n  });\n});\n\nit(`\n    1. 用户进入页面时，等待5s\n    2. 列表应该显示远程返回的数据\n`, done => {\n  const wrapper = mount(\n    <Provider store={store}>\n      <TodoList />\n    </Provider>\n  );\n  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n  jest.runAllTimers();\n  process.nickTick(() => {\n    wrapper.update(); // 更新 wrapper 防止取上一次的 wrapper\n    const listItems = findTestWrapper(wrapper, \"list-item\");\n    expect(listItems.length).toBe(2);\n    done();\n  });\n});\n\nit(`\n  1. 用户进入页面时，请求远程数据失败\n  2. 列表应该显示空数据，不应该挂掉\n`, done => {\n  axios.success = false;\n  const wrapper = mount(\n    <Provider store={store}>\n      <TodoList />\n    </Provider>\n  );\n  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n  jest.runAllTimers();\n  process.nickTick(() => {\n    wrapper.update();\n    const listItems = findTestWrapper(wrapper, \"list-item\");\n    expect(listItems.length).toBe(0);\n    done();\n  });\n});\n```\n\n---\n\n<a name=\"63ab0b81\"></a>\n## 14. vue 项目的自动化测试\n\n<a name=\"7740ff83\"></a>\n### 14.1 使用传统方式对 vue 组件进行测试\n\n```jsx\n// HelloWorld.test.js\nimport Vue from \"vue\";\nimport HelloWorld from \"@/components/HelloWorld\";\ndescribe(\"HelloWorld.vue\", () => {\n  it(\"renders props.msg when passed\", () => {\n    const root = document.createElement(\"div\");\n    root.className = \"root\";\n    document.body.appendChild(root);\n    new Vue({\n      render: h =>\n        h(HelloWorld, {\n          props: {\n            msg: \"dell lee\"\n          }\n        })\n    }).$mount(\".root\");\n    expect(document.getElementByClassName(\"hello\").length).toBe(1);\n  });\n});\n```\n\n缺点：写法过于复杂，局限性也很大，部分属性无法进行测试\n\n<a name=\"9f92aeab\"></a>\n### 14.2 使用 @vue/test-utils 对 vue 组件进行测试\n\n- [官方文档](https://vue-test-utils.vuejs.org/zh/)\n\n<a name=\"474de05c\"></a>\n### 14.2.1 for example\n\n```jsx\n// HelloWorld.test.js\nimport { shallowMount } from \"@vue/test-utils\";\nimport HelloWorld from \"@/components/HelloWorld\";\ndescribe(\"HelloWorld.vue\", () => {\n  it(\"renders props.msg when passed\", () => {\n    const msg = \"dell lee\";\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: { msg }\n    });\n    expect(wrapper.text()).toMatch(msg);\n  });\n});\n```\n\n<a name=\"42aa9119\"></a>\n### 14.2.2 快照测试\n\n使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听\n\n好处: 可以帮助我们及时发现组件中 `dom` 结构的变化\n\n```jsx\n// HelloWorld.test.js\nimport { shallowMount } from \"@vue/test-utils\";\nimport HelloWorld from \"@/components/HelloWorld\";\ndescribe(\"HelloWorld.vue 组件渲染正常\", () => {\n  it(\"renders props.msg when passed\", () => {\n    const msg = \"dell lee\";\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: { msg }\n    });\n    expect(wrapper).toMatchSnapshot();\n  });\n});\n```\n\n---\n\n<a name=\"245d2d6a\"></a>\n## 15. react 项目的自动化测试\n\n<a name=\"a85bc8fa\"></a>\n### 15.1 使用传统方式对 react 组件进行测试\n\n```jsx\n// App.test.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nit(\"render App\", () => {\n  const div = document.createElement(\"div\");\n  ReactDOM.render(<App />, div);\n  const container = div.getElementsByClassName(\"App\");\n  expect(container.length).toBe(1);\n});\n```\n\n缺点：写法过于复杂，局限性也很大，部分属性无法进行测试\n\n<a name=\"b54705b0\"></a>\n### 15.2 enzyme 的配置和使用\n\n- [官方文档](https://enzymejs.github.io/enzyme/)\n- [github](https://github.com/enzymejs/enzyme)\n- [jest-enzyme](https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-enzyme)\n\n<a name=\"2edd525d\"></a>\n### 15.2.1 for example\n\n```jsx\n// App.test.js\nimport React from \"react\";\nimport Enzyme, { shallow } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport App from \"App\";\nEnzyme.configure({ adapter: new Adapter() });\nit(\"render App\", () => {\n  const wrapper = shallow(<App />);\n  expect(wrapper.find('[data-test=\"App\"]').length).toBe(2);\n});\n```\n\n使用自定义 `props` 可以降低代码耦合度\n\n`shallow` 适合单元测试，属于浅渲染； `mount` 适合集成测试，会将当前组件包括其子组件一起渲染\n\n单元测试时更倾向于使用 `api` `.state()` ；集成测试时更倾向于使用 `api` `.prop()`\n\n<a name=\"c14005d5\"></a>\n### 15.2.2 快照测试\n\n使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听\n\n好处: 可以帮助我们及时发现组件中 `dom` 结构的变化\n\n```jsx\n// App.test.js\nimport React from \"react\";\nimport Enzyme, { shallow } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport App from \"App\";\nEnzyme.configure({ adapter: new Adapter() });\nit(\"render App\", () => {\n  const wrapper = shallow(<App />);\n  expect(wrapper).toMatchSnapshot();\n});\n```\n\n---\n\n<a name=\"efea21cb\"></a>\n## 16. 前端自动化测试的优势\n\n- 更好的代码组织，项目的可维护性强\n- 更少的 `Bug` 出现概率，尤其是回归测试中的 `Bug`\n- 修改工程质量差的项目，更加安全\n- 项目具备潜在的文档特性\n- 扩展前端的知识面\n\n<a name=\"5215b451\"></a>\n## 17 总结重要的点\n\n1. `BDD` 和 `TDD`\n2. 集成测试 和 单元测试\n3. 测试和业务的解耦\n4. 代码测试覆盖率并不代表一定靠谱\n5. 功能性测试 和 `UI`测试\n6. 测试越独立，隐藏的问题就越多\n",
  "body_html": "<!doctype html><a name=\"前端自动化测试\"></a><h1 id=\"1cc518ba\">前端自动化测试</h1><p><br /></p><a name=\"1.-单元测试\"></a><h2 id=\"e06fdbee\">1. 单元测试</h2><p><br /></p><p>对软件中的最小可测试单元进行检查和验证，在前端一般为一个模块。</p><p><br /></p><a name=\"1.1-单元测试的优缺点\"></a><h3 id=\"759aac61\">1.1 单元测试的优缺点</h3><p><br /></p><ol start=\"1\"><li>测试覆盖率高</li></ol><ol start=\"2\"><li>业务耦合度高</li></ol><ol start=\"3\"><li>代码量大</li></ol><ol start=\"4\"><li>过于独立</li></ol><p><br /></p><a name=\"1.2-总结\"></a><h3 id=\"7b50fee4\">1.2 总结</h3><p><br /></p><p>在某些场景下适合适用单元测试，某些场景下不适合适用单元测试</p><p><br /></p><a name=\"2.-集成测试\"></a><h2 id=\"2f883435\">2. 集成测试</h2><p><br /></p><p>又叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。</p><p><br /></p><a name=\"3.-jest-中的匹配器\"></a><h2 id=\"e0cc0593\">3. jest 中的匹配器</h2><p><br /></p><p><a href=\"https://jestjs.io/docs/en/expect\" target=\"_blank\">jest 匹配器官网</a></p><p><br /></p><p>修改 <code>jest</code>  默认配置命令 <code>npx jest --init</code></p><p><br /></p><a name=\"3.1-实时监听测试用例的改变\"></a><h3 id=\"e489b565\">3.1 实时监听测试用例的改变</h3><p><br /></p><p><code>jest --watchAll</code> 一旦某个测试用例发生变化，所有的测试用例都将会重新执行</p><p><br /></p><p><code>jest --watch</code>  默认进入 <code>o</code>  模式，即只对发生变化的测试用例重新执行</p><p><br /></p><a name=\"3.2-常用匹配器\"></a><h3 id=\"9278cb4c\">3.2 常用匹配器</h3><p><br /></p><a name=\"3.2.1-toBe()\"></a><h3 id=\"d21eba22\">3.2.1 toBe()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBe的匹配器&quot;, () =&gt; {\n  const a = { name: &quot;张三&quot; };\n  expect(a).toBe({ name: &quot;张三&quot; });\n});\n// ❌ 因为引用类型使用toBe不是全等效果</code></pre><p><br /></p><p><code>toBe</code> 匹配器类似于 <code>===</code>。</p><hr /><a name=\"3.2.2-toEqual()\"></a><h3 id=\"9ba722f8\">3.2.2 toEqual()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toEqual的匹配器&quot;, () =&gt; {\n  const a = { name: &quot;张三&quot; };\n  expect(a).toBe({ name: &quot;张三&quot; });\n});\n// ✅ 因为toEqual只是对结果的匹配，而不是全等效果</code></pre><p><br /></p><p><code>toEqual</code> 匹配器只是对结果相等与否进行匹配</p><hr /><a name=\"3.2.3-toBeNull()\"></a><h3 id=\"5b2da47a\">3.2.3 toBeNull()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeNull的匹配器&quot;, () =&gt; {\n  const a = null;\n  expect(a).toBeNull();\n});\n// ✅</code></pre><p><br /></p><p><code>toBeNull</code> 是对 <code>null</code> 值的匹配</p><hr /><a name=\"3.2.4-toBeUndefined()\"></a><h3 id=\"4f58955d\">3.2.4 toBeUndefined()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeUndefined的匹配器&quot;, () =&gt; {\n  const a = undefined;\n  expect(a).toBeUndefined();\n});\n// ✅</code></pre><p><br /></p><p><code>toBeUndefined</code> 是对 <code>undefined</code> 值的匹配</p><hr /><a name=\"3.2.5-toBeDefined()\"></a><h3 id=\"aa717d1f\">3.2.5 toBeDefined()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeDefined的匹配器&quot;, () =&gt; {\n  const a = 1;\n  expect(a).toBeDefined();\n});\n// ✅</code></pre><p><br /></p><p><code>toBeDefined</code> 是对已经定义的值的匹配，若为 <code>undefined</code> 则不通过</p><hr /><a name=\"3.2.6-toBeTruthy()\"></a><h3 id=\"3e22cb95\">3.2.6 toBeTruthy()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeTruthy的匹配器&quot;, () =&gt; {\n  const a = 0;\n  expect(a).toBeTruthy();\n});\n// 0 =&gt; ❌，因为 toBeTruthy 是对 true 值的匹配\n// 1 =&gt; ✅</code></pre><p><br /></p><p><code>toBeTruthy</code> 是对 <code>true</code> 值的匹配</p><hr /><a name=\"3.2.7-toBeFalsy()\"></a><h3 id=\"daa53386\">3.2.7 toBeFalsy()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeFalsy的匹配器&quot;, () =&gt; {\n  const a = 1;\n  expect(a).toBeFalsy();\n});\n// 1 =&gt; ❌\n// 0 =&gt; ✅</code></pre><p><br /></p><p><code>toBeFalsy</code> 是对 <code>false</code> 值的匹配</p><hr /><a name=\"3.2.8-toBeGreaterThan()\"></a><h3 id=\"95777fd5\">3.2.8 toBeGreaterThan()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeGreaterThan匹配器&quot;, () =&gt; {\n  const count = 10;\n  expect(a).toBeGreaterThan(9);\n});\n// ✅</code></pre><p><br /></p><p><code>toBeGreaterThan</code> 相当于 <code>&gt;</code></p><hr /><a name=\"3.2.9-toBeLessThan()\"></a><h3 id=\"5ed81d3a\">3.2.9 toBeLessThan()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeLessThan匹配器&quot;, () =&gt; {\n  const count = 8;\n  expect(a).toBeLessThan(9);\n});\n// ✅</code></pre><p><br /></p><p><code>toBeLessThan</code> 相当于 <code>&lt;</code></p><hr /><a name=\"3.2.10-toBeGreaterThanOrEqual()\"></a><h3 id=\"1f0e8517\">3.2.10 toBeGreaterThanOrEqual()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeGreaterThanOrEqual匹配器&quot;, () =&gt; {\n  const count = 10;\n  expect(a).toBeGreaterThanOrEqual(10);\n});\n// ✅</code></pre><p><br /></p><p><code>toBeGreaterThanOrEqual</code> 相当于 <code>&gt;=</code></p><hr /><a name=\"3.2.11-toBeLessThanOrEqual()\"></a><h3 id=\"d137001e\">3.2.11 toBeLessThanOrEqual()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeLessThanOrEqual匹配器&quot;, () =&gt; {\n  const count = 10;\n  expect(a).toBeLessThanOrEqual(10);\n});\n// ✅</code></pre><p><br /></p><p><code>toBeLessThanOrEqual</code> 相当于 <code>&lt;=</code></p><hr /><a name=\"3.2.12-toBeCloseTo()\"></a><h3 id=\"bb417baa\">3.2.12 toBeCloseTo()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toBeCloseTo匹配器&quot;, () =&gt; {\n  const one = 0.1;\n  const two = 0.2;\n  expect(one + two).toEqual(0.3);\n});\n// ❌ 因为浮点精度不同\n\ntest(&quot;测试toBeCloseTo匹配器&quot;, () =&gt; {\n  const one = 0.1;\n  const two = 0.2;\n  expect(one + two).toBeCloseTo(0.3);\n});\n// ✅</code></pre><p><br /></p><p><code>toBeCloseTo</code> 为了解决浮点精度不同导致的无法匹配的问题</p><hr /><a name=\"3.2.13-toMatch()\"></a><h3 id=\"3d3d7425\">3.2.13 toMatch()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toMatch匹配器&quot;, () =&gt; {\n  const str = &quot;张三、李四、王五&quot;;\n  expect(str).toMatch(&quot;李四&quot;);\n});\n// ✅\n\ntest(&quot;测试toMatch匹配器&quot;, () =&gt; {\n  const str = &quot;张三、李四、王五&quot;;\n  expect(str).toMatch(/李四/);\n});\n// ✅</code></pre><p><br /></p><p><code>toMatch</code> 为字符串包含匹配器，用来匹配字符串中包含的内容，也可传正则表达式</p><hr /><a name=\"3.2.14-toContain()\"></a><h3 id=\"0e7662e8\">3.2.14 toContain()</h3><p><br /></p><pre data-lang=\"jsx\"><code>test(&quot;测试toContain匹配器&quot;, () =&gt; {\n  const arr = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];\n  expect(arr).toContain(&quot;张三&quot;);\n});\n// ✅\n\ntest(&quot;测试toContain匹配器&quot;, () =&gt; {\n  const arr = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];\n  const data = new Set(arr);\n  expect(data).toContain(&quot;张三&quot;);\n});</code></pre><p><br /></p><p><code>toContain</code> 为数据包含匹器，用来匹配数组中包含的项。同时可完全兼容 <code>Set</code> 测试</p><hr /><a name=\"3.2.15-toHaveLength()\"></a><h3 id=\"2d803288\">3.2.15 toHaveLength()</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// functions.js\nexport default {\n  getIntArray(num) {\n    if (!Number.isInteger(num)) {\n      throw Error('&quot;getIntArray&quot;只接受整数类型的参数');\n    }\n    let result = [];\n    for (let i = 0, len = num; i &lt; len; i++) {\n      result.push(i);\n    }\n    return result;\n  }\n};\n\n/// functions.test.js\nimport { getIntArray } from &quot;../src/functions&quot;;\ntest(&quot;getIntArray(3)返回的数组长度应该为3&quot;, () =&gt; {\n  expect(getIntArray(3)).toHaveLength(3);\n});</code></pre><p><br /></p><p><code>toHaveLength</code>可以很方便的用来测试字符串和数组类型的长度是否满足预期。</p><p><br /></p><a name=\"3.2.16-toThrow()\"></a><h3 id=\"c34e47a0\">3.2.16 toThrow()</h3><p><br /></p><pre data-lang=\"jsx\"><code>const throwNewErrorFunc = () =&gt; {\n  throw new Error(&quot;this is a new error&quot;);\n};\n\ntest(&quot;测试toThrow匹配器&quot;, () =&gt; {\n  expect(throwNewErrorFunc).toThrow();\n});</code></pre><p><br /></p><p><code>toThrow</code> 是专门对异常进行处理的匹配器，可以检测一个方法会不会抛出异常</p><p><br /></p><pre data-lang=\"jsx\"><code>const throwNewErrorFunc = () =&gt; {\n  throw new Error(&quot;this is a new error&quot;);\n};\n\ntest(&quot;测试toThrow匹配器&quot;, () =&gt; {\n  expect(throwNewErrorFunc).toThrow(&quot;this is a new error&quot;);\n});</code></pre><p><br /></p><p>我们也可以对这个匹配器中加一些字符串，意思就是抛出的异常必须和字符串相对应，如果字符串不匹配，也没办法通过异常测试。</p><hr /><a name=\"3.2.17-not()\"></a><h3 id=\"764f06c9\">3.2.17 not()</h3><p><br /></p><pre data-lang=\"jsx\"><code>const throwNewErrorFunc = () =&gt; {\n  throw new Error(&quot;this is a new error&quot;);\n};\n\ntest(&quot;测试not匹配器&quot;, () =&gt; {\n  expect(throwNewErrorFunc).not.toThrow();\n});</code></pre><p><br /></p><p><code>not</code> 匹配器是 <code>jest</code> 中比较特殊的匹配器，意思就是 “相反” 或者说 “取反” .比如上面的例子，我们不希望方法抛出异常，就可以使用<code>not</code> 匹配器。</p><hr /><a name=\"3.3-异步代码测试方法\"></a><h3 id=\"3babda61\">3.3 异步代码测试方法</h3><p><br /></p><a name=\"3.3.1-回调函数式\"></a><h3 id=\"1891407f\">3.3.1 回调函数式</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// fetchData.js\nimport axios from &quot;axios&quot;;\nexport const fetchData = fn =&gt; {\n  axios.get(&quot;http://a.jspang.com/jestTest.json&quot;).then(res =&gt; {\n    fn(res.data);\n  });\n};\n\n/// fetchData.test.js\nimport { fetchData } from &quot;./fetchData.js&quot;;\ntest(&quot;fetchData测试&quot;, done =&gt; {\n  fetchData(data =&gt; {\n    expect(data).toEqual({ success: true });\n    done();\n  });\n});</code></pre><p><br /></p><p>必须加入一个 <code>done</code> 方法，保证我们的回调已经完成了，这时候我们表示测试完成</p><hr /><a name=\"3.3.2-直接返回-Promise\"></a><h3 id=\"0ad6b7b2\">3.3.2 直接返回 Promise</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// fetchTwoData.js\nimport axios from &quot;axios&quot;;\nexport const fetchTwoData = () =&gt; axios.get(&quot;http://a.jspang.com/jestTest.json&quot;;\n\n/// fetchTwoData.test.js\nimport { fetchTwoData } from &quot;./fetchTwoData.js&quot;;\ntest(&quot;fetchTwoData的测试用例&quot;, () =&gt; {\n return fetchTwoData().then(res =&gt; {\n  expect(res.data).toEqual({ success: true });\n });\n});</code></pre><p><br /></p><p>注意要 <code>return</code></p><p><br /></p><a name=\"3.3.3-不存在的接口\"></a><h3 id=\"83b4fa78\">3.3.3 不存在的接口</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// fetchData.js\nexport const fetchData = () =&gt; {\n  return axios.get(&quot;http://a.jspang.com/jestTest_error.json&quot;); // 此地址并不存在\n};\n\n/// fetchData.test.js\n// 方式1\ntest(&quot;fetchData测试&quot;, () =&gt; {\n  expect.assertions(1); // 断言，必须执行一次 expect\n  return fetchData().catch(err =&gt; {\n    expect(err.toString().indexOf(&quot;404&quot;) &gt; -1).toBe(true);\n  });\n});\n\n// 方式2\ntest(&quot;fetchData测试&quot;, async () =&gt; {\n  return await fetchData().rejects.toThrow();\n});\n\n// 方式3\ntest(&quot;fetchData测试&quot;, async () =&gt; {\n  expect().assertions(1); // 断言，必须执行一次 expect\n  try {\n    await fetchData();\n  } catch (err) {\n    expect(err.toString().indexOf(&quot;404&quot;) &gt; -1).toBe(true);\n  }\n});</code></pre><p><br /></p><p>因为测试用例使用了 <code>catch</code> 方法，也就是说只有出现异常的时候才会走这个方法，而现在没有出现异常，就不会走这个测试方法，<code>jest</code> 就默认这个用例通过了测试。因此必须要执行断言，即必须让其执行一次即可。</p><p><br /></p><a name=\"3.3.4-async-await\"></a><h3 id=\"001d5d5a\">3.3.4 async/await</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// fetchData.js\nexport const fetchData = () =&gt; {\n return axios.get(&quot;http://a.jspang.com/jestTest.json&quot;); // 此地址并不存在};\n\n/// fetchData.test.js\n// 方式1\ntest(&quot;fetchData测试&quot;, async () =&gt; {\n await expect(fetchData()).resolves.toMatchObject({\n  data: {\n   success: true\n  }\n });\n});\n\n// 方式2\ntest(&quot;fetchData测试&quot;, async () =&gt; {\n const response = await fetchData();\n expect(response.data).toEqual({ success: true });\n});</code></pre><p><br /></p><p>这时候我们的代码使用 <code>async....await...</code> 的形式，这里我们还使用了 <code>resolves</code> 用于把现有对象转换成 <code>Promise</code> 对象，然后使用 <code>jest</code> 中的 <code>toMatchObject</code> 进行匹配对象中的属性。</p><p><br /></p><a name=\"4.-jest-中的四个钩子函数\"></a><h2 id=\"9ead1173\">4. jest 中的四个钩子函数</h2><p><br /></p><a name=\"4.1-beforeAll()\"></a><h3 id=\"44253391\">4.1 beforeAll()</h3><p><br /></p><p><code>beforeAll()</code>钩子函数的意思是在所有测试用例之前进行执行。</p><p><br /></p><a name=\"4.2-afterAll()\"></a><h3 id=\"e43fb792\">4.2 afterAll()</h3><p><br /></p><p><code>afterAll()</code>钩子函数是在完成所有测试用例之后才执行的函数。</p><p><br /></p><a name=\"4.3-beforeEach()\"></a><h3 id=\"b6bb2f69\">4.3 beforeEach()</h3><p><br /></p><p><code>beforeEach()</code>钩子函数，是在每个测试用例前都会执行一次的钩子函数。</p><p><br /></p><a name=\"4.4-afterEach()\"></a><h3 id=\"4208beab\">4.4 afterEach()</h3><p><br /></p><p><code>afterEach()</code>钩子函数，是在每次测试用例完成测试之后执行一次的钩子函数。</p><p><br /></p><a name=\"5.-jest-测试用例分组\"></a><h2 id=\"7c331432\">5. jest 测试用例分组</h2><p><br /></p><pre data-lang=\"jsx\"><code>/// eat.js\nexport default class Eat {\n  setName(number) {\n    this.name = number === 1 ? &quot;水饺&quot; : &quot;火锅&quot;;\n  }\n  setDesc() {\n    this.desc = this.user + &quot;描述&quot;;\n  }\n  setMoney() {\n    this.money = this.name === &quot;水饺&quot; ? 80 : 300;\n  }\n}\n\n/// eat.test.js\nimport Eat from &quot;./eat&quot;;\nconst eat = new Eat();\nbeforeAll(() =&gt; {\n  console.log(&quot;开始吃饭&quot;);\n});\nafterAll(() =&gt; {\n  console.log(&quot;吃完饭了&quot;);\n});\ndescribe(&quot;水饺相关内容&quot;, () =&gt; {\n  test(&quot;测试水饺描述&quot;, () =&gt; {\n    eat.setName(1);\n    eat.setDesc();\n    expect(eat.desc).toEqual(&quot;水饺描述&quot;);\n  });\n  test(&quot;测试水饺价格&quot;, () =&gt; {\n    eat.setName(1);\n    eat.setMoney();\n    expect(eat.money).toEqual(80);\n  });\n});\ndescribe(&quot;火锅相关内容&quot;, () =&gt; {\n  test(&quot;测试火锅描述&quot;, () =&gt; {\n    eat.setName(2);\n    eat.setDesc();\n    expect(eat.desc).toEqual(&quot;火锅描述&quot;);\n  });\n  test(&quot;测试火锅价格&quot;, () =&gt; {\n    eat.setName(2);\n    eat.setMoney();\n    expect(eat.money).toEqual(300);\n  });\n});</code></pre><p><br /></p><a name=\"6.-钩子函数的作用域\"></a><h2 id=\"49e6c15a\">6. 钩子函数的作用域</h2><p><br /></p><a name=\"6.1-钩子函数在父级分组可作用域子集，类似继承\"></a><h3 id=\"45e52b93\">6.1 钩子函数在父级分组可作用域子集，类似继承</h3><p><br /></p><p>即父级作用域下的钩子函数在子作用域下也生效</p><p><br /></p><a name=\"6.2-钩子函数同级分组作用域互不干扰，各起作用\"></a><h3 id=\"d71c5a3e\">6.2 钩子函数同级分组作用域互不干扰，各起作用</h3><p><br /></p><p>同作用域下将都会执行</p><p><br /></p><a name=\"6.3-先执行外部的钩子函数，再执行内部的钩子函数\"></a><h3 id=\"1bf8564e\">6.3 先执行外部的钩子函数，再执行内部的钩子函数</h3><p><br /></p><p>优先父级作用域下的钩子函数，其次执行子作用域下的钩子函数</p><p><br /></p><a name=\"6.4-在进行测试准备的时候，将对应逻辑写到钩子函数\"></a><h3 id=\"df16bf8c\">6.4 在进行测试准备的时候，将对应逻辑写到钩子函数</h3><p><br /></p><p>如果将对应逻辑写到了非钩子函数的位置，那么将会优先执行，然后才会执行钩子函数</p><p><br /></p><a name=\"6.5-对单个测试用例的调试\"></a><h3 id=\"98129511\">6.5 对单个测试用例的调试</h3><p><br /></p><p>当一个测试文件中的测试用例变得越来越多的时候，假如此时我们相对其中某一个测试用例进行调试，那么我们就需要使用 <code>test.only</code></p><p><br /></p><pre data-lang=\"jsx\"><code>test.only(&quot;测试用例&quot;, () =&gt; {\n  expect(1 + 1).toBe(2);\n});</code></pre><p><br /></p><a name=\"7.-Jest-中的-Mock\"></a><h2 id=\"a0910c49\">7. Jest 中的 Mock</h2><p><br /></p><a name=\"7.1-作用\"></a><h3 id=\"839e4d75\">7.1 作用</h3><p><br /></p><a name=\"7.1.1-捕获函数的调用和返回结果，以及--code-this--code--和调用顺序\"></a><h3 id=\"c2a650e9\">7.1.1 捕获函数的调用和返回结果，以及 <code>this</code> 和调用顺序</h3><p><br /></p><a name=\"7.1.2-它可以让我们自由的设置返回结果\"></a><h3 id=\"c18cc7ec\">7.1.2 它可以让我们自由的设置返回结果</h3><p><br /></p><a name=\"7.1.3-改变内部函数的实现\"></a><h3 id=\"1c8f5291\">7.1.3 改变内部函数的实现</h3><p><br /></p><a name=\"7.2-判定函数是否被调用\"></a><h3 id=\"bd204024\">7.2 判定函数是否被调用</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const runCallback = callback =&gt; {\n  callback();\n};\n\n// demo.test.js\nimport { runCallback } from &quot;./demo&quot;;\ntest(&quot;测试 runCallback&quot;, () =&gt; {\n  const func = jest.fn();\n  runCallback(func);\n  expect(func).toBeCalled(); // 测试用例被调用\n});</code></pre><p><br /></p><p><code>jest.fn()</code>  可以帮助我们捕获函数的调用</p><p><br /></p><a name=\"7.3-jest.fn().mock.calls-判定函数被调用了几次和传递的参数\"></a><h3 id=\"022d5da8\">7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const runCallback = callback =&gt; {\n  callback(&quot;张三&quot;);\n};\n\n// demo.test.js\nimport { runCallback } from &quot;./demo&quot;;\ntest(&quot;测试 runCallback&quot;, () =&gt; {\n  const func = jest.fn();\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.calls.length).toBe(2); // 测试用例被调用2次\n  expect(func.mock.calls[0]).toEqual([&quot;张三&quot;]); // 测试用例传递的第一个参数是 &quot;张三&quot;\n});</code></pre><p><br /></p><p>此处打印 <code>func.mock</code>  将会打印一些常用的方法，可以根据需求进行相应的用例测试</p><p><br /></p><a name=\"7.4-jest.fn().mockReturnValue()-判定函数执行了几次和返回结果\"></a><h3 id=\"4b1d4193\">7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const runCallback = callback =&gt; {\n  callback(&quot;张三&quot;);\n};\n\n// demo.test.js\nimport { runCallback } from &quot;./demo&quot;;\ntest(&quot;测试 runCallback&quot;, () =&gt; {\n  const func = jest.fn();\n  // func.mockReturnValue(&quot;Common&quot;)\n  // 所有模拟返回值都是 &quot;Common&quot;\n  func.mockReturnValueOnce(&quot;A&quot;); // 第一次模拟返回值返回 &quot;A&quot;\n  func.mockReturnValueOnce(&quot;B&quot;); // 第二次模拟返回值返回 &quot;B&quot;\n  func.mockReturnValueOnce(&quot;C&quot;); // 第三次模拟返回值返回 &quot;C&quot;\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.results[0].value).toBe(&quot;A&quot;);\n  expect(func.mock.results[1].value).toBe(&quot;B&quot;);\n  expect(func.mock.results[2].value).toBe(&quot;C&quot;);\n});</code></pre><p><br /></p><p><code>func.mockReturnValue()</code>  将对所有模拟返回的值生效</p><p><br /></p><p><code>func.mockReturnValueOnce()</code>  执行到第几次就对第几个函数的模拟返回值生效</p><p><br /></p><p>支持链式调用</p><p><br /></p><a name=\"7.5-jest.fn().mock.invocationCallOrder-判定函数执行顺序\"></a><h3 id=\"4d54342e\">7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const runCallback = callback =&gt; {\n  callback(&quot;张三&quot;);\n};\n\n// demo.test.js\nimport { runCallback } from &quot;./demo&quot;;\ntest(&quot;测试 runCallback&quot;, () =&gt; {\n  const func = jest.fn();\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.invocationCallOrder).toEqual([1, 2, 3]);\n});</code></pre><p><br /></p><a name=\"7.6-jest.fn().mock.instances-判定函数调用了几次以及-this-指向\"></a><h3 id=\"b4132e26\">7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const createObject = (ClassItem) =&gt; {\n  new ClassItem();\n}\n\n// demo.test.js\nimport { createObject } from &quot;./demo&quot;;\ntest(&quot;测试 createObject&quot;, () =&gt; {\n  const func = jest.fn();\n  createObject(func);\n  expect(func.mock.instances).toEqual([mockConstructor{}]); // 此处的 this 就是 mockConstructor\n});</code></pre><p><br /></p><a name=\"7.7-jest.fn().mockImplementation()-判定函数返回结果和其他逻辑处理\"></a><h3 id=\"3daaf7be\">7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const runCallback = callback =&gt; {\n  callback(&quot;张三&quot;);\n};\n\n// demo.test.js\nimport { runCallback } from &quot;./demo&quot;;\ntest(&quot;测试 runCallback&quot;, () =&gt; {\n  const func = jest.fn();\n  // func.mockImplementation(() =&gt; &quot;hello&quot;); 等价于 jest.fn(() =&gt; &quot;hello&quot;)\n  // func.mockImplementation(() =&gt; this); 等价于 jest.fn().mockReturnThis()\n  func.mockImplementationOnce(() =&gt; &quot;dell&quot;);\n  func.mockImplementationOnce(() =&gt; &quot;lee&quot;);\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.results[0].value).toBe(&quot;dell&quot;);\n  expect(func.mock.results[1].value).toBe(&quot;lee&quot;);\n});</code></pre><p><br /></p><p><code>mockImplementation</code>  比 <code>mockReturnValue</code>  更健壮，因为内部可以写一些额外的逻辑</p><p><br /></p><a name=\"7.8-toBeCalledWith()-来判定每次函数调用时的参数\"></a><h3 id=\"e5eee6bb\">7.8 toBeCalledWith() 来判定每次函数调用时的参数</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const runCallback = (callback) =&gt; {\n  callback(&quot;ABC&quot;);\n}\n\n// demo.test.js\nimport { runCallback } from &quot;./demo&quot;;\ntest(&quot;测试 runCallback&quot;, () =&gt; {\n  const func = jest.fn();\n  runCallback(func);\n  expect(func.mock.results[0]).toEqual([&quot;ABC&quot;);\n  expect(func).toBeCalledWith(&quot;ABC&quot;);\n});</code></pre><p><br /></p><a name=\"7.9-模拟异步请求\"></a><h3 id=\"6c1b528b\">7.9 模拟异步请求</h3><p><br /></p><p>对于前端来说一般异步接口是测试是否发送了，而不测试后端接口返回的内容，是属于后端自动化测试的内容</p><p><br /></p><a name=\"7.9.1-通过模拟库的方式来模拟异步测试\"></a><h3 id=\"82bb8fdc\">7.9.1 通过模拟库的方式来模拟异步测试</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const getData = () =&gt; {\n  return axios.get(&quot;/api&quot;).then(res =&gt; res.data);\n};\n\n// demo.test.js\nimport axios from &quot;axios&quot;;\nimport { getData } from &quot;./demo&quot;;\njest.mock(&quot;axios&quot;); // 对 axios 进行模拟，这样就不会请求真正数据\ntest(&quot;测试 getData&quot;, async () =&gt; {\n  axios.get.mockResolvedValue({ data: &quot;hello&quot; }); // 使用 axios 请求的时候模拟成功的返回值就是 hello\n  await getData().then(data =&gt; {\n    expect(data).toBe(&quot;hello&quot;);\n  });\n});</code></pre><p><br /></p><p><code>mockResolvedValue</code> 模拟不限次数</p><p><br /></p><p><code>mockResolvedValueOnce</code> 模拟一次，模拟两次就会报错，需再次调用</p><p><br /></p><a name=\"7.9.2-通过模拟-Promise-方式模拟异步\"></a><h3 id=\"4ad5bf63\">7.9.2 通过模拟 Promise 方式模拟异步</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const fetchData = () =&gt; {\n  return axios.get(&quot;/&quot;).then(res =&gt; res.data);\n};\n\n// __mocks__/demo.js\nexport const fetchData = () =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    resolve(&quot;function() { return '123' }&quot;);\n  });\n};\n\n// demo.test.js\njest.mock(&quot;./demo&quot;);\nimport { fetchData } from &quot;./demo&quot;;\ntest(&quot;测试fetchData&quot;, () =&gt; {\n  return fetchData().then(data =&gt; {\n    expect(eval(data)).toEqual(&quot;123&quot;);\n  });\n});\n\n/// 实现方式3\n// 修改jest.config.js 可以自动查找项目内部__mocks__下与要测试文件名字相同的文件做替换\n// 等同于 jest.mock(&quot;要测试文件名字相同的__mocks__下的文件&quot;){  automock: true; }</code></pre><p><br /></p><a name=\"7.9.3-通过修改-jest.config.js-来自动识别-strong-mocks--strong-下的文件\"></a><h3 id=\"481f7bdb\">7.9.3 通过修改 jest.config.js 来自动识别<strong>mocks</strong>下的文件</h3><p><br /></p><p>修改 <code>jest.config.js</code> 可以自动查找项目内部 <code>__mocks__</code> 下与要测试文件名字相同的文件做替换</p><p><br /></p><p>等同于&gt; <code>jest.mock(&quot;要测试文件名字相同的__mocks__下的文件&quot;)</code></p><p><br /></p><a name=\"7.9.4-使用-jest.unmock()-可取消-mock-模拟\"></a><h3 id=\"0c7a36bc\">7.9.4 使用 jest.unmock() 可取消 mock 模拟</h3><p><br /></p><a name=\"7.9.5-解决测试文件中部分功能不需要-mock，部分功能需要-mock-模拟异步的问题\"></a><h3 id=\"768c0ac4\">7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const fetchData = () =&gt; {\n  return axios.get(&quot;/&quot;).then(res =&gt; res.data);\n};\nexport const getNumber = () =&gt; 123;\n\n// __mocks__/demo.js\nexport const fetchData = () =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    resolve(&quot;function() { return '123' }&quot;);\n  });\n};\n\n// demo.test.js\njest.mock(&quot;./demo&quot;);\nimport { fetchData } from &quot;./demo&quot;;\nconst { getNumber } = jest.requireActual(&quot;./demo&quot;); // 引入真实文件\ntest(&quot;测试 fetchData&quot;, () =&gt; {\n  return fetchData().then(data =&gt; {\n    expect(eval(data)).toEqual(&quot;123&quot;);\n  });\n});\n\ntest(&quot;测试 getNumber&quot;, () =&gt; {\n  expect(getNumber()).toEqual(123);\n});</code></pre><p><br /></p><a name=\"8.-snapshot-快照测试\"></a><h2 id=\"65760d36\">8. snapshot 快照测试</h2><p><br /></p><p>常用于测试配置文件</p><p><br /></p><a name=\"8.1-toMatchSnapshot()\"></a><h3 id=\"cd5ad64e\">8.1 toMatchSnapshot()</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const generateConfig = () =&gt; {\n  return {\n    server: &quot;http://localhost&quot;,\n    port: 8080,\n    domain: &quot;localhost&quot;\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from &quot;./demo&quot;;\ntest(&quot;测试 generateConfig&quot;, () =&gt; {\n  expect(generateConfig()).toMatchSnapshot(); // 将会在项目里生成快照文件\n});</code></pre><p><br /></p><p>如果要确认更新快照，需要在控制台选择。 <code>u</code>  代表对所有快照进行更新， <code>i</code>  代表对单个确认的快照进行更新</p><p><br /></p><a name=\"8.2-测试部分可变变量的内容\"></a><h3 id=\"feac445e\">8.2 测试部分可变变量的内容</h3><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const generateConfig = () =&gt; {\n  return {\n    server: &quot;http://localhost&quot;,\n    port: 8080,\n    domain: &quot;localhost&quot;,\n    time: new Date(),\n    // 可变变量\n    random: Math.random()\n    // 可变变量\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from &quot;./demo&quot;;\ntest(&quot;测试 generateConfig&quot;, () =&gt; {\n  expect(generateConfig()).toMatchSnapshot({\n    time: expect.any(Date),\n    random: expect.any(Number)\n  });\n});</code></pre><p><br /></p><a name=\"8.3-行内的-snapshot\"></a><h3 id=\"9a1d84a3\">8.3 行内的 snapshot</h3><p><br /></p><p><code>npm install prettier --save</code></p><p><br /></p><p>可以快照放到行内的测试用例中</p><p><br /></p><pre data-lang=\"jsx\"><code>// demo.js\nexport const generateConfig = () =&gt; {\n  return {\n    server: &quot;http://localhost&quot;,\n    port: 8080,\n    domain: &quot;localhost&quot;,\n    time: new Date(),\n    // 可变变量\n    random: Math.random()\n    // 可变变量\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from &quot;./demo&quot;;\ntest(&quot;测试 generateConfig&quot;, () =&gt; {\n  // toMatchInlineSnapshot 可以快照放到行内的测试用例中\n  expect(generateConfig()).toMatchInlineSnapshot({\n    time: expect.any(Date),\n    random: expect.any(Number)\n  });\n});</code></pre><hr /><a name=\"9.-Test-Driven-Development(TDD)-测试驱动开发\"></a><h2 id=\"23393306\">9. Test Driven Development(TDD) 测试驱动开发</h2><p><br /></p><a name=\"9.1-TDD-开发流程\"></a><h3 id=\"ed6430cc\">9.1 TDD 开发流程</h3><p><br /></p><ol start=\"1\"><li>编写测试用例（知道功能，先写测试用例）</li></ol><ol start=\"2\"><li>运行测试，测试用例无法通过测试</li></ol><ol start=\"3\"><li>编写代码，使测试用例通过测试</li></ol><ol start=\"4\"><li>优化代码， 完成开发</li></ol><ol start=\"5\"><li>新增功能，重复执行 1-4</li></ol><p><br /></p><a name=\"9.2-TDD-的优势\"></a><h3 id=\"3c65ae93\">9.2 TDD 的优势</h3><p><br /></p><ol start=\"1\"><li>长期减少项目的回归 bug（减少修改代码产生的 bug）</li></ol><ol start=\"2\"><li>代码质量更好（组织，可维护性好）</li></ol><ol start=\"3\"><li>测试覆盖率高（因为是先编写测试用例，但测试覆盖率过高会影响很大精力）</li></ol><ol start=\"4\"><li>错误测试代码不容易出现</li></ol><p><br /></p><a name=\"9.3-TDD-的适用场景\"></a><h3 id=\"3ecdd7a1\">9.3 TDD 的适用场景</h3><p><br /></p><ol start=\"1\"><li>不适用于开发业务代码时使用（开发业务代码时会大量的与业务代码产生耦合，加大工作量）</li></ol><ol start=\"2\"><li>适用于一些库的开发（开发库时代码耦合度较低，通常只处理函数等相关功能）</li></ol><hr /><a name=\"10.-Behavior-Driven-Development(BDD)-行为驱动开发\"></a><h2 id=\"59f902bb\">10. Behavior Driven Development(BDD) 行为驱动开发</h2><p><br /></p><a name=\"10.1-BDD-开发流程\"></a><h3 id=\"6733a7a6\">10.1 BDD 开发流程</h3><p><br /></p><ol start=\"1\"><li>先编写业务代码，不关心测试</li></ol><ol start=\"2\"><li>思考并描述用户行为</li></ol><ol start=\"3\"><li>根据用户行为模拟测试</li></ol><p><br /></p><a name=\"10.2-vue-example\"></a><h3 id=\"f821175c\">10.2 vue example</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// testUtils.js\nexport const findTestWrapper = (wrapper, tag) =&gt; {\n  return wrapper.find(`[data-test=&quot;${tag}&quot;]`);\n};</code></pre><p><br /></p><pre data-lang=\"jsx\"><code>/// __tests__/integration/TodoList.test.js\nimport { mount } from &quot;@vue/test-utils&quot;;\nimport { findTestWrapper } from &quot;../../../../utils/testUtils&quot;;\nimport TodoList from &quot;../../TodoList&quot;;\n// import store from &quot;../../../../store&quot;\nit(`    \n 新增内容逻辑的集成测试    \n 1. 用户会在header输入框输入内容    \n 2. 用户会点击回车按钮  \n 3. 列表项应该增加用户输入内容的列表项`, () =&gt; {\n  const wrapper = mount(TodoList);\n  // const wrapper = mount(TodoList, { store })\n  // 如果使用 vuex，也几乎无改动\n  const inputElem = findTestWrapper(wrapper, &quot;header-input&quot;).at(0);\n  const content = &quot;Dell lee&quot;;\n  inputElem.setValue(content);\n  inputElem.trigger(&quot;change&quot;);\n  inputElem.trigger(&quot;keyup.enter&quot;);\n  const listItems = findTestWrapper(wrapper, &quot;list-item&quot;).at(0);\n  expect(listItems.length).toBe(1);\n  expect(listItems.at(0).text()).toContain(content);\n});</code></pre><p><br /></p><a name=\"10.3-react-example\"></a><h3 id=\"9b16dd87\">10.3 react example</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// testUtils.js\nexport const findTestWrapper = (wrapper, tag) =&gt; {\n  return wrapper.find(`[data-test=&quot;${tag}&quot;]`);\n};</code></pre><p><br /></p><pre data-lang=\"jsx\"><code>/// __tests__/integration/TodoList.test.js\nimport React from &quot;react&quot;;\n// import { Provider } from &quot;react-redux&quot;;\nimport Enzyme, { mount } from &quot;enzyme&quot;;\nimport Adapter from &quot;enzyme-adapter-react-16&quot;;\nimport TodoList from &quot;../../TodoList&quot;;\n// import store from &quot;../../../../store/createStore&quot;;\nEnzyme.configure({ adapter: new Adapter() });\n\nit(`\n    新增内容逻辑的集成测试\n    1. 用户会在header输入框输入内容\n    2. 用户会点击回车按钮\n   3. 列表项应该增加用户输入内容的列表项\n`, () =&gt; {\n  const wrapper = mount(&lt;TodoList /&gt;);\n  /** \n  const wrapper = mount(\n   &lt;Provider store={store}&gt;\n    &lt;TodoList /&gt;&lt;/Provider&gt;\n   &lt;/Provider&gt;\n  )  \n  // 如果使用 redux，也几乎无改动\n */\n  const inputElem = findTestWrapper(wrapper, &quot;header-input&quot;);\n  const content = &quot;Dell lee&quot;;\n  inputElem.simulate(&quot;change&quot;, { target: { value: content } });\n  inputElem.simulate(&quot;keyUp&quot;, { keyCode: 13 });\n  const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);\n  expect(listItems.length).toBe(1);\n  expect(listItems.text()).toContain(content);\n});</code></pre><hr /><a name=\"11.-TDD-和-BDD-的对比\"></a><h2 id=\"c2aee4b0\">11. TDD 和 BDD 的对比</h2><p><br /></p><ol start=\"1\"><li><code>TDD</code> 先写测试后写代码; <code>BDD</code> 先写代码后写测试</li></ol><ol start=\"2\"><li><code>TDD</code> 创建的是 <code>unit</code> 单元测试文件夹，一般结合单元测试，属于白盒测试(知道实现测试代码); <code>BDD</code> 创建的是 <code>integration</code> 集成测试文件夹，一般结合集成测试，属于黑盒测试(不知道实现测试代码)</li></ol><ol start=\"3\"><li><code>TDD</code> 测试重点在代码; <code>BDD</code> 测试重点在 <code>UI</code> ( <code>DOM</code>)</li></ol><ol start=\"4\"><li><code>TDD</code> 安全感低(无法保证各个组件拼撞到一起是否不会有问题); <code>BDD</code> 安全感高</li></ol><ol start=\"5\"><li><code>TDD</code> 速度快; <code>BDD</code> 速度慢</li></ol><hr /><a name=\"12.-TDD-与-BDD-混用\"></a><h2 id=\"1f761f1e\">12. TDD 与 BDD 混用</h2><p><br /></p><a name=\"12.1-对一些工具函数的测试\"></a><h3 id=\"11f73608\">12.1 对一些工具函数的测试</h3><p><br /></p><a name=\"12.2-对-vuex-的-store-进行测试\"></a><h3 id=\"4767b160\">12.2 对 vuex 的 store 进行测试</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// __tests__/unit/store.test.js\nimport store from &quot;../../../../store&quot;;\nit(&quot;当 store 接受 changeInputValue 的 commit 时, inputValue 发生变化&quot;, () =&gt; {\n  const value = &quot;123&quot;;\n  store.commit(&quot;changeInputValue&quot;, value);\n  expect(store.state.inputValue).toBe(value);\n});</code></pre><p><br /></p><a name=\"12.3-对-redux-的-store-进行测试\"></a><h3 id=\"05a2b125\">12.3 对 redux 的 store 进行测试</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// __tests__/unit/store.test.js\nimport store from &quot;../../../../store/createStore&quot;;\nimport { changeInputValue } from &quot;../../../../store/actions&quot;;\nit(&quot;当 store 接受 changeInputValue 的 dispatch 时, inputValue 发生变化&quot;, () =&gt; {\n  const value = &quot;123&quot;;\n  /**   \n  const changeInputValue = (payload) =&gt; ({ \n   type: CHANGE_IMPUT_VALUE, payload \n  })   \n */\n  store.dispatch(changeInputValue(value));\n  expect(store.getState().inputValue).toBe(value);\n});</code></pre><hr /><a name=\"13.-异步测试\"></a><h2 id=\"71b9d92e\">13. 异步测试</h2><p><br /></p><p>注意：异步测试如果用到了异步函数，则需要调用 <code>done</code>  函数</p><p><br /></p><a name=\"13.1-vue-的异步测试\"></a><h3 id=\"e3e302bb\">13.1 vue 的异步测试</h3><p><br /></p><pre data-lang=\"javascript\"><code>/// __mocks__/axios.js\nconst undoList = {  success: true,  data: [\n { status: &quot;div&quot;, value: &quot;dell&quot; },\n { status: &quot;div&quot;, value: &quot;lee&quot; }\n]};\nexport default {\n get(url) {\n  if (url === &quot;/getUndoList.json&quot;) {\n   return new Promise((resolve, reject) =&gt; {\n    if (this.success === true) {\n     resolve(undoList);\n    } else {\n     reject(new Error());\n    }\n   });\n  }\n }};\n\n/// __tests__/integration/TodoList.test.js\nimport { mount } from &quot;@vue/test-utils&quot;;\nimport { findTestWrapper } from &quot;../../../../utils/testUtils&quot;;\nimport TodoList from &quot;../../TodoList&quot;;\nimport store from &quot;../../../../store&quot;;\n\nbeforeEach(() =&gt; {\n axios.success = true;\n jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响});\nit(`1. 用户进入页面时，请求远程测试; 2. 列表应该显示远程返回的数据`, done =&gt; {\n  const wrapper = mount(TodoList, { store });\n  wrapper.vm.$nickTick(() =&gt; {\n   const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);\n   expect(listItems.length).toBe(2);\n   done();\n  });\n });\nit(`1. 用户进入页面时，等待5s; 2. 列表应该显示远程返回的数据`, done =&gt; {\n const wrapper = mount(TodoList, { store });\n expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n jest.runAllTimers();\n wrapper.vm.$nickTick(() =&gt; {\n  const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);\n  expect(listItems.length).toBe(2);\n  done();\n });\n});\n\nit(`1. 用户进入页面时，请求远程数据失败; 2. 列表应该显示空数据，不应该挂掉`, done =&gt; {\n axios.success = false;\n const wrapper = mount(TodoList, { store });\n expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n jest.runAllTimers();\n wrapper.vm.$nickTick(() =&gt; {\n  const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);\n  expect(listItems.length).toBe(0);\n  done();\n });\n});</code></pre><p><br /></p><a name=\"13.2-react-的异步测试\"></a><h3 id=\"833ac6cf\">13.2 react 的异步测试</h3><p><br /></p><pre data-lang=\"jsx\"><code>/// __mocks__/axios.js\nconst undoList = {\n  success: true,\n  data: [\n    { status: &quot;div&quot;, value: &quot;dell&quot; },\n    { status: &quot;div&quot;, value: &quot;lee&quot; }\n  ]\n};\n\nexport default {\n  get(url) {\n    if (url === &quot;/getUndoList.json&quot;) {\n      return new Promise((resolve, reject) =&gt; {\n        if (this.success === true) {\n          resolve(undoList);\n        } else {\n          reject(new Error());\n        }\n      });\n    }\n  }\n};\n\n/// __tests__/integration/TodoList.test.js\nimport React from &quot;react&quot;;\nimport { Provider } from &quot;react-redux&quot;;\nimport Enzyme, { mount } from &quot;enzyme&quot;;\nimport Adapter from &quot;enzyme-adapter-react-16&quot;;\nimport TodoList from &quot;../../TodoList&quot;;\nimport store from &quot;../../../../store/createStore&quot;;\nEnzyme.configure({ adapter: new Adapter() });\n\nbeforeEach(() =&gt; {\n  axios.success = true;\n  jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响\n});\n\nit(`\n    1. 用户进入页面时，请求远程测试\n    2. 列表应该显示远程返回的数据\n`, done =&gt; {\n  const wrapper = mount(\n    &lt;Provider store={store}&gt;\n      &lt;TodoList /&gt;\n    &lt;/Provider&gt;\n  );\n  process.nickTick(() =&gt; {\n    wrapper.update();\n    const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);\n    expect(listItems.length).toBe(2);\n    done();\n  });\n});\n\nit(`\n    1. 用户进入页面时，等待5s\n    2. 列表应该显示远程返回的数据\n`, done =&gt; {\n  const wrapper = mount(\n    &lt;Provider store={store}&gt;\n      &lt;TodoList /&gt;\n    &lt;/Provider&gt;\n  );\n  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n  jest.runAllTimers();\n  process.nickTick(() =&gt; {\n    wrapper.update(); // 更新 wrapper 防止取上一次的 wrapper\n    const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);\n    expect(listItems.length).toBe(2);\n    done();\n  });\n});\n\nit(`\n  1. 用户进入页面时，请求远程数据失败\n  2. 列表应该显示空数据，不应该挂掉\n`, done =&gt; {\n  axios.success = false;\n  const wrapper = mount(\n    &lt;Provider store={store}&gt;\n      &lt;TodoList /&gt;\n    &lt;/Provider&gt;\n  );\n  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n  jest.runAllTimers();\n  process.nickTick(() =&gt; {\n    wrapper.update();\n    const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);\n    expect(listItems.length).toBe(0);\n    done();\n  });\n});</code></pre><hr /><a name=\"14.-vue-项目的自动化测试\"></a><h2 id=\"63ab0b81\">14. vue 项目的自动化测试</h2><p><br /></p><a name=\"14.1-使用传统方式对-vue-组件进行测试\"></a><h3 id=\"7740ff83\">14.1 使用传统方式对 vue 组件进行测试</h3><p><br /></p><pre data-lang=\"jsx\"><code>// HelloWorld.test.js\nimport Vue from &quot;vue&quot;;\nimport HelloWorld from &quot;@/components/HelloWorld&quot;;\ndescribe(&quot;HelloWorld.vue&quot;, () =&gt; {\n  it(&quot;renders props.msg when passed&quot;, () =&gt; {\n    const root = document.createElement(&quot;div&quot;);\n    root.className = &quot;root&quot;;\n    document.body.appendChild(root);\n    new Vue({\n      render: h =&gt;\n        h(HelloWorld, {\n          props: {\n            msg: &quot;dell lee&quot;\n          }\n        })\n    }).$mount(&quot;.root&quot;);\n    expect(document.getElementByClassName(&quot;hello&quot;).length).toBe(1);\n  });\n});</code></pre><p><br /></p><p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p><p><br /></p><a name=\"14.2-使用-@vue-test-utils-对-vue-组件进行测试\"></a><h3 id=\"9f92aeab\">14.2 使用 @vue/test-utils 对 vue 组件进行测试</h3><p><br /></p><ul><li><a href=\"https://vue-test-utils.vuejs.org/zh/\" target=\"_blank\">官方文档</a></li></ul><p><br /></p><a name=\"14.2.1-for-example\"></a><h3 id=\"474de05c\">14.2.1 for example</h3><p><br /></p><pre data-lang=\"jsx\"><code>// HelloWorld.test.js\nimport { shallowMount } from &quot;@vue/test-utils&quot;;\nimport HelloWorld from &quot;@/components/HelloWorld&quot;;\ndescribe(&quot;HelloWorld.vue&quot;, () =&gt; {\n  it(&quot;renders props.msg when passed&quot;, () =&gt; {\n    const msg = &quot;dell lee&quot;;\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: { msg }\n    });\n    expect(wrapper.text()).toMatch(msg);\n  });\n});</code></pre><p><br /></p><a name=\"14.2.2-快照测试\"></a><h3 id=\"42aa9119\">14.2.2 快照测试</h3><p><br /></p><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p><p><br /></p><p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p><p><br /></p><pre data-lang=\"jsx\"><code>// HelloWorld.test.js\nimport { shallowMount } from &quot;@vue/test-utils&quot;;\nimport HelloWorld from &quot;@/components/HelloWorld&quot;;\ndescribe(&quot;HelloWorld.vue 组件渲染正常&quot;, () =&gt; {\n  it(&quot;renders props.msg when passed&quot;, () =&gt; {\n    const msg = &quot;dell lee&quot;;\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: { msg }\n    });\n    expect(wrapper).toMatchSnapshot();\n  });\n});</code></pre><hr /><a name=\"15.-react-项目的自动化测试\"></a><h2 id=\"245d2d6a\">15. react 项目的自动化测试</h2><p><br /></p><a name=\"15.1-使用传统方式对-react-组件进行测试\"></a><h3 id=\"a85bc8fa\">15.1 使用传统方式对 react 组件进行测试</h3><p><br /></p><pre data-lang=\"jsx\"><code>// App.test.js\nimport React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport App from &quot;./App&quot;;\n\nit(&quot;render App&quot;, () =&gt; {\n  const div = document.createElement(&quot;div&quot;);\n  ReactDOM.render(&lt;App /&gt;, div);\n  const container = div.getElementsByClassName(&quot;App&quot;);\n  expect(container.length).toBe(1);\n});</code></pre><p><br /></p><p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p><p><br /></p><a name=\"15.2-enzyme-的配置和使用\"></a><h3 id=\"b54705b0\">15.2 enzyme 的配置和使用</h3><p><br /></p><ul><li><a href=\"https://enzymejs.github.io/enzyme/\" target=\"_blank\">官方文档</a></li></ul><ul><li><a href=\"https://github.com/enzymejs/enzyme\" target=\"_blank\">github</a></li></ul><ul><li><a href=\"https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-enzyme\" target=\"_blank\">jest-enzyme</a></li></ul><p><br /></p><a name=\"15.2.1-for-example\"></a><h3 id=\"2edd525d\">15.2.1 for example</h3><p><br /></p><pre data-lang=\"jsx\"><code>// App.test.js\nimport React from &quot;react&quot;;\nimport Enzyme, { shallow } from &quot;enzyme&quot;;\nimport Adapter from &quot;enzyme-adapter-react-16&quot;;\nimport App from &quot;App&quot;;\nEnzyme.configure({ adapter: new Adapter() });\nit(&quot;render App&quot;, () =&gt; {\n  const wrapper = shallow(&lt;App /&gt;);\n  expect(wrapper.find('[data-test=&quot;App&quot;]').length).toBe(2);\n});</code></pre><p><br /></p><p>使用自定义 <code>props</code> 可以降低代码耦合度</p><p><br /></p><p><code>shallow</code> 适合单元测试，属于浅渲染； <code>mount</code> 适合集成测试，会将当前组件包括其子组件一起渲染</p><p><br /></p><p>单元测试时更倾向于使用 <code>api</code> <code>.state()</code> ；集成测试时更倾向于使用 <code>api</code> <code>.prop()</code></p><p><br /></p><a name=\"15.2.2-快照测试\"></a><h3 id=\"c14005d5\">15.2.2 快照测试</h3><p><br /></p><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p><p><br /></p><p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p><p><br /></p><pre data-lang=\"jsx\"><code>// App.test.js\nimport React from &quot;react&quot;;\nimport Enzyme, { shallow } from &quot;enzyme&quot;;\nimport Adapter from &quot;enzyme-adapter-react-16&quot;;\nimport App from &quot;App&quot;;\nEnzyme.configure({ adapter: new Adapter() });\nit(&quot;render App&quot;, () =&gt; {\n  const wrapper = shallow(&lt;App /&gt;);\n  expect(wrapper).toMatchSnapshot();\n});</code></pre><hr /><a name=\"16.-前端自动化测试的优势\"></a><h2 id=\"efea21cb\">16. 前端自动化测试的优势</h2><p><br /></p><ul><li>更好的代码组织，项目的可维护性强</li></ul><ul><li>更少的 <code>Bug</code> 出现概率，尤其是回归测试中的 <code>Bug</code></li></ul><ul><li>修改工程质量差的项目，更加安全</li></ul><ul><li>项目具备潜在的文档特性</li></ul><ul><li>扩展前端的知识面</li></ul><p><br /></p><a name=\"17-总结重要的点\"></a><h2 id=\"5215b451\">17 总结重要的点</h2><p><br /></p><ol start=\"1\"><li><code>BDD</code> 和 <code>TDD</code></li></ol><ol start=\"2\"><li>集成测试 和 单元测试</li></ol><ol start=\"3\"><li>测试和业务的解耦</li></ol><ol start=\"4\"><li>代码测试覆盖率并不代表一定靠谱</li></ol><ol start=\"5\"><li>功能性测试 和 <code>UI</code>测试</li></ol><ol start=\"6\"><li>测试越独立，隐藏的问题就越多</li></ol>",
  "body_lake": "<!doctype lake><a name=\"前端自动化测试\"></a><h1 id=\"1cc518ba\">前端自动化测试</h1><p><br /></p><a name=\"1.-单元测试\"></a><h2 id=\"e06fdbee\">1. 单元测试</h2><p><br /></p><p>对软件中的最小可测试单元进行检查和验证，在前端一般为一个模块。</p><p><br /></p><a name=\"1.1-单元测试的优缺点\"></a><h3 id=\"759aac61\">1.1 单元测试的优缺点</h3><p><br /></p><ol start=\"1\"><li>测试覆盖率高</li></ol><ol start=\"2\"><li>业务耦合度高</li></ol><ol start=\"3\"><li>代码量大</li></ol><ol start=\"4\"><li>过于独立</li></ol><p><br /></p><a name=\"1.2-总结\"></a><h3 id=\"7b50fee4\">1.2 总结</h3><p><br /></p><p>在某些场景下适合适用单元测试，某些场景下不适合适用单元测试</p><p><br /></p><a name=\"2.-集成测试\"></a><h2 id=\"2f883435\">2. 集成测试</h2><p><br /></p><p>又叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。</p><p><br /></p><a name=\"3.-jest-中的匹配器\"></a><h2 id=\"e0cc0593\">3. jest 中的匹配器</h2><p><br /></p><p><a href=\"https://jestjs.io/docs/en/expect\" target=\"_blank\">jest 匹配器官网</a></p><p><br /></p><p>修改 <code>jest</code>  默认配置命令 <code>npx jest --init</code></p><p><br /></p><a name=\"3.1-实时监听测试用例的改变\"></a><h3 id=\"e489b565\">3.1 实时监听测试用例的改变</h3><p><br /></p><p><code>jest --watchAll</code> 一旦某个测试用例发生变化，所有的测试用例都将会重新执行</p><p><br /></p><p><code>jest --watch</code>  默认进入 <code>o</code>  模式，即只对发生变化的测试用例重新执行</p><p><br /></p><a name=\"3.2-常用匹配器\"></a><h3 id=\"9278cb4c\">3.2 常用匹配器</h3><p><br /></p><a name=\"3.2.1-toBe()\"></a><h3 id=\"d21eba22\">3.2.1 toBe()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%225e58ac80%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBe%E7%9A%84%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20a%20%3D%20%7B%20name%3A%20%5C%22%E5%BC%A0%E4%B8%89%5C%22%20%7D%3B%5Cn%20%20expect(a).toBe(%7B%20name%3A%20%5C%22%E5%BC%A0%E4%B8%89%5C%22%20%7D)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9D%8C%20%E5%9B%A0%E4%B8%BA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8toBe%E4%B8%8D%E6%98%AF%E5%85%A8%E7%AD%89%E6%95%88%E6%9E%9C%22%7D\"></card><p><br /></p><p><code>toBe</code> 匹配器类似于 <code>===</code>。</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.2-toEqual()\"></a><h3 id=\"9ba722f8\">3.2.2 toEqual()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%229b21978c%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toEqual%E7%9A%84%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20a%20%3D%20%7B%20name%3A%20%5C%22%E5%BC%A0%E4%B8%89%5C%22%20%7D%3B%5Cn%20%20expect(a).toBe(%7B%20name%3A%20%5C%22%E5%BC%A0%E4%B8%89%5C%22%20%7D)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%20%E5%9B%A0%E4%B8%BAtoEqual%E5%8F%AA%E6%98%AF%E5%AF%B9%E7%BB%93%E6%9E%9C%E7%9A%84%E5%8C%B9%E9%85%8D%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%A8%E7%AD%89%E6%95%88%E6%9E%9C%22%7D\"></card><p><br /></p><p><code>toEqual</code> 匹配器只是对结果相等与否进行匹配</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.3-toBeNull()\"></a><h3 id=\"5b2da47a\">3.2.3 toBeNull()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22803b9272%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeNull%E7%9A%84%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20a%20%3D%20null%3B%5Cn%20%20expect(a).toBeNull()%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeNull</code> 是对 <code>null</code> 值的匹配</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.4-toBeUndefined()\"></a><h3 id=\"4f58955d\">3.2.4 toBeUndefined()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22e4812d18%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeUndefined%E7%9A%84%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20a%20%3D%20undefined%3B%5Cn%20%20expect(a).toBeUndefined()%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeUndefined</code> 是对 <code>undefined</code> 值的匹配</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.5-toBeDefined()\"></a><h3 id=\"aa717d1f\">3.2.5 toBeDefined()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22bdd34645%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeDefined%E7%9A%84%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20a%20%3D%201%3B%5Cn%20%20expect(a).toBeDefined()%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeDefined</code> 是对已经定义的值的匹配，若为 <code>undefined</code> 则不通过</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.6-toBeTruthy()\"></a><h3 id=\"3e22cb95\">3.2.6 toBeTruthy()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22ba0f30ef%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeTruthy%E7%9A%84%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20a%20%3D%200%3B%5Cn%20%20expect(a).toBeTruthy()%3B%5Cn%7D)%3B%5Cn%2F%2F%200%20%3D%3E%20%E2%9D%8C%EF%BC%8C%E5%9B%A0%E4%B8%BA%20toBeTruthy%20%E6%98%AF%E5%AF%B9%20true%20%E5%80%BC%E7%9A%84%E5%8C%B9%E9%85%8D%5Cn%2F%2F%201%20%3D%3E%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeTruthy</code> 是对 <code>true</code> 值的匹配</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.7-toBeFalsy()\"></a><h3 id=\"daa53386\">3.2.7 toBeFalsy()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%225f79915f%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeFalsy%E7%9A%84%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20a%20%3D%201%3B%5Cn%20%20expect(a).toBeFalsy()%3B%5Cn%7D)%3B%5Cn%2F%2F%201%20%3D%3E%20%E2%9D%8C%5Cn%2F%2F%200%20%3D%3E%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeFalsy</code> 是对 <code>false</code> 值的匹配</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.8-toBeGreaterThan()\"></a><h3 id=\"95777fd5\">3.2.8 toBeGreaterThan()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%223943162e%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeGreaterThan%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20count%20%3D%2010%3B%5Cn%20%20expect(a).toBeGreaterThan(9)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeGreaterThan</code> 相当于 <code>&gt;</code></p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.9-toBeLessThan()\"></a><h3 id=\"5ed81d3a\">3.2.9 toBeLessThan()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%228b8f702e%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeLessThan%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20count%20%3D%208%3B%5Cn%20%20expect(a).toBeLessThan(9)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeLessThan</code> 相当于 <code>&lt;</code></p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.10-toBeGreaterThanOrEqual()\"></a><h3 id=\"1f0e8517\">3.2.10 toBeGreaterThanOrEqual()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%222bcd9e30%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeGreaterThanOrEqual%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20count%20%3D%2010%3B%5Cn%20%20expect(a).toBeGreaterThanOrEqual(10)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeGreaterThanOrEqual</code> 相当于 <code>&gt;=</code></p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.11-toBeLessThanOrEqual()\"></a><h3 id=\"d137001e\">3.2.11 toBeLessThanOrEqual()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%221b69db1d%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeLessThanOrEqual%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20count%20%3D%2010%3B%5Cn%20%20expect(a).toBeLessThanOrEqual(10)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeLessThanOrEqual</code> 相当于 <code>&lt;=</code></p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.12-toBeCloseTo()\"></a><h3 id=\"bb417baa\">3.2.12 toBeCloseTo()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2231f3713f%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toBeCloseTo%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20one%20%3D%200.1%3B%5Cn%20%20const%20two%20%3D%200.2%3B%5Cn%20%20expect(one%20%2B%20two).toEqual(0.3)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9D%8C%20%E5%9B%A0%E4%B8%BA%E6%B5%AE%E7%82%B9%E7%B2%BE%E5%BA%A6%E4%B8%8D%E5%90%8C%5Cn%5Cntest(%5C%22%E6%B5%8B%E8%AF%95toBeCloseTo%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20one%20%3D%200.1%3B%5Cn%20%20const%20two%20%3D%200.2%3B%5Cn%20%20expect(one%20%2B%20two).toBeCloseTo(0.3)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toBeCloseTo</code> 为了解决浮点精度不同导致的无法匹配的问题</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.13-toMatch()\"></a><h3 id=\"3d3d7425\">3.2.13 toMatch()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%225ff3f513%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toMatch%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20str%20%3D%20%5C%22%E5%BC%A0%E4%B8%89%E3%80%81%E6%9D%8E%E5%9B%9B%E3%80%81%E7%8E%8B%E4%BA%94%5C%22%3B%5Cn%20%20expect(str).toMatch(%5C%22%E6%9D%8E%E5%9B%9B%5C%22)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%5Cn%5Cntest(%5C%22%E6%B5%8B%E8%AF%95toMatch%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20str%20%3D%20%5C%22%E5%BC%A0%E4%B8%89%E3%80%81%E6%9D%8E%E5%9B%9B%E3%80%81%E7%8E%8B%E4%BA%94%5C%22%3B%5Cn%20%20expect(str).toMatch(%2F%E6%9D%8E%E5%9B%9B%2F)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%22%7D\"></card><p><br /></p><p><code>toMatch</code> 为字符串包含匹配器，用来匹配字符串中包含的内容，也可传正则表达式</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.14-toContain()\"></a><h3 id=\"0e7662e8\">3.2.14 toContain()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%226825fc61%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test(%5C%22%E6%B5%8B%E8%AF%95toContain%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20arr%20%3D%20%5B%5C%22%E5%BC%A0%E4%B8%89%5C%22%2C%20%5C%22%E6%9D%8E%E5%9B%9B%5C%22%2C%20%5C%22%E7%8E%8B%E4%BA%94%5C%22%5D%3B%5Cn%20%20expect(arr).toContain(%5C%22%E5%BC%A0%E4%B8%89%5C%22)%3B%5Cn%7D)%3B%5Cn%2F%2F%20%E2%9C%85%5Cn%5Cntest(%5C%22%E6%B5%8B%E8%AF%95toContain%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20arr%20%3D%20%5B%5C%22%E5%BC%A0%E4%B8%89%5C%22%2C%20%5C%22%E6%9D%8E%E5%9B%9B%5C%22%2C%20%5C%22%E7%8E%8B%E4%BA%94%5C%22%5D%3B%5Cn%20%20const%20data%20%3D%20new%20Set(arr)%3B%5Cn%20%20expect(data).toContain(%5C%22%E5%BC%A0%E4%B8%89%5C%22)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p><code>toContain</code> 为数据包含匹器，用来匹配数组中包含的项。同时可完全兼容 <code>Set</code> 测试</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.15-toHaveLength()\"></a><h3 id=\"2d803288\">3.2.15 toHaveLength()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%223844d7f3%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20functions.js%5Cnexport%20default%20%7B%5Cn%20%20getIntArray(num)%20%7B%5Cn%20%20%20%20if%20(!Number.isInteger(num))%20%7B%5Cn%20%20%20%20%20%20throw%20Error('%5C%22getIntArray%5C%22%E5%8F%AA%E6%8E%A5%E5%8F%97%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0')%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20let%20result%20%3D%20%5B%5D%3B%5Cn%20%20%20%20for%20(let%20i%20%3D%200%2C%20len%20%3D%20num%3B%20i%20%3C%20len%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20result.push(i)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20result%3B%5Cn%20%20%7D%5Cn%7D%3B%5Cn%5Cn%2F%2F%2F%20functions.test.js%5Cnimport%20%7B%20getIntArray%20%7D%20from%20%5C%22..%2Fsrc%2Ffunctions%5C%22%3B%5Cntest(%5C%22getIntArray(3)%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E5%BA%94%E8%AF%A5%E4%B8%BA3%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20expect(getIntArray(3)).toHaveLength(3)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p><code>toHaveLength</code>可以很方便的用来测试字符串和数组类型的长度是否满足预期。</p><p><br /></p><a name=\"3.2.16-toThrow()\"></a><h3 id=\"c34e47a0\">3.2.16 toThrow()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22a8eeac06%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22const%20throwNewErrorFunc%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20throw%20new%20Error(%5C%22this%20is%20a%20new%20error%5C%22)%3B%5Cn%7D%3B%5Cn%5Cntest(%5C%22%E6%B5%8B%E8%AF%95toThrow%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20expect(throwNewErrorFunc).toThrow()%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p><code>toThrow</code> 是专门对异常进行处理的匹配器，可以检测一个方法会不会抛出异常</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22fba7a360%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22const%20throwNewErrorFunc%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20throw%20new%20Error(%5C%22this%20is%20a%20new%20error%5C%22)%3B%5Cn%7D%3B%5Cn%5Cntest(%5C%22%E6%B5%8B%E8%AF%95toThrow%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20expect(throwNewErrorFunc).toThrow(%5C%22this%20is%20a%20new%20error%5C%22)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>我们也可以对这个匹配器中加一些字符串，意思就是抛出的异常必须和字符串相对应，如果字符串不匹配，也没办法通过异常测试。</p><card type=\"block\" name=\"hr\"></card><a name=\"3.2.17-not()\"></a><h3 id=\"764f06c9\">3.2.17 not()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22a588efcc%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22const%20throwNewErrorFunc%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20throw%20new%20Error(%5C%22this%20is%20a%20new%20error%5C%22)%3B%5Cn%7D%3B%5Cn%5Cntest(%5C%22%E6%B5%8B%E8%AF%95not%E5%8C%B9%E9%85%8D%E5%99%A8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20expect(throwNewErrorFunc).not.toThrow()%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p><code>not</code> 匹配器是 <code>jest</code> 中比较特殊的匹配器，意思就是 “相反” 或者说 “取反” .比如上面的例子，我们不希望方法抛出异常，就可以使用<code>not</code> 匹配器。</p><card type=\"block\" name=\"hr\"></card><a name=\"3.3-异步代码测试方法\"></a><h3 id=\"3babda61\">3.3 异步代码测试方法</h3><p><br /></p><a name=\"3.3.1-回调函数式\"></a><h3 id=\"1891407f\">3.3.1 回调函数式</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b44f99c4%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20fetchData.js%5Cnimport%20axios%20from%20%5C%22axios%5C%22%3B%5Cnexport%20const%20fetchData%20%3D%20fn%20%3D%3E%20%7B%5Cn%20%20axios.get(%5C%22http%3A%2F%2Fa.jspang.com%2FjestTest.json%5C%22).then(res%20%3D%3E%20%7B%5Cn%20%20%20%20fn(res.data)%3B%5Cn%20%20%7D)%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%2F%20fetchData.test.js%5Cnimport%20%7B%20fetchData%20%7D%20from%20%5C%22.%2FfetchData.js%5C%22%3B%5Cntest(%5C%22fetchData%E6%B5%8B%E8%AF%95%5C%22%2C%20done%20%3D%3E%20%7B%5Cn%20%20fetchData(data%20%3D%3E%20%7B%5Cn%20%20%20%20expect(data).toEqual(%7B%20success%3A%20true%20%7D)%3B%5Cn%20%20%20%20done()%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>必须加入一个 <code>done</code> 方法，保证我们的回调已经完成了，这时候我们表示测试完成</p><card type=\"block\" name=\"hr\"></card><a name=\"3.3.2-直接返回-Promise\"></a><h3 id=\"0ad6b7b2\">3.3.2 直接返回 Promise</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%222dc53b09%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20fetchTwoData.js%5Cnimport%20axios%20from%20%5C%22axios%5C%22%3B%5Cnexport%20const%20fetchTwoData%20%3D%20()%20%3D%3E%20axios.get(%5C%22http%3A%2F%2Fa.jspang.com%2FjestTest.json%5C%22%3B%5Cn%5Cn%2F%2F%2F%20fetchTwoData.test.js%5Cnimport%20%7B%20fetchTwoData%20%7D%20from%20%5C%22.%2FfetchTwoData.js%5C%22%3B%5Cntest(%5C%22fetchTwoData%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20return%20fetchTwoData().then(res%20%3D%3E%20%7B%5Cn%20%20expect(res.data).toEqual(%7B%20success%3A%20true%20%7D)%3B%5Cn%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>注意要 <code>return</code></p><p><br /></p><a name=\"3.3.3-不存在的接口\"></a><h3 id=\"83b4fa78\">3.3.3 不存在的接口</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22a9b4308b%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20fetchData.js%5Cnexport%20const%20fetchData%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20return%20axios.get(%5C%22http%3A%2F%2Fa.jspang.com%2FjestTest_error.json%5C%22)%3B%20%2F%2F%20%E6%AD%A4%E5%9C%B0%E5%9D%80%E5%B9%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%5Cn%7D%3B%5Cn%5Cn%2F%2F%2F%20fetchData.test.js%5Cn%2F%2F%20%E6%96%B9%E5%BC%8F1%5Cntest(%5C%22fetchData%E6%B5%8B%E8%AF%95%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20expect.assertions(1)%3B%20%2F%2F%20%E6%96%AD%E8%A8%80%EF%BC%8C%E5%BF%85%E9%A1%BB%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%20expect%5Cn%20%20return%20fetchData().catch(err%20%3D%3E%20%7B%5Cn%20%20%20%20expect(err.toString().indexOf(%5C%22404%5C%22)%20%3E%20-1).toBe(true)%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20%E6%96%B9%E5%BC%8F2%5Cntest(%5C%22fetchData%E6%B5%8B%E8%AF%95%5C%22%2C%20async%20()%20%3D%3E%20%7B%5Cn%20%20return%20await%20fetchData().rejects.toThrow()%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20%E6%96%B9%E5%BC%8F3%5Cntest(%5C%22fetchData%E6%B5%8B%E8%AF%95%5C%22%2C%20async%20()%20%3D%3E%20%7B%5Cn%20%20expect().assertions(1)%3B%20%2F%2F%20%E6%96%AD%E8%A8%80%EF%BC%8C%E5%BF%85%E9%A1%BB%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%20expect%5Cn%20%20try%20%7B%5Cn%20%20%20%20await%20fetchData()%3B%5Cn%20%20%7D%20catch%20(err)%20%7B%5Cn%20%20%20%20expect(err.toString().indexOf(%5C%22404%5C%22)%20%3E%20-1).toBe(true)%3B%5Cn%20%20%7D%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>因为测试用例使用了 <code>catch</code> 方法，也就是说只有出现异常的时候才会走这个方法，而现在没有出现异常，就不会走这个测试方法，<code>jest</code> 就默认这个用例通过了测试。因此必须要执行断言，即必须让其执行一次即可。</p><p><br /></p><a name=\"3.3.4-async-await\"></a><h3 id=\"001d5d5a\">3.3.4 async/await</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b7df213b%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20fetchData.js%5Cnexport%20const%20fetchData%20%3D%20()%20%3D%3E%20%7B%5Cn%20return%20axios.get(%5C%22http%3A%2F%2Fa.jspang.com%2FjestTest.json%5C%22)%3B%20%2F%2F%20%E6%AD%A4%E5%9C%B0%E5%9D%80%E5%B9%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%7D%3B%5Cn%5Cn%2F%2F%2F%20fetchData.test.js%5Cn%2F%2F%20%E6%96%B9%E5%BC%8F1%5Cntest(%5C%22fetchData%E6%B5%8B%E8%AF%95%5C%22%2C%20async%20()%20%3D%3E%20%7B%5Cn%20await%20expect(fetchData()).resolves.toMatchObject(%7B%5Cn%20%20data%3A%20%7B%5Cn%20%20%20success%3A%20true%5Cn%20%20%7D%5Cn%20%7D)%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20%E6%96%B9%E5%BC%8F2%5Cntest(%5C%22fetchData%E6%B5%8B%E8%AF%95%5C%22%2C%20async%20()%20%3D%3E%20%7B%5Cn%20const%20response%20%3D%20await%20fetchData()%3B%5Cn%20expect(response.data).toEqual(%7B%20success%3A%20true%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>这时候我们的代码使用 <code>async....await...</code> 的形式，这里我们还使用了 <code>resolves</code> 用于把现有对象转换成 <code>Promise</code> 对象，然后使用 <code>jest</code> 中的 <code>toMatchObject</code> 进行匹配对象中的属性。</p><p><br /></p><a name=\"4.-jest-中的四个钩子函数\"></a><h2 id=\"9ead1173\">4. jest 中的四个钩子函数</h2><p><br /></p><a name=\"4.1-beforeAll()\"></a><h3 id=\"44253391\">4.1 beforeAll()</h3><p><br /></p><p><code>beforeAll()</code>钩子函数的意思是在所有测试用例之前进行执行。</p><p><br /></p><a name=\"4.2-afterAll()\"></a><h3 id=\"e43fb792\">4.2 afterAll()</h3><p><br /></p><p><code>afterAll()</code>钩子函数是在完成所有测试用例之后才执行的函数。</p><p><br /></p><a name=\"4.3-beforeEach()\"></a><h3 id=\"b6bb2f69\">4.3 beforeEach()</h3><p><br /></p><p><code>beforeEach()</code>钩子函数，是在每个测试用例前都会执行一次的钩子函数。</p><p><br /></p><a name=\"4.4-afterEach()\"></a><h3 id=\"4208beab\">4.4 afterEach()</h3><p><br /></p><p><code>afterEach()</code>钩子函数，是在每次测试用例完成测试之后执行一次的钩子函数。</p><p><br /></p><a name=\"5.-jest-测试用例分组\"></a><h2 id=\"7c331432\">5. jest 测试用例分组</h2><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%221f95dd76%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20eat.js%5Cnexport%20default%20class%20Eat%20%7B%5Cn%20%20setName(number)%20%7B%5Cn%20%20%20%20this.name%20%3D%20number%20%3D%3D%3D%201%20%3F%20%5C%22%E6%B0%B4%E9%A5%BA%5C%22%20%3A%20%5C%22%E7%81%AB%E9%94%85%5C%22%3B%5Cn%20%20%7D%5Cn%20%20setDesc()%20%7B%5Cn%20%20%20%20this.desc%20%3D%20this.user%20%2B%20%5C%22%E6%8F%8F%E8%BF%B0%5C%22%3B%5Cn%20%20%7D%5Cn%20%20setMoney()%20%7B%5Cn%20%20%20%20this.money%20%3D%20this.name%20%3D%3D%3D%20%5C%22%E6%B0%B4%E9%A5%BA%5C%22%20%3F%2080%20%3A%20300%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%2F%20eat.test.js%5Cnimport%20Eat%20from%20%5C%22.%2Feat%5C%22%3B%5Cnconst%20eat%20%3D%20new%20Eat()%3B%5CnbeforeAll(()%20%3D%3E%20%7B%5Cn%20%20console.log(%5C%22%E5%BC%80%E5%A7%8B%E5%90%83%E9%A5%AD%5C%22)%3B%5Cn%7D)%3B%5CnafterAll(()%20%3D%3E%20%7B%5Cn%20%20console.log(%5C%22%E5%90%83%E5%AE%8C%E9%A5%AD%E4%BA%86%5C%22)%3B%5Cn%7D)%3B%5Cndescribe(%5C%22%E6%B0%B4%E9%A5%BA%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20test(%5C%22%E6%B5%8B%E8%AF%95%E6%B0%B4%E9%A5%BA%E6%8F%8F%E8%BF%B0%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20eat.setName(1)%3B%5Cn%20%20%20%20eat.setDesc()%3B%5Cn%20%20%20%20expect(eat.desc).toEqual(%5C%22%E6%B0%B4%E9%A5%BA%E6%8F%8F%E8%BF%B0%5C%22)%3B%5Cn%20%20%7D)%3B%5Cn%20%20test(%5C%22%E6%B5%8B%E8%AF%95%E6%B0%B4%E9%A5%BA%E4%BB%B7%E6%A0%BC%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20eat.setName(1)%3B%5Cn%20%20%20%20eat.setMoney()%3B%5Cn%20%20%20%20expect(eat.money).toEqual(80)%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%5Cndescribe(%5C%22%E7%81%AB%E9%94%85%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20test(%5C%22%E6%B5%8B%E8%AF%95%E7%81%AB%E9%94%85%E6%8F%8F%E8%BF%B0%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20eat.setName(2)%3B%5Cn%20%20%20%20eat.setDesc()%3B%5Cn%20%20%20%20expect(eat.desc).toEqual(%5C%22%E7%81%AB%E9%94%85%E6%8F%8F%E8%BF%B0%5C%22)%3B%5Cn%20%20%7D)%3B%5Cn%20%20test(%5C%22%E6%B5%8B%E8%AF%95%E7%81%AB%E9%94%85%E4%BB%B7%E6%A0%BC%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20eat.setName(2)%3B%5Cn%20%20%20%20eat.setMoney()%3B%5Cn%20%20%20%20expect(eat.money).toEqual(300)%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"6.-钩子函数的作用域\"></a><h2 id=\"49e6c15a\">6. 钩子函数的作用域</h2><p><br /></p><a name=\"6.1-钩子函数在父级分组可作用域子集，类似继承\"></a><h3 id=\"45e52b93\">6.1 钩子函数在父级分组可作用域子集，类似继承</h3><p><br /></p><p>即父级作用域下的钩子函数在子作用域下也生效</p><p><br /></p><a name=\"6.2-钩子函数同级分组作用域互不干扰，各起作用\"></a><h3 id=\"d71c5a3e\">6.2 钩子函数同级分组作用域互不干扰，各起作用</h3><p><br /></p><p>同作用域下将都会执行</p><p><br /></p><a name=\"6.3-先执行外部的钩子函数，再执行内部的钩子函数\"></a><h3 id=\"1bf8564e\">6.3 先执行外部的钩子函数，再执行内部的钩子函数</h3><p><br /></p><p>优先父级作用域下的钩子函数，其次执行子作用域下的钩子函数</p><p><br /></p><a name=\"6.4-在进行测试准备的时候，将对应逻辑写到钩子函数\"></a><h3 id=\"df16bf8c\">6.4 在进行测试准备的时候，将对应逻辑写到钩子函数</h3><p><br /></p><p>如果将对应逻辑写到了非钩子函数的位置，那么将会优先执行，然后才会执行钩子函数</p><p><br /></p><a name=\"6.5-对单个测试用例的调试\"></a><h3 id=\"98129511\">6.5 对单个测试用例的调试</h3><p><br /></p><p>当一个测试文件中的测试用例变得越来越多的时候，假如此时我们相对其中某一个测试用例进行调试，那么我们就需要使用 <code>test.only</code></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22aacdbe9a%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22test.only(%5C%22%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20expect(1%20%2B%201).toBe(2)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"7.-Jest-中的-Mock\"></a><h2 id=\"a0910c49\">7. Jest 中的 Mock</h2><p><br /></p><a name=\"7.1-作用\"></a><h3 id=\"839e4d75\">7.1 作用</h3><p><br /></p><a name=\"7.1.1-捕获函数的调用和返回结果，以及--code-this--code--和调用顺序\"></a><h3 id=\"c2a650e9\">7.1.1 捕获函数的调用和返回结果，以及 <code>this</code> 和调用顺序</h3><p><br /></p><a name=\"7.1.2-它可以让我们自由的设置返回结果\"></a><h3 id=\"c18cc7ec\">7.1.2 它可以让我们自由的设置返回结果</h3><p><br /></p><a name=\"7.1.3-改变内部函数的实现\"></a><h3 id=\"1c8f5291\">7.1.3 改变内部函数的实现</h3><p><br /></p><a name=\"7.2-判定函数是否被调用\"></a><h3 id=\"bd204024\">7.2 判定函数是否被调用</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2205ab580a%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20runCallback%20%3D%20callback%20%3D%3E%20%7B%5Cn%20%20callback()%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20runCallback%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20runCallback%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20func%20%3D%20jest.fn()%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20expect(func).toBeCalled()%3B%20%2F%2F%20%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%A2%AB%E8%B0%83%E7%94%A8%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p><code>jest.fn()</code>  可以帮助我们捕获函数的调用</p><p><br /></p><a name=\"7.3-jest.fn().mock.calls-判定函数被调用了几次和传递的参数\"></a><h3 id=\"022d5da8\">7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22e33a49f0%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20runCallback%20%3D%20callback%20%3D%3E%20%7B%5Cn%20%20callback(%5C%22%E5%BC%A0%E4%B8%89%5C%22)%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20runCallback%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20runCallback%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20func%20%3D%20jest.fn()%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20expect(func.mock.calls.length).toBe(2)%3B%20%2F%2F%20%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%A2%AB%E8%B0%83%E7%94%A82%E6%AC%A1%5Cn%20%20expect(func.mock.calls%5B0%5D).toEqual(%5B%5C%22%E5%BC%A0%E4%B8%89%5C%22%5D)%3B%20%2F%2F%20%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BC%A0%E9%80%92%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%20%5C%22%E5%BC%A0%E4%B8%89%5C%22%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>此处打印 <code>func.mock</code>  将会打印一些常用的方法，可以根据需求进行相应的用例测试</p><p><br /></p><a name=\"7.4-jest.fn().mockReturnValue()-判定函数执行了几次和返回结果\"></a><h3 id=\"4b1d4193\">7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22e6701ee5%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20runCallback%20%3D%20callback%20%3D%3E%20%7B%5Cn%20%20callback(%5C%22%E5%BC%A0%E4%B8%89%5C%22)%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20runCallback%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20runCallback%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20func%20%3D%20jest.fn()%3B%5Cn%20%20%2F%2F%20func.mockReturnValue(%5C%22Common%5C%22)%5Cn%20%20%2F%2F%20%E6%89%80%E6%9C%89%E6%A8%A1%E6%8B%9F%E8%BF%94%E5%9B%9E%E5%80%BC%E9%83%BD%E6%98%AF%20%5C%22Common%5C%22%5Cn%20%20func.mockReturnValueOnce(%5C%22A%5C%22)%3B%20%2F%2F%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%A8%A1%E6%8B%9F%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%94%E5%9B%9E%20%5C%22A%5C%22%5Cn%20%20func.mockReturnValueOnce(%5C%22B%5C%22)%3B%20%2F%2F%20%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%A8%A1%E6%8B%9F%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%94%E5%9B%9E%20%5C%22B%5C%22%5Cn%20%20func.mockReturnValueOnce(%5C%22C%5C%22)%3B%20%2F%2F%20%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%A8%A1%E6%8B%9F%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%94%E5%9B%9E%20%5C%22C%5C%22%5Cn%20%20runCallback(func)%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20expect(func.mock.results%5B0%5D.value).toBe(%5C%22A%5C%22)%3B%5Cn%20%20expect(func.mock.results%5B1%5D.value).toBe(%5C%22B%5C%22)%3B%5Cn%20%20expect(func.mock.results%5B2%5D.value).toBe(%5C%22C%5C%22)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p><code>func.mockReturnValue()</code>  将对所有模拟返回的值生效</p><p><br /></p><p><code>func.mockReturnValueOnce()</code>  执行到第几次就对第几个函数的模拟返回值生效</p><p><br /></p><p>支持链式调用</p><p><br /></p><a name=\"7.5-jest.fn().mock.invocationCallOrder-判定函数执行顺序\"></a><h3 id=\"4d54342e\">7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2210964210%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20runCallback%20%3D%20callback%20%3D%3E%20%7B%5Cn%20%20callback(%5C%22%E5%BC%A0%E4%B8%89%5C%22)%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20runCallback%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20runCallback%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20func%20%3D%20jest.fn()%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20expect(func.mock.invocationCallOrder).toEqual(%5B1%2C%202%2C%203%5D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"7.6-jest.fn().mock.instances-判定函数调用了几次以及-this-指向\"></a><h3 id=\"b4132e26\">7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22a2847cd3%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20createObject%20%3D%20(ClassItem)%20%3D%3E%20%7B%5Cn%20%20new%20ClassItem()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20createObject%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20createObject%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20func%20%3D%20jest.fn()%3B%5Cn%20%20createObject(func)%3B%5Cn%20%20expect(func.mock.instances).toEqual(%5BmockConstructor%7B%7D%5D)%3B%20%2F%2F%20%E6%AD%A4%E5%A4%84%E7%9A%84%20this%20%E5%B0%B1%E6%98%AF%20mockConstructor%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"7.7-jest.fn().mockImplementation()-判定函数返回结果和其他逻辑处理\"></a><h3 id=\"3daaf7be\">7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22d0e5790f%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20runCallback%20%3D%20callback%20%3D%3E%20%7B%5Cn%20%20callback(%5C%22%E5%BC%A0%E4%B8%89%5C%22)%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20runCallback%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20runCallback%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20func%20%3D%20jest.fn()%3B%5Cn%20%20%2F%2F%20func.mockImplementation(()%20%3D%3E%20%5C%22hello%5C%22)%3B%20%E7%AD%89%E4%BB%B7%E4%BA%8E%20jest.fn(()%20%3D%3E%20%5C%22hello%5C%22)%5Cn%20%20%2F%2F%20func.mockImplementation(()%20%3D%3E%20this)%3B%20%E7%AD%89%E4%BB%B7%E4%BA%8E%20jest.fn().mockReturnThis()%5Cn%20%20func.mockImplementationOnce(()%20%3D%3E%20%5C%22dell%5C%22)%3B%5Cn%20%20func.mockImplementationOnce(()%20%3D%3E%20%5C%22lee%5C%22)%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20expect(func.mock.results%5B0%5D.value).toBe(%5C%22dell%5C%22)%3B%5Cn%20%20expect(func.mock.results%5B1%5D.value).toBe(%5C%22lee%5C%22)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p><code>mockImplementation</code>  比 <code>mockReturnValue</code>  更健壮，因为内部可以写一些额外的逻辑</p><p><br /></p><a name=\"7.8-toBeCalledWith()-来判定每次函数调用时的参数\"></a><h3 id=\"e5eee6bb\">7.8 toBeCalledWith() 来判定每次函数调用时的参数</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22c91c9935%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20runCallback%20%3D%20(callback)%20%3D%3E%20%7B%5Cn%20%20callback(%5C%22ABC%5C%22)%3B%5Cn%7D%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20runCallback%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20runCallback%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20func%20%3D%20jest.fn()%3B%5Cn%20%20runCallback(func)%3B%5Cn%20%20expect(func.mock.results%5B0%5D).toEqual(%5B%5C%22ABC%5C%22)%3B%5Cn%20%20expect(func).toBeCalledWith(%5C%22ABC%5C%22)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"7.9-模拟异步请求\"></a><h3 id=\"6c1b528b\">7.9 模拟异步请求</h3><p><br /></p><p>对于前端来说一般异步接口是测试是否发送了，而不测试后端接口返回的内容，是属于后端自动化测试的内容</p><p><br /></p><a name=\"7.9.1-通过模拟库的方式来模拟异步测试\"></a><h3 id=\"82bb8fdc\">7.9.1 通过模拟库的方式来模拟异步测试</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b2ac0edd%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20getData%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20return%20axios.get(%5C%22%2Fapi%5C%22).then(res%20%3D%3E%20res.data)%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20axios%20from%20%5C%22axios%5C%22%3B%5Cnimport%20%7B%20getData%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cnjest.mock(%5C%22axios%5C%22)%3B%20%2F%2F%20%E5%AF%B9%20axios%20%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%AF%B7%E6%B1%82%E7%9C%9F%E6%AD%A3%E6%95%B0%E6%8D%AE%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20getData%5C%22%2C%20async%20()%20%3D%3E%20%7B%5Cn%20%20axios.get.mockResolvedValue(%7B%20data%3A%20%5C%22hello%5C%22%20%7D)%3B%20%2F%2F%20%E4%BD%BF%E7%94%A8%20axios%20%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99%E6%A8%A1%E6%8B%9F%E6%88%90%E5%8A%9F%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%B0%B1%E6%98%AF%20hello%5Cn%20%20await%20getData().then(data%20%3D%3E%20%7B%5Cn%20%20%20%20expect(data).toBe(%5C%22hello%5C%22)%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p><code>mockResolvedValue</code> 模拟不限次数</p><p><br /></p><p><code>mockResolvedValueOnce</code> 模拟一次，模拟两次就会报错，需再次调用</p><p><br /></p><a name=\"7.9.2-通过模拟-Promise-方式模拟异步\"></a><h3 id=\"4ad5bf63\">7.9.2 通过模拟 Promise 方式模拟异步</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22117f187f%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20fetchData%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20return%20axios.get(%5C%22%2F%5C%22).then(res%20%3D%3E%20res.data)%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20__mocks__%2Fdemo.js%5Cnexport%20const%20fetchData%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%5Cn%20%20%20%20resolve(%5C%22function()%20%7B%20return%20'123'%20%7D%5C%22)%3B%5Cn%20%20%7D)%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnjest.mock(%5C%22.%2Fdemo%5C%22)%3B%5Cnimport%20%7B%20fetchData%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95fetchData%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20return%20fetchData().then(data%20%3D%3E%20%7B%5Cn%20%20%20%20expect(eval(data)).toEqual(%5C%22123%5C%22)%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%2F%20%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F3%5Cn%2F%2F%20%E4%BF%AE%E6%94%B9jest.config.js%20%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E6%9F%A5%E6%89%BE%E9%A1%B9%E7%9B%AE%E5%86%85%E9%83%A8__mocks__%E4%B8%8B%E4%B8%8E%E8%A6%81%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E7%9B%B8%E5%90%8C%E7%9A%84%E6%96%87%E4%BB%B6%E5%81%9A%E6%9B%BF%E6%8D%A2%5Cn%2F%2F%20%E7%AD%89%E5%90%8C%E4%BA%8E%20jest.mock(%5C%22%E8%A6%81%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E7%9B%B8%E5%90%8C%E7%9A%84__mocks__%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%5C%22)%7B%20%20automock%3A%20true%3B%20%7D%22%7D\"></card><p><br /></p><a name=\"7.9.3-通过修改-jest.config.js-来自动识别-strong-mocks--strong-下的文件\"></a><h3 id=\"481f7bdb\">7.9.3 通过修改 jest.config.js 来自动识别<strong>mocks</strong>下的文件</h3><p><br /></p><p>修改 <code>jest.config.js</code> 可以自动查找项目内部 <code>__mocks__</code> 下与要测试文件名字相同的文件做替换</p><p><br /></p><p>等同于&gt; <code>jest.mock(&quot;要测试文件名字相同的__mocks__下的文件&quot;)</code></p><p><br /></p><a name=\"7.9.4-使用-jest.unmock()-可取消-mock-模拟\"></a><h3 id=\"0c7a36bc\">7.9.4 使用 jest.unmock() 可取消 mock 模拟</h3><p><br /></p><a name=\"7.9.5-解决测试文件中部分功能不需要-mock，部分功能需要-mock-模拟异步的问题\"></a><h3 id=\"768c0ac4\">7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22471cecdd%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20fetchData%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20return%20axios.get(%5C%22%2F%5C%22).then(res%20%3D%3E%20res.data)%3B%5Cn%7D%3B%5Cnexport%20const%20getNumber%20%3D%20()%20%3D%3E%20123%3B%5Cn%5Cn%2F%2F%20__mocks__%2Fdemo.js%5Cnexport%20const%20fetchData%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%5Cn%20%20%20%20resolve(%5C%22function()%20%7B%20return%20'123'%20%7D%5C%22)%3B%5Cn%20%20%7D)%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnjest.mock(%5C%22.%2Fdemo%5C%22)%3B%5Cnimport%20%7B%20fetchData%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cnconst%20%7B%20getNumber%20%7D%20%3D%20jest.requireActual(%5C%22.%2Fdemo%5C%22)%3B%20%2F%2F%20%E5%BC%95%E5%85%A5%E7%9C%9F%E5%AE%9E%E6%96%87%E4%BB%B6%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20fetchData%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20return%20fetchData().then(data%20%3D%3E%20%7B%5Cn%20%20%20%20expect(eval(data)).toEqual(%5C%22123%5C%22)%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%5Cn%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20getNumber%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20expect(getNumber()).toEqual(123)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"8.-snapshot-快照测试\"></a><h2 id=\"65760d36\">8. snapshot 快照测试</h2><p><br /></p><p>常用于测试配置文件</p><p><br /></p><a name=\"8.1-toMatchSnapshot()\"></a><h3 id=\"cd5ad64e\">8.1 toMatchSnapshot()</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22bd715316%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20generateConfig%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20return%20%7B%5Cn%20%20%20%20server%3A%20%5C%22http%3A%2F%2Flocalhost%5C%22%2C%5Cn%20%20%20%20port%3A%208080%2C%5Cn%20%20%20%20domain%3A%20%5C%22localhost%5C%22%5Cn%20%20%7D%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20generateConfig%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20generateConfig%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20expect(generateConfig()).toMatchSnapshot()%3B%20%2F%2F%20%E5%B0%86%E4%BC%9A%E5%9C%A8%E9%A1%B9%E7%9B%AE%E9%87%8C%E7%94%9F%E6%88%90%E5%BF%AB%E7%85%A7%E6%96%87%E4%BB%B6%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>如果要确认更新快照，需要在控制台选择。 <code>u</code>  代表对所有快照进行更新， <code>i</code>  代表对单个确认的快照进行更新</p><p><br /></p><a name=\"8.2-测试部分可变变量的内容\"></a><h3 id=\"feac445e\">8.2 测试部分可变变量的内容</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%223179dbd8%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20generateConfig%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20return%20%7B%5Cn%20%20%20%20server%3A%20%5C%22http%3A%2F%2Flocalhost%5C%22%2C%5Cn%20%20%20%20port%3A%208080%2C%5Cn%20%20%20%20domain%3A%20%5C%22localhost%5C%22%2C%5Cn%20%20%20%20time%3A%20new%20Date()%2C%5Cn%20%20%20%20%2F%2F%20%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%5Cn%20%20%20%20random%3A%20Math.random()%5Cn%20%20%20%20%2F%2F%20%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%5Cn%20%20%7D%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20generateConfig%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20generateConfig%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20expect(generateConfig()).toMatchSnapshot(%7B%5Cn%20%20%20%20time%3A%20expect.any(Date)%2C%5Cn%20%20%20%20random%3A%20expect.any(Number)%5Cn%20%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"8.3-行内的-snapshot\"></a><h3 id=\"9a1d84a3\">8.3 行内的 snapshot</h3><p><br /></p><p><code>npm install prettier --save</code></p><p><br /></p><p>可以快照放到行内的测试用例中</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%224fc6eeb8%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20demo.js%5Cnexport%20const%20generateConfig%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20return%20%7B%5Cn%20%20%20%20server%3A%20%5C%22http%3A%2F%2Flocalhost%5C%22%2C%5Cn%20%20%20%20port%3A%208080%2C%5Cn%20%20%20%20domain%3A%20%5C%22localhost%5C%22%2C%5Cn%20%20%20%20time%3A%20new%20Date()%2C%5Cn%20%20%20%20%2F%2F%20%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%5Cn%20%20%20%20random%3A%20Math.random()%5Cn%20%20%20%20%2F%2F%20%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%5Cn%20%20%7D%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20demo.test.js%5Cnimport%20%7B%20generateConfig%20%7D%20from%20%5C%22.%2Fdemo%5C%22%3B%5Cntest(%5C%22%E6%B5%8B%E8%AF%95%20generateConfig%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%2F%2F%20toMatchInlineSnapshot%20%E5%8F%AF%E4%BB%A5%E5%BF%AB%E7%85%A7%E6%94%BE%E5%88%B0%E8%A1%8C%E5%86%85%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%B8%AD%5Cn%20%20expect(generateConfig()).toMatchInlineSnapshot(%7B%5Cn%20%20%20%20time%3A%20expect.any(Date)%2C%5Cn%20%20%20%20random%3A%20expect.any(Number)%5Cn%20%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><card type=\"block\" name=\"hr\"></card><a name=\"9.-Test-Driven-Development(TDD)-测试驱动开发\"></a><h2 id=\"23393306\">9. Test Driven Development(TDD) 测试驱动开发</h2><p><br /></p><a name=\"9.1-TDD-开发流程\"></a><h3 id=\"ed6430cc\">9.1 TDD 开发流程</h3><p><br /></p><ol start=\"1\"><li>编写测试用例（知道功能，先写测试用例）</li></ol><ol start=\"2\"><li>运行测试，测试用例无法通过测试</li></ol><ol start=\"3\"><li>编写代码，使测试用例通过测试</li></ol><ol start=\"4\"><li>优化代码， 完成开发</li></ol><ol start=\"5\"><li>新增功能，重复执行 1-4</li></ol><p><br /></p><a name=\"9.2-TDD-的优势\"></a><h3 id=\"3c65ae93\">9.2 TDD 的优势</h3><p><br /></p><ol start=\"1\"><li>长期减少项目的回归 bug（减少修改代码产生的 bug）</li></ol><ol start=\"2\"><li>代码质量更好（组织，可维护性好）</li></ol><ol start=\"3\"><li>测试覆盖率高（因为是先编写测试用例，但测试覆盖率过高会影响很大精力）</li></ol><ol start=\"4\"><li>错误测试代码不容易出现</li></ol><p><br /></p><a name=\"9.3-TDD-的适用场景\"></a><h3 id=\"3ecdd7a1\">9.3 TDD 的适用场景</h3><p><br /></p><ol start=\"1\"><li>不适用于开发业务代码时使用（开发业务代码时会大量的与业务代码产生耦合，加大工作量）</li></ol><ol start=\"2\"><li>适用于一些库的开发（开发库时代码耦合度较低，通常只处理函数等相关功能）</li></ol><card type=\"block\" name=\"hr\"></card><a name=\"10.-Behavior-Driven-Development(BDD)-行为驱动开发\"></a><h2 id=\"59f902bb\">10. Behavior Driven Development(BDD) 行为驱动开发</h2><p><br /></p><a name=\"10.1-BDD-开发流程\"></a><h3 id=\"6733a7a6\">10.1 BDD 开发流程</h3><p><br /></p><ol start=\"1\"><li>先编写业务代码，不关心测试</li></ol><ol start=\"2\"><li>思考并描述用户行为</li></ol><ol start=\"3\"><li>根据用户行为模拟测试</li></ol><p><br /></p><a name=\"10.2-vue-example\"></a><h3 id=\"f821175c\">10.2 vue example</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2295c13e7f%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20testUtils.js%5Cnexport%20const%20findTestWrapper%20%3D%20(wrapper%2C%20tag)%20%3D%3E%20%7B%5Cn%20%20return%20wrapper.find(%60%5Bdata-test%3D%5C%22%24%7Btag%7D%5C%22%5D%60)%3B%5Cn%7D%3B%22%7D\"></card><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22c8bbaa92%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20__tests__%2Fintegration%2FTodoList.test.js%5Cnimport%20%7B%20mount%20%7D%20from%20%5C%22%40vue%2Ftest-utils%5C%22%3B%5Cnimport%20%7B%20findTestWrapper%20%7D%20from%20%5C%22..%2F..%2F..%2F..%2Futils%2FtestUtils%5C%22%3B%5Cnimport%20TodoList%20from%20%5C%22..%2F..%2FTodoList%5C%22%3B%5Cn%2F%2F%20import%20store%20from%20%5C%22..%2F..%2F..%2F..%2Fstore%5C%22%5Cnit(%60%20%20%20%20%5Cn%20%E6%96%B0%E5%A2%9E%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%20%20%20%20%5Cn%201.%20%E7%94%A8%E6%88%B7%E4%BC%9A%E5%9C%A8header%E8%BE%93%E5%85%A5%E6%A1%86%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%20%20%20%20%5Cn%202.%20%E7%94%A8%E6%88%B7%E4%BC%9A%E7%82%B9%E5%87%BB%E5%9B%9E%E8%BD%A6%E6%8C%89%E9%92%AE%20%20%5Cn%203.%20%E5%88%97%E8%A1%A8%E9%A1%B9%E5%BA%94%E8%AF%A5%E5%A2%9E%E5%8A%A0%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E7%9A%84%E5%88%97%E8%A1%A8%E9%A1%B9%60%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20wrapper%20%3D%20mount(TodoList)%3B%5Cn%20%20%2F%2F%20const%20wrapper%20%3D%20mount(TodoList%2C%20%7B%20store%20%7D)%5Cn%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%20vuex%EF%BC%8C%E4%B9%9F%E5%87%A0%E4%B9%8E%E6%97%A0%E6%94%B9%E5%8A%A8%5Cn%20%20const%20inputElem%20%3D%20findTestWrapper(wrapper%2C%20%5C%22header-input%5C%22).at(0)%3B%5Cn%20%20const%20content%20%3D%20%5C%22Dell%20lee%5C%22%3B%5Cn%20%20inputElem.setValue(content)%3B%5Cn%20%20inputElem.trigger(%5C%22change%5C%22)%3B%5Cn%20%20inputElem.trigger(%5C%22keyup.enter%5C%22)%3B%5Cn%20%20const%20listItems%20%3D%20findTestWrapper(wrapper%2C%20%5C%22list-item%5C%22).at(0)%3B%5Cn%20%20expect(listItems.length).toBe(1)%3B%5Cn%20%20expect(listItems.at(0).text()).toContain(content)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"10.3-react-example\"></a><h3 id=\"9b16dd87\">10.3 react example</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2295c13e7f-1%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20testUtils.js%5Cnexport%20const%20findTestWrapper%20%3D%20(wrapper%2C%20tag)%20%3D%3E%20%7B%5Cn%20%20return%20wrapper.find(%60%5Bdata-test%3D%5C%22%24%7Btag%7D%5C%22%5D%60)%3B%5Cn%7D%3B%22%7D\"></card><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22e3407c38%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20__tests__%2Fintegration%2FTodoList.test.js%5Cnimport%20React%20from%20%5C%22react%5C%22%3B%5Cn%2F%2F%20import%20%7B%20Provider%20%7D%20from%20%5C%22react-redux%5C%22%3B%5Cnimport%20Enzyme%2C%20%7B%20mount%20%7D%20from%20%5C%22enzyme%5C%22%3B%5Cnimport%20Adapter%20from%20%5C%22enzyme-adapter-react-16%5C%22%3B%5Cnimport%20TodoList%20from%20%5C%22..%2F..%2FTodoList%5C%22%3B%5Cn%2F%2F%20import%20store%20from%20%5C%22..%2F..%2F..%2F..%2Fstore%2FcreateStore%5C%22%3B%5CnEnzyme.configure(%7B%20adapter%3A%20new%20Adapter()%20%7D)%3B%5Cn%5Cnit(%60%5Cn%20%20%20%20%E6%96%B0%E5%A2%9E%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%5Cn%20%20%20%201.%20%E7%94%A8%E6%88%B7%E4%BC%9A%E5%9C%A8header%E8%BE%93%E5%85%A5%E6%A1%86%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%5Cn%20%20%20%202.%20%E7%94%A8%E6%88%B7%E4%BC%9A%E7%82%B9%E5%87%BB%E5%9B%9E%E8%BD%A6%E6%8C%89%E9%92%AE%5Cn%20%20%203.%20%E5%88%97%E8%A1%A8%E9%A1%B9%E5%BA%94%E8%AF%A5%E5%A2%9E%E5%8A%A0%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E7%9A%84%E5%88%97%E8%A1%A8%E9%A1%B9%5Cn%60%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20wrapper%20%3D%20mount(%3CTodoList%20%2F%3E)%3B%5Cn%20%20%2F**%20%5Cn%20%20const%20wrapper%20%3D%20mount(%5Cn%20%20%20%3CProvider%20store%3D%7Bstore%7D%3E%5Cn%20%20%20%20%3CTodoList%20%2F%3E%3C%2FProvider%3E%5Cn%20%20%20%3C%2FProvider%3E%5Cn%20%20)%20%20%5Cn%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%20redux%EF%BC%8C%E4%B9%9F%E5%87%A0%E4%B9%8E%E6%97%A0%E6%94%B9%E5%8A%A8%5Cn%20*%2F%5Cn%20%20const%20inputElem%20%3D%20findTestWrapper(wrapper%2C%20%5C%22header-input%5C%22)%3B%5Cn%20%20const%20content%20%3D%20%5C%22Dell%20lee%5C%22%3B%5Cn%20%20inputElem.simulate(%5C%22change%5C%22%2C%20%7B%20target%3A%20%7B%20value%3A%20content%20%7D%20%7D)%3B%5Cn%20%20inputElem.simulate(%5C%22keyUp%5C%22%2C%20%7B%20keyCode%3A%2013%20%7D)%3B%5Cn%20%20const%20listItems%20%3D%20findTestWrapper(wrapper%2C%20%5C%22list-item%5C%22)%3B%5Cn%20%20expect(listItems.length).toBe(1)%3B%5Cn%20%20expect(listItems.text()).toContain(content)%3B%5Cn%7D)%3B%22%7D\"></card><card type=\"block\" name=\"hr\"></card><a name=\"11.-TDD-和-BDD-的对比\"></a><h2 id=\"c2aee4b0\">11. TDD 和 BDD 的对比</h2><p><br /></p><ol start=\"1\"><li><code>TDD</code> 先写测试后写代码; <code>BDD</code> 先写代码后写测试</li></ol><ol start=\"2\"><li><code>TDD</code> 创建的是 <code>unit</code> 单元测试文件夹，一般结合单元测试，属于白盒测试(知道实现测试代码); <code>BDD</code> 创建的是 <code>integration</code> 集成测试文件夹，一般结合集成测试，属于黑盒测试(不知道实现测试代码)</li></ol><ol start=\"3\"><li><code>TDD</code> 测试重点在代码; <code>BDD</code> 测试重点在 <code>UI</code> ( <code>DOM</code>)</li></ol><ol start=\"4\"><li><code>TDD</code> 安全感低(无法保证各个组件拼撞到一起是否不会有问题); <code>BDD</code> 安全感高</li></ol><ol start=\"5\"><li><code>TDD</code> 速度快; <code>BDD</code> 速度慢</li></ol><card type=\"block\" name=\"hr\"></card><a name=\"12.-TDD-与-BDD-混用\"></a><h2 id=\"1f761f1e\">12. TDD 与 BDD 混用</h2><p><br /></p><a name=\"12.1-对一些工具函数的测试\"></a><h3 id=\"11f73608\">12.1 对一些工具函数的测试</h3><p><br /></p><a name=\"12.2-对-vuex-的-store-进行测试\"></a><h3 id=\"4767b160\">12.2 对 vuex 的 store 进行测试</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22f84c502d%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20__tests__%2Funit%2Fstore.test.js%5Cnimport%20store%20from%20%5C%22..%2F..%2F..%2F..%2Fstore%5C%22%3B%5Cnit(%5C%22%E5%BD%93%20store%20%E6%8E%A5%E5%8F%97%20changeInputValue%20%E7%9A%84%20commit%20%E6%97%B6%2C%20inputValue%20%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20value%20%3D%20%5C%22123%5C%22%3B%5Cn%20%20store.commit(%5C%22changeInputValue%5C%22%2C%20value)%3B%5Cn%20%20expect(store.state.inputValue).toBe(value)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"12.3-对-redux-的-store-进行测试\"></a><h3 id=\"05a2b125\">12.3 对 redux 的 store 进行测试</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22809c97fb%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20__tests__%2Funit%2Fstore.test.js%5Cnimport%20store%20from%20%5C%22..%2F..%2F..%2F..%2Fstore%2FcreateStore%5C%22%3B%5Cnimport%20%7B%20changeInputValue%20%7D%20from%20%5C%22..%2F..%2F..%2F..%2Fstore%2Factions%5C%22%3B%5Cnit(%5C%22%E5%BD%93%20store%20%E6%8E%A5%E5%8F%97%20changeInputValue%20%E7%9A%84%20dispatch%20%E6%97%B6%2C%20inputValue%20%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20value%20%3D%20%5C%22123%5C%22%3B%5Cn%20%20%2F**%20%20%20%5Cn%20%20const%20changeInputValue%20%3D%20(payload)%20%3D%3E%20(%7B%20%5Cn%20%20%20type%3A%20CHANGE_IMPUT_VALUE%2C%20payload%20%5Cn%20%20%7D)%20%20%20%5Cn%20*%2F%5Cn%20%20store.dispatch(changeInputValue(value))%3B%5Cn%20%20expect(store.getState().inputValue).toBe(value)%3B%5Cn%7D)%3B%22%7D\"></card><card type=\"block\" name=\"hr\"></card><a name=\"13.-异步测试\"></a><h2 id=\"71b9d92e\">13. 异步测试</h2><p><br /></p><p>注意：异步测试如果用到了异步函数，则需要调用 <code>done</code>  函数</p><p><br /></p><a name=\"13.1-vue-的异步测试\"></a><h3 id=\"e3e302bb\">13.1 vue 的异步测试</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2257e7f0e3%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%2F%20__mocks__%2Faxios.js%5Cnconst%20undoList%20%3D%20%7B%20%20success%3A%20true%2C%20%20data%3A%20%5B%5Cn%20%7B%20status%3A%20%5C%22div%5C%22%2C%20value%3A%20%5C%22dell%5C%22%20%7D%2C%5Cn%20%7B%20status%3A%20%5C%22div%5C%22%2C%20value%3A%20%5C%22lee%5C%22%20%7D%5Cn%5D%7D%3B%5Cnexport%20default%20%7B%5Cn%20get(url)%20%7B%5Cn%20%20if%20(url%20%3D%3D%3D%20%5C%22%2FgetUndoList.json%5C%22)%20%7B%5Cn%20%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%5Cn%20%20%20%20if%20(this.success%20%3D%3D%3D%20true)%20%7B%5Cn%20%20%20%20%20resolve(undoList)%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20reject(new%20Error())%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%7D)%3B%5Cn%20%20%7D%5Cn%20%7D%7D%3B%5Cn%5Cn%2F%2F%2F%20__tests__%2Fintegration%2FTodoList.test.js%5Cnimport%20%7B%20mount%20%7D%20from%20%5C%22%40vue%2Ftest-utils%5C%22%3B%5Cnimport%20%7B%20findTestWrapper%20%7D%20from%20%5C%22..%2F..%2F..%2F..%2Futils%2FtestUtils%5C%22%3B%5Cnimport%20TodoList%20from%20%5C%22..%2F..%2FTodoList%5C%22%3B%5Cnimport%20store%20from%20%5C%22..%2F..%2F..%2F..%2Fstore%5C%22%3B%5Cn%5CnbeforeEach(()%20%3D%3E%20%7B%5Cn%20axios.success%20%3D%20true%3B%5Cn%20jest.useFakeTimers()%3B%20%2F%2F%20%E5%86%99%E5%9C%A8%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%B8%BA%E4%BA%86%E6%B8%85%E9%99%A4%E7%BB%9F%E8%AE%A1%E6%AC%A1%E6%95%B0%EF%BC%8C%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%AF%B9%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BA%A7%E7%94%9F%E5%BD%B1%E5%93%8D%7D)%3B%5Cnit(%601.%20%E7%94%A8%E6%88%B7%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BF%9C%E7%A8%8B%E6%B5%8B%E8%AF%95%3B%202.%20%E5%88%97%E8%A1%A8%E5%BA%94%E8%AF%A5%E6%98%BE%E7%A4%BA%E8%BF%9C%E7%A8%8B%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%60%2C%20done%20%3D%3E%20%7B%5Cn%20%20const%20wrapper%20%3D%20mount(TodoList%2C%20%7B%20store%20%7D)%3B%5Cn%20%20wrapper.vm.%24nickTick(()%20%3D%3E%20%7B%5Cn%20%20%20const%20listItems%20%3D%20findTestWrapper(wrapper%2C%20%5C%22list-item%5C%22)%3B%5Cn%20%20%20expect(listItems.length).toBe(2)%3B%5Cn%20%20%20done()%3B%5Cn%20%20%7D)%3B%5Cn%20%7D)%3B%5Cnit(%601.%20%E7%94%A8%E6%88%B7%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E7%AD%89%E5%BE%855s%3B%202.%20%E5%88%97%E8%A1%A8%E5%BA%94%E8%AF%A5%E6%98%BE%E7%A4%BA%E8%BF%9C%E7%A8%8B%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%60%2C%20done%20%3D%3E%20%7B%5Cn%20const%20wrapper%20%3D%20mount(TodoList%2C%20%7B%20store%20%7D)%3B%5Cn%20expect(setTimeout).toHaveBeenCalledTimes(1)%3B%20%2F%2F%20%E8%87%B3%E5%B0%91%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%5Cn%20jest.runAllTimers()%3B%5Cn%20wrapper.vm.%24nickTick(()%20%3D%3E%20%7B%5Cn%20%20const%20listItems%20%3D%20findTestWrapper(wrapper%2C%20%5C%22list-item%5C%22)%3B%5Cn%20%20expect(listItems.length).toBe(2)%3B%5Cn%20%20done()%3B%5Cn%20%7D)%3B%5Cn%7D)%3B%5Cn%5Cnit(%601.%20%E7%94%A8%E6%88%B7%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%A4%B1%E8%B4%A5%3B%202.%20%E5%88%97%E8%A1%A8%E5%BA%94%E8%AF%A5%E6%98%BE%E7%A4%BA%E7%A9%BA%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8D%E5%BA%94%E8%AF%A5%E6%8C%82%E6%8E%89%60%2C%20done%20%3D%3E%20%7B%5Cn%20axios.success%20%3D%20false%3B%5Cn%20const%20wrapper%20%3D%20mount(TodoList%2C%20%7B%20store%20%7D)%3B%5Cn%20expect(setTimeout).toHaveBeenCalledTimes(1)%3B%20%2F%2F%20%E8%87%B3%E5%B0%91%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%5Cn%20jest.runAllTimers()%3B%5Cn%20wrapper.vm.%24nickTick(()%20%3D%3E%20%7B%5Cn%20%20const%20listItems%20%3D%20findTestWrapper(wrapper%2C%20%5C%22list-item%5C%22)%3B%5Cn%20%20expect(listItems.length).toBe(0)%3B%5Cn%20%20done()%3B%5Cn%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"13.2-react-的异步测试\"></a><h3 id=\"833ac6cf\">13.2 react 的异步测试</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%220b2ddbf7%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%2F%20__mocks__%2Faxios.js%5Cnconst%20undoList%20%3D%20%7B%5Cn%20%20success%3A%20true%2C%5Cn%20%20data%3A%20%5B%5Cn%20%20%20%20%7B%20status%3A%20%5C%22div%5C%22%2C%20value%3A%20%5C%22dell%5C%22%20%7D%2C%5Cn%20%20%20%20%7B%20status%3A%20%5C%22div%5C%22%2C%20value%3A%20%5C%22lee%5C%22%20%7D%5Cn%20%20%5D%5Cn%7D%3B%5Cn%5Cnexport%20default%20%7B%5Cn%20%20get(url)%20%7B%5Cn%20%20%20%20if%20(url%20%3D%3D%3D%20%5C%22%2FgetUndoList.json%5C%22)%20%7B%5Cn%20%20%20%20%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20if%20(this.success%20%3D%3D%3D%20true)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20resolve(undoList)%3B%5Cn%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20reject(new%20Error())%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%7D%3B%5Cn%5Cn%2F%2F%2F%20__tests__%2Fintegration%2FTodoList.test.js%5Cnimport%20React%20from%20%5C%22react%5C%22%3B%5Cnimport%20%7B%20Provider%20%7D%20from%20%5C%22react-redux%5C%22%3B%5Cnimport%20Enzyme%2C%20%7B%20mount%20%7D%20from%20%5C%22enzyme%5C%22%3B%5Cnimport%20Adapter%20from%20%5C%22enzyme-adapter-react-16%5C%22%3B%5Cnimport%20TodoList%20from%20%5C%22..%2F..%2FTodoList%5C%22%3B%5Cnimport%20store%20from%20%5C%22..%2F..%2F..%2F..%2Fstore%2FcreateStore%5C%22%3B%5CnEnzyme.configure(%7B%20adapter%3A%20new%20Adapter()%20%7D)%3B%5Cn%5CnbeforeEach(()%20%3D%3E%20%7B%5Cn%20%20axios.success%20%3D%20true%3B%5Cn%20%20jest.useFakeTimers()%3B%20%2F%2F%20%E5%86%99%E5%9C%A8%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%B8%BA%E4%BA%86%E6%B8%85%E9%99%A4%E7%BB%9F%E8%AE%A1%E6%AC%A1%E6%95%B0%EF%BC%8C%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%EF%BC%8C%E9%98%B2%E6%AD%A2%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%AF%B9%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BA%A7%E7%94%9F%E5%BD%B1%E5%93%8D%5Cn%7D)%3B%5Cn%5Cnit(%60%5Cn%20%20%20%201.%20%E7%94%A8%E6%88%B7%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BF%9C%E7%A8%8B%E6%B5%8B%E8%AF%95%5Cn%20%20%20%202.%20%E5%88%97%E8%A1%A8%E5%BA%94%E8%AF%A5%E6%98%BE%E7%A4%BA%E8%BF%9C%E7%A8%8B%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%5Cn%60%2C%20done%20%3D%3E%20%7B%5Cn%20%20const%20wrapper%20%3D%20mount(%5Cn%20%20%20%20%3CProvider%20store%3D%7Bstore%7D%3E%5Cn%20%20%20%20%20%20%3CTodoList%20%2F%3E%5Cn%20%20%20%20%3C%2FProvider%3E%5Cn%20%20)%3B%5Cn%20%20process.nickTick(()%20%3D%3E%20%7B%5Cn%20%20%20%20wrapper.update()%3B%5Cn%20%20%20%20const%20listItems%20%3D%20findTestWrapper(wrapper%2C%20%5C%22list-item%5C%22)%3B%5Cn%20%20%20%20expect(listItems.length).toBe(2)%3B%5Cn%20%20%20%20done()%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%5Cn%5Cnit(%60%5Cn%20%20%20%201.%20%E7%94%A8%E6%88%B7%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E7%AD%89%E5%BE%855s%5Cn%20%20%20%202.%20%E5%88%97%E8%A1%A8%E5%BA%94%E8%AF%A5%E6%98%BE%E7%A4%BA%E8%BF%9C%E7%A8%8B%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%5Cn%60%2C%20done%20%3D%3E%20%7B%5Cn%20%20const%20wrapper%20%3D%20mount(%5Cn%20%20%20%20%3CProvider%20store%3D%7Bstore%7D%3E%5Cn%20%20%20%20%20%20%3CTodoList%20%2F%3E%5Cn%20%20%20%20%3C%2FProvider%3E%5Cn%20%20)%3B%5Cn%20%20expect(setTimeout).toHaveBeenCalledTimes(1)%3B%20%2F%2F%20%E8%87%B3%E5%B0%91%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%5Cn%20%20jest.runAllTimers()%3B%5Cn%20%20process.nickTick(()%20%3D%3E%20%7B%5Cn%20%20%20%20wrapper.update()%3B%20%2F%2F%20%E6%9B%B4%E6%96%B0%20wrapper%20%E9%98%B2%E6%AD%A2%E5%8F%96%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%20wrapper%5Cn%20%20%20%20const%20listItems%20%3D%20findTestWrapper(wrapper%2C%20%5C%22list-item%5C%22)%3B%5Cn%20%20%20%20expect(listItems.length).toBe(2)%3B%5Cn%20%20%20%20done()%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%5Cn%5Cnit(%60%5Cn%20%201.%20%E7%94%A8%E6%88%B7%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%A4%B1%E8%B4%A5%5Cn%20%202.%20%E5%88%97%E8%A1%A8%E5%BA%94%E8%AF%A5%E6%98%BE%E7%A4%BA%E7%A9%BA%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8D%E5%BA%94%E8%AF%A5%E6%8C%82%E6%8E%89%5Cn%60%2C%20done%20%3D%3E%20%7B%5Cn%20%20axios.success%20%3D%20false%3B%5Cn%20%20const%20wrapper%20%3D%20mount(%5Cn%20%20%20%20%3CProvider%20store%3D%7Bstore%7D%3E%5Cn%20%20%20%20%20%20%3CTodoList%20%2F%3E%5Cn%20%20%20%20%3C%2FProvider%3E%5Cn%20%20)%3B%5Cn%20%20expect(setTimeout).toHaveBeenCalledTimes(1)%3B%20%2F%2F%20%E8%87%B3%E5%B0%91%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%5Cn%20%20jest.runAllTimers()%3B%5Cn%20%20process.nickTick(()%20%3D%3E%20%7B%5Cn%20%20%20%20wrapper.update()%3B%5Cn%20%20%20%20const%20listItems%20%3D%20findTestWrapper(wrapper%2C%20%5C%22list-item%5C%22)%3B%5Cn%20%20%20%20expect(listItems.length).toBe(0)%3B%5Cn%20%20%20%20done()%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><card type=\"block\" name=\"hr\"></card><a name=\"14.-vue-项目的自动化测试\"></a><h2 id=\"63ab0b81\">14. vue 项目的自动化测试</h2><p><br /></p><a name=\"14.1-使用传统方式对-vue-组件进行测试\"></a><h3 id=\"7740ff83\">14.1 使用传统方式对 vue 组件进行测试</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22d03cf515%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20HelloWorld.test.js%5Cnimport%20Vue%20from%20%5C%22vue%5C%22%3B%5Cnimport%20HelloWorld%20from%20%5C%22%40%2Fcomponents%2FHelloWorld%5C%22%3B%5Cndescribe(%5C%22HelloWorld.vue%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20it(%5C%22renders%20props.msg%20when%20passed%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20root%20%3D%20document.createElement(%5C%22div%5C%22)%3B%5Cn%20%20%20%20root.className%20%3D%20%5C%22root%5C%22%3B%5Cn%20%20%20%20document.body.appendChild(root)%3B%5Cn%20%20%20%20new%20Vue(%7B%5Cn%20%20%20%20%20%20render%3A%20h%20%3D%3E%5Cn%20%20%20%20%20%20%20%20h(HelloWorld%2C%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20props%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20msg%3A%20%5C%22dell%20lee%5C%22%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%7D).%24mount(%5C%22.root%5C%22)%3B%5Cn%20%20%20%20expect(document.getElementByClassName(%5C%22hello%5C%22).length).toBe(1)%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p><p><br /></p><a name=\"14.2-使用-@vue-test-utils-对-vue-组件进行测试\"></a><h3 id=\"9f92aeab\">14.2 使用 @vue/test-utils 对 vue 组件进行测试</h3><p><br /></p><ul><li><a href=\"https://vue-test-utils.vuejs.org/zh/\" target=\"_blank\">官方文档</a></li></ul><p><br /></p><a name=\"14.2.1-for-example\"></a><h3 id=\"474de05c\">14.2.1 for example</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b12b396b%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20HelloWorld.test.js%5Cnimport%20%7B%20shallowMount%20%7D%20from%20%5C%22%40vue%2Ftest-utils%5C%22%3B%5Cnimport%20HelloWorld%20from%20%5C%22%40%2Fcomponents%2FHelloWorld%5C%22%3B%5Cndescribe(%5C%22HelloWorld.vue%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20it(%5C%22renders%20props.msg%20when%20passed%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20msg%20%3D%20%5C%22dell%20lee%5C%22%3B%5Cn%20%20%20%20const%20wrapper%20%3D%20shallowMount(HelloWorld%2C%20%7B%5Cn%20%20%20%20%20%20propsData%3A%20%7B%20msg%20%7D%5Cn%20%20%20%20%7D)%3B%5Cn%20%20%20%20expect(wrapper.text()).toMatch(msg)%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><a name=\"14.2.2-快照测试\"></a><h3 id=\"42aa9119\">14.2.2 快照测试</h3><p><br /></p><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p><p><br /></p><p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%220c1e8f28%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20HelloWorld.test.js%5Cnimport%20%7B%20shallowMount%20%7D%20from%20%5C%22%40vue%2Ftest-utils%5C%22%3B%5Cnimport%20HelloWorld%20from%20%5C%22%40%2Fcomponents%2FHelloWorld%5C%22%3B%5Cndescribe(%5C%22HelloWorld.vue%20%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%AD%A3%E5%B8%B8%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20it(%5C%22renders%20props.msg%20when%20passed%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20msg%20%3D%20%5C%22dell%20lee%5C%22%3B%5Cn%20%20%20%20const%20wrapper%20%3D%20shallowMount(HelloWorld%2C%20%7B%5Cn%20%20%20%20%20%20propsData%3A%20%7B%20msg%20%7D%5Cn%20%20%20%20%7D)%3B%5Cn%20%20%20%20expect(wrapper).toMatchSnapshot()%3B%5Cn%20%20%7D)%3B%5Cn%7D)%3B%22%7D\"></card><card type=\"block\" name=\"hr\"></card><a name=\"15.-react-项目的自动化测试\"></a><h2 id=\"245d2d6a\">15. react 项目的自动化测试</h2><p><br /></p><a name=\"15.1-使用传统方式对-react-组件进行测试\"></a><h3 id=\"a85bc8fa\">15.1 使用传统方式对 react 组件进行测试</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22e7fa5dc1%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20App.test.js%5Cnimport%20React%20from%20%5C%22react%5C%22%3B%5Cnimport%20ReactDOM%20from%20%5C%22react-dom%5C%22%3B%5Cnimport%20App%20from%20%5C%22.%2FApp%5C%22%3B%5Cn%5Cnit(%5C%22render%20App%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20div%20%3D%20document.createElement(%5C%22div%5C%22)%3B%5Cn%20%20ReactDOM.render(%3CApp%20%2F%3E%2C%20div)%3B%5Cn%20%20const%20container%20%3D%20div.getElementsByClassName(%5C%22App%5C%22)%3B%5Cn%20%20expect(container.length).toBe(1)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p><p><br /></p><a name=\"15.2-enzyme-的配置和使用\"></a><h3 id=\"b54705b0\">15.2 enzyme 的配置和使用</h3><p><br /></p><ul><li><a href=\"https://enzymejs.github.io/enzyme/\" target=\"_blank\">官方文档</a></li></ul><ul><li><a href=\"https://github.com/enzymejs/enzyme\" target=\"_blank\">github</a></li></ul><ul><li><a href=\"https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-enzyme\" target=\"_blank\">jest-enzyme</a></li></ul><p><br /></p><a name=\"15.2.1-for-example\"></a><h3 id=\"2edd525d\">15.2.1 for example</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22a32baa77%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20App.test.js%5Cnimport%20React%20from%20%5C%22react%5C%22%3B%5Cnimport%20Enzyme%2C%20%7B%20shallow%20%7D%20from%20%5C%22enzyme%5C%22%3B%5Cnimport%20Adapter%20from%20%5C%22enzyme-adapter-react-16%5C%22%3B%5Cnimport%20App%20from%20%5C%22App%5C%22%3B%5CnEnzyme.configure(%7B%20adapter%3A%20new%20Adapter()%20%7D)%3B%5Cnit(%5C%22render%20App%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20wrapper%20%3D%20shallow(%3CApp%20%2F%3E)%3B%5Cn%20%20expect(wrapper.find('%5Bdata-test%3D%5C%22App%5C%22%5D').length).toBe(2)%3B%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p>使用自定义 <code>props</code> 可以降低代码耦合度</p><p><br /></p><p><code>shallow</code> 适合单元测试，属于浅渲染； <code>mount</code> 适合集成测试，会将当前组件包括其子组件一起渲染</p><p><br /></p><p>单元测试时更倾向于使用 <code>api</code> <code>.state()</code> ；集成测试时更倾向于使用 <code>api</code> <code>.prop()</code></p><p><br /></p><a name=\"15.2.2-快照测试\"></a><h3 id=\"c14005d5\">15.2.2 快照测试</h3><p><br /></p><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p><p><br /></p><p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%226348958f%22%2C%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20App.test.js%5Cnimport%20React%20from%20%5C%22react%5C%22%3B%5Cnimport%20Enzyme%2C%20%7B%20shallow%20%7D%20from%20%5C%22enzyme%5C%22%3B%5Cnimport%20Adapter%20from%20%5C%22enzyme-adapter-react-16%5C%22%3B%5Cnimport%20App%20from%20%5C%22App%5C%22%3B%5CnEnzyme.configure(%7B%20adapter%3A%20new%20Adapter()%20%7D)%3B%5Cnit(%5C%22render%20App%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20const%20wrapper%20%3D%20shallow(%3CApp%20%2F%3E)%3B%5Cn%20%20expect(wrapper).toMatchSnapshot()%3B%5Cn%7D)%3B%22%7D\"></card><card type=\"block\" name=\"hr\"></card><a name=\"16.-前端自动化测试的优势\"></a><h2 id=\"efea21cb\">16. 前端自动化测试的优势</h2><p><br /></p><ul><li>更好的代码组织，项目的可维护性强</li></ul><ul><li>更少的 <code>Bug</code> 出现概率，尤其是回归测试中的 <code>Bug</code></li></ul><ul><li>修改工程质量差的项目，更加安全</li></ul><ul><li>项目具备潜在的文档特性</li></ul><ul><li>扩展前端的知识面</li></ul><p><br /></p><a name=\"17-总结重要的点\"></a><h2 id=\"5215b451\">17 总结重要的点</h2><p><br /></p><ol start=\"1\"><li><code>BDD</code> 和 <code>TDD</code></li></ol><ol start=\"2\"><li>集成测试 和 单元测试</li></ol><ol start=\"3\"><li>测试和业务的解耦</li></ol><ol start=\"4\"><li>代码测试覆盖率并不代表一定靠谱</li></ol><ol start=\"5\"><li>功能性测试 和 <code>UI</code>测试</li></ol><ol start=\"6\"><li>测试越独立，隐藏的问题就越多</li></ol>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 6167,
  "created_at": "2021-03-15T07:26:14.000Z",
  "updated_at": "2023-11-12T12:52:53.000Z",
  "content_updated_at": "2021-03-15T07:26:14.000Z",
  "published_at": "2021-03-15T07:26:14.000Z",
  "first_published_at": "2021-03-15T07:26:14.000Z",
  "book": {
    "id": 25332296,
    "type": "Book",
    "slug": "xxble8",
    "name": "前端技术文章",
    "user_id": 732231,
    "description": "记录前端相关的技术性文章",
    "toc_yml": "- type: META\n  count: 35\n  display_level: 1\n  tail_type: UPDATED_AT\n  base_version_id: 212554542\n  published: true\n  max_level: 2\n  last_updated_at: 2022-06-15T01:16:18.992Z\n  version_id: 213246417\n- type: TITLE\n  title: 包管理\n  uuid: _QuaGpvQyXOJqViR\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  child_uuid: rCzMi2OLxQeldZoL\n  sibling_uuid: esTqfZ-VIsO4KK9Q\n- type: DOC\n  title: verdaccio\n  uuid: rCzMi2OLxQeldZoL\n  url: tbmwax\n  parent_uuid: _QuaGpvQyXOJqViR\n  doc_id: 76715838\n  level: 1\n  id: 76715838\n  open_window: 0\n  visible: 1\n  prev_uuid: _QuaGpvQyXOJqViR\n  sibling_uuid: cv09hDGqlf4qMuLA\n- type: DOC\n  title: npm 包发布/卸载\n  uuid: cv09hDGqlf4qMuLA\n  url: zirrw6\n  parent_uuid: _QuaGpvQyXOJqViR\n  doc_id: 69834306\n  level: 1\n  id: 69834306\n  open_window: 0\n  visible: 1\n  prev_uuid: rCzMi2OLxQeldZoL\n- type: TITLE\n  title: 算法\n  uuid: esTqfZ-VIsO4KK9Q\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: _QuaGpvQyXOJqViR\n  child_uuid: Ogc2uBwNrDY5GME-\n  sibling_uuid: tk3brROhNFOdvu5c\n- type: DOC\n  title: 常用排序算法\n  uuid: Ogc2uBwNrDY5GME-\n  url: cwwn2a\n  parent_uuid: esTqfZ-VIsO4KK9Q\n  doc_id: 69585869\n  level: 1\n  id: 69585869\n  open_window: 0\n  visible: 1\n  prev_uuid: esTqfZ-VIsO4KK9Q\n- type: TITLE\n  title: 前端三架马车(html、css、javaScript)\n  uuid: tk3brROhNFOdvu5c\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: esTqfZ-VIsO4KK9Q\n  child_uuid: 89gjblQgjF0QZj7N\n  sibling_uuid: AnAUOtoVl35Ctf-m\n- type: DOC\n  title: 正则表达式梳理\n  uuid: 89gjblQgjF0QZj7N\n  url: ygg1li\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 69445939\n  level: 1\n  id: 69445939\n  open_window: 0\n  visible: 1\n  prev_uuid: tk3brROhNFOdvu5c\n  sibling_uuid: s4St0Tz5-SfLvKIX\n- type: DOC\n  title: 前端自动化测试\n  uuid: s4St0Tz5-SfLvKIX\n  url: tuiqkt\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 32924996\n  level: 1\n  id: 32924996\n  open_window: 1\n  visible: 1\n  prev_uuid: 89gjblQgjF0QZj7N\n  sibling_uuid: dxTurh6P_eb0zy_L\n- type: DOC\n  title: 从图片裁剪了解 javaScript 二进制常用 api\n  uuid: dxTurh6P_eb0zy_L\n  url: dflyyg\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11942849\n  level: 1\n  id: 11942849\n  open_window: 1\n  visible: 1\n  prev_uuid: s4St0Tz5-SfLvKIX\n  sibling_uuid: zMSTSZz39xp5h8EQ\n- type: DOC\n  title: Hybrid 简介\n  uuid: zMSTSZz39xp5h8EQ\n  url: wgdslk\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11444492\n  level: 1\n  id: 11444492\n  open_window: 1\n  visible: 1\n  prev_uuid: dxTurh6P_eb0zy_L\n  sibling_uuid: vT0QKWss3m0hDXF_\n- type: DOC\n  title: 渐进式 web 应用程序 pwa 简介\n  uuid: vT0QKWss3m0hDXF_\n  url: fm39qi\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11444574\n  level: 1\n  id: 11444574\n  open_window: 1\n  visible: 1\n  prev_uuid: zMSTSZz39xp5h8EQ\n  sibling_uuid: BN9ltP3u0AoFK0fF\n- type: DOC\n  title: H5 相关问题收集\n  uuid: BN9ltP3u0AoFK0fF\n  url: gxfam0\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11465630\n  level: 1\n  id: 11465630\n  open_window: 1\n  visible: 1\n  prev_uuid: vT0QKWss3m0hDXF_\n  sibling_uuid: 9AamH2OW8UgEfrja\n- type: DOC\n  title: 元素隐藏问题\n  uuid: 9AamH2OW8UgEfrja\n  url: ecvr1k\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11432332\n  level: 1\n  id: 11432332\n  open_window: 1\n  visible: 1\n  prev_uuid: BN9ltP3u0AoFK0fF\n  sibling_uuid: nx-R8OiSdFKMbNkp\n- type: DOC\n  title: 外边距合并问题\n  uuid: nx-R8OiSdFKMbNkp\n  url: vsuafl\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11432306\n  level: 1\n  id: 11432306\n  open_window: 1\n  visible: 1\n  prev_uuid: 9AamH2OW8UgEfrja\n- type: TITLE\n  title: 三大框架\n  uuid: AnAUOtoVl35Ctf-m\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: tk3brROhNFOdvu5c\n  child_uuid: d5-PKpnqrDERp5XH\n  sibling_uuid: T6Dd_ALAOey1mOT2\n- type: TITLE\n  title: Vue\n  uuid: d5-PKpnqrDERp5XH\n  url: ''\n  parent_uuid: AnAUOtoVl35Ctf-m\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: AnAUOtoVl35Ctf-m\n  sibling_uuid: 4iLlxHU6lkSzDraZ\n- type: TITLE\n  title: React\n  uuid: 4iLlxHU6lkSzDraZ\n  url: ''\n  parent_uuid: AnAUOtoVl35Ctf-m\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: d5-PKpnqrDERp5XH\n  child_uuid: YWc6qlQILrlxUTHD\n  sibling_uuid: ARWJ2u2tTxx00ebt\n- type: DOC\n  title: React Hooks 的一些特性\n  uuid: YWc6qlQILrlxUTHD\n  url: ydrldx\n  parent_uuid: 4iLlxHU6lkSzDraZ\n  doc_id: 32985727\n  level: 2\n  id: 32985727\n  open_window: 1\n  visible: 1\n  prev_uuid: 4iLlxHU6lkSzDraZ\n  sibling_uuid: ddokQtvYayoQdAz4\n- type: DOC\n  title: 编写 React 组件时常见的 5 个错误\n  uuid: ddokQtvYayoQdAz4\n  url: lscqxu\n  parent_uuid: 4iLlxHU6lkSzDraZ\n  doc_id: 32985721\n  level: 2\n  id: 32985721\n  open_window: 1\n  visible: 1\n  prev_uuid: YWc6qlQILrlxUTHD\n  sibling_uuid: 30Wx9_DYfG0kg9QA\n- type: DOC\n  title: React16 文档\n  uuid: 30Wx9_DYfG0kg9QA\n  url: di9gc4\n  parent_uuid: 4iLlxHU6lkSzDraZ\n  doc_id: 11440297\n  level: 2\n  id: 11440297\n  open_window: 1\n  visible: 1\n  prev_uuid: ddokQtvYayoQdAz4\n  sibling_uuid: aMQJEwPDNep085nZ\n- type: DOC\n  title: React 常见面试题\n  uuid: aMQJEwPDNep085nZ\n  url: qf8r3p\n  parent_uuid: 4iLlxHU6lkSzDraZ\n  doc_id: 68063610\n  level: 2\n  id: 68063610\n  open_window: 0\n  visible: 1\n  prev_uuid: 30Wx9_DYfG0kg9QA\n- type: TITLE\n  title: Angular\n  uuid: ARWJ2u2tTxx00ebt\n  url: ''\n  parent_uuid: AnAUOtoVl35Ctf-m\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: 4iLlxHU6lkSzDraZ\n- type: DOC\n  title: TS\n  uuid: T6Dd_ALAOey1mOT2\n  url: pggx4l\n  parent_uuid: ''\n  doc_id: 70125357\n  level: 0\n  id: 70125357\n  open_window: 0\n  visible: 1\n  prev_uuid: AnAUOtoVl35Ctf-m\n  sibling_uuid: quDnA_CtXFJewZef\n- type: TITLE\n  title: 构建工具\n  uuid: quDnA_CtXFJewZef\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: T6Dd_ALAOey1mOT2\n  child_uuid: ko6UTJnvyRxJxFks\n  sibling_uuid: Nvq-1t47zI5eZ5K2\n- type: TITLE\n  title: Webpack\n  uuid: ko6UTJnvyRxJxFks\n  url: ''\n  parent_uuid: quDnA_CtXFJewZef\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: quDnA_CtXFJewZef\n  sibling_uuid: mF0ZJuTxvQYAlc-6\n- type: TITLE\n  title: Vite\n  uuid: mF0ZJuTxvQYAlc-6\n  url: ''\n  parent_uuid: quDnA_CtXFJewZef\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: ko6UTJnvyRxJxFks\n- type: TITLE\n  title: Node\n  uuid: Nvq-1t47zI5eZ5K2\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: quDnA_CtXFJewZef\n  child_uuid: N9McFxnJzAZ1joGk\n  sibling_uuid: 2ip6Vh79GxkcT9qC\n- type: DOC\n  title: 传统部署\n  uuid: N9McFxnJzAZ1joGk\n  url: gzrbf3\n  parent_uuid: Nvq-1t47zI5eZ5K2\n  doc_id: 11465755\n  level: 1\n  id: 11465755\n  open_window: 1\n  visible: 1\n  prev_uuid: Nvq-1t47zI5eZ5K2\n  sibling_uuid: iav0UTEn9wp9P6wQ\n- type: DOC\n  title: graphql\n  uuid: iav0UTEn9wp9P6wQ\n  url: cnpgks\n  parent_uuid: Nvq-1t47zI5eZ5K2\n  doc_id: 11465980\n  level: 1\n  id: 11465980\n  open_window: 1\n  visible: 1\n  prev_uuid: N9McFxnJzAZ1joGk\n- type: TITLE\n  title: 面试精选文章\n  uuid: 2ip6Vh79GxkcT9qC\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: Nvq-1t47zI5eZ5K2\n  child_uuid: e-Y2Xaz9wC8qUoRT\n- type: DOC\n  title: Css 精选\n  uuid: e-Y2Xaz9wC8qUoRT\n  url: wcrp5i\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69585398\n  level: 1\n  id: 69585398\n  open_window: 0\n  visible: 1\n  prev_uuid: 2ip6Vh79GxkcT9qC\n  sibling_uuid: dKE7-48QzE7EMFuU\n- type: DOC\n  title: Html 精选\n  uuid: dKE7-48QzE7EMFuU\n  url: if2bzn\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69585313\n  level: 1\n  id: 69585313\n  open_window: 0\n  visible: 1\n  prev_uuid: e-Y2Xaz9wC8qUoRT\n  sibling_uuid: DMqan83XPeKFCVOy\n- type: DOC\n  title: JavaScript 精选\n  uuid: DMqan83XPeKFCVOy\n  url: omn9xg\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69584814\n  level: 1\n  id: 69584814\n  open_window: 0\n  visible: 1\n  prev_uuid: dKE7-48QzE7EMFuU\n  sibling_uuid: kuWh1bH6rb88i7up\n- type: DOC\n  title: 计算机网络精选\n  uuid: kuWh1bH6rb88i7up\n  url: uyhudu\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69584083\n  level: 1\n  id: 69584083\n  open_window: 0\n  visible: 1\n  prev_uuid: DMqan83XPeKFCVOy\n  sibling_uuid: MVGimszERfJIqa5_\n- type: DOC\n  title: 操作系统精选\n  uuid: MVGimszERfJIqa5_\n  url: nyvkbg\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69584018\n  level: 1\n  id: 69584018\n  open_window: 0\n  visible: 1\n  prev_uuid: kuWh1bH6rb88i7up\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 23,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2022-06-15T01:16:19.043Z",
    "created_at": "2022-03-13T09:55:39.000Z",
    "updated_at": "2023-11-11T18:11:38.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-22T20:13:30.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/xxble8",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 958456288,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}