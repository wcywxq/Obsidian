{
  "id": 32985727,
  "slug": "ydrldx",
  "title": "React Hooks 的一些特性",
  "description": "React Hooks 的一些特性1. 逆潮而动每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 statefunction Example(props) {   useEffect(() => {     setTi...",
  "cover": "",
  "user_id": 732231,
  "book_id": 25332296,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><h1 id=\"fe406e93\"><span class=\"ne-text\">React Hooks 的一些特性</span></h1><h2 id=\"e350ad92\"><span class=\"ne-text\">1. 逆潮而动</span><span class=\"ne-text\" style=\"background-color: #FFEC3D\"></span></h2><p id=\"u1119fdc6\" class=\"ne-p\"><br></p><p id=\"u4592763d\" class=\"ne-p\"><span class=\"ne-text\">每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 state</span></p><p id=\"u9bad3378\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"e1087529\" class=\"ne-codeblock language-jsx\">function Example(props) {\n  useEffect(() =&gt; {\n    setTimeout(() =&gt; {\n      console.log(props.counter);\n    }, 1000);\n  });\n}\n\n// 等效于\n\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() =&gt; {\n    setTimeout(() =&gt; {\n      console.log(counter);\n    });\n  });\n}</pre><p id=\"uee5aae4a\" class=\"ne-p\"><br></p><h2 id=\"4f71ead0\"><span class=\"ne-text\">2. effects 中的清理</span></h2><p id=\"u193a22d4\" class=\"ne-p\"><br></p><p id=\"u4b496cdd\" class=\"ne-p\"><span class=\"ne-text\">目的: 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用的 effect，比如取消订阅。</span></p><p id=\"ue457dca0\" class=\"ne-p\"><br></p><p id=\"u52a0907d\" class=\"ne-p\"><span class=\"ne-text\">effect 的清除并不会读取 &quot;最新&quot; 的 props。它只能读取到定义它的那次渲染中的 props 的值</span></p><p id=\"u374e9222\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"ce076e09\" class=\"ne-codeblock language-jsx\">// First render, props are {id: 10}\nfunction Example() {\n  // ...\n  useEffect(() =&gt; {\n    ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    // cleanup for effect from first render\n    return () =&gt; {\n      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    };\n  });\n  // ...\n}\n// Next render, props are {id: 20}\nfunction Example() {\n  // ...\n  useEffect(() =&gt; {\n    ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    return () =&gt; {\n      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    };\n  });\n  // ...\n}</pre><p id=\"u2c34d6a7\" class=\"ne-p\"><br></p><h2 id=\"06aa1b26\"><span class=\"ne-text\">3. 避免重复调用</span></h2><p id=\"u1eb57611\" class=\"ne-p\"><br></p><p id=\"u21cfdbde\" class=\"ne-p\"><span class=\"ne-text\">为了避免 effects 不必要的重复调用，我们可以提供给 useEffect 一个依赖数组参数(deps)</span></p><p id=\"u87d02128\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"8e80e557\" class=\"ne-codeblock language-jsx\">useEffect(() =&gt; {\n  document.title = &quot;Hello, &quot; + title;\n}, [name]);</pre><p id=\"u6eba3ceb\" class=\"ne-p\"><br></p><p id=\"u8ca90977\" class=\"ne-p\"><span class=\"ne-text\">如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect。</span></p><p id=\"ufad4d72b\" class=\"ne-p\"><br></p><h2 id=\"3ab31427\"><span class=\"ne-text\">4. 两种诚实告知依赖的方法</span></h2><p id=\"u39c5a115\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u59da956d\"><span class=\"ne-text\">在依赖中包含所有 effect 中用到的组件内的值</span></li></ul><p id=\"ud09b176d\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"f82ff37f\" class=\"ne-codeblock language-jsx\">import React, { useState, useEffect } from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =&gt; {\n    const id = setInterval(() =&gt; {\n      setCount(count + 1);\n    });\n    return () =&gt; clearInterval(id);\n  }, [count]);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;you clicked it {count} times&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;click me&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\nReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</pre><p id=\"u1682635b\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u8d61b5b1\"><span class=\"ne-text\">修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使依赖更少。</span></li></ul><p id=\"u232742de\" class=\"ne-p\"><br></p><h2 id=\"c5999af3\"><span class=\"ne-text\">5. 让 Effect 自给自足</span></h2><p id=\"ueb241092\" class=\"ne-p\"><br></p><p id=\"uf41fe9d7\" class=\"ne-p\"><span class=\"ne-text\">我们想要根据前一个状态更新状态的时候，我们可以使用 setState 的 函数形式</span></p><p id=\"u0ee70da3\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"e38dc5a0\" class=\"ne-codeblock language-jsx\">useEffect(() =&gt; {\n  const id = setInterval(() =&gt; {\n    setCount(c =&gt; c + 1);\n  }, 1000);\n  return () =&gt; clearInterval(id);\n}, []);</pre><p id=\"u85cbd24c\" class=\"ne-p\"><br></p><p id=\"uaf5bf684\" class=\"ne-p\"><span class=\"ne-text\">这正是 setCount(c =&gt; c + 1) 做的事情。你可以认为它是在给 React &quot;发送指令&quot; 告知如何更新状态。这种 &quot;更新形式&quot; 在其他情况下也有帮助，比如你需要 &quot;批量更新&quot;。</span></p><p id=\"uc385ed21\" class=\"ne-p\"><br></p><h2 id=\"587b909c\"><span class=\"ne-text\">6. 解耦来自 Actions 的更新</span></h2><p id=\"u14a40505\" class=\"ne-p\"><br></p><p id=\"u697248c4\" class=\"ne-p\"><span class=\"ne-text\">当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用 useReducer 去替换它们。</span></p><p id=\"ua82ca908\" class=\"ne-p\"><br></p><p id=\"u9e1453d2\" class=\"ne-p\"><span class=\"ne-text\">当你写类似 setSomething(something =&gt; ...) 这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你 </span><strong><span class=\"ne-text\">把组件内发生了什么(actions)</span></strong><span class=\"ne-text\"> 和 </span><strong><span class=\"ne-text\">状态如何响应并更新</span></strong><span class=\"ne-text\"> 分开表述。</span></p><p id=\"ub15805fa\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"c992941c\" class=\"ne-codeblock language-jsx\">const [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\nuseEffect(() =&gt; {\n    const id = setInterval(() =&gt; {\n        dispatch({ type: &quot;tick&quot; }); // Instead of setCount(c =&gt; c + step) }, 1000);\n        return () =&gt; clearInterval(id);\n}, [dispatch]);</pre><p id=\"u653123d1\" class=\"ne-p\"><br></p><p id=\"u0e4e372a\" class=\"ne-p\"><span class=\"ne-text\">相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理。</span></p><p id=\"ufa717c59\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"2ee8af8e\" class=\"ne-codeblock language-jsx\">const initialState = {\n  count: 0,\n  step: 1\n};\nfunction reducer(state, action) {\n  const { count, step } = state;\n  if (action.type === &quot;tick&quot;) {\n    return { count: count + step, step };\n  } else if (action.type === &quot;step&quot;) {\n    return { count, step: action.step };\n  } else {\n    throw new Error();\n  }\n}</pre><p id=\"uc0073aa5\" class=\"ne-p\"><br></p><h2 id=\"4e22f74b\"><span class=\"ne-text\">7. 为什么 useReducer 是 Hooks 的作弊模式</span></h2><p id=\"u17975e7e\" class=\"ne-p\"><br></p><p id=\"u9d9d1278\" class=\"ne-p\"><span class=\"ne-text\">假如我们需要依赖 props 去计算下一个状态。举个例子，也许我们的 API 是 </span><code class=\"ne-code\"><span class=\"ne-text\">&lt;Counter step={1} /&gt;</span></code><span class=\"ne-text\">。确定的是，在这种情况下，我们没法避免依赖 props.step 。</span></p><p id=\"u34985d95\" class=\"ne-p\"><br></p><p id=\"uf2ddaf1d\" class=\"ne-p\"><span class=\"ne-text\">实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props。</span></p><p id=\"u2e4237b7\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"139992a5\" class=\"ne-codeblock language-jsx\">function Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n  function reducer(state, action) {\n    if (action.type === &quot;tick&quot;) {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n  useEffect(() =&gt; {\n    const id = setInterval(() =&gt; {\n      dispatch({ type: &quot;tick&quot; });\n    }, 1000);\n  }, [dispatch]);\n  return &lt;h1&gt;{count}&lt;/h1&gt;;\n}</pre><p id=\"ub7c6969c\" class=\"ne-p\"><br></p><p id=\"u16dbdc5d\" class=\"ne-p\"><span class=\"ne-text\">注意：这种模式会使一些优化失败，所以你应该避免滥用它，不过如果你需要，完全可以在 reducer 里面访问 props。</span></p><p id=\"u3af4027d\" class=\"ne-p\"><br></p><p id=\"ue5eb9a90\" class=\"ne-p\"><span class=\"ne-text\">它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。</span></p><p id=\"u5348bb23\" class=\"ne-p\"><br></p><h2 id=\"a105eb33\"><span class=\"ne-text\">8. 如何不把函数放到 Effect 里</span></h2><p id=\"u1ef3a0e4\" class=\"ne-p\"><br></p><p id=\"ubdca1d10\" class=\"ne-p\"><span class=\"ne-text\">有时候我们可能不想把函数移入 effect 里。</span></p><p id=\"u6692e0cd\" class=\"ne-p\"><br></p><p id=\"u80d5f657\" class=\"ne-p\"><span class=\"ne-text\">比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。</span></p><p id=\"u2de71625\" class=\"ne-p\"><br></p><p id=\"uf21ff2cb\" class=\"ne-p\"><span class=\"ne-text\">函数每次渲染都会改变这个事实本身就是个问题。比如有两个 effects 会调用 getFetchUrl:</span></p><p id=\"u88754522\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"d5472507\" class=\"ne-codeblock language-jsx\">function SearchResults() {\n  function getFetchUrl(query) {\n    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n  }\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;react&quot;);\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;redux&quot;);\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  // ...\n}</pre><p id=\"u50519119\" class=\"ne-p\"><br></p><p id=\"u41a3cfcc\" class=\"ne-p\"><span class=\"ne-text\">我们可能不想把 getFetchUrl 移到 effect 中，因为你想复用逻辑。</span></p><p id=\"u0b01e9bb\" class=\"ne-p\"><br></p><h3 id=\"295e64b5\"><span class=\"ne-text\">8.1 方法一</span></h3><p id=\"u8aefd35b\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u4b43a864\"><span class=\"ne-text\">如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用</span></li></ul><p id=\"u35faeac8\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"63b596c0\" class=\"ne-codeblock language-jsx\">// ✅ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n}\n\nfunction SearchResults() {\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;react&quot;);\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;redux&quot;);\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}</pre><p id=\"u9a3138b2\" class=\"ne-p\"><br></p><p id=\"ub0e6f7cf\" class=\"ne-p\"><span class=\"ne-text\">你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state 。</span></p><p id=\"u4d335c5a\" class=\"ne-p\"><br></p><h3 id=\"b3f76ab9\"><span class=\"ne-text\">8.2 方法二</span></h3><p id=\"udd29f19a\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"udb79db5e\"><span class=\"ne-text\">你也可以把它包装成 useCallback Hook</span></li></ul><p id=\"ud824ab08\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"d6ca7967\" class=\"ne-codeblock language-jsx\">function SearchResults() {\n  // ✅ Preserves identity when its own deps are the same\n  const getFetchUrl = useCallback(query =&gt; {\n    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n  }, []); // ✅ Callback deps are OK\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;react&quot;);\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;redux&quot;);\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}</pre><p id=\"u8425ce56\" class=\"ne-p\"><br></p><p id=\"uf6199d27\" class=\"ne-p\"><span class=\"ne-text\">useCallback 本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。</span></p><p id=\"u8fe63eb1\" class=\"ne-p\"><br></p><p id=\"u19dc6b65\" class=\"ne-p\"><span class=\"ne-text\">如果我们想添加一个输入框允许你输入任意的查询条件(query)。不同于传递 query 参数的方式，现在 getFetchUrl 会从状态中读取。</span></p><p id=\"uf72c2088\" class=\"ne-p\"><br></p><p id=\"u1d188a3e\" class=\"ne-p\"><span class=\"ne-text\">如果我们把 query 添加到 useCallback 的依赖中，任何调用了 getFetchUrl 的 effect 在 query 改变后都会重新运行：</span></p><p id=\"u0b576511\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"767f60be\" class=\"ne-codeblock language-jsx\">function SearchResults() {\n  const [query, setQuery] = useState(&quot;react&quot;);\n\n  // ✅ Preserves identity until query changes\n  const getFetchUrl = useCallback(() =&gt; {\n    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n  }, [query]); // ✅ Callback deps are OK\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}</pre><p id=\"u334b016e\" class=\"ne-p\"><br></p><p id=\"u07f9b123\" class=\"ne-p\"><span class=\"ne-text\">这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用</span></p><p id=\"u37e44479\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"0f74833d\" class=\"ne-codeblock language-jsx\">function Parent() {\n  const [query, setQuery] = useState(&quot;react&quot;);\n  // ✅ Preserves identity until query changes\n  const fetchData = useCallback(() =&gt; {\n    const url = &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n    // ... Fetch data and return it ...\n  }, [query]); // ✅ Callback deps are OK\n  return &lt;Child fetchData={fetchData} /&gt;;\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n  // ...\n}</pre><p id=\"uf2a7b255\" class=\"ne-p\"><br></p><p id=\"u19aa9d4e\" class=\"ne-p\"><span class=\"ne-text\">因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据。</span></p><p id=\"u0693de13\" class=\"ne-p\"><br></p><h2 id=\"e10c53f8\"><span class=\"ne-text\">9. 函数是数据流的一部分么</span></h2><p id=\"u85364839\" class=\"ne-p\"><br></p><p id=\"ud66a2d29\" class=\"ne-p\"><span class=\"ne-text\">在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的 this 变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 &quot;diff&quot;。我们无法知道传入的 this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。</span></p><p id=\"uce6a59df\" class=\"ne-p\"><br></p><p id=\"ueb872c9c\" class=\"ne-p\"><span class=\"ne-text\">使用 useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。使用的 useCallback，属性 props.fetchData 的改变也会自动传递下去。</span></p><p id=\"uf3ae35f3\" class=\"ne-p\"><br></p><p id=\"u311bd647\" class=\"ne-p\"><span class=\"ne-text\">类似地，useMemo 可以让我们对复杂对象做类似的事情。</span></p><p id=\"u7af23ef5\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"abb4fe3d\" class=\"ne-codeblock language-jsx\">function ColorPicker() {\n  // Doesn't break Child's shallow equality prop check\n  // unless the color actually changes.\n  const [color, setColor] = useState(&quot;pink&quot;);\n  const style = useMemo(() =&gt; ({ color }), [color]);\n  return &lt;Child style={style} /&gt;;\n}</pre><p id=\"uaa03f934\" class=\"ne-p\"><br></p><h2 id=\"8ecdf1f0\"><span class=\"ne-text\">10. 竞态</span></h2><p id=\"u53600ad8\" class=\"ne-p\"><br></p><p id=\"u94dbe1d3\" class=\"ne-p\"><span class=\"ne-text\">下面是一个典型的在 class 组件里发请求的例子：</span></p><p id=\"u121b93e8\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"68a3b581\" class=\"ne-codeblock language-jsx\">class Article extends React.Component {\n  state = {\n    article: null\n  };\n  componentDidMount() {\n    this.fetchData(this.props.id);\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.id !== this.props.id) {\n      this.fetchData(this.props.id);\n    }\n  }\n  async fetchData(id) {\n    const article = await API.fetchArticle(id);\n    this.setState({ article });\n  }\n  // ...\n}</pre><p id=\"u7c0e715b\" class=\"ne-p\"><br></p><p id=\"u9fc52574\" class=\"ne-p\"><span class=\"ne-text\">这被叫做竞态，这在混合了 async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（ props 和 state 可能会在 async 函数调用过程中发生改变）。</span></p><p id=\"u47e0b75a\" class=\"ne-p\"><br></p><p id=\"ua0f58702\" class=\"ne-p\"><span class=\"ne-text\">Effects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个 async 函数给 effect。</span></p><p id=\"u659299b4\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ue7c701d1\"><span class=\"ne-text\">解决方式</span></li></ul><p id=\"u4ab6513b\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"ue379c304\"><span class=\"ne-text\"> 如果你使用的异步方式支持取消。你可以直接在清除函数中取消异步请求。 </span></li></ol><ol start=\"2\" class=\"ne-ol\"><li id=\"ubf77a809\"><span class=\"ne-text\"> 或者，最简单的权宜之计是用一个布尔值来跟踪它。 </span></li></ol><p id=\"u2af82159\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"981076a4\" class=\"ne-codeblock language-jsx\">function Article({ id }) {\n  const [article, setArticle] = useState(null);\n\n  useEffect(() =&gt; {\n    let didCancel = false;\n    const fetchData = async () =&gt; {\n      const article = await API.fetchArticle(id);\n      if (!didCancel) {\n        setArticle(article);\n      }\n    };\n    fetchData();\n    return () =&gt; {\n      didCancel = true;\n    };\n  }, [id]);\n  // ...\n}</pre></div>",
  "body": "<a name=\"fe406e93\"></a>\n# React Hooks 的一些特性\n<a name=\"e350ad92\"></a>\n## 1. 逆潮而动\n\n每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 state\n\n```jsx\nfunction Example(props) {\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(props.counter);\n    }, 1000);\n  });\n}\n\n// 等效于\n\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(counter);\n    });\n  });\n}\n```\n\n<a name=\"4f71ead0\"></a>\n## 2. effects 中的清理\n\n目的: 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用的 effect，比如取消订阅。\n\neffect 的清除并不会读取 \"最新\" 的 props。它只能读取到定义它的那次渲染中的 props 的值\n\n```jsx\n// First render, props are {id: 10}\nfunction Example() {\n  // ...\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    // cleanup for effect from first render\n    return () => {\n      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    };\n  });\n  // ...\n}\n// Next render, props are {id: 20}\nfunction Example() {\n  // ...\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    return () => {\n      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    };\n  });\n  // ...\n}\n```\n\n<a name=\"06aa1b26\"></a>\n## 3. 避免重复调用\n\n为了避免 effects 不必要的重复调用，我们可以提供给 useEffect 一个依赖数组参数(deps)\n\n```jsx\nuseEffect(() => {\n  document.title = \"Hello, \" + title;\n}, [name]);\n```\n\n如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect。\n\n<a name=\"3ab31427\"></a>\n## 4. 两种诚实告知依赖的方法\n\n- 在依赖中包含所有 effect 中用到的组件内的值\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    });\n    return () => clearInterval(id);\n  }, [count]);\n\n  return (\n    <div>\n      <p>you clicked it {count} times</p>\n      <button onClick={() => setCount(count + 1)}>click me</button>\n    </div>\n  );\n}\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n- 修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使依赖更少。\n\n<a name=\"c5999af3\"></a>\n## 5. 让 Effect 自给自足\n\n我们想要根据前一个状态更新状态的时候，我们可以使用 setState 的 函数形式\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(c => c + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, []);\n```\n\n这正是 setCount(c => c + 1) 做的事情。你可以认为它是在给 React \"发送指令\" 告知如何更新状态。这种 \"更新形式\" 在其他情况下也有帮助，比如你需要 \"批量更新\"。\n\n<a name=\"587b909c\"></a>\n## 6. 解耦来自 Actions 的更新\n\n当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用 useReducer 去替换它们。\n\n当你写类似 setSomething(something => ...) 这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你 **把组件内发生了什么(actions)** 和 **状态如何响应并更新** 分开表述。\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\nuseEffect(() => {\n    const id = setInterval(() => {\n        dispatch({ type: \"tick\" }); // Instead of setCount(c => c + step) }, 1000);\n        return () => clearInterval(id);\n}, [dispatch]);\n```\n\n相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理。\n\n```jsx\nconst initialState = {\n  count: 0,\n  step: 1\n};\nfunction reducer(state, action) {\n  const { count, step } = state;\n  if (action.type === \"tick\") {\n    return { count: count + step, step };\n  } else if (action.type === \"step\") {\n    return { count, step: action.step };\n  } else {\n    throw new Error();\n  }\n}\n```\n\n<a name=\"4e22f74b\"></a>\n## 7. 为什么 useReducer 是 Hooks 的作弊模式\n\n假如我们需要依赖 props 去计算下一个状态。举个例子，也许我们的 API 是 `<Counter step={1} />`。确定的是，在这种情况下，我们没法避免依赖 props.step 。\n\n实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props。\n\n```jsx\nfunction Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n  function reducer(state, action) {\n    if (action.type === \"tick\") {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: \"tick\" });\n    }, 1000);\n  }, [dispatch]);\n  return <h1>{count}</h1>;\n}\n```\n\n注意：这种模式会使一些优化失败，所以你应该避免滥用它，不过如果你需要，完全可以在 reducer 里面访问 props。\n\n它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。\n\n<a name=\"a105eb33\"></a>\n## 8. 如何不把函数放到 Effect 里\n\n有时候我们可能不想把函数移入 effect 里。\n\n比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。\n\n函数每次渲染都会改变这个事实本身就是个问题。比如有两个 effects 会调用 getFetchUrl:\n\n```jsx\nfunction SearchResults() {\n  function getFetchUrl(query) {\n    return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n  }\n\n  useEffect(() => {\n    const url = getFetchUrl(\"react\");\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  useEffect(() => {\n    const url = getFetchUrl(\"redux\");\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  // ...\n}\n```\n\n我们可能不想把 getFetchUrl 移到 effect 中，因为你想复用逻辑。\n\n<a name=\"295e64b5\"></a>\n### 8.1 方法一\n\n- 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用\n\n```jsx\n// ✅ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n}\n\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl(\"react\");\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl(\"redux\");\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state 。\n\n<a name=\"b3f76ab9\"></a>\n### 8.2 方法二\n\n- 你也可以把它包装成 useCallback Hook\n\n```jsx\nfunction SearchResults() {\n  // ✅ Preserves identity when its own deps are the same\n  const getFetchUrl = useCallback(query => {\n    return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n  }, []); // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl(\"react\");\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl(\"redux\");\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\nuseCallback 本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。\n\n如果我们想添加一个输入框允许你输入任意的查询条件(query)。不同于传递 query 参数的方式，现在 getFetchUrl 会从状态中读取。\n\n如果我们把 query 添加到 useCallback 的依赖中，任何调用了 getFetchUrl 的 effect 在 query 改变后都会重新运行：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState(\"react\");\n\n  // ✅ Preserves identity until query changes\n  const getFetchUrl = useCallback(() => {\n    return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n  }, [query]); // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用\n\n```jsx\nfunction Parent() {\n  const [query, setQuery] = useState(\"react\");\n  // ✅ Preserves identity until query changes\n  const fetchData = useCallback(() => {\n    const url = \"https://hn.algolia.com/api/v1/search?query=\" + query;\n    // ... Fetch data and return it ...\n  }, [query]); // ✅ Callback deps are OK\n  return <Child fetchData={fetchData} />;\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n  // ...\n}\n```\n\n因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据。\n\n<a name=\"e10c53f8\"></a>\n## 9. 函数是数据流的一部分么\n\n在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的 this 变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 \"diff\"。我们无法知道传入的 this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。\n\n使用 useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。使用的 useCallback，属性 props.fetchData 的改变也会自动传递下去。\n\n类似地，useMemo 可以让我们对复杂对象做类似的事情。\n\n```jsx\nfunction ColorPicker() {\n  // Doesn't break Child's shallow equality prop check\n  // unless the color actually changes.\n  const [color, setColor] = useState(\"pink\");\n  const style = useMemo(() => ({ color }), [color]);\n  return <Child style={style} />;\n}\n```\n\n<a name=\"8ecdf1f0\"></a>\n## 10. 竞态\n\n下面是一个典型的在 class 组件里发请求的例子：\n\n```jsx\nclass Article extends React.Component {\n  state = {\n    article: null\n  };\n  componentDidMount() {\n    this.fetchData(this.props.id);\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.id !== this.props.id) {\n      this.fetchData(this.props.id);\n    }\n  }\n  async fetchData(id) {\n    const article = await API.fetchArticle(id);\n    this.setState({ article });\n  }\n  // ...\n}\n```\n\n这被叫做竞态，这在混合了 async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（ props 和 state 可能会在 async 函数调用过程中发生改变）。\n\nEffects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个 async 函数给 effect。\n\n- 解决方式\n\n1.  如果你使用的异步方式支持取消。你可以直接在清除函数中取消异步请求。 \n2.  或者，最简单的权宜之计是用一个布尔值来跟踪它。 \n\n```jsx\nfunction Article({ id }) {\n  const [article, setArticle] = useState(null);\n\n  useEffect(() => {\n    let didCancel = false;\n    const fetchData = async () => {\n      const article = await API.fetchArticle(id);\n      if (!didCancel) {\n        setArticle(article);\n      }\n    };\n    fetchData();\n    return () => {\n      didCancel = true;\n    };\n  }, [id]);\n  // ...\n}\n```\n",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"traditional\"><h1 id=\"fe406e93\"><span class=\"ne-text\">React Hooks 的一些特性</span></h1><h2 id=\"e350ad92\"><span class=\"ne-text\">1. 逆潮而动</span><span class=\"ne-text\" style=\"background-color: #FFEC3D\"></span></h2><p id=\"u1119fdc6\" class=\"ne-p\"><br></p><p id=\"u4592763d\" class=\"ne-p\"><span class=\"ne-text\">每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 state</span></p><p id=\"u9bad3378\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"e1087529\" class=\"ne-codeblock language-jsx\">function Example(props) {\n  useEffect(() =&gt; {\n    setTimeout(() =&gt; {\n      console.log(props.counter);\n    }, 1000);\n  });\n}\n\n// 等效于\n\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() =&gt; {\n    setTimeout(() =&gt; {\n      console.log(counter);\n    });\n  });\n}</pre><p id=\"uee5aae4a\" class=\"ne-p\"><br></p><h2 id=\"4f71ead0\"><span class=\"ne-text\">2. effects 中的清理</span></h2><p id=\"u193a22d4\" class=\"ne-p\"><br></p><p id=\"u4b496cdd\" class=\"ne-p\"><span class=\"ne-text\">目的: 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用的 effect，比如取消订阅。</span></p><p id=\"ue457dca0\" class=\"ne-p\"><br></p><p id=\"u52a0907d\" class=\"ne-p\"><span class=\"ne-text\">effect 的清除并不会读取 &quot;最新&quot; 的 props。它只能读取到定义它的那次渲染中的 props 的值</span></p><p id=\"u374e9222\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"ce076e09\" class=\"ne-codeblock language-jsx\">// First render, props are {id: 10}\nfunction Example() {\n  // ...\n  useEffect(() =&gt; {\n    ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    // cleanup for effect from first render\n    return () =&gt; {\n      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    };\n  });\n  // ...\n}\n// Next render, props are {id: 20}\nfunction Example() {\n  // ...\n  useEffect(() =&gt; {\n    ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    return () =&gt; {\n      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    };\n  });\n  // ...\n}</pre><p id=\"u2c34d6a7\" class=\"ne-p\"><br></p><h2 id=\"06aa1b26\"><span class=\"ne-text\">3. 避免重复调用</span></h2><p id=\"u1eb57611\" class=\"ne-p\"><br></p><p id=\"u21cfdbde\" class=\"ne-p\"><span class=\"ne-text\">为了避免 effects 不必要的重复调用，我们可以提供给 useEffect 一个依赖数组参数(deps)</span></p><p id=\"u87d02128\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"8e80e557\" class=\"ne-codeblock language-jsx\">useEffect(() =&gt; {\n  document.title = &quot;Hello, &quot; + title;\n}, [name]);</pre><p id=\"u6eba3ceb\" class=\"ne-p\"><br></p><p id=\"u8ca90977\" class=\"ne-p\"><span class=\"ne-text\">如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect。</span></p><p id=\"ufad4d72b\" class=\"ne-p\"><br></p><h2 id=\"3ab31427\"><span class=\"ne-text\">4. 两种诚实告知依赖的方法</span></h2><p id=\"u39c5a115\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u59da956d\"><span class=\"ne-text\">在依赖中包含所有 effect 中用到的组件内的值</span></li></ul><p id=\"ud09b176d\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"f82ff37f\" class=\"ne-codeblock language-jsx\">import React, { useState, useEffect } from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =&gt; {\n    const id = setInterval(() =&gt; {\n      setCount(count + 1);\n    });\n    return () =&gt; clearInterval(id);\n  }, [count]);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;you clicked it {count} times&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;click me&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\nReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</pre><p id=\"u1682635b\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u8d61b5b1\"><span class=\"ne-text\">修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使依赖更少。</span></li></ul><p id=\"u232742de\" class=\"ne-p\"><br></p><h2 id=\"c5999af3\"><span class=\"ne-text\">5. 让 Effect 自给自足</span></h2><p id=\"ueb241092\" class=\"ne-p\"><br></p><p id=\"uf41fe9d7\" class=\"ne-p\"><span class=\"ne-text\">我们想要根据前一个状态更新状态的时候，我们可以使用 setState 的 函数形式</span></p><p id=\"u0ee70da3\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"e38dc5a0\" class=\"ne-codeblock language-jsx\">useEffect(() =&gt; {\n  const id = setInterval(() =&gt; {\n    setCount(c =&gt; c + 1);\n  }, 1000);\n  return () =&gt; clearInterval(id);\n}, []);</pre><p id=\"u85cbd24c\" class=\"ne-p\"><br></p><p id=\"uaf5bf684\" class=\"ne-p\"><span class=\"ne-text\">这正是 setCount(c =&gt; c + 1) 做的事情。你可以认为它是在给 React &quot;发送指令&quot; 告知如何更新状态。这种 &quot;更新形式&quot; 在其他情况下也有帮助，比如你需要 &quot;批量更新&quot;。</span></p><p id=\"uc385ed21\" class=\"ne-p\"><br></p><h2 id=\"587b909c\"><span class=\"ne-text\">6. 解耦来自 Actions 的更新</span></h2><p id=\"u14a40505\" class=\"ne-p\"><br></p><p id=\"u697248c4\" class=\"ne-p\"><span class=\"ne-text\">当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用 useReducer 去替换它们。</span></p><p id=\"ua82ca908\" class=\"ne-p\"><br></p><p id=\"u9e1453d2\" class=\"ne-p\"><span class=\"ne-text\">当你写类似 setSomething(something =&gt; ...) 这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你 </span><strong><span class=\"ne-text\">把组件内发生了什么(actions)</span></strong><span class=\"ne-text\"> 和 </span><strong><span class=\"ne-text\">状态如何响应并更新</span></strong><span class=\"ne-text\"> 分开表述。</span></p><p id=\"ub15805fa\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"c992941c\" class=\"ne-codeblock language-jsx\">const [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\nuseEffect(() =&gt; {\n    const id = setInterval(() =&gt; {\n        dispatch({ type: &quot;tick&quot; }); // Instead of setCount(c =&gt; c + step) }, 1000);\n        return () =&gt; clearInterval(id);\n}, [dispatch]);</pre><p id=\"u653123d1\" class=\"ne-p\"><br></p><p id=\"u0e4e372a\" class=\"ne-p\"><span class=\"ne-text\">相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理。</span></p><p id=\"ufa717c59\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"2ee8af8e\" class=\"ne-codeblock language-jsx\">const initialState = {\n  count: 0,\n  step: 1\n};\nfunction reducer(state, action) {\n  const { count, step } = state;\n  if (action.type === &quot;tick&quot;) {\n    return { count: count + step, step };\n  } else if (action.type === &quot;step&quot;) {\n    return { count, step: action.step };\n  } else {\n    throw new Error();\n  }\n}</pre><p id=\"uc0073aa5\" class=\"ne-p\"><br></p><h2 id=\"4e22f74b\"><span class=\"ne-text\">7. 为什么 useReducer 是 Hooks 的作弊模式</span></h2><p id=\"u17975e7e\" class=\"ne-p\"><br></p><p id=\"u9d9d1278\" class=\"ne-p\"><span class=\"ne-text\">假如我们需要依赖 props 去计算下一个状态。举个例子，也许我们的 API 是 </span><code class=\"ne-code\"><span class=\"ne-text\">&lt;Counter step={1} /&gt;</span></code><span class=\"ne-text\">。确定的是，在这种情况下，我们没法避免依赖 props.step 。</span></p><p id=\"u34985d95\" class=\"ne-p\"><br></p><p id=\"uf2ddaf1d\" class=\"ne-p\"><span class=\"ne-text\">实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props。</span></p><p id=\"u2e4237b7\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"139992a5\" class=\"ne-codeblock language-jsx\">function Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n  function reducer(state, action) {\n    if (action.type === &quot;tick&quot;) {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n  useEffect(() =&gt; {\n    const id = setInterval(() =&gt; {\n      dispatch({ type: &quot;tick&quot; });\n    }, 1000);\n  }, [dispatch]);\n  return &lt;h1&gt;{count}&lt;/h1&gt;;\n}</pre><p id=\"ub7c6969c\" class=\"ne-p\"><br></p><p id=\"u16dbdc5d\" class=\"ne-p\"><span class=\"ne-text\">注意：这种模式会使一些优化失败，所以你应该避免滥用它，不过如果你需要，完全可以在 reducer 里面访问 props。</span></p><p id=\"u3af4027d\" class=\"ne-p\"><br></p><p id=\"ue5eb9a90\" class=\"ne-p\"><span class=\"ne-text\">它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。</span></p><p id=\"u5348bb23\" class=\"ne-p\"><br></p><h2 id=\"a105eb33\"><span class=\"ne-text\">8. 如何不把函数放到 Effect 里</span></h2><p id=\"u1ef3a0e4\" class=\"ne-p\"><br></p><p id=\"ubdca1d10\" class=\"ne-p\"><span class=\"ne-text\">有时候我们可能不想把函数移入 effect 里。</span></p><p id=\"u6692e0cd\" class=\"ne-p\"><br></p><p id=\"u80d5f657\" class=\"ne-p\"><span class=\"ne-text\">比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。</span></p><p id=\"u2de71625\" class=\"ne-p\"><br></p><p id=\"uf21ff2cb\" class=\"ne-p\"><span class=\"ne-text\">函数每次渲染都会改变这个事实本身就是个问题。比如有两个 effects 会调用 getFetchUrl:</span></p><p id=\"u88754522\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"d5472507\" class=\"ne-codeblock language-jsx\">function SearchResults() {\n  function getFetchUrl(query) {\n    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n  }\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;react&quot;);\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;redux&quot;);\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  // ...\n}</pre><p id=\"u50519119\" class=\"ne-p\"><br></p><p id=\"u41a3cfcc\" class=\"ne-p\"><span class=\"ne-text\">我们可能不想把 getFetchUrl 移到 effect 中，因为你想复用逻辑。</span></p><p id=\"u0b01e9bb\" class=\"ne-p\"><br></p><h3 id=\"295e64b5\"><span class=\"ne-text\">8.1 方法一</span></h3><p id=\"u8aefd35b\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u4b43a864\"><span class=\"ne-text\">如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用</span></li></ul><p id=\"u35faeac8\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"63b596c0\" class=\"ne-codeblock language-jsx\">// ✅ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n}\n\nfunction SearchResults() {\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;react&quot;);\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;redux&quot;);\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}</pre><p id=\"u9a3138b2\" class=\"ne-p\"><br></p><p id=\"ub0e6f7cf\" class=\"ne-p\"><span class=\"ne-text\">你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state 。</span></p><p id=\"u4d335c5a\" class=\"ne-p\"><br></p><h3 id=\"b3f76ab9\"><span class=\"ne-text\">8.2 方法二</span></h3><p id=\"udd29f19a\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"udb79db5e\"><span class=\"ne-text\">你也可以把它包装成 useCallback Hook</span></li></ul><p id=\"ud824ab08\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"d6ca7967\" class=\"ne-codeblock language-jsx\">function SearchResults() {\n  // ✅ Preserves identity when its own deps are the same\n  const getFetchUrl = useCallback(query =&gt; {\n    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n  }, []); // ✅ Callback deps are OK\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;react&quot;);\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl(&quot;redux&quot;);\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}</pre><p id=\"u8425ce56\" class=\"ne-p\"><br></p><p id=\"uf6199d27\" class=\"ne-p\"><span class=\"ne-text\">useCallback 本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。</span></p><p id=\"u8fe63eb1\" class=\"ne-p\"><br></p><p id=\"u19dc6b65\" class=\"ne-p\"><span class=\"ne-text\">如果我们想添加一个输入框允许你输入任意的查询条件(query)。不同于传递 query 参数的方式，现在 getFetchUrl 会从状态中读取。</span></p><p id=\"uf72c2088\" class=\"ne-p\"><br></p><p id=\"u1d188a3e\" class=\"ne-p\"><span class=\"ne-text\">如果我们把 query 添加到 useCallback 的依赖中，任何调用了 getFetchUrl 的 effect 在 query 改变后都会重新运行：</span></p><p id=\"u0b576511\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"767f60be\" class=\"ne-codeblock language-jsx\">function SearchResults() {\n  const [query, setQuery] = useState(&quot;react&quot;);\n\n  // ✅ Preserves identity until query changes\n  const getFetchUrl = useCallback(() =&gt; {\n    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n  }, [query]); // ✅ Callback deps are OK\n\n  useEffect(() =&gt; {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}</pre><p id=\"u334b016e\" class=\"ne-p\"><br></p><p id=\"u07f9b123\" class=\"ne-p\"><span class=\"ne-text\">这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用</span></p><p id=\"u37e44479\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"0f74833d\" class=\"ne-codeblock language-jsx\">function Parent() {\n  const [query, setQuery] = useState(&quot;react&quot;);\n  // ✅ Preserves identity until query changes\n  const fetchData = useCallback(() =&gt; {\n    const url = &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;\n    // ... Fetch data and return it ...\n  }, [query]); // ✅ Callback deps are OK\n  return &lt;Child fetchData={fetchData} /&gt;;\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n  // ...\n}</pre><p id=\"uf2a7b255\" class=\"ne-p\"><br></p><p id=\"u19aa9d4e\" class=\"ne-p\"><span class=\"ne-text\">因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据。</span></p><p id=\"u0693de13\" class=\"ne-p\"><br></p><h2 id=\"e10c53f8\"><span class=\"ne-text\">9. 函数是数据流的一部分么</span></h2><p id=\"u85364839\" class=\"ne-p\"><br></p><p id=\"ud66a2d29\" class=\"ne-p\"><span class=\"ne-text\">在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的 this 变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 &quot;diff&quot;。我们无法知道传入的 this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。</span></p><p id=\"uce6a59df\" class=\"ne-p\"><br></p><p id=\"ueb872c9c\" class=\"ne-p\"><span class=\"ne-text\">使用 useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。使用的 useCallback，属性 props.fetchData 的改变也会自动传递下去。</span></p><p id=\"uf3ae35f3\" class=\"ne-p\"><br></p><p id=\"u311bd647\" class=\"ne-p\"><span class=\"ne-text\">类似地，useMemo 可以让我们对复杂对象做类似的事情。</span></p><p id=\"u7af23ef5\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"abb4fe3d\" class=\"ne-codeblock language-jsx\">function ColorPicker() {\n  // Doesn't break Child's shallow equality prop check\n  // unless the color actually changes.\n  const [color, setColor] = useState(&quot;pink&quot;);\n  const style = useMemo(() =&gt; ({ color }), [color]);\n  return &lt;Child style={style} /&gt;;\n}</pre><p id=\"uaa03f934\" class=\"ne-p\"><br></p><h2 id=\"8ecdf1f0\"><span class=\"ne-text\">10. 竞态</span></h2><p id=\"u53600ad8\" class=\"ne-p\"><br></p><p id=\"u94dbe1d3\" class=\"ne-p\"><span class=\"ne-text\">下面是一个典型的在 class 组件里发请求的例子：</span></p><p id=\"u121b93e8\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"68a3b581\" class=\"ne-codeblock language-jsx\">class Article extends React.Component {\n  state = {\n    article: null\n  };\n  componentDidMount() {\n    this.fetchData(this.props.id);\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.id !== this.props.id) {\n      this.fetchData(this.props.id);\n    }\n  }\n  async fetchData(id) {\n    const article = await API.fetchArticle(id);\n    this.setState({ article });\n  }\n  // ...\n}</pre><p id=\"u7c0e715b\" class=\"ne-p\"><br></p><p id=\"u9fc52574\" class=\"ne-p\"><span class=\"ne-text\">这被叫做竞态，这在混合了 async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（ props 和 state 可能会在 async 函数调用过程中发生改变）。</span></p><p id=\"u47e0b75a\" class=\"ne-p\"><br></p><p id=\"ua0f58702\" class=\"ne-p\"><span class=\"ne-text\">Effects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个 async 函数给 effect。</span></p><p id=\"u659299b4\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ue7c701d1\"><span class=\"ne-text\">解决方式</span></li></ul><p id=\"u4ab6513b\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"ue379c304\"><span class=\"ne-text\"> 如果你使用的异步方式支持取消。你可以直接在清除函数中取消异步请求。 </span></li></ol><ol start=\"2\" class=\"ne-ol\"><li id=\"ubf77a809\"><span class=\"ne-text\"> 或者，最简单的权宜之计是用一个布尔值来跟踪它。 </span></li></ol><p id=\"u2af82159\" class=\"ne-p\"><br></p><pre data-language=\"jsx\" id=\"981076a4\" class=\"ne-codeblock language-jsx\">function Article({ id }) {\n  const [article, setArticle] = useState(null);\n\n  useEffect(() =&gt; {\n    let didCancel = false;\n    const fetchData = async () =&gt; {\n      const article = await API.fetchArticle(id);\n      if (!didCancel) {\n        setArticle(article);\n      }\n    };\n    fetchData();\n    return () =&gt; {\n      didCancel = true;\n    };\n  }, [id]);\n  // ...\n}</pre></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"traditional\" /><meta name=\"viewport\" content=\"adapt\" /><h1 data-lake-id=\"fe406e93\" id=\"fe406e93\"><span data-lake-id=\"u9f479866\" id=\"u9f479866\">React Hooks 的一些特性</span></h1><h2 data-lake-id=\"e350ad92\" id=\"e350ad92\"><span data-lake-id=\"ufe12f7a1\" id=\"ufe12f7a1\">1. 逆潮而动</span><span data-lake-id=\"u7adadfb1\" id=\"u7adadfb1\" style=\"background-color: #FFEC3D\">​</span></h2><p data-lake-id=\"u1119fdc6\" id=\"u1119fdc6\"><br></p><p data-lake-id=\"u4592763d\" id=\"u4592763d\"><span data-lake-id=\"ud36acd12\" id=\"ud36acd12\">每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 state</span></p><p data-lake-id=\"u9bad3378\" id=\"u9bad3378\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20Example(props)%20%7B%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20setTimeout(()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20console.log(props.counter)%3B%5Cn%20%20%20%20%7D%2C%201000)%3B%5Cn%20%20%7D)%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E7%AD%89%E6%95%88%E4%BA%8E%5Cn%5Cnfunction%20Example(props)%20%7B%5Cn%20%20const%20counter%20%3D%20props.counter%3B%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20setTimeout(()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20console.log(counter)%3B%5Cn%20%20%20%20%7D)%3B%5Cn%20%20%7D)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22e1087529%22%7D\"></card><p data-lake-id=\"uee5aae4a\" id=\"uee5aae4a\"><br></p><h2 data-lake-id=\"4f71ead0\" id=\"4f71ead0\"><span data-lake-id=\"u66a5f180\" id=\"u66a5f180\">2. effects 中的清理</span></h2><p data-lake-id=\"u193a22d4\" id=\"u193a22d4\"><br></p><p data-lake-id=\"u4b496cdd\" id=\"u4b496cdd\"><span data-lake-id=\"u575be055\" id=\"u575be055\">目的: 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用的 effect，比如取消订阅。</span></p><p data-lake-id=\"ue457dca0\" id=\"ue457dca0\"><br></p><p data-lake-id=\"u52a0907d\" id=\"u52a0907d\"><span data-lake-id=\"u66befede\" id=\"u66befede\">effect 的清除并不会读取 &quot;最新&quot; 的 props。它只能读取到定义它的那次渲染中的 props 的值</span></p><p data-lake-id=\"u374e9222\" id=\"u374e9222\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20First%20render%2C%20props%20are%20%7Bid%3A%2010%7D%5Cnfunction%20Example()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20ChatAPI.subscribeToFriendStatus(10%2C%20handleStatusChange)%3B%5Cn%20%20%20%20%2F%2F%20cleanup%20for%20effect%20from%20first%20render%5Cn%20%20%20%20return%20()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20ChatAPI.subscribeToFriendStatus(10%2C%20handleStatusChange)%3B%5Cn%20%20%20%20%7D%3B%5Cn%20%20%7D)%3B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%2F%2F%20Next%20render%2C%20props%20are%20%7Bid%3A%2020%7D%5Cnfunction%20Example()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20ChatAPI.subscribeToFriendStatus(20%2C%20handleStatusChange)%3B%5Cn%20%20%20%20return%20()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20ChatAPI.subscribeToFriendStatus(20%2C%20handleStatusChange)%3B%5Cn%20%20%20%20%7D%3B%5Cn%20%20%7D)%3B%5Cn%20%20%2F%2F%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22ce076e09%22%7D\"></card><p data-lake-id=\"u2c34d6a7\" id=\"u2c34d6a7\"><br></p><h2 data-lake-id=\"06aa1b26\" id=\"06aa1b26\"><span data-lake-id=\"u3ad3fc0e\" id=\"u3ad3fc0e\">3. 避免重复调用</span></h2><p data-lake-id=\"u1eb57611\" id=\"u1eb57611\"><br></p><p data-lake-id=\"u21cfdbde\" id=\"u21cfdbde\"><span data-lake-id=\"u0b9aea06\" id=\"u0b9aea06\">为了避免 effects 不必要的重复调用，我们可以提供给 useEffect 一个依赖数组参数(deps)</span></p><p data-lake-id=\"u87d02128\" id=\"u87d02128\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22useEffect(()%20%3D%3E%20%7B%5Cn%20%20document.title%20%3D%20%5C%22Hello%2C%20%5C%22%20%2B%20title%3B%5Cn%7D%2C%20%5Bname%5D)%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%228e80e557%22%7D\"></card><p data-lake-id=\"u6eba3ceb\" id=\"u6eba3ceb\"><br></p><p data-lake-id=\"u8ca90977\" id=\"u8ca90977\"><span data-lake-id=\"ua0afa6d0\" id=\"ua0afa6d0\">如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect。</span></p><p data-lake-id=\"ufad4d72b\" id=\"ufad4d72b\"><br></p><h2 data-lake-id=\"3ab31427\" id=\"3ab31427\"><span data-lake-id=\"u0850f3f3\" id=\"u0850f3f3\">4. 两种诚实告知依赖的方法</span></h2><p data-lake-id=\"u39c5a115\" id=\"u39c5a115\"><br></p><ul list=\"u4cdc798c\"><li fid=\"u052d0c36\" data-lake-id=\"u59da956d\" id=\"u59da956d\"><span data-lake-id=\"ud1b2c5a7\" id=\"ud1b2c5a7\">在依赖中包含所有 effect 中用到的组件内的值</span></li></ul><p data-lake-id=\"ud09b176d\" id=\"ud09b176d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22import%20React%2C%20%7B%20useState%2C%20useEffect%20%7D%20from%20%5C%22react%5C%22%3B%5Cnimport%20ReactDOM%20from%20%5C%22react-dom%5C%22%3B%5Cn%5Cnexport%20default%20function%20App()%20%7B%5Cn%20%20const%20%5Bcount%2C%20setCount%5D%20%3D%20useState(0)%3B%5Cn%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20id%20%3D%20setInterval(()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20setCount(count%20%2B%201)%3B%5Cn%20%20%20%20%7D)%3B%5Cn%20%20%20%20return%20()%20%3D%3E%20clearInterval(id)%3B%5Cn%20%20%7D%2C%20%5Bcount%5D)%3B%5Cn%5Cn%20%20return%20(%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%3Cp%3Eyou%20clicked%20it%20%7Bcount%7D%20times%3C%2Fp%3E%5Cn%20%20%20%20%20%20%3Cbutton%20onClick%3D%7B()%20%3D%3E%20setCount(count%20%2B%201)%7D%3Eclick%20me%3C%2Fbutton%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20)%3B%5Cn%7D%5CnReactDOM.render(%3CApp%20%2F%3E%2C%20document.getElementById(%5C%22root%5C%22))%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22f82ff37f%22%7D\"></card><p data-lake-id=\"u1682635b\" id=\"u1682635b\"><br></p><ul list=\"u463c36ba\"><li fid=\"u5a7ccfe9\" data-lake-id=\"u8d61b5b1\" id=\"u8d61b5b1\"><span data-lake-id=\"ue7065663\" id=\"ue7065663\">修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使依赖更少。</span></li></ul><p data-lake-id=\"u232742de\" id=\"u232742de\"><br></p><h2 data-lake-id=\"c5999af3\" id=\"c5999af3\"><span data-lake-id=\"ue00f1375\" id=\"ue00f1375\">5. 让 Effect 自给自足</span></h2><p data-lake-id=\"ueb241092\" id=\"ueb241092\"><br></p><p data-lake-id=\"uf41fe9d7\" id=\"uf41fe9d7\"><span data-lake-id=\"u6a63783b\" id=\"u6a63783b\">我们想要根据前一个状态更新状态的时候，我们可以使用 setState 的 函数形式</span></p><p data-lake-id=\"u0ee70da3\" id=\"u0ee70da3\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22useEffect(()%20%3D%3E%20%7B%5Cn%20%20const%20id%20%3D%20setInterval(()%20%3D%3E%20%7B%5Cn%20%20%20%20setCount(c%20%3D%3E%20c%20%2B%201)%3B%5Cn%20%20%7D%2C%201000)%3B%5Cn%20%20return%20()%20%3D%3E%20clearInterval(id)%3B%5Cn%7D%2C%20%5B%5D)%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22e38dc5a0%22%7D\"></card><p data-lake-id=\"u85cbd24c\" id=\"u85cbd24c\"><br></p><p data-lake-id=\"uaf5bf684\" id=\"uaf5bf684\"><span data-lake-id=\"ucc477958\" id=\"ucc477958\">这正是 setCount(c =&gt; c + 1) 做的事情。你可以认为它是在给 React &quot;发送指令&quot; 告知如何更新状态。这种 &quot;更新形式&quot; 在其他情况下也有帮助，比如你需要 &quot;批量更新&quot;。</span></p><p data-lake-id=\"uc385ed21\" id=\"uc385ed21\"><br></p><h2 data-lake-id=\"587b909c\" id=\"587b909c\"><span data-lake-id=\"u750febec\" id=\"u750febec\">6. 解耦来自 Actions 的更新</span></h2><p data-lake-id=\"u14a40505\" id=\"u14a40505\"><br></p><p data-lake-id=\"u697248c4\" id=\"u697248c4\"><span data-lake-id=\"ud8ff86d8\" id=\"ud8ff86d8\">当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用 useReducer 去替换它们。</span></p><p data-lake-id=\"ua82ca908\" id=\"ua82ca908\"><br></p><p data-lake-id=\"u9e1453d2\" id=\"u9e1453d2\"><span data-lake-id=\"u52906dd7\" id=\"u52906dd7\">当你写类似 setSomething(something =&gt; ...) 这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你 </span><strong><span data-lake-id=\"uf3695d5b\" id=\"uf3695d5b\">把组件内发生了什么(actions)</span></strong><span data-lake-id=\"ua3451526\" id=\"ua3451526\"> 和 </span><strong><span data-lake-id=\"u34edd1a1\" id=\"u34edd1a1\">状态如何响应并更新</span></strong><span data-lake-id=\"u83d9dcf3\" id=\"u83d9dcf3\"> 分开表述。</span></p><p data-lake-id=\"ub15805fa\" id=\"ub15805fa\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22const%20%5Bstate%2C%20dispatch%5D%20%3D%20useReducer(reducer%2C%20initialState)%3B%5Cnconst%20%7B%20count%2C%20step%20%7D%20%3D%20state%3B%5CnuseEffect(()%20%3D%3E%20%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%20id%20%3D%20setInterval(()%20%3D%3E%20%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0dispatch(%7B%20type%3A%20%5C%22tick%5C%22%20%7D)%3B%20%2F%2F%20Instead%20of%20setCount(c%20%3D%3E%20c%20%2B%20step)%20%7D%2C%201000)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%20()%20%3D%3E%20clearInterval(id)%3B%5Cn%7D%2C%20%5Bdispatch%5D)%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22c992941c%22%7D\"></card><p data-lake-id=\"u653123d1\" id=\"u653123d1\"><br></p><p data-lake-id=\"u0e4e372a\" id=\"u0e4e372a\"><span data-lake-id=\"uca152851\" id=\"uca152851\">相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理。</span></p><p data-lake-id=\"ufa717c59\" id=\"ufa717c59\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22const%20initialState%20%3D%20%7B%5Cn%20%20count%3A%200%2C%5Cn%20%20step%3A%201%5Cn%7D%3B%5Cnfunction%20reducer(state%2C%20action)%20%7B%5Cn%20%20const%20%7B%20count%2C%20step%20%7D%20%3D%20state%3B%5Cn%20%20if%20(action.type%20%3D%3D%3D%20%5C%22tick%5C%22)%20%7B%5Cn%20%20%20%20return%20%7B%20count%3A%20count%20%2B%20step%2C%20step%20%7D%3B%5Cn%20%20%7D%20else%20if%20(action.type%20%3D%3D%3D%20%5C%22step%5C%22)%20%7B%5Cn%20%20%20%20return%20%7B%20count%2C%20step%3A%20action.step%20%7D%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20throw%20new%20Error()%3B%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%222ee8af8e%22%7D\"></card><p data-lake-id=\"uc0073aa5\" id=\"uc0073aa5\"><br></p><h2 data-lake-id=\"4e22f74b\" id=\"4e22f74b\"><span data-lake-id=\"ub875a714\" id=\"ub875a714\">7. 为什么 useReducer 是 Hooks 的作弊模式</span></h2><p data-lake-id=\"u17975e7e\" id=\"u17975e7e\"><br></p><p data-lake-id=\"u9d9d1278\" id=\"u9d9d1278\"><span data-lake-id=\"u811dd200\" id=\"u811dd200\">假如我们需要依赖 props 去计算下一个状态。举个例子，也许我们的 API 是 </span><code data-lake-id=\"u5a7314a3\" id=\"u5a7314a3\"><span data-lake-id=\"u44edc931\" id=\"u44edc931\">&lt;Counter step={1} /&gt;</span></code><span data-lake-id=\"u80cd413f\" id=\"u80cd413f\">。确定的是，在这种情况下，我们没法避免依赖 props.step 。</span></p><p data-lake-id=\"u34985d95\" id=\"u34985d95\"><br></p><p data-lake-id=\"uf2ddaf1d\" id=\"uf2ddaf1d\"><span data-lake-id=\"uc7222436\" id=\"uc7222436\">实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props。</span></p><p data-lake-id=\"u2e4237b7\" id=\"u2e4237b7\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20Counter(%7B%20step%20%7D)%20%7B%5Cn%20%20const%20%5Bcount%2C%20dispatch%5D%20%3D%20useReducer(reducer%2C%200)%3B%5Cn%20%20function%20reducer(state%2C%20action)%20%7B%5Cn%20%20%20%20if%20(action.type%20%3D%3D%3D%20%5C%22tick%5C%22)%20%7B%5Cn%20%20%20%20%20%20return%20state%20%2B%20step%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20throw%20new%20Error()%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20id%20%3D%20setInterval(()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20dispatch(%7B%20type%3A%20%5C%22tick%5C%22%20%7D)%3B%5Cn%20%20%20%20%7D%2C%201000)%3B%5Cn%20%20%7D%2C%20%5Bdispatch%5D)%3B%5Cn%20%20return%20%3Ch1%3E%7Bcount%7D%3C%2Fh1%3E%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22139992a5%22%7D\"></card><p data-lake-id=\"ub7c6969c\" id=\"ub7c6969c\"><br></p><p data-lake-id=\"u16dbdc5d\" id=\"u16dbdc5d\"><span data-lake-id=\"u645825d4\" id=\"u645825d4\">注意：这种模式会使一些优化失败，所以你应该避免滥用它，不过如果你需要，完全可以在 reducer 里面访问 props。</span></p><p data-lake-id=\"u3af4027d\" id=\"u3af4027d\"><br></p><p data-lake-id=\"ue5eb9a90\" id=\"ue5eb9a90\"><span data-lake-id=\"ue33352d1\" id=\"ue33352d1\">它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。</span></p><p data-lake-id=\"u5348bb23\" id=\"u5348bb23\"><br></p><h2 data-lake-id=\"a105eb33\" id=\"a105eb33\"><span data-lake-id=\"u50a7f043\" id=\"u50a7f043\">8. 如何不把函数放到 Effect 里</span></h2><p data-lake-id=\"u1ef3a0e4\" id=\"u1ef3a0e4\"><br></p><p data-lake-id=\"ubdca1d10\" id=\"ubdca1d10\"><span data-lake-id=\"u8cf87da6\" id=\"u8cf87da6\">有时候我们可能不想把函数移入 effect 里。</span></p><p data-lake-id=\"u6692e0cd\" id=\"u6692e0cd\"><br></p><p data-lake-id=\"u80d5f657\" id=\"u80d5f657\"><span data-lake-id=\"u9b768dd3\" id=\"u9b768dd3\">比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。</span></p><p data-lake-id=\"u2de71625\" id=\"u2de71625\"><br></p><p data-lake-id=\"uf21ff2cb\" id=\"uf21ff2cb\"><span data-lake-id=\"uae2f90ba\" id=\"uae2f90ba\">函数每次渲染都会改变这个事实本身就是个问题。比如有两个 effects 会调用 getFetchUrl:</span></p><p data-lake-id=\"u88754522\" id=\"u88754522\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20SearchResults()%20%7B%5Cn%20%20function%20getFetchUrl(query)%20%7B%5Cn%20%20%20%20return%20%5C%22https%3A%2F%2Fhn.algolia.com%2Fapi%2Fv1%2Fsearch%3Fquery%3D%5C%22%20%2B%20query%3B%5Cn%20%20%7D%5Cn%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20url%20%3D%20getFetchUrl(%5C%22react%5C%22)%3B%5Cn%20%20%20%20%2F%2F%20...%20Fetch%20data%20and%20do%20something%20...%5Cn%20%20%7D%2C%20%5B%5D)%3B%20%2F%2F%20%F0%9F%94%B4%20Missing%20dep%3A%20getFetchUrl%5Cn%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20url%20%3D%20getFetchUrl(%5C%22redux%5C%22)%3B%5Cn%20%20%20%20%2F%2F%20...%20Fetch%20data%20and%20do%20something%20...%5Cn%20%20%7D%2C%20%5B%5D)%3B%20%2F%2F%20%F0%9F%94%B4%20Missing%20dep%3A%20getFetchUrl%5Cn%5Cn%20%20%2F%2F%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22d5472507%22%7D\"></card><p data-lake-id=\"u50519119\" id=\"u50519119\"><br></p><p data-lake-id=\"u41a3cfcc\" id=\"u41a3cfcc\"><span data-lake-id=\"u809cf9ee\" id=\"u809cf9ee\">我们可能不想把 getFetchUrl 移到 effect 中，因为你想复用逻辑。</span></p><p data-lake-id=\"u0b01e9bb\" id=\"u0b01e9bb\"><br></p><h3 data-lake-id=\"295e64b5\" id=\"295e64b5\"><span data-lake-id=\"u3b2ea4c5\" id=\"u3b2ea4c5\">8.1 方法一</span></h3><p data-lake-id=\"u8aefd35b\" id=\"u8aefd35b\"><br></p><ul list=\"u1335e8c9\"><li fid=\"ued9950c2\" data-lake-id=\"u4b43a864\" id=\"u4b43a864\"><span data-lake-id=\"u6da1328b\" id=\"u6da1328b\">如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用</span></li></ul><p data-lake-id=\"u35faeac8\" id=\"u35faeac8\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22%2F%2F%20%E2%9C%85%20Not%20affected%20by%20the%20data%20flow%5Cnfunction%20getFetchUrl(query)%20%7B%5Cn%20%20return%20%5C%22https%3A%2F%2Fhn.algolia.com%2Fapi%2Fv1%2Fsearch%3Fquery%3D%5C%22%20%2B%20query%3B%5Cn%7D%5Cn%5Cnfunction%20SearchResults()%20%7B%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20url%20%3D%20getFetchUrl(%5C%22react%5C%22)%3B%5Cn%20%20%20%20%2F%2F%20...%20Fetch%20data%20and%20do%20something%20...%5Cn%20%20%7D%2C%20%5B%5D)%3B%20%2F%2F%20%E2%9C%85%20Deps%20are%20OK%5Cn%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20url%20%3D%20getFetchUrl(%5C%22redux%5C%22)%3B%5Cn%20%20%20%20%2F%2F%20...%20Fetch%20data%20and%20do%20something%20...%5Cn%20%20%7D%2C%20%5B%5D)%3B%20%2F%2F%20%E2%9C%85%20Deps%20are%20OK%5Cn%5Cn%20%20%2F%2F%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2263b596c0%22%7D\"></card><p data-lake-id=\"u9a3138b2\" id=\"u9a3138b2\"><br></p><p data-lake-id=\"ub0e6f7cf\" id=\"ub0e6f7cf\"><span data-lake-id=\"ubcd1c12a\" id=\"ubcd1c12a\">你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state 。</span></p><p data-lake-id=\"u4d335c5a\" id=\"u4d335c5a\"><br></p><h3 data-lake-id=\"b3f76ab9\" id=\"b3f76ab9\"><span data-lake-id=\"uc4fede0b\" id=\"uc4fede0b\">8.2 方法二</span></h3><p data-lake-id=\"udd29f19a\" id=\"udd29f19a\"><br></p><ul list=\"udc1450fc\"><li fid=\"ud900206e\" data-lake-id=\"udb79db5e\" id=\"udb79db5e\"><span data-lake-id=\"u1eae7182\" id=\"u1eae7182\">你也可以把它包装成 useCallback Hook</span></li></ul><p data-lake-id=\"ud824ab08\" id=\"ud824ab08\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20SearchResults()%20%7B%5Cn%20%20%2F%2F%20%E2%9C%85%20Preserves%20identity%20when%20its%20own%20deps%20are%20the%20same%5Cn%20%20const%20getFetchUrl%20%3D%20useCallback(query%20%3D%3E%20%7B%5Cn%20%20%20%20return%20%5C%22https%3A%2F%2Fhn.algolia.com%2Fapi%2Fv1%2Fsearch%3Fquery%3D%5C%22%20%2B%20query%3B%5Cn%20%20%7D%2C%20%5B%5D)%3B%20%2F%2F%20%E2%9C%85%20Callback%20deps%20are%20OK%5Cn%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20url%20%3D%20getFetchUrl(%5C%22react%5C%22)%3B%5Cn%20%20%20%20%2F%2F%20...%20Fetch%20data%20and%20do%20something%20...%5Cn%20%20%7D%2C%20%5BgetFetchUrl%5D)%3B%20%2F%2F%20%E2%9C%85%20Effect%20deps%20are%20OK%5Cn%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20url%20%3D%20getFetchUrl(%5C%22redux%5C%22)%3B%5Cn%20%20%20%20%2F%2F%20...%20Fetch%20data%20and%20do%20something%20...%5Cn%20%20%7D%2C%20%5BgetFetchUrl%5D)%3B%20%2F%2F%20%E2%9C%85%20Effect%20deps%20are%20OK%5Cn%5Cn%20%20%2F%2F%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22d6ca7967%22%7D\"></card><p data-lake-id=\"u8425ce56\" id=\"u8425ce56\"><br></p><p data-lake-id=\"uf6199d27\" id=\"uf6199d27\"><span data-lake-id=\"u91453c39\" id=\"u91453c39\">useCallback 本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。</span></p><p data-lake-id=\"u8fe63eb1\" id=\"u8fe63eb1\"><br></p><p data-lake-id=\"u19dc6b65\" id=\"u19dc6b65\"><span data-lake-id=\"uba93086c\" id=\"uba93086c\">如果我们想添加一个输入框允许你输入任意的查询条件(query)。不同于传递 query 参数的方式，现在 getFetchUrl 会从状态中读取。</span></p><p data-lake-id=\"uf72c2088\" id=\"uf72c2088\"><br></p><p data-lake-id=\"u1d188a3e\" id=\"u1d188a3e\"><span data-lake-id=\"u2c688aed\" id=\"u2c688aed\">如果我们把 query 添加到 useCallback 的依赖中，任何调用了 getFetchUrl 的 effect 在 query 改变后都会重新运行：</span></p><p data-lake-id=\"u0b576511\" id=\"u0b576511\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20SearchResults()%20%7B%5Cn%20%20const%20%5Bquery%2C%20setQuery%5D%20%3D%20useState(%5C%22react%5C%22)%3B%5Cn%5Cn%20%20%2F%2F%20%E2%9C%85%20Preserves%20identity%20until%20query%20changes%5Cn%20%20const%20getFetchUrl%20%3D%20useCallback(()%20%3D%3E%20%7B%5Cn%20%20%20%20return%20%5C%22https%3A%2F%2Fhn.algolia.com%2Fapi%2Fv1%2Fsearch%3Fquery%3D%5C%22%20%2B%20query%3B%5Cn%20%20%7D%2C%20%5Bquery%5D)%3B%20%2F%2F%20%E2%9C%85%20Callback%20deps%20are%20OK%5Cn%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20url%20%3D%20getFetchUrl()%3B%5Cn%20%20%20%20%2F%2F%20...%20Fetch%20data%20and%20do%20something%20...%5Cn%20%20%7D%2C%20%5BgetFetchUrl%5D)%3B%20%2F%2F%20%E2%9C%85%20Effect%20deps%20are%20OK%5Cn%5Cn%20%20%2F%2F%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22767f60be%22%7D\"></card><p data-lake-id=\"u334b016e\" id=\"u334b016e\"><br></p><p data-lake-id=\"u07f9b123\" id=\"u07f9b123\"><span data-lake-id=\"u1cf6d5f8\" id=\"u1cf6d5f8\">这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用</span></p><p data-lake-id=\"u37e44479\" id=\"u37e44479\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20Parent()%20%7B%5Cn%20%20const%20%5Bquery%2C%20setQuery%5D%20%3D%20useState(%5C%22react%5C%22)%3B%5Cn%20%20%2F%2F%20%E2%9C%85%20Preserves%20identity%20until%20query%20changes%5Cn%20%20const%20fetchData%20%3D%20useCallback(()%20%3D%3E%20%7B%5Cn%20%20%20%20const%20url%20%3D%20%5C%22https%3A%2F%2Fhn.algolia.com%2Fapi%2Fv1%2Fsearch%3Fquery%3D%5C%22%20%2B%20query%3B%5Cn%20%20%20%20%2F%2F%20...%20Fetch%20data%20and%20return%20it%20...%5Cn%20%20%7D%2C%20%5Bquery%5D)%3B%20%2F%2F%20%E2%9C%85%20Callback%20deps%20are%20OK%5Cn%20%20return%20%3CChild%20fetchData%3D%7BfetchData%7D%20%2F%3E%3B%5Cn%7D%5Cn%5Cnfunction%20Child(%7B%20fetchData%20%7D)%20%7B%5Cn%20%20let%20%5Bdata%2C%20setData%5D%20%3D%20useState(null)%3B%5Cn%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20fetchData().then(setData)%3B%5Cn%20%20%7D%2C%20%5BfetchData%5D)%3B%20%2F%2F%20%E2%9C%85%20Effect%20deps%20are%20OK%5Cn%20%20%2F%2F%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%220f74833d%22%7D\"></card><p data-lake-id=\"uf2a7b255\" id=\"uf2a7b255\"><br></p><p data-lake-id=\"u19aa9d4e\" id=\"u19aa9d4e\"><span data-lake-id=\"ud36512b6\" id=\"ud36512b6\">因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据。</span></p><p data-lake-id=\"u0693de13\" id=\"u0693de13\"><br></p><h2 data-lake-id=\"e10c53f8\" id=\"e10c53f8\"><span data-lake-id=\"ua706e938\" id=\"ua706e938\">9. 函数是数据流的一部分么</span></h2><p data-lake-id=\"u85364839\" id=\"u85364839\"><br></p><p data-lake-id=\"ud66a2d29\" id=\"ud66a2d29\"><span data-lake-id=\"u882fe0d7\" id=\"u882fe0d7\">在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的 this 变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 &quot;diff&quot;。我们无法知道传入的 this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。</span></p><p data-lake-id=\"uce6a59df\" id=\"uce6a59df\"><br></p><p data-lake-id=\"ueb872c9c\" id=\"ueb872c9c\"><span data-lake-id=\"uf18f83cb\" id=\"uf18f83cb\">使用 useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。使用的 useCallback，属性 props.fetchData 的改变也会自动传递下去。</span></p><p data-lake-id=\"uf3ae35f3\" id=\"uf3ae35f3\"><br></p><p data-lake-id=\"u311bd647\" id=\"u311bd647\"><span data-lake-id=\"uc592de2e\" id=\"uc592de2e\">类似地，useMemo 可以让我们对复杂对象做类似的事情。</span></p><p data-lake-id=\"u7af23ef5\" id=\"u7af23ef5\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20ColorPicker()%20%7B%5Cn%20%20%2F%2F%20Doesn't%20break%20Child's%20shallow%20equality%20prop%20check%5Cn%20%20%2F%2F%20unless%20the%20color%20actually%20changes.%5Cn%20%20const%20%5Bcolor%2C%20setColor%5D%20%3D%20useState(%5C%22pink%5C%22)%3B%5Cn%20%20const%20style%20%3D%20useMemo(()%20%3D%3E%20(%7B%20color%20%7D)%2C%20%5Bcolor%5D)%3B%5Cn%20%20return%20%3CChild%20style%3D%7Bstyle%7D%20%2F%3E%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22abb4fe3d%22%7D\"></card><p data-lake-id=\"uaa03f934\" id=\"uaa03f934\"><br></p><h2 data-lake-id=\"8ecdf1f0\" id=\"8ecdf1f0\"><span data-lake-id=\"ub6a8f3d4\" id=\"ub6a8f3d4\">10. 竞态</span></h2><p data-lake-id=\"u53600ad8\" id=\"u53600ad8\"><br></p><p data-lake-id=\"u94dbe1d3\" id=\"u94dbe1d3\"><span data-lake-id=\"ucab7f641\" id=\"ucab7f641\">下面是一个典型的在 class 组件里发请求的例子：</span></p><p data-lake-id=\"u121b93e8\" id=\"u121b93e8\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22class%20Article%20extends%20React.Component%20%7B%5Cn%20%20state%20%3D%20%7B%5Cn%20%20%20%20article%3A%20null%5Cn%20%20%7D%3B%5Cn%20%20componentDidMount()%20%7B%5Cn%20%20%20%20this.fetchData(this.props.id)%3B%5Cn%20%20%7D%5Cn%20%20componentDidUpdate(prevProps)%20%7B%5Cn%20%20%20%20if%20(prevProps.id%20!%3D%3D%20this.props.id)%20%7B%5Cn%20%20%20%20%20%20this.fetchData(this.props.id)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20async%20fetchData(id)%20%7B%5Cn%20%20%20%20const%20article%20%3D%20await%20API.fetchArticle(id)%3B%5Cn%20%20%20%20this.setState(%7B%20article%20%7D)%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2268a3b581%22%7D\"></card><p data-lake-id=\"u7c0e715b\" id=\"u7c0e715b\"><br></p><p data-lake-id=\"u9fc52574\" id=\"u9fc52574\"><span data-lake-id=\"ucb03bc08\" id=\"ucb03bc08\">这被叫做竞态，这在混合了 async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（ props 和 state 可能会在 async 函数调用过程中发生改变）。</span></p><p data-lake-id=\"u47e0b75a\" id=\"u47e0b75a\"><br></p><p data-lake-id=\"ua0f58702\" id=\"ua0f58702\"><span data-lake-id=\"u9b93f471\" id=\"u9b93f471\">Effects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个 async 函数给 effect。</span></p><p data-lake-id=\"u659299b4\" id=\"u659299b4\"><br></p><ul list=\"uf7795079\"><li fid=\"ubead4aba\" data-lake-id=\"ue7c701d1\" id=\"ue7c701d1\"><span data-lake-id=\"uf5eb66f0\" id=\"uf5eb66f0\">解决方式</span></li></ul><p data-lake-id=\"u4ab6513b\" id=\"u4ab6513b\"><br></p><ol list=\"u4016a866\"><li fid=\"ue431b323\" data-lake-id=\"ue379c304\" id=\"ue379c304\"><span data-lake-id=\"uac45e94b\" id=\"uac45e94b\"> 如果你使用的异步方式支持取消。你可以直接在清除函数中取消异步请求。 </span></li></ol><ol list=\"ub91778f7\" start=\"2\"><li fid=\"uc23a4791\" data-lake-id=\"ubf77a809\" id=\"ubf77a809\"><span data-lake-id=\"u6a8b058b\" id=\"u6a8b058b\"> 或者，最简单的权宜之计是用一个布尔值来跟踪它。 </span></li></ol><p data-lake-id=\"u2af82159\" id=\"u2af82159\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22jsx%22%2C%22code%22%3A%22function%20Article(%7B%20id%20%7D)%20%7B%5Cn%20%20const%20%5Barticle%2C%20setArticle%5D%20%3D%20useState(null)%3B%5Cn%5Cn%20%20useEffect(()%20%3D%3E%20%7B%5Cn%20%20%20%20let%20didCancel%20%3D%20false%3B%5Cn%20%20%20%20const%20fetchData%20%3D%20async%20()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20const%20article%20%3D%20await%20API.fetchArticle(id)%3B%5Cn%20%20%20%20%20%20if%20(!didCancel)%20%7B%5Cn%20%20%20%20%20%20%20%20setArticle(article)%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%3B%5Cn%20%20%20%20fetchData()%3B%5Cn%20%20%20%20return%20()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20didCancel%20%3D%20true%3B%5Cn%20%20%20%20%7D%3B%5Cn%20%20%7D%2C%20%5Bid%5D)%3B%5Cn%20%20%2F%2F%20...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22981076a4%22%7D\"></card>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 2507,
  "created_at": "2021-03-16T06:05:21.000Z",
  "updated_at": "2022-03-13T09:58:45.000Z",
  "content_updated_at": "2022-03-03T15:36:26.000Z",
  "published_at": "2022-03-03T15:36:26.000Z",
  "first_published_at": "2021-03-16T06:05:21.000Z",
  "book": {
    "id": 25332296,
    "type": "Book",
    "slug": "xxble8",
    "name": "前端技术文章",
    "user_id": 732231,
    "description": "记录前端相关的技术性文章",
    "toc_yml": "- type: META\n  count: 35\n  display_level: 1\n  tail_type: UPDATED_AT\n  base_version_id: 212554542\n  published: true\n  max_level: 2\n  last_updated_at: 2022-06-15T01:16:18.992Z\n  version_id: 213246417\n- type: TITLE\n  title: 包管理\n  uuid: _QuaGpvQyXOJqViR\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  child_uuid: rCzMi2OLxQeldZoL\n  sibling_uuid: esTqfZ-VIsO4KK9Q\n- type: DOC\n  title: verdaccio\n  uuid: rCzMi2OLxQeldZoL\n  url: tbmwax\n  parent_uuid: _QuaGpvQyXOJqViR\n  doc_id: 76715838\n  level: 1\n  id: 76715838\n  open_window: 0\n  visible: 1\n  prev_uuid: _QuaGpvQyXOJqViR\n  sibling_uuid: cv09hDGqlf4qMuLA\n- type: DOC\n  title: npm 包发布/卸载\n  uuid: cv09hDGqlf4qMuLA\n  url: zirrw6\n  parent_uuid: _QuaGpvQyXOJqViR\n  doc_id: 69834306\n  level: 1\n  id: 69834306\n  open_window: 0\n  visible: 1\n  prev_uuid: rCzMi2OLxQeldZoL\n- type: TITLE\n  title: 算法\n  uuid: esTqfZ-VIsO4KK9Q\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: _QuaGpvQyXOJqViR\n  child_uuid: Ogc2uBwNrDY5GME-\n  sibling_uuid: tk3brROhNFOdvu5c\n- type: DOC\n  title: 常用排序算法\n  uuid: Ogc2uBwNrDY5GME-\n  url: cwwn2a\n  parent_uuid: esTqfZ-VIsO4KK9Q\n  doc_id: 69585869\n  level: 1\n  id: 69585869\n  open_window: 0\n  visible: 1\n  prev_uuid: esTqfZ-VIsO4KK9Q\n- type: TITLE\n  title: 前端三架马车(html、css、javaScript)\n  uuid: tk3brROhNFOdvu5c\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: esTqfZ-VIsO4KK9Q\n  child_uuid: 89gjblQgjF0QZj7N\n  sibling_uuid: AnAUOtoVl35Ctf-m\n- type: DOC\n  title: 正则表达式梳理\n  uuid: 89gjblQgjF0QZj7N\n  url: ygg1li\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 69445939\n  level: 1\n  id: 69445939\n  open_window: 0\n  visible: 1\n  prev_uuid: tk3brROhNFOdvu5c\n  sibling_uuid: s4St0Tz5-SfLvKIX\n- type: DOC\n  title: 前端自动化测试\n  uuid: s4St0Tz5-SfLvKIX\n  url: tuiqkt\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 32924996\n  level: 1\n  id: 32924996\n  open_window: 1\n  visible: 1\n  prev_uuid: 89gjblQgjF0QZj7N\n  sibling_uuid: dxTurh6P_eb0zy_L\n- type: DOC\n  title: 从图片裁剪了解 javaScript 二进制常用 api\n  uuid: dxTurh6P_eb0zy_L\n  url: dflyyg\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11942849\n  level: 1\n  id: 11942849\n  open_window: 1\n  visible: 1\n  prev_uuid: s4St0Tz5-SfLvKIX\n  sibling_uuid: zMSTSZz39xp5h8EQ\n- type: DOC\n  title: Hybrid 简介\n  uuid: zMSTSZz39xp5h8EQ\n  url: wgdslk\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11444492\n  level: 1\n  id: 11444492\n  open_window: 1\n  visible: 1\n  prev_uuid: dxTurh6P_eb0zy_L\n  sibling_uuid: vT0QKWss3m0hDXF_\n- type: DOC\n  title: 渐进式 web 应用程序 pwa 简介\n  uuid: vT0QKWss3m0hDXF_\n  url: fm39qi\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11444574\n  level: 1\n  id: 11444574\n  open_window: 1\n  visible: 1\n  prev_uuid: zMSTSZz39xp5h8EQ\n  sibling_uuid: BN9ltP3u0AoFK0fF\n- type: DOC\n  title: H5 相关问题收集\n  uuid: BN9ltP3u0AoFK0fF\n  url: gxfam0\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11465630\n  level: 1\n  id: 11465630\n  open_window: 1\n  visible: 1\n  prev_uuid: vT0QKWss3m0hDXF_\n  sibling_uuid: 9AamH2OW8UgEfrja\n- type: DOC\n  title: 元素隐藏问题\n  uuid: 9AamH2OW8UgEfrja\n  url: ecvr1k\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11432332\n  level: 1\n  id: 11432332\n  open_window: 1\n  visible: 1\n  prev_uuid: BN9ltP3u0AoFK0fF\n  sibling_uuid: nx-R8OiSdFKMbNkp\n- type: DOC\n  title: 外边距合并问题\n  uuid: nx-R8OiSdFKMbNkp\n  url: vsuafl\n  parent_uuid: tk3brROhNFOdvu5c\n  doc_id: 11432306\n  level: 1\n  id: 11432306\n  open_window: 1\n  visible: 1\n  prev_uuid: 9AamH2OW8UgEfrja\n- type: TITLE\n  title: 三大框架\n  uuid: AnAUOtoVl35Ctf-m\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: tk3brROhNFOdvu5c\n  child_uuid: d5-PKpnqrDERp5XH\n  sibling_uuid: T6Dd_ALAOey1mOT2\n- type: TITLE\n  title: Vue\n  uuid: d5-PKpnqrDERp5XH\n  url: ''\n  parent_uuid: AnAUOtoVl35Ctf-m\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: AnAUOtoVl35Ctf-m\n  sibling_uuid: 4iLlxHU6lkSzDraZ\n- type: TITLE\n  title: React\n  uuid: 4iLlxHU6lkSzDraZ\n  url: ''\n  parent_uuid: AnAUOtoVl35Ctf-m\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: d5-PKpnqrDERp5XH\n  child_uuid: YWc6qlQILrlxUTHD\n  sibling_uuid: ARWJ2u2tTxx00ebt\n- type: DOC\n  title: React Hooks 的一些特性\n  uuid: YWc6qlQILrlxUTHD\n  url: ydrldx\n  parent_uuid: 4iLlxHU6lkSzDraZ\n  doc_id: 32985727\n  level: 2\n  id: 32985727\n  open_window: 1\n  visible: 1\n  prev_uuid: 4iLlxHU6lkSzDraZ\n  sibling_uuid: ddokQtvYayoQdAz4\n- type: DOC\n  title: 编写 React 组件时常见的 5 个错误\n  uuid: ddokQtvYayoQdAz4\n  url: lscqxu\n  parent_uuid: 4iLlxHU6lkSzDraZ\n  doc_id: 32985721\n  level: 2\n  id: 32985721\n  open_window: 1\n  visible: 1\n  prev_uuid: YWc6qlQILrlxUTHD\n  sibling_uuid: 30Wx9_DYfG0kg9QA\n- type: DOC\n  title: React16 文档\n  uuid: 30Wx9_DYfG0kg9QA\n  url: di9gc4\n  parent_uuid: 4iLlxHU6lkSzDraZ\n  doc_id: 11440297\n  level: 2\n  id: 11440297\n  open_window: 1\n  visible: 1\n  prev_uuid: ddokQtvYayoQdAz4\n  sibling_uuid: aMQJEwPDNep085nZ\n- type: DOC\n  title: React 常见面试题\n  uuid: aMQJEwPDNep085nZ\n  url: qf8r3p\n  parent_uuid: 4iLlxHU6lkSzDraZ\n  doc_id: 68063610\n  level: 2\n  id: 68063610\n  open_window: 0\n  visible: 1\n  prev_uuid: 30Wx9_DYfG0kg9QA\n- type: TITLE\n  title: Angular\n  uuid: ARWJ2u2tTxx00ebt\n  url: ''\n  parent_uuid: AnAUOtoVl35Ctf-m\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: 4iLlxHU6lkSzDraZ\n- type: DOC\n  title: TS\n  uuid: T6Dd_ALAOey1mOT2\n  url: pggx4l\n  parent_uuid: ''\n  doc_id: 70125357\n  level: 0\n  id: 70125357\n  open_window: 0\n  visible: 1\n  prev_uuid: AnAUOtoVl35Ctf-m\n  sibling_uuid: quDnA_CtXFJewZef\n- type: TITLE\n  title: 构建工具\n  uuid: quDnA_CtXFJewZef\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: T6Dd_ALAOey1mOT2\n  child_uuid: ko6UTJnvyRxJxFks\n  sibling_uuid: Nvq-1t47zI5eZ5K2\n- type: TITLE\n  title: Webpack\n  uuid: ko6UTJnvyRxJxFks\n  url: ''\n  parent_uuid: quDnA_CtXFJewZef\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: quDnA_CtXFJewZef\n  sibling_uuid: mF0ZJuTxvQYAlc-6\n- type: TITLE\n  title: Vite\n  uuid: mF0ZJuTxvQYAlc-6\n  url: ''\n  parent_uuid: quDnA_CtXFJewZef\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: ko6UTJnvyRxJxFks\n- type: TITLE\n  title: Node\n  uuid: Nvq-1t47zI5eZ5K2\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: quDnA_CtXFJewZef\n  child_uuid: N9McFxnJzAZ1joGk\n  sibling_uuid: 2ip6Vh79GxkcT9qC\n- type: DOC\n  title: 传统部署\n  uuid: N9McFxnJzAZ1joGk\n  url: gzrbf3\n  parent_uuid: Nvq-1t47zI5eZ5K2\n  doc_id: 11465755\n  level: 1\n  id: 11465755\n  open_window: 1\n  visible: 1\n  prev_uuid: Nvq-1t47zI5eZ5K2\n  sibling_uuid: iav0UTEn9wp9P6wQ\n- type: DOC\n  title: graphql\n  uuid: iav0UTEn9wp9P6wQ\n  url: cnpgks\n  parent_uuid: Nvq-1t47zI5eZ5K2\n  doc_id: 11465980\n  level: 1\n  id: 11465980\n  open_window: 1\n  visible: 1\n  prev_uuid: N9McFxnJzAZ1joGk\n- type: TITLE\n  title: 面试精选文章\n  uuid: 2ip6Vh79GxkcT9qC\n  url: ''\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n  prev_uuid: Nvq-1t47zI5eZ5K2\n  child_uuid: e-Y2Xaz9wC8qUoRT\n- type: DOC\n  title: Css 精选\n  uuid: e-Y2Xaz9wC8qUoRT\n  url: wcrp5i\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69585398\n  level: 1\n  id: 69585398\n  open_window: 0\n  visible: 1\n  prev_uuid: 2ip6Vh79GxkcT9qC\n  sibling_uuid: dKE7-48QzE7EMFuU\n- type: DOC\n  title: Html 精选\n  uuid: dKE7-48QzE7EMFuU\n  url: if2bzn\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69585313\n  level: 1\n  id: 69585313\n  open_window: 0\n  visible: 1\n  prev_uuid: e-Y2Xaz9wC8qUoRT\n  sibling_uuid: DMqan83XPeKFCVOy\n- type: DOC\n  title: JavaScript 精选\n  uuid: DMqan83XPeKFCVOy\n  url: omn9xg\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69584814\n  level: 1\n  id: 69584814\n  open_window: 0\n  visible: 1\n  prev_uuid: dKE7-48QzE7EMFuU\n  sibling_uuid: kuWh1bH6rb88i7up\n- type: DOC\n  title: 计算机网络精选\n  uuid: kuWh1bH6rb88i7up\n  url: uyhudu\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69584083\n  level: 1\n  id: 69584083\n  open_window: 0\n  visible: 1\n  prev_uuid: DMqan83XPeKFCVOy\n  sibling_uuid: MVGimszERfJIqa5_\n- type: DOC\n  title: 操作系统精选\n  uuid: MVGimszERfJIqa5_\n  url: nyvkbg\n  parent_uuid: 2ip6Vh79GxkcT9qC\n  doc_id: 69584018\n  level: 1\n  id: 69584018\n  open_window: 0\n  visible: 1\n  prev_uuid: kuWh1bH6rb88i7up\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 23,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2022-06-15T01:16:19.043Z",
    "created_at": "2022-03-13T09:55:39.000Z",
    "updated_at": "2023-11-11T18:11:38.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-22T20:13:30.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/xxble8",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 960055228,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}