{
  "id": 70125424,
  "slug": "bp0lie",
  "title": "TypeScript 在团队内部的实践总结",
  "description": "TS 的特性JavaScript：解释型脚本语⾔，⽆需额外编译，便可在浏览器等环境中解释执⾏。TypeScript：⾯向对象的编程语⾔，增加了静态类型、接⼝、泛型、类型注解等。通过静态类型检测，更容易编写健壮性强的代码，更适合⼤型项⽬开发。浏览器、Node 等环境⽆法直接运⾏ TypeScri...",
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1647788931569-ff27bf88-cbf2-426b-a218-f9b25d290548.png",
  "user_id": 732231,
  "book_id": 24987782,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"64c6f2f3\"><span class=\"ne-text\">TS 的特性</span></h2><p id=\"u1f4f931d\" class=\"ne-p\"><br></p><p id=\"u231d9f9a\" class=\"ne-p\"><span class=\"ne-text\">JavaScript：</span></p><p id=\"uac543ffd\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u5a6e4b51\"><span class=\"ne-text\">解释型脚本语⾔，⽆需额外编译，便可在浏览器等环境中解释执⾏。</span></li></ul><p id=\"ubffcc6f8\" class=\"ne-p\"><br></p><p id=\"ua3a45538\" class=\"ne-p\"><span class=\"ne-text\">TypeScript：</span></p><p id=\"u9586cecd\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ufe489996\"><span class=\"ne-text\">⾯向对象的编程语⾔，增加了静态类型、接⼝、泛型、类型注解等。</span></li><li id=\"u94b9ac9c\"><span class=\"ne-text\">通过静态类型检测，更容易编写健壮性强的代码，更适合⼤型项⽬开发。</span></li></ul><ul class=\"ne-ul\"><li id=\"u0db4971c\"><span class=\"ne-text\">浏览器、Node 等环境⽆法直接运⾏ TypeScript，需编译成 JavaScript 后运⾏。</span></li></ul><p id=\"ubeb2551e\" class=\"ne-p\"><br></p><h2 id=\"52b8c184\"><span class=\"ne-text\">优点</span></h2><p id=\"uc5fff112\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u8a38418e\"><span class=\"ne-text\">丰富的类型系统：基本类型、接口、类、函数、泛型、枚举......</span></li><li id=\"u1fcce0cf\"><span class=\"ne-text\">强大的类型推导能力：支持类型推导，命名空间和模块，装饰器等特性</span></li></ul><ul class=\"ne-ul\"><li id=\"u7ee08a3c\"><span class=\"ne-text\">完善的生态支持：tsc/bable 编译器、IDE、eslint、</span><a href=\"/types \" data-href=\"/types \" class=\"ne-link\"><span class=\"ne-text\">@types </span></a><span class=\"ne-text\"> </span></li></ul><p id=\"ue4558ce4\" class=\"ne-p\"><br></p><h2 id=\"a38829fa\"><span class=\"ne-text\">前后端通信之痛</span></h2><p id=\"ubffacf83\" class=\"ne-p\"><br></p><p id=\"ua902d84e\" class=\"ne-p\"><span class=\"ne-text\">我之前所在的部门，一个化妆品电商品牌前端团队，N 个前端，M 个品牌，2N 个后端，总共几百人，几乎每天都在不停的开发、联调中，电商业务需求多、迭代块、细节多，一款品牌电商经过历史迭代、多⼈多团队维护，存在代码结构混乱、逻辑耦合极⾼，单⼀⽂件动辄上千⾏，代码可读性、可维护性均较差；基于 JavaScript 设计的数据结构、数据传递等⾮常复杂，导致线上⼩问题层出不穷，排查修复成本⾼；另外还有是由于每个研发同事的水平、代码风格、做事风格的不同，也难以保持 API 和字段单词的规范和统一，更别说所有开发人员保证实时更新 API 文档了。</span></p><p id=\"u9bba4f47\" class=\"ne-p\"><br></p><h3 id=\"2372b182\"><span class=\"ne-text\">⽬标</span></h3><p id=\"u8beb7b5d\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"uc2b05d94\"><span class=\"ne-text\">项目太大，在长期的迭代中，代码风格不同，组件、函数升级，参数不兼容</span></li><li id=\"u6863c8be\"><span class=\"ne-text\">前后端接口字段不一致等</span></li></ul><ul class=\"ne-ul\"><li id=\"ude0ee1ae\"><span class=\"ne-text\">接口文档与代码不一致等</span></li></ul><p id=\"u0a326c13\" class=\"ne-p\"><br></p><p id=\"u08f80b19\" class=\"ne-p\"><span class=\"ne-text\">基于以上一些项目维护中的痛点，决定想要实现通过对项⽬代码的基础能⼒、业务逻辑⼩步快跑式的拆解，降低项⽬代码的复杂度，并形成团队内⼀致的⼯程规范、编码规范等，提升项⽬代码的可读性、可维护性。</span></p><p id=\"u77c09ddc\" class=\"ne-p\"><br></p><p id=\"u16a1c8e9\" class=\"ne-p\"><span class=\"ne-text\">通过 TypeScript 等相关技术栈引⼊，梳理并重构业务代码数据结构、数据传递等逻辑，通过静态类型校验，增加编译时排雷的概率，降低运⾏时出错的⻛险。</span></p><p id=\"ue35711a3\" class=\"ne-p\"><br></p><p id=\"uc35516cb\" class=\"ne-p\"><span class=\"ne-text\">维持项⽬技术新度，偿还历史项⽬的技术债务，提升团队同学的技术热情与技术能⼒。</span></p><p id=\"ud972bc9c\" class=\"ne-p\"><br></p><h2 id=\"f47adc3a\"><span class=\"ne-text\">TS 在欧莱雅电商业务中的迁移实践</span></h2><p id=\"uc319a88f\" class=\"ne-p\"><br></p><h3 id=\"74c68b51\"><span class=\"ne-text\">迁移原则</span></h3><p id=\"u57f3e2d8\" class=\"ne-p\"><br></p><p id=\"ub1212190\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647788931569-ff27bf88-cbf2-426b-a218-f9b25d290548.png#clientId=u6a6385bd-ca73-4&amp;from=paste&amp;height=270&amp;id=u3eee2473&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=484&amp;originalType=binary&amp;ratio=1&amp;size=63816&amp;status=done&amp;style=none&amp;taskId=u65812ddd-3999-4c5f-84a9-93021fb40e6&amp;width=484\" width=\"484\" id=\"dQ99P\" class=\"ne-image\"></p><p id=\"u4c3d7dcb\" class=\"ne-p\"><br></p><h3 id=\"0f6433a9\"><span class=\"ne-text\">实践⽅案</span></h3><p id=\"u00c42677\" class=\"ne-p\"><br></p><p id=\"ufa1b3568\" class=\"ne-p\"><span class=\"ne-text\">Monorepo (pnpm + TypeScript) + esbuild + Changesets</span></p><p id=\"ufef39691\" class=\"ne-p\"><br></p><h3 id=\"83527ca9\"><span class=\"ne-text\">⽅案设计说明</span></h3><p id=\"u436ca123\" class=\"ne-p\"><br></p><p id=\"uab40c7bb\" class=\"ne-p\"><span class=\"ne-text\">以小程序为例，考虑到电商务的代码体量及复杂性，比如兰蔻、YSL、娇兰等电商小程序至少 100+页面，妄图一个小程序一个主包吞下整个电商全流程不太现实。所以，我们采取的⽅案是按照功能属性拆分代码并渐进式改造升级。第⼀步，我们对项⽬中&quot;基础能⼒&quot;部分拆分；第⼆步，我们对项⽬中&quot;业务逻辑&quot;与&quot;视图渲染&quot;拆分。</span></p><p id=\"ubd941245\" class=\"ne-p\"><br></p><p id=\"ua4ff4850\" class=\"ne-p\"><span class=\"ne-text\">基础能⼒部分，独⽴功能模块众多，因此采⽤ Monorepo 模式整合。出于构建速度的考量，对 TypeScript 的 Dev 环境与 Prod 环境构建使⽤ Vite/webpack + esbuild (团队种老的电商多租户平台还是在用 Vue2 + elementui，新电商后台已全面改用 vite + Vue3/React)。基础能⼒部分，功能相对独⽴、业务属性弱，在渐进式改造升级的过程中以依赖包的形式集成⼊原⼯程，所以使⽤轻量化、社区活跃度⾼的 Changesets 来迭代维护依赖包更新。</span></p><p id=\"uc47a3d60\" class=\"ne-p\"><br></p><h3 id=\"0f6433a9-1\"><span class=\"ne-text\">实践⽅案</span></h3><p id=\"ub88baeab\" class=\"ne-p\"><br></p><p id=\"ue725d370\" class=\"ne-p\"><span class=\"ne-text\">在 toB 的 PC 端项目方面，⼯程结构：</span></p><p id=\"u6f785e30\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"b560c78d\" class=\"ne-codeblock language-typescript\"> .changeset                 -- 基础库版本管理配置\n dist                       -- 基础库production产物\n packages\n    - loreal-sign           -- 商城登录基础库\n    - loreal-ec             -- EC电商通用基础库\n    - loreal-axios          -- 二次封装ec请求库\n    - loreal-trace          -- 电商埋点SDK及其工具\n    - loreal-utils          -- EC电商工具链\n pnpm-workspace.yaml        --\n tsconfig.json              -- dev模式 TypeScritp配置文件\n tsconfig.type-check.json   -- tsc模式 TypeScript配置文件，用于prod模式构建时做并行类型检查\n vite.config.ts             -- vite dev模式配置文件\n vite.prod-config.ts        -- vite prod模式配置文件</pre><p id=\"ubbff69cb\" class=\"ne-p\"><br></p><p id=\"u2c3868de\" class=\"ne-p\"><span class=\"ne-text\">在 toC 的小程序端项目方面，⼯程结构：</span></p><p id=\"ud33599c9\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"49fb4343\" class=\"ne-codeblock language-typescript\">  miniprogram\n    - api                   -- API治理中心\n    - assets                -- 静态资源\n    - components            -- loreal电商组件\n    - config                -- 与APPID有关的配置信息\n    - packages              -- 分包\n    - pages                 -- 主包\n    - plugins               -- 插件\n    - utils                 -- 工具函数，包括wxs\n  model\n    - api                   -- api接口的types文件、插件的types\n    index.d.ts\n  node_modules\n  typings\n    - types                 -- 微信自身api的一些types\n    index.d.ts\n- package.json\n- project.config.json\n- project.private.config.json\n- tsconfig.json</pre><p id=\"ue46140cc\" class=\"ne-p\"><br></p><h2 id=\"eaebb74e\"><span class=\"ne-text\">TS 迁移过程中的踩坑记录</span></h2><p id=\"u74159bc4\" class=\"ne-p\"><br></p><h3 id=\"161c52fb\"><span class=\"ne-text\">1. 对于 toB 的项目，Vite 对库模式开发⽀持不友好</span></h3><p id=\"u738e8c3d\" class=\"ne-p\"><br></p><p id=\"u699c18a8\" class=\"ne-p\"><span class=\"ne-text\">踩坑：Vite 新⽣事物，虽说迭代挺快，但不⾜也挺明显。如，Vite 对多⻚应⽤构建配置友好， 但对 Monorepo 库模式配置能⼒不⾜，需要编程式（Vite -&gt; build()）解决构建需求。</span></p><p id=\"ue3687ba3\" class=\"ne-p\"><br></p><h3 id=\"20b26e2f\"><span class=\"ne-text\">2. esbuild ⽆类型检查能⼒及声明⽂件⽣成能⼒</span></h3><p id=\"ucf410652\" class=\"ne-p\"><br></p><p id=\"u3b1f22f9\" class=\"ne-p\"><span class=\"ne-text\">踩坑：选择 Vite 很⼤⼀部分因素是它使⽤ esbuild 做构建，且 esbuild 内置了 TypeScript 编译能⼒， 但 esbuild 不提供类型检查与声明⽂件⽣成。所以，最终的⽅案是，ESBuild 构建同时使⽤ TSC 编译器并⾏的完成类型检查与声明⽂件⽣成。</span></p><p id=\"u9017b81e\" class=\"ne-p\"><br></p><h3 id=\"f634ebdd\"><span class=\"ne-text\">3. TSConfig 配置⽂件⾃定义问题</span></h3><p id=\"u58758c69\" class=\"ne-p\"><br></p><p id=\"uf631a584\" class=\"ne-p\"><span class=\"ne-text\">踩坑：仅 Prod 模式就需要 2 个 TS 配置⽂件。TSC 命令⽐较⽅便指定，但 Vite 暴露的 build 函数（执⾏ esbuild 构建）基本⽆说明⽂档。撸 Vite 源码找⾃定义配置⽅式，再结合 esbuild 官⽅⽂档</span></p><p id=\"u08956398\" class=\"ne-p\"><br></p><h2 id=\"5b099d89\"><span class=\"ne-text\">TS 代码迁移技巧</span></h2><p id=\"ucd1dfc59\" class=\"ne-p\"><br></p><h3 id=\"5b2bd130\"><span class=\"ne-text\">1.不使用 TS 提供的语法糖（除非已经纳入了 ECMAScript 标准）</span></h3><p id=\"u3cca425d\" class=\"ne-p\"><br></p><p id=\"u19142cbf\" class=\"ne-p\"><span class=\"ne-text\">enum、重载、 public, privaete, protected, readonly 修饰符、方法装饰器，访问器装饰器，属性装饰器等</span></p><p id=\"u6c0faad6\" class=\"ne-p\"><br></p><h3 id=\"a163a782\"><span class=\"ne-text\">2.定义类型时尽量使用交叉类型（不使用 extends），Utility 定义 Types</span></h3><p id=\"ud321068c\" class=\"ne-p\"><br></p><p id=\"uca07c877\" class=\"ne-p\"><span class=\"ne-text\">交叉类型和 Mixins 有一点区别：交叉类型只是一个类型声明，用于类型约束；Mixins 会给类增加成员，new 对象时，对象会包含增加的成员属性。 同时 TS 在全局内置了很多 Utility Types,可以极大的提高我们开发效率。</span></p><p id=\"u01ebd9b3\" class=\"ne-p\"><br></p><h3 id=\"e44e7faa\"><span class=\"ne-text\">3.公共类型放在 src/types 或者 types 下，方便以后统一处理</span></h3><p id=\"u4e5a6f5d\" class=\"ne-p\"><br></p><p id=\"uc5f5fce9\" class=\"ne-p\"><span class=\"ne-text\">在日常开发中可能会经常用到 webpack 的路径别名，比如: import xxx from '@/path/to/name'，如果编辑器不做任何配置的话，编译器不会给任何路径提示，更不会给你语法提示。这里有个小技巧，基于 tsconfig.json 的 baseUrl 和 paths 这两个字段，配置好这两个字段后，.ts 文件里不但有了路径提示，还会跟踪到该路径进行语法提示。<br /></span><span class=\"ne-text\">如果把 tsconfig.json 重命名成 jsconfig.json，.js 文件里也可以享受到路径别名提示和语法提示。</span></p><p id=\"u3aba1f03\" class=\"ne-p\"><br></p><div data-type=\"info\" class=\"ne-alert\"><p id=\"u9bb95f6c\" class=\"ne-p\"><span class=\"ne-text\">如果把 tsconfig.json 重命名成 jsconfig.json，.js 文件里也可以享受到路径别名提示和语法提示。</span></p></div><p id=\"u985dded5\" class=\"ne-p\"><br></p><h3 id=\"f0b6dbea\"><span class=\"ne-text\">4.需要时才定义类型，尽量使用类型推断，非复用（简单）类型使用字面量定义</span></h3><p id=\"u6855cdd1\" class=\"ne-p\"><br></p><p id=\"u59e007b8\" class=\"ne-p\"><span class=\"ne-text\">在 ts 中，代码实现中的 typeof 关键词能够帮助 ts 判断出变量的基本类型:</span></p><p id=\"u29b7d101\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"4a9ecb26\" class=\"ne-codeblock language-typescript\">function fn(x: string | number) {\n    if (typeof x === &quot;string&quot;) {\n        // x is string\n        return x.length\n    } else {\n        // x is number\n        // .....\n    }\n}</pre><p id=\"uf4a566d6\" class=\"ne-p\"><br></p><p id=\"u5e851854\" class=\"ne-p\"><span class=\"ne-text\">instanceof 关键词能够帮助 ts 判断出构造函数的类型;在条件判断中，ts 会自动对 null 和 undefined 进行类型保护,如果我们已经知道的参数不为空，可以使用 ! 来手动标记.</span></p><p id=\"ua2fb7c75\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"11263a98\" class=\"ne-codeblock language-typescript\">function fn2(x?: string) {\n    return x!.length\n}</pre><p id=\"ub4f2702f\" class=\"ne-p\"><br></p><h3 id=\"853984fd\"><span class=\"ne-text\">5.暂时不能解决的使用 TsFixme &amp; </span><a href=\"/ts-ignore \" data-href=\"/ts-ignore \" class=\"ne-link\"><span class=\"ne-text\">@ts-ignore </span></a><span class=\"ne-text\"> </span></h3><p id=\"ub84723af\" class=\"ne-p\"><br></p><p id=\"u70b1bc4a\" class=\"ne-p\"><span class=\"ne-text\">在开发过程中，我们都会不时地写一些 // TODO: 和 // FIXME: 注释。有时我们这样做是因为我们知道代码可以做得更好，但暂时不确定如何做，有时由于 deadline 而没有时间编写最佳解决方案，而有时我们只是想着手处理更紧急的事情，这时我们只需在代码中标识一个 // TODO: or // FIXME 提示自己以便在将来某一天再处理。</span></p><p id=\"u1f630fbf\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"82a7ccd3\" class=\"ne-codeblock language-typescript\">/**\n * 手动获取用户在天猫旗舰店的会员等级和积分\n * @returns {any | *} 返回会员等级和积分; FIXME: 此处类型较为复杂，先用 any 代替，有空再补\n */</pre><p id=\"u79195e21\" class=\"ne-p\"><br></p><h2 id=\"91fa4fd0\"><span class=\"ne-text\">TS 迁移流程</span></h2><p id=\"u82ed7786\" class=\"ne-p\"><br></p><h3 id=\"f2faa7eb\"><span class=\"ne-text\">1.先培训</span></h3><p id=\"u13f95e7a\" class=\"ne-p\"><br></p><p id=\"u332bc316\" class=\"ne-p\"><span class=\"ne-text\">因为一些常用的 JS 写法，在 TS 里面需要稍微变通一下才能使用，比如我们常用的 promise.all 这种方法，在 TypeScript 中，当你这么用 Promise.all 时，会遇到类型检查错误的问题。</span></p><p id=\"ua204e968\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"b87447bc\" class=\"ne-codeblock language-typescript\">Promise.all(Promise &lt; XX &gt; [])</pre><p id=\"u9345c067\" class=\"ne-p\"><br></p><p id=\"ub778ba44\" class=\"ne-p\"><span class=\"ne-text\">因为 lib.es6.d.ts 中，对 Promise.all 这么定义</span></p><p id=\"uf49688ca\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"622135c3\" class=\"ne-codeblock language-typescript\">all&lt;TAll&gt;(values: Iterable&lt;TAll | PromiseLike&lt;TAll&gt;&gt;): Promise&lt;TAll[]&gt;;</pre><p id=\"u3067a8b7\" class=\"ne-p\"><br></p><p id=\"u610fe3ea\" class=\"ne-p\"><span class=\"ne-text\">所以，对上述案例，TAll 被自动识别为了 Promise；而实际上，TAll 应该是 XX。 该定义文件的 PromiseLike 跟 Promise 似乎没什么关系，所以没能自动识别。 所以使用时，如果 Promise.all 传入的是一个数组，那么建议的用法是强制制定类型，如下。</span></p><p id=\"u79d42685\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"c40b2ec7\" class=\"ne-codeblock language-typescript\">Promise.all&lt;XX&gt;(Promise &lt; XX &gt; [])</pre><p id=\"ud834be71\" class=\"ne-p\"><br></p><p id=\"ubc509b88\" class=\"ne-p\"><span class=\"ne-text\">又比如：解决 ts-node 中使用 symlinks 时引用 node_modules 报错的问题 preserveSymlinks 在 TypeScripts 中默认为 true 而在 NodeJS 中默认为 false</span></p><p id=\"u5471aa5e\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"2f413a47\" class=\"ne-codeblock language-typescript\">ts-node --preserve-symlinks index.ts</pre><p id=\"u433a9a1d\" class=\"ne-p\"><br></p><h3 id=\"715c7290\"><span class=\"ne-text\">2.项目种常用类型补全，建立标准，服务于全体应用</span></h3><p id=\"ueb4223c5\" class=\"ne-p\"><br></p><p id=\"u25a3fa03\" class=\"ne-p\"><span class=\"ne-text\">前后端共享代码和类型定义，全程代码提示和类型报错</span></p><p id=\"ufb1c4ee6\" class=\"ne-p\"><br></p><h3 id=\"9855570a\"><span class=\"ne-text\">3.小范围试验，确保转换过程简单、安全和自动化</span></h3><p id=\"u554851a3\" class=\"ne-p\"><br></p><p id=\"u5b26c3cd\" class=\"ne-p\"><span class=\"ne-text\">先在欧莱雅、兰蔻、薇姿项目中重构改造，在一些重要电商里先行试水，随后在整个电商事业群里推广。改造的范围包括但不限于：</span></p><p id=\"u9662bedd\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u22ee8272\"><span class=\"ne-text\">core utils 迁移</span></li><li id=\"u31a72a29\"><span class=\"ne-text\">选取核心文件进行迁移</span></li></ol><p id=\"u68e3c853\" class=\"ne-p\"><br></p><h3 id=\"e87638f2\"><span class=\"ne-text\">4.总结试验结果并优化</span></h3><p id=\"u832c8636\" class=\"ne-p\"><br></p><p id=\"u3951cf02\" class=\"ne-p\"><span class=\"ne-text\">为了减轻这种风险，我们需要一个规范的流程来转换文件，其不会引入回归，也不会诱导工程师去做多余的事情。这个流程还要能快速执行。</span></p><p id=\"u3bb6be4f\" class=\"ne-p\"><br></p><p id=\"uca941e8a\" class=\"ne-p\"><span class=\"ne-text\">我们确定了一个分为两部分的流程：首先自动转换 CoffeeScript 文件，然后立即手动添加基本类型注解和与 linter 相关的更改。关键在于抵制（不管是什么方式）重构代码的诱惑。这样一来，转换工作就成为了简单、遵循安全规则的机械活动，不会影响运行时行为。</span></p><p id=\"ub4e2f655\" class=\"ne-p\"><br></p><h3 id=\"ffd31892\"><span class=\"ne-text\">5.大范围推广</span></h3><p id=\"ubdfead3f\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"ua42b1bfd\"><span class=\"ne-text\">新页面新文件、工具函数必须使用 ts，老文件修改超过 40% 需用 ts 重写</span></li><li id=\"uebee08e1\"><span class=\"ne-text\">使用 snippet 模板</span></li></ol><ol start=\"3\" class=\"ne-ol\"><li id=\"u3f3787c3\"><span class=\"ne-text\">code review</span></li></ol><p id=\"u5f1aecc0\" class=\"ne-p\"><br></p><h2 id=\"c22810c9\"><span class=\"ne-text\">收益&amp;总结</span></h2><p id=\"u7e2b4dda\" class=\"ne-p\"><br></p><h3 id=\"25c14cba\"><span class=\"ne-text\">收益：开发体验必须明显改善</span></h3><p id=\"u75378ac1\" class=\"ne-p\"><br></p><p id=\"u00320dbf\" class=\"ne-p\"><span class=\"ne-text\">要让整个团队都参与进来，必须让开发人员体会到，他们在编写 TypeScript 时会更有效率。如果团队只是将迁移看作是从一种语法换成另一种差不多的语法，他们永远都不会产生认同感。如果迁移之后他们的日常工作效率并没有提升，那么就算工程师们往往更喜欢编写类型化代码，也敌不过旧习惯的巨大惯性。</span></p><p id=\"u56bfbe11\" class=\"ne-p\"><br></p><p id=\"u752015a6\" class=\"ne-p\"><span class=\"ne-text\">将工具链和配置作为优先事项来对待。大多数开发人员使用的编辑器就是那么几种而已，因此我们创建了可以直接使用的编辑器配置，添加了调试配置，从而可以轻松设置断点和单步执行代码。</span></p><p id=\"u8bb64fdf\" class=\"ne-p\"><br></p><p id=\"u117bee71\" class=\"ne-p\"><span class=\"ne-text\">最后，我们整理了一套取得共识的 linting 规则，这些规则使我们能够在整个组织中以统一的样式编写代码，并让开发人员对迁移行动更加满意。</span></p><p id=\"u54d906ce\" class=\"ne-p\"><br></p><p id=\"u6300b368\" class=\"ne-p\"><span class=\"ne-text\">当团队开始看到这些转换工作的成果时，整个项目也就得到了认可，前进动力也会更足了。当我们的工程师开始将类型化数据访问视为必不可少的工具后，他们就能更好地意识到，代码库的其它部分也会平稳地转换完毕。</span></p><p id=\"u559e422f\" class=\"ne-p\"><br></p><h3 id=\"25f9c7fa\"><span class=\"ne-text\">总结</span></h3><p id=\"u8c996528\" class=\"ne-p\"><br></p><p id=\"u2699c81d\" class=\"ne-p\"><span class=\"ne-text\">⽬前，电商业务渐进式改造升级，第⼀部分“基础能⼒”的拆分进⼊尾声，初步拆分出“账号登录”、“⽹络请求”、“数据埋点”等模块。通过“基础能⼒”模块的拆分，降低了原有代码的冗余度，使相关功能模块的逻辑清晰化、内聚化，可维护性增强；通过 TypeScript 语⾔的使⽤，使复杂的数据结构类型化、规范化，能更好的应对业务体量的增⻓，提升产品运⾏时的稳定性；同时，新的技术栈及技术⽅案的引⼊，切实提升了团队同学的技术能⼒，营造了团队良好的技术氛围。</span></p><p id=\"ud80f5563\" class=\"ne-p\"><br></p><p id=\"u60ddbd8b\" class=\"ne-p\"><span class=\"ne-text\">全面拥抱 Typescript，不仅仅是增加了类型，而是编程方式的转变。</span></p><p id=\"ud6085e47\" class=\"ne-p\"><br></p><p id=\"ude827336\" class=\"ne-p\"><span class=\"ne-text\">变量 =&gt; 类型 =&gt; 结构</span></p><p id=\"ue1bf901d\" class=\"ne-p\"><br></p><p id=\"u62db9c5f\" class=\"ne-p\"><span class=\"ne-text\">面向过程 =&gt; 面向接口</span></p></div>",
  "body": "<a name=\"64c6f2f3\"></a>\n## TS 的特性\n\nJavaScript：\n\n- 解释型脚本语⾔，⽆需额外编译，便可在浏览器等环境中解释执⾏。\n\nTypeScript：\n\n- ⾯向对象的编程语⾔，增加了静态类型、接⼝、泛型、类型注解等。\n- 通过静态类型检测，更容易编写健壮性强的代码，更适合⼤型项⽬开发。\n- 浏览器、Node 等环境⽆法直接运⾏ TypeScript，需编译成 JavaScript 后运⾏。\n\n<a name=\"52b8c184\"></a>\n## 优点\n\n- 丰富的类型系统：基本类型、接口、类、函数、泛型、枚举......\n- 强大的类型推导能力：支持类型推导，命名空间和模块，装饰器等特性\n- 完善的生态支持：tsc/bable 编译器、IDE、eslint、[@types ](/types ) \n\n<a name=\"a38829fa\"></a>\n## 前后端通信之痛\n\n我之前所在的部门，一个化妆品电商品牌前端团队，N 个前端，M 个品牌，2N 个后端，总共几百人，几乎每天都在不停的开发、联调中，电商业务需求多、迭代块、细节多，一款品牌电商经过历史迭代、多⼈多团队维护，存在代码结构混乱、逻辑耦合极⾼，单⼀⽂件动辄上千⾏，代码可读性、可维护性均较差；基于 JavaScript 设计的数据结构、数据传递等⾮常复杂，导致线上⼩问题层出不穷，排查修复成本⾼；另外还有是由于每个研发同事的水平、代码风格、做事风格的不同，也难以保持 API 和字段单词的规范和统一，更别说所有开发人员保证实时更新 API 文档了。\n\n<a name=\"2372b182\"></a>\n### ⽬标\n\n- 项目太大，在长期的迭代中，代码风格不同，组件、函数升级，参数不兼容\n- 前后端接口字段不一致等\n- 接口文档与代码不一致等\n\n基于以上一些项目维护中的痛点，决定想要实现通过对项⽬代码的基础能⼒、业务逻辑⼩步快跑式的拆解，降低项⽬代码的复杂度，并形成团队内⼀致的⼯程规范、编码规范等，提升项⽬代码的可读性、可维护性。\n\n通过 TypeScript 等相关技术栈引⼊，梳理并重构业务代码数据结构、数据传递等逻辑，通过静态类型校验，增加编译时排雷的概率，降低运⾏时出错的⻛险。\n\n维持项⽬技术新度，偿还历史项⽬的技术债务，提升团队同学的技术热情与技术能⼒。\n\n<a name=\"f47adc3a\"></a>\n## TS 在欧莱雅电商业务中的迁移实践\n\n<a name=\"74c68b51\"></a>\n### 迁移原则\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1647788931569-ff27bf88-cbf2-426b-a218-f9b25d290548.png#clientId=u6a6385bd-ca73-4&from=paste&height=270&id=u3eee2473&margin=%5Bobject%20Object%5D&name=image.png&originHeight=270&originWidth=484&originalType=binary&ratio=1&size=63816&status=done&style=none&taskId=u65812ddd-3999-4c5f-84a9-93021fb40e6&width=484#id=dQ99P&originHeight=270&originWidth=484&originalType=binary&ratio=1&status=done&style=none)\n\n<a name=\"0f6433a9\"></a>\n### 实践⽅案\n\nMonorepo (pnpm + TypeScript) + esbuild + Changesets\n\n<a name=\"83527ca9\"></a>\n### ⽅案设计说明\n\n以小程序为例，考虑到电商务的代码体量及复杂性，比如兰蔻、YSL、娇兰等电商小程序至少 100+页面，妄图一个小程序一个主包吞下整个电商全流程不太现实。所以，我们采取的⽅案是按照功能属性拆分代码并渐进式改造升级。第⼀步，我们对项⽬中\"基础能⼒\"部分拆分；第⼆步，我们对项⽬中\"业务逻辑\"与\"视图渲染\"拆分。\n\n基础能⼒部分，独⽴功能模块众多，因此采⽤ Monorepo 模式整合。出于构建速度的考量，对 TypeScript 的 Dev 环境与 Prod 环境构建使⽤ Vite/webpack + esbuild (团队种老的电商多租户平台还是在用 Vue2 + elementui，新电商后台已全面改用 vite + Vue3/React)。基础能⼒部分，功能相对独⽴、业务属性弱，在渐进式改造升级的过程中以依赖包的形式集成⼊原⼯程，所以使⽤轻量化、社区活跃度⾼的 Changesets 来迭代维护依赖包更新。\n\n<a name=\"0f6433a9-1\"></a>\n### 实践⽅案\n\n在 toB 的 PC 端项目方面，⼯程结构：\n\n```typescript\n .changeset                 -- 基础库版本管理配置\n dist                       -- 基础库production产物\n packages\n    - loreal-sign           -- 商城登录基础库\n    - loreal-ec             -- EC电商通用基础库\n    - loreal-axios          -- 二次封装ec请求库\n    - loreal-trace          -- 电商埋点SDK及其工具\n    - loreal-utils          -- EC电商工具链\n pnpm-workspace.yaml        --\n tsconfig.json              -- dev模式 TypeScritp配置文件\n tsconfig.type-check.json   -- tsc模式 TypeScript配置文件，用于prod模式构建时做并行类型检查\n vite.config.ts             -- vite dev模式配置文件\n vite.prod-config.ts        -- vite prod模式配置文件\n```\n\n在 toC 的小程序端项目方面，⼯程结构：\n\n```typescript\n  miniprogram\n    - api                   -- API治理中心\n    - assets                -- 静态资源\n    - components            -- loreal电商组件\n    - config                -- 与APPID有关的配置信息\n    - packages              -- 分包\n    - pages                 -- 主包\n    - plugins               -- 插件\n    - utils                 -- 工具函数，包括wxs\n  model\n    - api                   -- api接口的types文件、插件的types\n    index.d.ts\n  node_modules\n  typings\n    - types                 -- 微信自身api的一些types\n    index.d.ts\n- package.json\n- project.config.json\n- project.private.config.json\n- tsconfig.json\n```\n\n<a name=\"eaebb74e\"></a>\n## TS 迁移过程中的踩坑记录\n\n<a name=\"161c52fb\"></a>\n### 1. 对于 toB 的项目，Vite 对库模式开发⽀持不友好\n\n踩坑：Vite 新⽣事物，虽说迭代挺快，但不⾜也挺明显。如，Vite 对多⻚应⽤构建配置友好， 但对 Monorepo 库模式配置能⼒不⾜，需要编程式（Vite -> build()）解决构建需求。\n\n<a name=\"20b26e2f\"></a>\n### 2. esbuild ⽆类型检查能⼒及声明⽂件⽣成能⼒\n\n踩坑：选择 Vite 很⼤⼀部分因素是它使⽤ esbuild 做构建，且 esbuild 内置了 TypeScript 编译能⼒， 但 esbuild 不提供类型检查与声明⽂件⽣成。所以，最终的⽅案是，ESBuild 构建同时使⽤ TSC 编译器并⾏的完成类型检查与声明⽂件⽣成。\n\n<a name=\"f634ebdd\"></a>\n### 3. TSConfig 配置⽂件⾃定义问题\n\n踩坑：仅 Prod 模式就需要 2 个 TS 配置⽂件。TSC 命令⽐较⽅便指定，但 Vite 暴露的 build 函数（执⾏ esbuild 构建）基本⽆说明⽂档。撸 Vite 源码找⾃定义配置⽅式，再结合 esbuild 官⽅⽂档\n\n<a name=\"5b099d89\"></a>\n## TS 代码迁移技巧\n\n<a name=\"5b2bd130\"></a>\n### 1.不使用 TS 提供的语法糖（除非已经纳入了 ECMAScript 标准）\n\nenum、重载、 public, privaete, protected, readonly 修饰符、方法装饰器，访问器装饰器，属性装饰器等\n\n<a name=\"a163a782\"></a>\n### 2.定义类型时尽量使用交叉类型（不使用 extends），Utility 定义 Types\n\n交叉类型和 Mixins 有一点区别：交叉类型只是一个类型声明，用于类型约束；Mixins 会给类增加成员，new 对象时，对象会包含增加的成员属性。 同时 TS 在全局内置了很多 Utility Types,可以极大的提高我们开发效率。\n\n<a name=\"e44e7faa\"></a>\n### 3.公共类型放在 src/types 或者 types 下，方便以后统一处理\n\n在日常开发中可能会经常用到 webpack 的路径别名，比如: import xxx from '@/path/to/name'，如果编辑器不做任何配置的话，编译器不会给任何路径提示，更不会给你语法提示。这里有个小技巧，基于 tsconfig.json 的 baseUrl 和 paths 这两个字段，配置好这两个字段后，.ts 文件里不但有了路径提示，还会跟踪到该路径进行语法提示。<br />如果把 tsconfig.json 重命名成 jsconfig.json，.js 文件里也可以享受到路径别名提示和语法提示。\n\n:::info\n如果把 tsconfig.json 重命名成 jsconfig.json，.js 文件里也可以享受到路径别名提示和语法提示。\n:::\n\n<a name=\"f0b6dbea\"></a>\n### 4.需要时才定义类型，尽量使用类型推断，非复用（简单）类型使用字面量定义\n\n在 ts 中，代码实现中的 typeof 关键词能够帮助 ts 判断出变量的基本类型:\n\n```typescript\nfunction fn(x: string | number) {\n    if (typeof x === \"string\") {\n        // x is string\n        return x.length\n    } else {\n        // x is number\n        // .....\n    }\n}\n```\n\ninstanceof 关键词能够帮助 ts 判断出构造函数的类型;在条件判断中，ts 会自动对 null 和 undefined 进行类型保护,如果我们已经知道的参数不为空，可以使用 ! 来手动标记.\n\n```typescript\nfunction fn2(x?: string) {\n    return x!.length\n}\n```\n\n<a name=\"853984fd\"></a>\n### 5.暂时不能解决的使用 TsFixme & [@ts-ignore ](/ts-ignore ) \n\n在开发过程中，我们都会不时地写一些 // TODO: 和 // FIXME: 注释。有时我们这样做是因为我们知道代码可以做得更好，但暂时不确定如何做，有时由于 deadline 而没有时间编写最佳解决方案，而有时我们只是想着手处理更紧急的事情，这时我们只需在代码中标识一个 // TODO: or // FIXME 提示自己以便在将来某一天再处理。\n\n```typescript\n/**\n * 手动获取用户在天猫旗舰店的会员等级和积分\n * @returns {any | *} 返回会员等级和积分; FIXME: 此处类型较为复杂，先用 any 代替，有空再补\n */\n```\n\n<a name=\"91fa4fd0\"></a>\n## TS 迁移流程\n\n<a name=\"f2faa7eb\"></a>\n### 1.先培训\n\n因为一些常用的 JS 写法，在 TS 里面需要稍微变通一下才能使用，比如我们常用的 promise.all 这种方法，在 TypeScript 中，当你这么用 Promise.all 时，会遇到类型检查错误的问题。\n\n```typescript\nPromise.all(Promise < XX > [])\n```\n\n因为 lib.es6.d.ts 中，对 Promise.all 这么定义\n\n```typescript\nall<TAll>(values: Iterable<TAll | PromiseLike<TAll>>): Promise<TAll[]>;\n```\n\n所以，对上述案例，TAll 被自动识别为了 Promise；而实际上，TAll 应该是 XX。 该定义文件的 PromiseLike 跟 Promise 似乎没什么关系，所以没能自动识别。 所以使用时，如果 Promise.all 传入的是一个数组，那么建议的用法是强制制定类型，如下。\n\n```typescript\nPromise.all<XX>(Promise < XX > [])\n```\n\n又比如：解决 ts-node 中使用 symlinks 时引用 node_modules 报错的问题 preserveSymlinks 在 TypeScripts 中默认为 true 而在 NodeJS 中默认为 false\n\n```typescript\nts-node --preserve-symlinks index.ts\n```\n\n<a name=\"715c7290\"></a>\n### 2.项目种常用类型补全，建立标准，服务于全体应用\n\n前后端共享代码和类型定义，全程代码提示和类型报错\n\n<a name=\"9855570a\"></a>\n### 3.小范围试验，确保转换过程简单、安全和自动化\n\n先在欧莱雅、兰蔻、薇姿项目中重构改造，在一些重要电商里先行试水，随后在整个电商事业群里推广。改造的范围包括但不限于：\n\n1. core utils 迁移\n2. 选取核心文件进行迁移\n\n<a name=\"e87638f2\"></a>\n### 4.总结试验结果并优化\n\n为了减轻这种风险，我们需要一个规范的流程来转换文件，其不会引入回归，也不会诱导工程师去做多余的事情。这个流程还要能快速执行。\n\n我们确定了一个分为两部分的流程：首先自动转换 CoffeeScript 文件，然后立即手动添加基本类型注解和与 linter 相关的更改。关键在于抵制（不管是什么方式）重构代码的诱惑。这样一来，转换工作就成为了简单、遵循安全规则的机械活动，不会影响运行时行为。\n\n<a name=\"ffd31892\"></a>\n### 5.大范围推广\n\n1. 新页面新文件、工具函数必须使用 ts，老文件修改超过 40% 需用 ts 重写\n2. 使用 snippet 模板\n3. code review\n\n<a name=\"c22810c9\"></a>\n## 收益&总结\n\n<a name=\"25c14cba\"></a>\n### 收益：开发体验必须明显改善\n\n要让整个团队都参与进来，必须让开发人员体会到，他们在编写 TypeScript 时会更有效率。如果团队只是将迁移看作是从一种语法换成另一种差不多的语法，他们永远都不会产生认同感。如果迁移之后他们的日常工作效率并没有提升，那么就算工程师们往往更喜欢编写类型化代码，也敌不过旧习惯的巨大惯性。\n\n将工具链和配置作为优先事项来对待。大多数开发人员使用的编辑器就是那么几种而已，因此我们创建了可以直接使用的编辑器配置，添加了调试配置，从而可以轻松设置断点和单步执行代码。\n\n最后，我们整理了一套取得共识的 linting 规则，这些规则使我们能够在整个组织中以统一的样式编写代码，并让开发人员对迁移行动更加满意。\n\n当团队开始看到这些转换工作的成果时，整个项目也就得到了认可，前进动力也会更足了。当我们的工程师开始将类型化数据访问视为必不可少的工具后，他们就能更好地意识到，代码库的其它部分也会平稳地转换完毕。\n\n<a name=\"25f9c7fa\"></a>\n### 总结\n\n⽬前，电商业务渐进式改造升级，第⼀部分“基础能⼒”的拆分进⼊尾声，初步拆分出“账号登录”、“⽹络请求”、“数据埋点”等模块。通过“基础能⼒”模块的拆分，降低了原有代码的冗余度，使相关功能模块的逻辑清晰化、内聚化，可维护性增强；通过 TypeScript 语⾔的使⽤，使复杂的数据结构类型化、规范化，能更好的应对业务体量的增⻓，提升产品运⾏时的稳定性；同时，新的技术栈及技术⽅案的引⼊，切实提升了团队同学的技术能⼒，营造了团队良好的技术氛围。\n\n全面拥抱 Typescript，不仅仅是增加了类型，而是编程方式的转变。\n\n变量 => 类型 => 结构\n\n面向过程 => 面向接口\n",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"64c6f2f3\"><span class=\"ne-text\">TS 的特性</span></h2><p id=\"u1f4f931d\" class=\"ne-p\"><br></p><p id=\"u231d9f9a\" class=\"ne-p\"><span class=\"ne-text\">JavaScript：</span></p><p id=\"uac543ffd\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u5a6e4b51\"><span class=\"ne-text\">解释型脚本语⾔，⽆需额外编译，便可在浏览器等环境中解释执⾏。</span></li></ul><p id=\"ubffcc6f8\" class=\"ne-p\"><br></p><p id=\"ua3a45538\" class=\"ne-p\"><span class=\"ne-text\">TypeScript：</span></p><p id=\"u9586cecd\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"ufe489996\"><span class=\"ne-text\">⾯向对象的编程语⾔，增加了静态类型、接⼝、泛型、类型注解等。</span></li><li id=\"u94b9ac9c\"><span class=\"ne-text\">通过静态类型检测，更容易编写健壮性强的代码，更适合⼤型项⽬开发。</span></li></ul><ul class=\"ne-ul\"><li id=\"u0db4971c\"><span class=\"ne-text\">浏览器、Node 等环境⽆法直接运⾏ TypeScript，需编译成 JavaScript 后运⾏。</span></li></ul><p id=\"ubeb2551e\" class=\"ne-p\"><br></p><h2 id=\"52b8c184\"><span class=\"ne-text\">优点</span></h2><p id=\"uc5fff112\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u8a38418e\"><span class=\"ne-text\">丰富的类型系统：基本类型、接口、类、函数、泛型、枚举......</span></li><li id=\"u1fcce0cf\"><span class=\"ne-text\">强大的类型推导能力：支持类型推导，命名空间和模块，装饰器等特性</span></li></ul><ul class=\"ne-ul\"><li id=\"u7ee08a3c\"><span class=\"ne-text\">完善的生态支持：tsc/bable 编译器、IDE、eslint、</span><a href=\"/types \" data-href=\"/types \" class=\"ne-link\"><span class=\"ne-text\">@types </span></a><span class=\"ne-text\"> </span></li></ul><p id=\"ue4558ce4\" class=\"ne-p\"><br></p><h2 id=\"a38829fa\"><span class=\"ne-text\">前后端通信之痛</span></h2><p id=\"ubffacf83\" class=\"ne-p\"><br></p><p id=\"ua902d84e\" class=\"ne-p\"><span class=\"ne-text\">我之前所在的部门，一个化妆品电商品牌前端团队，N 个前端，M 个品牌，2N 个后端，总共几百人，几乎每天都在不停的开发、联调中，电商业务需求多、迭代块、细节多，一款品牌电商经过历史迭代、多⼈多团队维护，存在代码结构混乱、逻辑耦合极⾼，单⼀⽂件动辄上千⾏，代码可读性、可维护性均较差；基于 JavaScript 设计的数据结构、数据传递等⾮常复杂，导致线上⼩问题层出不穷，排查修复成本⾼；另外还有是由于每个研发同事的水平、代码风格、做事风格的不同，也难以保持 API 和字段单词的规范和统一，更别说所有开发人员保证实时更新 API 文档了。</span></p><p id=\"u9bba4f47\" class=\"ne-p\"><br></p><h3 id=\"2372b182\"><span class=\"ne-text\">⽬标</span></h3><p id=\"u8beb7b5d\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"uc2b05d94\"><span class=\"ne-text\">项目太大，在长期的迭代中，代码风格不同，组件、函数升级，参数不兼容</span></li><li id=\"u6863c8be\"><span class=\"ne-text\">前后端接口字段不一致等</span></li></ul><ul class=\"ne-ul\"><li id=\"ude0ee1ae\"><span class=\"ne-text\">接口文档与代码不一致等</span></li></ul><p id=\"u0a326c13\" class=\"ne-p\"><br></p><p id=\"u08f80b19\" class=\"ne-p\"><span class=\"ne-text\">基于以上一些项目维护中的痛点，决定想要实现通过对项⽬代码的基础能⼒、业务逻辑⼩步快跑式的拆解，降低项⽬代码的复杂度，并形成团队内⼀致的⼯程规范、编码规范等，提升项⽬代码的可读性、可维护性。</span></p><p id=\"u77c09ddc\" class=\"ne-p\"><br></p><p id=\"u16a1c8e9\" class=\"ne-p\"><span class=\"ne-text\">通过 TypeScript 等相关技术栈引⼊，梳理并重构业务代码数据结构、数据传递等逻辑，通过静态类型校验，增加编译时排雷的概率，降低运⾏时出错的⻛险。</span></p><p id=\"ue35711a3\" class=\"ne-p\"><br></p><p id=\"uc35516cb\" class=\"ne-p\"><span class=\"ne-text\">维持项⽬技术新度，偿还历史项⽬的技术债务，提升团队同学的技术热情与技术能⼒。</span></p><p id=\"ud972bc9c\" class=\"ne-p\"><br></p><h2 id=\"f47adc3a\"><span class=\"ne-text\">TS 在欧莱雅电商业务中的迁移实践</span></h2><p id=\"uc319a88f\" class=\"ne-p\"><br></p><h3 id=\"74c68b51\"><span class=\"ne-text\">迁移原则</span></h3><p id=\"u57f3e2d8\" class=\"ne-p\"><br></p><p id=\"ub1212190\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1647788931569-ff27bf88-cbf2-426b-a218-f9b25d290548.png#clientId=u6a6385bd-ca73-4&amp;from=paste&amp;height=270&amp;id=u3eee2473&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=484&amp;originalType=binary&amp;ratio=1&amp;size=63816&amp;status=done&amp;style=none&amp;taskId=u65812ddd-3999-4c5f-84a9-93021fb40e6&amp;width=484\" width=\"484\" id=\"dQ99P\" class=\"ne-image\"></p><p id=\"u4c3d7dcb\" class=\"ne-p\"><br></p><h3 id=\"0f6433a9\"><span class=\"ne-text\">实践⽅案</span></h3><p id=\"u00c42677\" class=\"ne-p\"><br></p><p id=\"ufa1b3568\" class=\"ne-p\"><span class=\"ne-text\">Monorepo (pnpm + TypeScript) + esbuild + Changesets</span></p><p id=\"ufef39691\" class=\"ne-p\"><br></p><h3 id=\"83527ca9\"><span class=\"ne-text\">⽅案设计说明</span></h3><p id=\"u436ca123\" class=\"ne-p\"><br></p><p id=\"uab40c7bb\" class=\"ne-p\"><span class=\"ne-text\">以小程序为例，考虑到电商务的代码体量及复杂性，比如兰蔻、YSL、娇兰等电商小程序至少 100+页面，妄图一个小程序一个主包吞下整个电商全流程不太现实。所以，我们采取的⽅案是按照功能属性拆分代码并渐进式改造升级。第⼀步，我们对项⽬中&quot;基础能⼒&quot;部分拆分；第⼆步，我们对项⽬中&quot;业务逻辑&quot;与&quot;视图渲染&quot;拆分。</span></p><p id=\"ubd941245\" class=\"ne-p\"><br></p><p id=\"ua4ff4850\" class=\"ne-p\"><span class=\"ne-text\">基础能⼒部分，独⽴功能模块众多，因此采⽤ Monorepo 模式整合。出于构建速度的考量，对 TypeScript 的 Dev 环境与 Prod 环境构建使⽤ Vite/webpack + esbuild (团队种老的电商多租户平台还是在用 Vue2 + elementui，新电商后台已全面改用 vite + Vue3/React)。基础能⼒部分，功能相对独⽴、业务属性弱，在渐进式改造升级的过程中以依赖包的形式集成⼊原⼯程，所以使⽤轻量化、社区活跃度⾼的 Changesets 来迭代维护依赖包更新。</span></p><p id=\"uc47a3d60\" class=\"ne-p\"><br></p><h3 id=\"0f6433a9-1\"><span class=\"ne-text\">实践⽅案</span></h3><p id=\"ub88baeab\" class=\"ne-p\"><br></p><p id=\"ue725d370\" class=\"ne-p\"><span class=\"ne-text\">在 toB 的 PC 端项目方面，⼯程结构：</span></p><p id=\"u6f785e30\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"b560c78d\" class=\"ne-codeblock language-typescript\"> .changeset                 -- 基础库版本管理配置\n dist                       -- 基础库production产物\n packages\n    - loreal-sign           -- 商城登录基础库\n    - loreal-ec             -- EC电商通用基础库\n    - loreal-axios          -- 二次封装ec请求库\n    - loreal-trace          -- 电商埋点SDK及其工具\n    - loreal-utils          -- EC电商工具链\n pnpm-workspace.yaml        --\n tsconfig.json              -- dev模式 TypeScritp配置文件\n tsconfig.type-check.json   -- tsc模式 TypeScript配置文件，用于prod模式构建时做并行类型检查\n vite.config.ts             -- vite dev模式配置文件\n vite.prod-config.ts        -- vite prod模式配置文件</pre><p id=\"ubbff69cb\" class=\"ne-p\"><br></p><p id=\"u2c3868de\" class=\"ne-p\"><span class=\"ne-text\">在 toC 的小程序端项目方面，⼯程结构：</span></p><p id=\"ud33599c9\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"49fb4343\" class=\"ne-codeblock language-typescript\">  miniprogram\n    - api                   -- API治理中心\n    - assets                -- 静态资源\n    - components            -- loreal电商组件\n    - config                -- 与APPID有关的配置信息\n    - packages              -- 分包\n    - pages                 -- 主包\n    - plugins               -- 插件\n    - utils                 -- 工具函数，包括wxs\n  model\n    - api                   -- api接口的types文件、插件的types\n    index.d.ts\n  node_modules\n  typings\n    - types                 -- 微信自身api的一些types\n    index.d.ts\n- package.json\n- project.config.json\n- project.private.config.json\n- tsconfig.json</pre><p id=\"ue46140cc\" class=\"ne-p\"><br></p><h2 id=\"eaebb74e\"><span class=\"ne-text\">TS 迁移过程中的踩坑记录</span></h2><p id=\"u74159bc4\" class=\"ne-p\"><br></p><h3 id=\"161c52fb\"><span class=\"ne-text\">1. 对于 toB 的项目，Vite 对库模式开发⽀持不友好</span></h3><p id=\"u738e8c3d\" class=\"ne-p\"><br></p><p id=\"u699c18a8\" class=\"ne-p\"><span class=\"ne-text\">踩坑：Vite 新⽣事物，虽说迭代挺快，但不⾜也挺明显。如，Vite 对多⻚应⽤构建配置友好， 但对 Monorepo 库模式配置能⼒不⾜，需要编程式（Vite -&gt; build()）解决构建需求。</span></p><p id=\"ue3687ba3\" class=\"ne-p\"><br></p><h3 id=\"20b26e2f\"><span class=\"ne-text\">2. esbuild ⽆类型检查能⼒及声明⽂件⽣成能⼒</span></h3><p id=\"ucf410652\" class=\"ne-p\"><br></p><p id=\"u3b1f22f9\" class=\"ne-p\"><span class=\"ne-text\">踩坑：选择 Vite 很⼤⼀部分因素是它使⽤ esbuild 做构建，且 esbuild 内置了 TypeScript 编译能⼒， 但 esbuild 不提供类型检查与声明⽂件⽣成。所以，最终的⽅案是，ESBuild 构建同时使⽤ TSC 编译器并⾏的完成类型检查与声明⽂件⽣成。</span></p><p id=\"u9017b81e\" class=\"ne-p\"><br></p><h3 id=\"f634ebdd\"><span class=\"ne-text\">3. TSConfig 配置⽂件⾃定义问题</span></h3><p id=\"u58758c69\" class=\"ne-p\"><br></p><p id=\"uf631a584\" class=\"ne-p\"><span class=\"ne-text\">踩坑：仅 Prod 模式就需要 2 个 TS 配置⽂件。TSC 命令⽐较⽅便指定，但 Vite 暴露的 build 函数（执⾏ esbuild 构建）基本⽆说明⽂档。撸 Vite 源码找⾃定义配置⽅式，再结合 esbuild 官⽅⽂档</span></p><p id=\"u08956398\" class=\"ne-p\"><br></p><h2 id=\"5b099d89\"><span class=\"ne-text\">TS 代码迁移技巧</span></h2><p id=\"ucd1dfc59\" class=\"ne-p\"><br></p><h3 id=\"5b2bd130\"><span class=\"ne-text\">1.不使用 TS 提供的语法糖（除非已经纳入了 ECMAScript 标准）</span></h3><p id=\"u3cca425d\" class=\"ne-p\"><br></p><p id=\"u19142cbf\" class=\"ne-p\"><span class=\"ne-text\">enum、重载、 public, privaete, protected, readonly 修饰符、方法装饰器，访问器装饰器，属性装饰器等</span></p><p id=\"u6c0faad6\" class=\"ne-p\"><br></p><h3 id=\"a163a782\"><span class=\"ne-text\">2.定义类型时尽量使用交叉类型（不使用 extends），Utility 定义 Types</span></h3><p id=\"ud321068c\" class=\"ne-p\"><br></p><p id=\"uca07c877\" class=\"ne-p\"><span class=\"ne-text\">交叉类型和 Mixins 有一点区别：交叉类型只是一个类型声明，用于类型约束；Mixins 会给类增加成员，new 对象时，对象会包含增加的成员属性。 同时 TS 在全局内置了很多 Utility Types,可以极大的提高我们开发效率。</span></p><p id=\"u01ebd9b3\" class=\"ne-p\"><br></p><h3 id=\"e44e7faa\"><span class=\"ne-text\">3.公共类型放在 src/types 或者 types 下，方便以后统一处理</span></h3><p id=\"u4e5a6f5d\" class=\"ne-p\"><br></p><p id=\"uc5f5fce9\" class=\"ne-p\"><span class=\"ne-text\">在日常开发中可能会经常用到 webpack 的路径别名，比如: import xxx from '@/path/to/name'，如果编辑器不做任何配置的话，编译器不会给任何路径提示，更不会给你语法提示。这里有个小技巧，基于 tsconfig.json 的 baseUrl 和 paths 这两个字段，配置好这两个字段后，.ts 文件里不但有了路径提示，还会跟踪到该路径进行语法提示。<br /></span><span class=\"ne-text\">如果把 tsconfig.json 重命名成 jsconfig.json，.js 文件里也可以享受到路径别名提示和语法提示。</span></p><p id=\"u3aba1f03\" class=\"ne-p\"><br></p><div data-type=\"info\" class=\"ne-alert\"><p id=\"u9bb95f6c\" class=\"ne-p\"><span class=\"ne-text\">如果把 tsconfig.json 重命名成 jsconfig.json，.js 文件里也可以享受到路径别名提示和语法提示。</span></p></div><p id=\"u985dded5\" class=\"ne-p\"><br></p><h3 id=\"f0b6dbea\"><span class=\"ne-text\">4.需要时才定义类型，尽量使用类型推断，非复用（简单）类型使用字面量定义</span></h3><p id=\"u6855cdd1\" class=\"ne-p\"><br></p><p id=\"u59e007b8\" class=\"ne-p\"><span class=\"ne-text\">在 ts 中，代码实现中的 typeof 关键词能够帮助 ts 判断出变量的基本类型:</span></p><p id=\"u29b7d101\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"4a9ecb26\" class=\"ne-codeblock language-typescript\">function fn(x: string | number) {\n    if (typeof x === &quot;string&quot;) {\n        // x is string\n        return x.length\n    } else {\n        // x is number\n        // .....\n    }\n}</pre><p id=\"uf4a566d6\" class=\"ne-p\"><br></p><p id=\"u5e851854\" class=\"ne-p\"><span class=\"ne-text\">instanceof 关键词能够帮助 ts 判断出构造函数的类型;在条件判断中，ts 会自动对 null 和 undefined 进行类型保护,如果我们已经知道的参数不为空，可以使用 ! 来手动标记.</span></p><p id=\"ua2fb7c75\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"11263a98\" class=\"ne-codeblock language-typescript\">function fn2(x?: string) {\n    return x!.length\n}</pre><p id=\"ub4f2702f\" class=\"ne-p\"><br></p><h3 id=\"853984fd\"><span class=\"ne-text\">5.暂时不能解决的使用 TsFixme &amp; </span><a href=\"/ts-ignore \" data-href=\"/ts-ignore \" class=\"ne-link\"><span class=\"ne-text\">@ts-ignore </span></a><span class=\"ne-text\"> </span></h3><p id=\"ub84723af\" class=\"ne-p\"><br></p><p id=\"u70b1bc4a\" class=\"ne-p\"><span class=\"ne-text\">在开发过程中，我们都会不时地写一些 // TODO: 和 // FIXME: 注释。有时我们这样做是因为我们知道代码可以做得更好，但暂时不确定如何做，有时由于 deadline 而没有时间编写最佳解决方案，而有时我们只是想着手处理更紧急的事情，这时我们只需在代码中标识一个 // TODO: or // FIXME 提示自己以便在将来某一天再处理。</span></p><p id=\"u1f630fbf\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"82a7ccd3\" class=\"ne-codeblock language-typescript\">/**\n * 手动获取用户在天猫旗舰店的会员等级和积分\n * @returns {any | *} 返回会员等级和积分; FIXME: 此处类型较为复杂，先用 any 代替，有空再补\n */</pre><p id=\"u79195e21\" class=\"ne-p\"><br></p><h2 id=\"91fa4fd0\"><span class=\"ne-text\">TS 迁移流程</span></h2><p id=\"u82ed7786\" class=\"ne-p\"><br></p><h3 id=\"f2faa7eb\"><span class=\"ne-text\">1.先培训</span></h3><p id=\"u13f95e7a\" class=\"ne-p\"><br></p><p id=\"u332bc316\" class=\"ne-p\"><span class=\"ne-text\">因为一些常用的 JS 写法，在 TS 里面需要稍微变通一下才能使用，比如我们常用的 promise.all 这种方法，在 TypeScript 中，当你这么用 Promise.all 时，会遇到类型检查错误的问题。</span></p><p id=\"ua204e968\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"b87447bc\" class=\"ne-codeblock language-typescript\">Promise.all(Promise &lt; XX &gt; [])</pre><p id=\"u9345c067\" class=\"ne-p\"><br></p><p id=\"ub778ba44\" class=\"ne-p\"><span class=\"ne-text\">因为 lib.es6.d.ts 中，对 Promise.all 这么定义</span></p><p id=\"uf49688ca\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"622135c3\" class=\"ne-codeblock language-typescript\">all&lt;TAll&gt;(values: Iterable&lt;TAll | PromiseLike&lt;TAll&gt;&gt;): Promise&lt;TAll[]&gt;;</pre><p id=\"u3067a8b7\" class=\"ne-p\"><br></p><p id=\"u610fe3ea\" class=\"ne-p\"><span class=\"ne-text\">所以，对上述案例，TAll 被自动识别为了 Promise；而实际上，TAll 应该是 XX。 该定义文件的 PromiseLike 跟 Promise 似乎没什么关系，所以没能自动识别。 所以使用时，如果 Promise.all 传入的是一个数组，那么建议的用法是强制制定类型，如下。</span></p><p id=\"u79d42685\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"c40b2ec7\" class=\"ne-codeblock language-typescript\">Promise.all&lt;XX&gt;(Promise &lt; XX &gt; [])</pre><p id=\"ud834be71\" class=\"ne-p\"><br></p><p id=\"ubc509b88\" class=\"ne-p\"><span class=\"ne-text\">又比如：解决 ts-node 中使用 symlinks 时引用 node_modules 报错的问题 preserveSymlinks 在 TypeScripts 中默认为 true 而在 NodeJS 中默认为 false</span></p><p id=\"u5471aa5e\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"2f413a47\" class=\"ne-codeblock language-typescript\">ts-node --preserve-symlinks index.ts</pre><p id=\"u433a9a1d\" class=\"ne-p\"><br></p><h3 id=\"715c7290\"><span class=\"ne-text\">2.项目种常用类型补全，建立标准，服务于全体应用</span></h3><p id=\"ueb4223c5\" class=\"ne-p\"><br></p><p id=\"u25a3fa03\" class=\"ne-p\"><span class=\"ne-text\">前后端共享代码和类型定义，全程代码提示和类型报错</span></p><p id=\"ufb1c4ee6\" class=\"ne-p\"><br></p><h3 id=\"9855570a\"><span class=\"ne-text\">3.小范围试验，确保转换过程简单、安全和自动化</span></h3><p id=\"u554851a3\" class=\"ne-p\"><br></p><p id=\"u5b26c3cd\" class=\"ne-p\"><span class=\"ne-text\">先在欧莱雅、兰蔻、薇姿项目中重构改造，在一些重要电商里先行试水，随后在整个电商事业群里推广。改造的范围包括但不限于：</span></p><p id=\"u9662bedd\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u22ee8272\"><span class=\"ne-text\">core utils 迁移</span></li><li id=\"u31a72a29\"><span class=\"ne-text\">选取核心文件进行迁移</span></li></ol><p id=\"u68e3c853\" class=\"ne-p\"><br></p><h3 id=\"e87638f2\"><span class=\"ne-text\">4.总结试验结果并优化</span></h3><p id=\"u832c8636\" class=\"ne-p\"><br></p><p id=\"u3951cf02\" class=\"ne-p\"><span class=\"ne-text\">为了减轻这种风险，我们需要一个规范的流程来转换文件，其不会引入回归，也不会诱导工程师去做多余的事情。这个流程还要能快速执行。</span></p><p id=\"u3bb6be4f\" class=\"ne-p\"><br></p><p id=\"uca941e8a\" class=\"ne-p\"><span class=\"ne-text\">我们确定了一个分为两部分的流程：首先自动转换 CoffeeScript 文件，然后立即手动添加基本类型注解和与 linter 相关的更改。关键在于抵制（不管是什么方式）重构代码的诱惑。这样一来，转换工作就成为了简单、遵循安全规则的机械活动，不会影响运行时行为。</span></p><p id=\"ub4e2f655\" class=\"ne-p\"><br></p><h3 id=\"ffd31892\"><span class=\"ne-text\">5.大范围推广</span></h3><p id=\"ubdfead3f\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"ua42b1bfd\"><span class=\"ne-text\">新页面新文件、工具函数必须使用 ts，老文件修改超过 40% 需用 ts 重写</span></li><li id=\"uebee08e1\"><span class=\"ne-text\">使用 snippet 模板</span></li></ol><ol start=\"3\" class=\"ne-ol\"><li id=\"u3f3787c3\"><span class=\"ne-text\">code review</span></li></ol><p id=\"u5f1aecc0\" class=\"ne-p\"><br></p><h2 id=\"c22810c9\"><span class=\"ne-text\">收益&amp;总结</span></h2><p id=\"u7e2b4dda\" class=\"ne-p\"><br></p><h3 id=\"25c14cba\"><span class=\"ne-text\">收益：开发体验必须明显改善</span></h3><p id=\"u75378ac1\" class=\"ne-p\"><br></p><p id=\"u00320dbf\" class=\"ne-p\"><span class=\"ne-text\">要让整个团队都参与进来，必须让开发人员体会到，他们在编写 TypeScript 时会更有效率。如果团队只是将迁移看作是从一种语法换成另一种差不多的语法，他们永远都不会产生认同感。如果迁移之后他们的日常工作效率并没有提升，那么就算工程师们往往更喜欢编写类型化代码，也敌不过旧习惯的巨大惯性。</span></p><p id=\"u56bfbe11\" class=\"ne-p\"><br></p><p id=\"u752015a6\" class=\"ne-p\"><span class=\"ne-text\">将工具链和配置作为优先事项来对待。大多数开发人员使用的编辑器就是那么几种而已，因此我们创建了可以直接使用的编辑器配置，添加了调试配置，从而可以轻松设置断点和单步执行代码。</span></p><p id=\"u8bb64fdf\" class=\"ne-p\"><br></p><p id=\"u117bee71\" class=\"ne-p\"><span class=\"ne-text\">最后，我们整理了一套取得共识的 linting 规则，这些规则使我们能够在整个组织中以统一的样式编写代码，并让开发人员对迁移行动更加满意。</span></p><p id=\"u54d906ce\" class=\"ne-p\"><br></p><p id=\"u6300b368\" class=\"ne-p\"><span class=\"ne-text\">当团队开始看到这些转换工作的成果时，整个项目也就得到了认可，前进动力也会更足了。当我们的工程师开始将类型化数据访问视为必不可少的工具后，他们就能更好地意识到，代码库的其它部分也会平稳地转换完毕。</span></p><p id=\"u559e422f\" class=\"ne-p\"><br></p><h3 id=\"25f9c7fa\"><span class=\"ne-text\">总结</span></h3><p id=\"u8c996528\" class=\"ne-p\"><br></p><p id=\"u2699c81d\" class=\"ne-p\"><span class=\"ne-text\">⽬前，电商业务渐进式改造升级，第⼀部分“基础能⼒”的拆分进⼊尾声，初步拆分出“账号登录”、“⽹络请求”、“数据埋点”等模块。通过“基础能⼒”模块的拆分，降低了原有代码的冗余度，使相关功能模块的逻辑清晰化、内聚化，可维护性增强；通过 TypeScript 语⾔的使⽤，使复杂的数据结构类型化、规范化，能更好的应对业务体量的增⻓，提升产品运⾏时的稳定性；同时，新的技术栈及技术⽅案的引⼊，切实提升了团队同学的技术能⼒，营造了团队良好的技术氛围。</span></p><p id=\"ud80f5563\" class=\"ne-p\"><br></p><p id=\"u60ddbd8b\" class=\"ne-p\"><span class=\"ne-text\">全面拥抱 Typescript，不仅仅是增加了类型，而是编程方式的转变。</span></p><p id=\"ud6085e47\" class=\"ne-p\"><br></p><p id=\"ude827336\" class=\"ne-p\"><span class=\"ne-text\">变量 =&gt; 类型 =&gt; 结构</span></p><p id=\"ue1bf901d\" class=\"ne-p\"><br></p><p id=\"u62db9c5f\" class=\"ne-p\"><span class=\"ne-text\">面向过程 =&gt; 面向接口</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"64c6f2f3\" id=\"64c6f2f3\"><span data-lake-id=\"u993a80ce\" id=\"u993a80ce\">TS 的特性</span></h2><p data-lake-id=\"u1f4f931d\" id=\"u1f4f931d\"><br></p><p data-lake-id=\"u231d9f9a\" id=\"u231d9f9a\"><span data-lake-id=\"ua93981d3\" id=\"ua93981d3\">JavaScript：</span></p><p data-lake-id=\"uac543ffd\" id=\"uac543ffd\"><br></p><ul list=\"u61854b34\"><li fid=\"u9e14742a\" data-lake-id=\"u5a6e4b51\" id=\"u5a6e4b51\"><span data-lake-id=\"ub6902a86\" id=\"ub6902a86\">解释型脚本语⾔，⽆需额外编译，便可在浏览器等环境中解释执⾏。</span></li></ul><p data-lake-id=\"ubffcc6f8\" id=\"ubffcc6f8\"><br></p><p data-lake-id=\"ua3a45538\" id=\"ua3a45538\"><span data-lake-id=\"u6e030b4d\" id=\"u6e030b4d\">TypeScript：</span></p><p data-lake-id=\"u9586cecd\" id=\"u9586cecd\"><br></p><ul list=\"u16a5b2fc\"><li fid=\"ubef84100\" data-lake-id=\"ufe489996\" id=\"ufe489996\"><span data-lake-id=\"u420a13e3\" id=\"u420a13e3\">⾯向对象的编程语⾔，增加了静态类型、接⼝、泛型、类型注解等。</span></li><li fid=\"ubef84100\" data-lake-id=\"u94b9ac9c\" id=\"u94b9ac9c\"><span data-lake-id=\"uda2bd1af\" id=\"uda2bd1af\">通过静态类型检测，更容易编写健壮性强的代码，更适合⼤型项⽬开发。</span></li><li fid=\"ubef84100\" data-lake-id=\"u0db4971c\" id=\"u0db4971c\"><span data-lake-id=\"u71ec1d01\" id=\"u71ec1d01\">浏览器、Node 等环境⽆法直接运⾏ TypeScript，需编译成 JavaScript 后运⾏。</span></li></ul><p data-lake-id=\"ubeb2551e\" id=\"ubeb2551e\"><br></p><h2 data-lake-id=\"52b8c184\" id=\"52b8c184\"><span data-lake-id=\"ue197416b\" id=\"ue197416b\">优点</span></h2><p data-lake-id=\"uc5fff112\" id=\"uc5fff112\"><br></p><ul list=\"u20050dfe\"><li fid=\"ufc2b058a\" data-lake-id=\"u8a38418e\" id=\"u8a38418e\"><span data-lake-id=\"u6ebf7d3f\" id=\"u6ebf7d3f\">丰富的类型系统：基本类型、接口、类、函数、泛型、枚举......</span></li><li fid=\"ufc2b058a\" data-lake-id=\"u1fcce0cf\" id=\"u1fcce0cf\"><span data-lake-id=\"u9f6c8e97\" id=\"u9f6c8e97\">强大的类型推导能力：支持类型推导，命名空间和模块，装饰器等特性</span></li><li fid=\"ufc2b058a\" data-lake-id=\"u7ee08a3c\" id=\"u7ee08a3c\"><span data-lake-id=\"uc8aa3c26\" id=\"uc8aa3c26\">完善的生态支持：tsc/bable 编译器、IDE、eslint、</span><a href=\"/types \" data-lake-id=\"uad55e53d\" id=\"uad55e53d\"><span data-lake-id=\"ucc560a62\" id=\"ucc560a62\">@types </span></a><span data-lake-id=\"u88086694\" id=\"u88086694\"> </span></li></ul><p data-lake-id=\"ue4558ce4\" id=\"ue4558ce4\"><br></p><h2 data-lake-id=\"a38829fa\" id=\"a38829fa\"><span data-lake-id=\"u1d5b5cae\" id=\"u1d5b5cae\">前后端通信之痛</span></h2><p data-lake-id=\"ubffacf83\" id=\"ubffacf83\"><br></p><p data-lake-id=\"ua902d84e\" id=\"ua902d84e\"><span data-lake-id=\"ud652c829\" id=\"ud652c829\">我之前所在的部门，一个化妆品电商品牌前端团队，N 个前端，M 个品牌，2N 个后端，总共几百人，几乎每天都在不停的开发、联调中，电商业务需求多、迭代块、细节多，一款品牌电商经过历史迭代、多⼈多团队维护，存在代码结构混乱、逻辑耦合极⾼，单⼀⽂件动辄上千⾏，代码可读性、可维护性均较差；基于 JavaScript 设计的数据结构、数据传递等⾮常复杂，导致线上⼩问题层出不穷，排查修复成本⾼；另外还有是由于每个研发同事的水平、代码风格、做事风格的不同，也难以保持 API 和字段单词的规范和统一，更别说所有开发人员保证实时更新 API 文档了。</span></p><p data-lake-id=\"u9bba4f47\" id=\"u9bba4f47\"><br></p><h3 data-lake-id=\"2372b182\" id=\"2372b182\"><span data-lake-id=\"u5068a882\" id=\"u5068a882\">⽬标</span></h3><p data-lake-id=\"u8beb7b5d\" id=\"u8beb7b5d\"><br></p><ul list=\"u097d7a63\"><li fid=\"u479e303f\" data-lake-id=\"uc2b05d94\" id=\"uc2b05d94\"><span data-lake-id=\"u36eaa86e\" id=\"u36eaa86e\">项目太大，在长期的迭代中，代码风格不同，组件、函数升级，参数不兼容</span></li><li fid=\"u479e303f\" data-lake-id=\"u6863c8be\" id=\"u6863c8be\"><span data-lake-id=\"u04bd0fab\" id=\"u04bd0fab\">前后端接口字段不一致等</span></li><li fid=\"u479e303f\" data-lake-id=\"ude0ee1ae\" id=\"ude0ee1ae\"><span data-lake-id=\"u1af3c5fa\" id=\"u1af3c5fa\">接口文档与代码不一致等</span></li></ul><p data-lake-id=\"u0a326c13\" id=\"u0a326c13\"><br></p><p data-lake-id=\"u08f80b19\" id=\"u08f80b19\"><span data-lake-id=\"ud1721add\" id=\"ud1721add\">基于以上一些项目维护中的痛点，决定想要实现通过对项⽬代码的基础能⼒、业务逻辑⼩步快跑式的拆解，降低项⽬代码的复杂度，并形成团队内⼀致的⼯程规范、编码规范等，提升项⽬代码的可读性、可维护性。</span></p><p data-lake-id=\"u77c09ddc\" id=\"u77c09ddc\"><br></p><p data-lake-id=\"u16a1c8e9\" id=\"u16a1c8e9\"><span data-lake-id=\"u1aa1563e\" id=\"u1aa1563e\">通过 TypeScript 等相关技术栈引⼊，梳理并重构业务代码数据结构、数据传递等逻辑，通过静态类型校验，增加编译时排雷的概率，降低运⾏时出错的⻛险。</span></p><p data-lake-id=\"ue35711a3\" id=\"ue35711a3\"><br></p><p data-lake-id=\"uc35516cb\" id=\"uc35516cb\"><span data-lake-id=\"u6f565770\" id=\"u6f565770\">维持项⽬技术新度，偿还历史项⽬的技术债务，提升团队同学的技术热情与技术能⼒。</span></p><p data-lake-id=\"ud972bc9c\" id=\"ud972bc9c\"><br></p><h2 data-lake-id=\"f47adc3a\" id=\"f47adc3a\"><span data-lake-id=\"uf6568ee7\" id=\"uf6568ee7\">TS 在欧莱雅电商业务中的迁移实践</span></h2><p data-lake-id=\"uc319a88f\" id=\"uc319a88f\"><br></p><h3 data-lake-id=\"74c68b51\" id=\"74c68b51\"><span data-lake-id=\"u9bedefc4\" id=\"u9bedefc4\">迁移原则</span></h3><p data-lake-id=\"u57f3e2d8\" id=\"u57f3e2d8\"><br></p><p data-lake-id=\"ub1212190\" id=\"ub1212190\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1647788931569-ff27bf88-cbf2-426b-a218-f9b25d290548.png%23clientId%3Du6a6385bd-ca73-4%26from%3Dpaste%26height%3D270%26id%3Du3eee2473%26margin%3D%255Bobject%2520Object%255D%26name%3Dimage.png%26originHeight%3D270%26originWidth%3D484%26originalType%3Dbinary%26ratio%3D1%26size%3D63816%26status%3Ddone%26style%3Dnone%26taskId%3Du65812ddd-3999-4c5f-84a9-93021fb40e6%26width%3D484%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A484%2C%22originHeight%22%3A270%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22id%22%3A%22dQ99P%22%7D\"></card></p><p data-lake-id=\"u4c3d7dcb\" id=\"u4c3d7dcb\"><br></p><h3 data-lake-id=\"0f6433a9\" id=\"0f6433a9\"><span data-lake-id=\"u58b079be\" id=\"u58b079be\">实践⽅案</span></h3><p data-lake-id=\"u00c42677\" id=\"u00c42677\"><br></p><p data-lake-id=\"ufa1b3568\" id=\"ufa1b3568\"><span data-lake-id=\"u3dc6d01c\" id=\"u3dc6d01c\">Monorepo (pnpm + TypeScript) + esbuild + Changesets</span></p><p data-lake-id=\"ufef39691\" id=\"ufef39691\"><br></p><h3 data-lake-id=\"83527ca9\" id=\"83527ca9\"><span data-lake-id=\"u6492969a\" id=\"u6492969a\">⽅案设计说明</span></h3><p data-lake-id=\"u436ca123\" id=\"u436ca123\"><br></p><p data-lake-id=\"uab40c7bb\" id=\"uab40c7bb\"><span data-lake-id=\"ua468b353\" id=\"ua468b353\">以小程序为例，考虑到电商务的代码体量及复杂性，比如兰蔻、YSL、娇兰等电商小程序至少 100+页面，妄图一个小程序一个主包吞下整个电商全流程不太现实。所以，我们采取的⽅案是按照功能属性拆分代码并渐进式改造升级。第⼀步，我们对项⽬中&quot;基础能⼒&quot;部分拆分；第⼆步，我们对项⽬中&quot;业务逻辑&quot;与&quot;视图渲染&quot;拆分。</span></p><p data-lake-id=\"ubd941245\" id=\"ubd941245\"><br></p><p data-lake-id=\"ua4ff4850\" id=\"ua4ff4850\"><span data-lake-id=\"u2ddbe047\" id=\"u2ddbe047\">基础能⼒部分，独⽴功能模块众多，因此采⽤ Monorepo 模式整合。出于构建速度的考量，对 TypeScript 的 Dev 环境与 Prod 环境构建使⽤ Vite/webpack + esbuild (团队种老的电商多租户平台还是在用 Vue2 + elementui，新电商后台已全面改用 vite + Vue3/React)。基础能⼒部分，功能相对独⽴、业务属性弱，在渐进式改造升级的过程中以依赖包的形式集成⼊原⼯程，所以使⽤轻量化、社区活跃度⾼的 Changesets 来迭代维护依赖包更新。</span></p><p data-lake-id=\"uc47a3d60\" id=\"uc47a3d60\"><br></p><h3 data-lake-id=\"0f6433a9-1\" id=\"0f6433a9-1\"><span data-lake-id=\"u7262d24b\" id=\"u7262d24b\">实践⽅案</span></h3><p data-lake-id=\"ub88baeab\" id=\"ub88baeab\"><br></p><p data-lake-id=\"ue725d370\" id=\"ue725d370\"><span data-lake-id=\"ufdb4bcc8\" id=\"ufdb4bcc8\">在 toB 的 PC 端项目方面，⼯程结构：</span></p><p data-lake-id=\"u6f785e30\" id=\"u6f785e30\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22%20.changeset%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20%E5%9F%BA%E7%A1%80%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%5Cn%20dist%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20%E5%9F%BA%E7%A1%80%E5%BA%93production%E4%BA%A7%E7%89%A9%5Cn%20packages%5Cn%20%20%20%20-%20loreal-sign%20%20%20%20%20%20%20%20%20%20%20--%20%E5%95%86%E5%9F%8E%E7%99%BB%E5%BD%95%E5%9F%BA%E7%A1%80%E5%BA%93%5Cn%20%20%20%20-%20loreal-ec%20%20%20%20%20%20%20%20%20%20%20%20%20--%20EC%E7%94%B5%E5%95%86%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E5%BA%93%5Cn%20%20%20%20-%20loreal-axios%20%20%20%20%20%20%20%20%20%20--%20%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85ec%E8%AF%B7%E6%B1%82%E5%BA%93%5Cn%20%20%20%20-%20loreal-trace%20%20%20%20%20%20%20%20%20%20--%20%E7%94%B5%E5%95%86%E5%9F%8B%E7%82%B9SDK%E5%8F%8A%E5%85%B6%E5%B7%A5%E5%85%B7%5Cn%20%20%20%20-%20loreal-utils%20%20%20%20%20%20%20%20%20%20--%20EC%E7%94%B5%E5%95%86%E5%B7%A5%E5%85%B7%E9%93%BE%5Cn%20pnpm-workspace.yaml%20%20%20%20%20%20%20%20--%5Cn%20tsconfig.json%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20dev%E6%A8%A1%E5%BC%8F%20TypeScritp%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%5Cn%20tsconfig.type-check.json%20%20%20--%20tsc%E6%A8%A1%E5%BC%8F%20TypeScript%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E7%94%A8%E4%BA%8Eprod%E6%A8%A1%E5%BC%8F%E6%9E%84%E5%BB%BA%E6%97%B6%E5%81%9A%E5%B9%B6%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%5Cn%20vite.config.ts%20%20%20%20%20%20%20%20%20%20%20%20%20--%20vite%20dev%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%5Cn%20vite.prod-config.ts%20%20%20%20%20%20%20%20--%20vite%20prod%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22b560c78d%22%7D\"></card><p data-lake-id=\"ubbff69cb\" id=\"ubbff69cb\"><br></p><p data-lake-id=\"u2c3868de\" id=\"u2c3868de\"><span data-lake-id=\"u1c95a1e1\" id=\"u1c95a1e1\">在 toC 的小程序端项目方面，⼯程结构：</span></p><p data-lake-id=\"ud33599c9\" id=\"ud33599c9\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22%20%20miniprogram%5Cn%20%20%20%20-%20api%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20API%E6%B2%BB%E7%90%86%E4%B8%AD%E5%BF%83%5Cn%20%20%20%20-%20assets%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%5Cn%20%20%20%20-%20components%20%20%20%20%20%20%20%20%20%20%20%20--%20loreal%E7%94%B5%E5%95%86%E7%BB%84%E4%BB%B6%5Cn%20%20%20%20-%20config%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20%E4%B8%8EAPPID%E6%9C%89%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%5Cn%20%20%20%20-%20packages%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20%E5%88%86%E5%8C%85%5Cn%20%20%20%20-%20pages%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20%E4%B8%BB%E5%8C%85%5Cn%20%20%20%20-%20plugins%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20%E6%8F%92%E4%BB%B6%5Cn%20%20%20%20-%20utils%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8C%85%E6%8B%ACwxs%5Cn%20%20model%5Cn%20%20%20%20-%20api%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20api%E6%8E%A5%E5%8F%A3%E7%9A%84types%E6%96%87%E4%BB%B6%E3%80%81%E6%8F%92%E4%BB%B6%E7%9A%84types%5Cn%20%20%20%20index.d.ts%5Cn%20%20node_modules%5Cn%20%20typings%5Cn%20%20%20%20-%20types%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20%E5%BE%AE%E4%BF%A1%E8%87%AA%E8%BA%ABapi%E7%9A%84%E4%B8%80%E4%BA%9Btypes%5Cn%20%20%20%20index.d.ts%5Cn-%20package.json%5Cn-%20project.config.json%5Cn-%20project.private.config.json%5Cn-%20tsconfig.json%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2249fb4343%22%7D\"></card><p data-lake-id=\"ue46140cc\" id=\"ue46140cc\"><br></p><h2 data-lake-id=\"eaebb74e\" id=\"eaebb74e\"><span data-lake-id=\"u5af1e834\" id=\"u5af1e834\">TS 迁移过程中的踩坑记录</span></h2><p data-lake-id=\"u74159bc4\" id=\"u74159bc4\"><br></p><h3 data-lake-id=\"161c52fb\" id=\"161c52fb\"><span data-lake-id=\"u34a7a39a\" id=\"u34a7a39a\">1. 对于 toB 的项目，Vite 对库模式开发⽀持不友好</span></h3><p data-lake-id=\"u738e8c3d\" id=\"u738e8c3d\"><br></p><p data-lake-id=\"u699c18a8\" id=\"u699c18a8\"><span data-lake-id=\"u84ef626a\" id=\"u84ef626a\">踩坑：Vite 新⽣事物，虽说迭代挺快，但不⾜也挺明显。如，Vite 对多⻚应⽤构建配置友好， 但对 Monorepo 库模式配置能⼒不⾜，需要编程式（Vite -&gt; build()）解决构建需求。</span></p><p data-lake-id=\"ue3687ba3\" id=\"ue3687ba3\"><br></p><h3 data-lake-id=\"20b26e2f\" id=\"20b26e2f\"><span data-lake-id=\"udd42b622\" id=\"udd42b622\">2. esbuild ⽆类型检查能⼒及声明⽂件⽣成能⼒</span></h3><p data-lake-id=\"ucf410652\" id=\"ucf410652\"><br></p><p data-lake-id=\"u3b1f22f9\" id=\"u3b1f22f9\"><span data-lake-id=\"u289c1601\" id=\"u289c1601\">踩坑：选择 Vite 很⼤⼀部分因素是它使⽤ esbuild 做构建，且 esbuild 内置了 TypeScript 编译能⼒， 但 esbuild 不提供类型检查与声明⽂件⽣成。所以，最终的⽅案是，ESBuild 构建同时使⽤ TSC 编译器并⾏的完成类型检查与声明⽂件⽣成。</span></p><p data-lake-id=\"u9017b81e\" id=\"u9017b81e\"><br></p><h3 data-lake-id=\"f634ebdd\" id=\"f634ebdd\"><span data-lake-id=\"uebd7e4c9\" id=\"uebd7e4c9\">3. TSConfig 配置⽂件⾃定义问题</span></h3><p data-lake-id=\"u58758c69\" id=\"u58758c69\"><br></p><p data-lake-id=\"uf631a584\" id=\"uf631a584\"><span data-lake-id=\"uf782a924\" id=\"uf782a924\">踩坑：仅 Prod 模式就需要 2 个 TS 配置⽂件。TSC 命令⽐较⽅便指定，但 Vite 暴露的 build 函数（执⾏ esbuild 构建）基本⽆说明⽂档。撸 Vite 源码找⾃定义配置⽅式，再结合 esbuild 官⽅⽂档</span></p><p data-lake-id=\"u08956398\" id=\"u08956398\"><br></p><h2 data-lake-id=\"5b099d89\" id=\"5b099d89\"><span data-lake-id=\"u645756f5\" id=\"u645756f5\">TS 代码迁移技巧</span></h2><p data-lake-id=\"ucd1dfc59\" id=\"ucd1dfc59\"><br></p><h3 data-lake-id=\"5b2bd130\" id=\"5b2bd130\"><span data-lake-id=\"u9c9e85c1\" id=\"u9c9e85c1\">1.不使用 TS 提供的语法糖（除非已经纳入了 ECMAScript 标准）</span></h3><p data-lake-id=\"u3cca425d\" id=\"u3cca425d\"><br></p><p data-lake-id=\"u19142cbf\" id=\"u19142cbf\"><span data-lake-id=\"ud37a3468\" id=\"ud37a3468\">enum、重载、 public, privaete, protected, readonly 修饰符、方法装饰器，访问器装饰器，属性装饰器等</span></p><p data-lake-id=\"u6c0faad6\" id=\"u6c0faad6\"><br></p><h3 data-lake-id=\"a163a782\" id=\"a163a782\"><span data-lake-id=\"u2d7a5ca9\" id=\"u2d7a5ca9\">2.定义类型时尽量使用交叉类型（不使用 extends），Utility 定义 Types</span></h3><p data-lake-id=\"ud321068c\" id=\"ud321068c\"><br></p><p data-lake-id=\"uca07c877\" id=\"uca07c877\"><span data-lake-id=\"ucd733dd2\" id=\"ucd733dd2\">交叉类型和 Mixins 有一点区别：交叉类型只是一个类型声明，用于类型约束；Mixins 会给类增加成员，new 对象时，对象会包含增加的成员属性。 同时 TS 在全局内置了很多 Utility Types,可以极大的提高我们开发效率。</span></p><p data-lake-id=\"u01ebd9b3\" id=\"u01ebd9b3\"><br></p><h3 data-lake-id=\"e44e7faa\" id=\"e44e7faa\"><span data-lake-id=\"u3a62b48e\" id=\"u3a62b48e\">3.公共类型放在 src/types 或者 types 下，方便以后统一处理</span></h3><p data-lake-id=\"u4e5a6f5d\" id=\"u4e5a6f5d\"><br></p><p data-lake-id=\"uc5f5fce9\" id=\"uc5f5fce9\"><span data-lake-id=\"u1aca419c\" id=\"u1aca419c\">在日常开发中可能会经常用到 webpack 的路径别名，比如: import xxx from '@/path/to/name'，如果编辑器不做任何配置的话，编译器不会给任何路径提示，更不会给你语法提示。这里有个小技巧，基于 tsconfig.json 的 baseUrl 和 paths 这两个字段，配置好这两个字段后，.ts 文件里不但有了路径提示，还会跟踪到该路径进行语法提示。<br /></span><span data-lake-id=\"udd2929a4\" id=\"udd2929a4\">如果把 tsconfig.json 重命名成 jsconfig.json，.js 文件里也可以享受到路径别名提示和语法提示。</span></p><p data-lake-id=\"u3aba1f03\" id=\"u3aba1f03\"><br></p><blockquote data-lake-id=\"u608562f8\" id=\"u608562f8\" class=\"lake-alert lake-alert-info\"><p data-lake-id=\"u9bb95f6c\" id=\"u9bb95f6c\"><span data-lake-id=\"u4e355fed\" id=\"u4e355fed\">如果把 tsconfig.json 重命名成 jsconfig.json，.js 文件里也可以享受到路径别名提示和语法提示。</span></p></blockquote><p data-lake-id=\"u985dded5\" id=\"u985dded5\"><br></p><h3 data-lake-id=\"f0b6dbea\" id=\"f0b6dbea\"><span data-lake-id=\"ubabb645d\" id=\"ubabb645d\">4.需要时才定义类型，尽量使用类型推断，非复用（简单）类型使用字面量定义</span></h3><p data-lake-id=\"u6855cdd1\" id=\"u6855cdd1\"><br></p><p data-lake-id=\"u59e007b8\" id=\"u59e007b8\"><span data-lake-id=\"u92879d10\" id=\"u92879d10\">在 ts 中，代码实现中的 typeof 关键词能够帮助 ts 判断出变量的基本类型:</span></p><p data-lake-id=\"u29b7d101\" id=\"u29b7d101\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22function%20fn(x%3A%20string%20%7C%20number)%20%7B%5Cn%20%20%20%20if%20(typeof%20x%20%3D%3D%3D%20%5C%22string%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20x%20is%20string%5Cn%20%20%20%20%20%20%20%20return%20x.length%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20x%20is%20number%5Cn%20%20%20%20%20%20%20%20%2F%2F%20.....%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%224a9ecb26%22%7D\"></card><p data-lake-id=\"uf4a566d6\" id=\"uf4a566d6\"><br></p><p data-lake-id=\"u5e851854\" id=\"u5e851854\"><span data-lake-id=\"ubb3c99c2\" id=\"ubb3c99c2\">instanceof 关键词能够帮助 ts 判断出构造函数的类型;在条件判断中，ts 会自动对 null 和 undefined 进行类型保护,如果我们已经知道的参数不为空，可以使用 ! 来手动标记.</span></p><p data-lake-id=\"ua2fb7c75\" id=\"ua2fb7c75\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22function%20fn2(x%3F%3A%20string)%20%7B%5Cn%20%20%20%20return%20x!.length%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2211263a98%22%7D\"></card><p data-lake-id=\"ub4f2702f\" id=\"ub4f2702f\"><br></p><h3 data-lake-id=\"853984fd\" id=\"853984fd\"><span data-lake-id=\"u72e6efd5\" id=\"u72e6efd5\">5.暂时不能解决的使用 TsFixme &amp; </span><a href=\"/ts-ignore \" data-lake-id=\"uddc5ca04\" id=\"uddc5ca04\"><span data-lake-id=\"ud6134a57\" id=\"ud6134a57\">@ts-ignore </span></a><span data-lake-id=\"u263af512\" id=\"u263af512\"> </span></h3><p data-lake-id=\"ub84723af\" id=\"ub84723af\"><br></p><p data-lake-id=\"u70b1bc4a\" id=\"u70b1bc4a\"><span data-lake-id=\"ub665738b\" id=\"ub665738b\">在开发过程中，我们都会不时地写一些 // TODO: 和 // FIXME: 注释。有时我们这样做是因为我们知道代码可以做得更好，但暂时不确定如何做，有时由于 deadline 而没有时间编写最佳解决方案，而有时我们只是想着手处理更紧急的事情，这时我们只需在代码中标识一个 // TODO: or // FIXME 提示自己以便在将来某一天再处理。</span></p><p data-lake-id=\"u1f630fbf\" id=\"u1f630fbf\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22%2F**%5Cn%20*%20%E6%89%8B%E5%8A%A8%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%9C%A8%E5%A4%A9%E7%8C%AB%E6%97%97%E8%88%B0%E5%BA%97%E7%9A%84%E4%BC%9A%E5%91%98%E7%AD%89%E7%BA%A7%E5%92%8C%E7%A7%AF%E5%88%86%5Cn%20*%20%40returns%20%7Bany%20%7C%20*%7D%20%E8%BF%94%E5%9B%9E%E4%BC%9A%E5%91%98%E7%AD%89%E7%BA%A7%E5%92%8C%E7%A7%AF%E5%88%86%3B%20FIXME%3A%20%E6%AD%A4%E5%A4%84%E7%B1%BB%E5%9E%8B%E8%BE%83%E4%B8%BA%E5%A4%8D%E6%9D%82%EF%BC%8C%E5%85%88%E7%94%A8%20any%20%E4%BB%A3%E6%9B%BF%EF%BC%8C%E6%9C%89%E7%A9%BA%E5%86%8D%E8%A1%A5%5Cn%20*%2F%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%2282a7ccd3%22%7D\"></card><p data-lake-id=\"u79195e21\" id=\"u79195e21\"><br></p><h2 data-lake-id=\"91fa4fd0\" id=\"91fa4fd0\"><span data-lake-id=\"uc0df472d\" id=\"uc0df472d\">TS 迁移流程</span></h2><p data-lake-id=\"u82ed7786\" id=\"u82ed7786\"><br></p><h3 data-lake-id=\"f2faa7eb\" id=\"f2faa7eb\"><span data-lake-id=\"ub656a6d2\" id=\"ub656a6d2\">1.先培训</span></h3><p data-lake-id=\"u13f95e7a\" id=\"u13f95e7a\"><br></p><p data-lake-id=\"u332bc316\" id=\"u332bc316\"><span data-lake-id=\"u841e8d9d\" id=\"u841e8d9d\">因为一些常用的 JS 写法，在 TS 里面需要稍微变通一下才能使用，比如我们常用的 promise.all 这种方法，在 TypeScript 中，当你这么用 Promise.all 时，会遇到类型检查错误的问题。</span></p><p data-lake-id=\"ua204e968\" id=\"ua204e968\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22Promise.all(Promise%20%3C%20XX%20%3E%20%5B%5D)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22b87447bc%22%7D\"></card><p data-lake-id=\"u9345c067\" id=\"u9345c067\"><br></p><p data-lake-id=\"ub778ba44\" id=\"ub778ba44\"><span data-lake-id=\"ub3e04199\" id=\"ub3e04199\">因为 lib.es6.d.ts 中，对 Promise.all 这么定义</span></p><p data-lake-id=\"uf49688ca\" id=\"uf49688ca\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22all%3CTAll%3E(values%3A%20Iterable%3CTAll%20%7C%20PromiseLike%3CTAll%3E%3E)%3A%20Promise%3CTAll%5B%5D%3E%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22622135c3%22%7D\"></card><p data-lake-id=\"u3067a8b7\" id=\"u3067a8b7\"><br></p><p data-lake-id=\"u610fe3ea\" id=\"u610fe3ea\"><span data-lake-id=\"u526577e4\" id=\"u526577e4\">所以，对上述案例，TAll 被自动识别为了 Promise；而实际上，TAll 应该是 XX。 该定义文件的 PromiseLike 跟 Promise 似乎没什么关系，所以没能自动识别。 所以使用时，如果 Promise.all 传入的是一个数组，那么建议的用法是强制制定类型，如下。</span></p><p data-lake-id=\"u79d42685\" id=\"u79d42685\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22Promise.all%3CXX%3E(Promise%20%3C%20XX%20%3E%20%5B%5D)%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22c40b2ec7%22%7D\"></card><p data-lake-id=\"ud834be71\" id=\"ud834be71\"><br></p><p data-lake-id=\"ubc509b88\" id=\"ubc509b88\"><span data-lake-id=\"ucd832cf9\" id=\"ucd832cf9\">又比如：解决 ts-node 中使用 symlinks 时引用 node_modules 报错的问题 preserveSymlinks 在 TypeScripts 中默认为 true 而在 NodeJS 中默认为 false</span></p><p data-lake-id=\"u5471aa5e\" id=\"u5471aa5e\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22ts-node%20--preserve-symlinks%20index.ts%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%222f413a47%22%7D\"></card><p data-lake-id=\"u433a9a1d\" id=\"u433a9a1d\"><br></p><h3 data-lake-id=\"715c7290\" id=\"715c7290\"><span data-lake-id=\"ua0f4da43\" id=\"ua0f4da43\">2.项目种常用类型补全，建立标准，服务于全体应用</span></h3><p data-lake-id=\"ueb4223c5\" id=\"ueb4223c5\"><br></p><p data-lake-id=\"u25a3fa03\" id=\"u25a3fa03\"><span data-lake-id=\"uacb290d2\" id=\"uacb290d2\">前后端共享代码和类型定义，全程代码提示和类型报错</span></p><p data-lake-id=\"ufb1c4ee6\" id=\"ufb1c4ee6\"><br></p><h3 data-lake-id=\"9855570a\" id=\"9855570a\"><span data-lake-id=\"ub383aaf5\" id=\"ub383aaf5\">3.小范围试验，确保转换过程简单、安全和自动化</span></h3><p data-lake-id=\"u554851a3\" id=\"u554851a3\"><br></p><p data-lake-id=\"u5b26c3cd\" id=\"u5b26c3cd\"><span data-lake-id=\"u10820dc4\" id=\"u10820dc4\">先在欧莱雅、兰蔻、薇姿项目中重构改造，在一些重要电商里先行试水，随后在整个电商事业群里推广。改造的范围包括但不限于：</span></p><p data-lake-id=\"u9662bedd\" id=\"u9662bedd\"><br></p><ol list=\"u76ac3a8e\"><li fid=\"u9c5dbc25\" data-lake-id=\"u22ee8272\" id=\"u22ee8272\"><span data-lake-id=\"u648c482c\" id=\"u648c482c\">core utils 迁移</span></li><li fid=\"u9c5dbc25\" data-lake-id=\"u31a72a29\" id=\"u31a72a29\"><span data-lake-id=\"u55343d8f\" id=\"u55343d8f\">选取核心文件进行迁移</span></li></ol><p data-lake-id=\"u68e3c853\" id=\"u68e3c853\"><br></p><h3 data-lake-id=\"e87638f2\" id=\"e87638f2\"><span data-lake-id=\"ua3eed7a8\" id=\"ua3eed7a8\">4.总结试验结果并优化</span></h3><p data-lake-id=\"u832c8636\" id=\"u832c8636\"><br></p><p data-lake-id=\"u3951cf02\" id=\"u3951cf02\"><span data-lake-id=\"ue16eeb06\" id=\"ue16eeb06\">为了减轻这种风险，我们需要一个规范的流程来转换文件，其不会引入回归，也不会诱导工程师去做多余的事情。这个流程还要能快速执行。</span></p><p data-lake-id=\"u3bb6be4f\" id=\"u3bb6be4f\"><br></p><p data-lake-id=\"uca941e8a\" id=\"uca941e8a\"><span data-lake-id=\"uc7f0fc7a\" id=\"uc7f0fc7a\">我们确定了一个分为两部分的流程：首先自动转换 CoffeeScript 文件，然后立即手动添加基本类型注解和与 linter 相关的更改。关键在于抵制（不管是什么方式）重构代码的诱惑。这样一来，转换工作就成为了简单、遵循安全规则的机械活动，不会影响运行时行为。</span></p><p data-lake-id=\"ub4e2f655\" id=\"ub4e2f655\"><br></p><h3 data-lake-id=\"ffd31892\" id=\"ffd31892\"><span data-lake-id=\"uab968bac\" id=\"uab968bac\">5.大范围推广</span></h3><p data-lake-id=\"ubdfead3f\" id=\"ubdfead3f\"><br></p><ol list=\"u364f8662\"><li fid=\"u03b5ab4f\" data-lake-id=\"ua42b1bfd\" id=\"ua42b1bfd\"><span data-lake-id=\"u3466304f\" id=\"u3466304f\">新页面新文件、工具函数必须使用 ts，老文件修改超过 40% 需用 ts 重写</span></li><li fid=\"u03b5ab4f\" data-lake-id=\"uebee08e1\" id=\"uebee08e1\"><span data-lake-id=\"ud765175f\" id=\"ud765175f\">使用 snippet 模板</span></li><li fid=\"u03b5ab4f\" data-lake-id=\"u3f3787c3\" id=\"u3f3787c3\"><span data-lake-id=\"u8134151d\" id=\"u8134151d\">code review</span></li></ol><p data-lake-id=\"u5f1aecc0\" id=\"u5f1aecc0\"><br></p><h2 data-lake-id=\"c22810c9\" id=\"c22810c9\"><span data-lake-id=\"ua35a0164\" id=\"ua35a0164\">收益&amp;总结</span></h2><p data-lake-id=\"u7e2b4dda\" id=\"u7e2b4dda\"><br></p><h3 data-lake-id=\"25c14cba\" id=\"25c14cba\"><span data-lake-id=\"u849ab6ea\" id=\"u849ab6ea\">收益：开发体验必须明显改善</span></h3><p data-lake-id=\"u75378ac1\" id=\"u75378ac1\"><br></p><p data-lake-id=\"u00320dbf\" id=\"u00320dbf\"><span data-lake-id=\"u21d5b975\" id=\"u21d5b975\">要让整个团队都参与进来，必须让开发人员体会到，他们在编写 TypeScript 时会更有效率。如果团队只是将迁移看作是从一种语法换成另一种差不多的语法，他们永远都不会产生认同感。如果迁移之后他们的日常工作效率并没有提升，那么就算工程师们往往更喜欢编写类型化代码，也敌不过旧习惯的巨大惯性。</span></p><p data-lake-id=\"u56bfbe11\" id=\"u56bfbe11\"><br></p><p data-lake-id=\"u752015a6\" id=\"u752015a6\"><span data-lake-id=\"u0907553b\" id=\"u0907553b\">将工具链和配置作为优先事项来对待。大多数开发人员使用的编辑器就是那么几种而已，因此我们创建了可以直接使用的编辑器配置，添加了调试配置，从而可以轻松设置断点和单步执行代码。</span></p><p data-lake-id=\"u8bb64fdf\" id=\"u8bb64fdf\"><br></p><p data-lake-id=\"u117bee71\" id=\"u117bee71\"><span data-lake-id=\"u95c39814\" id=\"u95c39814\">最后，我们整理了一套取得共识的 linting 规则，这些规则使我们能够在整个组织中以统一的样式编写代码，并让开发人员对迁移行动更加满意。</span></p><p data-lake-id=\"u54d906ce\" id=\"u54d906ce\"><br></p><p data-lake-id=\"u6300b368\" id=\"u6300b368\"><span data-lake-id=\"ud6d374c3\" id=\"ud6d374c3\">当团队开始看到这些转换工作的成果时，整个项目也就得到了认可，前进动力也会更足了。当我们的工程师开始将类型化数据访问视为必不可少的工具后，他们就能更好地意识到，代码库的其它部分也会平稳地转换完毕。</span></p><p data-lake-id=\"u559e422f\" id=\"u559e422f\"><br></p><h3 data-lake-id=\"25f9c7fa\" id=\"25f9c7fa\"><span data-lake-id=\"ubd2db5e6\" id=\"ubd2db5e6\">总结</span></h3><p data-lake-id=\"u8c996528\" id=\"u8c996528\"><br></p><p data-lake-id=\"u2699c81d\" id=\"u2699c81d\"><span data-lake-id=\"ub437aaf1\" id=\"ub437aaf1\">⽬前，电商业务渐进式改造升级，第⼀部分“基础能⼒”的拆分进⼊尾声，初步拆分出“账号登录”、“⽹络请求”、“数据埋点”等模块。通过“基础能⼒”模块的拆分，降低了原有代码的冗余度，使相关功能模块的逻辑清晰化、内聚化，可维护性增强；通过 TypeScript 语⾔的使⽤，使复杂的数据结构类型化、规范化，能更好的应对业务体量的增⻓，提升产品运⾏时的稳定性；同时，新的技术栈及技术⽅案的引⼊，切实提升了团队同学的技术能⼒，营造了团队良好的技术氛围。</span></p><p data-lake-id=\"ud80f5563\" id=\"ud80f5563\"><br></p><p data-lake-id=\"u60ddbd8b\" id=\"u60ddbd8b\"><span data-lake-id=\"u38c00d70\" id=\"u38c00d70\">全面拥抱 Typescript，不仅仅是增加了类型，而是编程方式的转变。</span></p><p data-lake-id=\"ud6085e47\" id=\"ud6085e47\"><br></p><p data-lake-id=\"ude827336\" id=\"ude827336\"><span data-lake-id=\"ufaf3e6a4\" id=\"ufaf3e6a4\">变量 =&gt; 类型 =&gt; 结构</span></p><p data-lake-id=\"ue1bf901d\" id=\"ue1bf901d\"><br></p><p data-lake-id=\"u62db9c5f\" id=\"u62db9c5f\"><span data-lake-id=\"uf7990e32\" id=\"uf7990e32\">面向过程 =&gt; 面向接口</span></p>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 3612,
  "created_at": "2022-03-19T11:12:04.000Z",
  "updated_at": "2022-03-20T15:15:10.000Z",
  "content_updated_at": "2022-03-20T15:14:51.000Z",
  "published_at": "2022-03-20T15:15:10.000Z",
  "first_published_at": "2022-03-20T15:13:30.000Z",
  "book": {
    "id": 24987782,
    "type": "Book",
    "slug": "aggvdq",
    "name": "项目梳理",
    "user_id": 732231,
    "description": "用来梳理一些项目的内容",
    "toc_yml": "- type: META\n  count: 27\n  display_level: 1\n  tail_type: UPDATED_AT\n  base_version_id: 219001536\n  published: true\n  max_level: 2\n  last_updated_at: 2022-07-05T05:31:54.296Z\n  version_id: 219001620\n- type: DOC\n  title: 自我介绍\n  uuid: czSnLwlZX5r2CJfX\n  url: nowm78\n  prev_uuid: ''\n  sibling_uuid: 0Z_QJNT6lajGoxNa\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 71314643\n  level: 0\n  id: 71314643\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 面经\n  uuid: 0Z_QJNT6lajGoxNa\n  url: uhv9t2\n  prev_uuid: czSnLwlZX5r2CJfX\n  sibling_uuid: BAls4pP-NeY80xRi\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 73218284\n  level: 0\n  id: 73218284\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 项目\n  uuid: BAls4pP-NeY80xRi\n  url: ''\n  prev_uuid: 0Z_QJNT6lajGoxNa\n  sibling_uuid: OBIPwt2GqG4q-vpQ\n  child_uuid: iAehDOuKbi90rUiI\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: mpx\n  uuid: iAehDOuKbi90rUiI\n  url: flzwri\n  prev_uuid: BAls4pP-NeY80xRi\n  sibling_uuid: ZBy9d0lBfyBCBXpu\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 82395946\n  level: 1\n  id: 82395946\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 滴滴出行小程序\n  uuid: ZBy9d0lBfyBCBXpu\n  url: ''\n  prev_uuid: iAehDOuKbi90rUiI\n  sibling_uuid: GLK4TI6bZt4Xxu6b\n  child_uuid: '-dL8H8y1HcmyCKgY'\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 小程序包体积优化\n  uuid: '-dL8H8y1HcmyCKgY'\n  url: qf3q0x\n  prev_uuid: ZBy9d0lBfyBCBXpu\n  sibling_uuid: EJe2oPQpRB-N11Xb\n  child_uuid: ''\n  parent_uuid: ZBy9d0lBfyBCBXpu\n  doc_id: 75039167\n  level: 2\n  id: 75039167\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: mpx 性能优化\n  uuid: EJe2oPQpRB-N11Xb\n  url: hgoyws\n  prev_uuid: '-dL8H8y1HcmyCKgY'\n  sibling_uuid: guwD9YXgthBX_ez4\n  child_uuid: ''\n  parent_uuid: ZBy9d0lBfyBCBXpu\n  doc_id: 74717740\n  level: 2\n  id: 74717740\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 冒泡页\n  uuid: guwD9YXgthBX_ez4\n  url: mo05y7\n  prev_uuid: EJe2oPQpRB-N11Xb\n  sibling_uuid: jVVd9OODBN3wWQ5P\n  child_uuid: ''\n  parent_uuid: ZBy9d0lBfyBCBXpu\n  doc_id: 73628145\n  level: 2\n  id: 73628145\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 行程中\n  uuid: jVVd9OODBN3wWQ5P\n  url: oyxdqe\n  prev_uuid: guwD9YXgthBX_ez4\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ZBy9d0lBfyBCBXpu\n  doc_id: 73628172\n  level: 2\n  id: 73628172\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 小程序上线管理平台\n  uuid: GLK4TI6bZt4Xxu6b\n  url: ''\n  prev_uuid: ZBy9d0lBfyBCBXpu\n  sibling_uuid: 1Y-EVaBFWkuKnN0_\n  child_uuid: xpKQHRV_K7bfp3gb\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 介绍\n  uuid: xpKQHRV_K7bfp3gb\n  url: klkzoy\n  prev_uuid: GLK4TI6bZt4Xxu6b\n  sibling_uuid: xCty9hwaaVernWqJ\n  child_uuid: ''\n  parent_uuid: GLK4TI6bZt4Xxu6b\n  doc_id: 66948082\n  level: 2\n  id: 66948082\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 发布方式\n  uuid: xCty9hwaaVernWqJ\n  url: ohsgmx\n  prev_uuid: xpKQHRV_K7bfp3gb\n  sibling_uuid: 1robqYdQQG0wFPvT\n  child_uuid: ''\n  parent_uuid: GLK4TI6bZt4Xxu6b\n  doc_id: 75212608\n  level: 2\n  id: 75212608\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数据库表设计\n  uuid: 1robqYdQQG0wFPvT\n  url: csg8d4\n  prev_uuid: xCty9hwaaVernWqJ\n  sibling_uuid: Dvglyu8bpWNiJpBK\n  child_uuid: ''\n  parent_uuid: GLK4TI6bZt4Xxu6b\n  doc_id: 66912281\n  level: 2\n  id: 66912281\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 原型设计\n  uuid: Dvglyu8bpWNiJpBK\n  url: ktgzlc\n  prev_uuid: 1robqYdQQG0wFPvT\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: GLK4TI6bZt4Xxu6b\n  doc_id: 67155542\n  level: 2\n  id: 67155542\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: webx\n  uuid: 1Y-EVaBFWkuKnN0_\n  url: yghis3\n  prev_uuid: GLK4TI6bZt4Xxu6b\n  sibling_uuid: s3s0XuEuOPAMWB6v\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 73626184\n  level: 1\n  id: 73626184\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: TypeScript 在团队内部的实践总结\n  uuid: s3s0XuEuOPAMWB6v\n  url: bp0lie\n  prev_uuid: 1Y-EVaBFWkuKnN0_\n  sibling_uuid: cBBVzib8WHiSWbfw\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 70125424\n  level: 1\n  id: 70125424\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 利用 ts + proxy 增强 api 类型推导功能\n  uuid: cBBVzib8WHiSWbfw\n  url: wagl2t\n  prev_uuid: s3s0XuEuOPAMWB6v\n  sibling_uuid: OSV3qUcGRRunfF_K\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 75215879\n  level: 1\n  id: 75215879\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 人工审核系统\n  uuid: OSV3qUcGRRunfF_K\n  url: nw2hf8\n  prev_uuid: cBBVzib8WHiSWbfw\n  sibling_uuid: Z9NSZiuYLWhda8gH\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 75041091\n  level: 1\n  id: 75041091\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 长列表性能优化\n  uuid: Z9NSZiuYLWhda8gH\n  url: gkfqwb\n  prev_uuid: OSV3qUcGRRunfF_K\n  sibling_uuid: Xkshht2CcjCCitea\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 75286551\n  level: 1\n  id: 75286551\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 小程序体验分优化\n  uuid: Xkshht2CcjCCitea\n  url: kdytb8\n  prev_uuid: Z9NSZiuYLWhda8gH\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 75216281\n  level: 1\n  id: 75216281\n  open_window: 0\n  visible: 0\n- type: TITLE\n  title: 小程序接入原子化 css 样式库并支持分包输出\n  uuid: OBIPwt2GqG4q-vpQ\n  url: ''\n  prev_uuid: BAls4pP-NeY80xRi\n  sibling_uuid: aPheiwf1071mw6tU\n  child_uuid: tpFBhK_D2hlsZj9w\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 备忘录\n  uuid: tpFBhK_D2hlsZj9w\n  url: pbxykl\n  prev_uuid: OBIPwt2GqG4q-vpQ\n  sibling_uuid: iJCb_ylpdQ6AVtDy\n  child_uuid: ''\n  parent_uuid: OBIPwt2GqG4q-vpQ\n  doc_id: 67295600\n  level: 1\n  id: 67295600\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 架构设计\n  uuid: iJCb_ylpdQ6AVtDy\n  url: elafeo\n  prev_uuid: tpFBhK_D2hlsZj9w\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: OBIPwt2GqG4q-vpQ\n  doc_id: 70799795\n  level: 1\n  id: 70799795\n  open_window: 0\n  visible: 0\n- type: DOC\n  title: 研发流程\n  uuid: aPheiwf1071mw6tU\n  url: rl51ig\n  prev_uuid: OBIPwt2GqG4q-vpQ\n  sibling_uuid: KiBu4V9imsSGolKk\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 70125489\n  level: 0\n  id: 70125489\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 一些分享\n  uuid: KiBu4V9imsSGolKk\n  url: guat9s\n  prev_uuid: aPheiwf1071mw6tU\n  sibling_uuid: 5AwFIGCO-4sox4yt\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 71173266\n  level: 0\n  id: 71173266\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字节面经\n  uuid: 5AwFIGCO-4sox4yt\n  url: gq8kd3\n  prev_uuid: KiBu4V9imsSGolKk\n  sibling_uuid: 8ot1aeLekjpB9XKV\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 81937341\n  level: 0\n  id: 81937341\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: polyfill\n  uuid: 8ot1aeLekjpB9XKV\n  url: nzrear\n  prev_uuid: 5AwFIGCO-4sox4yt\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 81938260\n  level: 0\n  id: 81938260\n  open_window: 0\n  visible: 1\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 23,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2022-12-25T07:59:52.340Z",
    "created_at": "2022-03-03T15:06:25.000Z",
    "updated_at": "2023-11-07T15:52:14.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-22T20:13:30.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/aggvdq",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 878060988,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-22T20:13:30.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}