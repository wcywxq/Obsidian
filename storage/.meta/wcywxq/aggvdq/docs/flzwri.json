{
  "id": 82395946,
  "slug": "flzwri",
  "title": "mpx",
  "description": "状态管理Mpx 参考 vuex 设计实现了外部状态管理系统（store），其中的概念与 api 与 vuex 保持一致，为了更好地支持状态模块管理和跨团队合作场景，我们提出多实例 store 作为 vuex 中 modules 的替代方案，该方案在模块拆分及合并上的灵活性远高于 modules...",
  "cover": "https://cdn.nlark.com/yuque/0/2022/png/732231/1657000472275-1181d196-a4d6-4229-a7b1-b1ffc1ce08aa.png",
  "user_id": 732231,
  "book_id": 24987782,
  "last_editor_id": 732231,
  "format": "lake",
  "body_draft": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"lgIKN\"><span class=\"ne-text\">状态管理</span></h2><p id=\"u553ca6d4\" class=\"ne-p\"><span class=\"ne-text\">Mpx 参考 vuex 设计实现了外部状态管理系统（store），其中的概念与 api 与 vuex 保持一致，为了更好地支持状态模块管理和跨团队合作场景，我们提出多实例 store 作为 vuex 中 modules 的替代方案，该方案在模块拆分及合并上的灵活性远高于 modules。</span></p><p id=\"u94a534a0\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ud3f1de34\" class=\"ne-p\"><span class=\"ne-text\">与 vuex 中的不同的地方在于，vuex 奉行单一状态树，一个应用当中只存在一个 store 示例，用户能够在组件中通过 this.$store 隐式地访问到当前应用的 store；而 Mpx 当中为了追求灵活便捷的状态模块化管理及跨团队合作的能力，支持了多实例 store，用户需要显式地引入 store 实例，并通过计算属性将其注入到组件当中。</span></p><p id=\"u119b1ef5\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"uc1c87b6f\" class=\"ne-p\"><span class=\"ne-text\">在实际的跨团队业务当中，我们既希望不同团队间的数据管理尽量解耦，也希望一些共同的部分能够复用，这就要求我们的 store 实例可以以某种方式组合起来使用，我们提供了 deps 能来实现多实例 store 的合并与继承。</span></p><h2 id=\"AuwFo\"><span class=\"ne-text\">Mixin</span></h2><p id=\"u80ee5afd\" class=\"ne-p\"><span class=\"ne-text\">Mpx 提供了一套完善的 mixin 机制，有人可能要问，原生小程序中已经支持了 behaviors，为何我们还需要提供 mixin 呢？主要有以下两点原因：</span></p><ol class=\"ne-ol\"><li id=\"u9dba62e4\"><span class=\"ne-text\">Behaviors 是平台限度的，只有在部分小程序平台中可以使用，而且内置 behaviors 承载了除了 mixin 外的其他功能，框架提供的 mixin 是一个与平台无关的基础能力；</span></li><li id=\"u194bf62d\"><span class=\"ne-text\">Behaviors 只有组件支持使用，页面不支持，而且只支持局部声明，框架提供的 mixin 与组件页面无关，且支持全局 mixin 声明。</span></li></ol><h2 id=\"yk1PK\"><span class=\"ne-text\">分包异步化</span></h2><p id=\"u70314832\" class=\"ne-p\"><span class=\"ne-text\">在小程序中，不同的分包对应不同的下载单元；因此，除了非独立分包可以依赖主包外，分包之间不能互相使用自定义组件或进行 require。 「分包异步化」特性将允许通过一些配置和新的接口，使部分跨分包的内容可以等待下载后异步使用，从而一定程度上解决这个限制。</span></p><h2 id=\"AubFm\"><span class=\"ne-text\">图像资源引入有三种方式</span></h2><ol class=\"ne-ol\"><li id=\"u4a9dc64f\"><span class=\"ne-text\">Template 中通过 image src 指定图像资源</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u7b096d2a\"><span class=\"ne-text\">直接指定图像的远程资源地址</span></li><li id=\"ufd9bc6b5\"><span class=\"ne-text\">资源为本地路径，若配置 publicPath，则 publicPath 与 webpack loader 中配置的 name 进行拼接</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u99a3c606\"><span class=\"ne-text\">Style 中通过 src 指定图像资源</span></li><li id=\"uaaf1375c\"><span class=\"ne-text\">Style 中通过 class 指定图像资源</span></li></ol><p id=\"u9dadb38f\" class=\"ne-p\"><span class=\"ne-text\">Wxss文件中只能用 CDN 地址或 Base64, 针对第二、三种方式引入的资源，可以通过配置决定使用 CDN 还是 Base64，且 Mpx 中图像资源处理会优先检查 Base64，具体配置参数如下：</span></p><ul class=\"ne-ul\"><li id=\"u8e24972f\"><span class=\"ne-text\">publicPath：资源存放 CDN 地址，可选</span></li><li id=\"u055e8182\"><span class=\"ne-text\">limit: 资源大小限制，可根据资源的大小判断走 Base64 还是 CDN， 可选</span></li><li id=\"u8e10b3d0\"><span class=\"ne-text\">publicPathScope: 限制输出 CDN 图像资源的范围，可选 styleOnly、all，默认为 styleOnly。（图像引用方式分两大类 Template, Style）</span></li><li id=\"u0cf1a88c\"><span class=\"ne-text\">outputPathCDN: 设置 CDN 图像对应的本地相对地址（相对于当前编译输出目录的地址，如 dist,或者 dist/wx），可写脚本将本地图像批量上传到 CDN</span></li></ul><h2 id=\"kPYvL\"><span class=\"ne-text\">类名样式绑定</span></h2><p id=\"u892b35c6\" class=\"ne-p\"><span class=\"ne-text\">Mpx利用wxs完整实现了Vue中的类名样式绑定，性能优良且没有任何使用限制（很多小程序框架基于字符串解析来实现该能力，只支持在模板上写简单的字面量，大大限制了使用场景）</span></p><h2 id=\"uxpEa\"><span class=\"ne-text\">极致性能</span></h2><p id=\"uf1040cf7\" class=\"ne-p\"><span class=\"ne-text\">Mpx在性能上做到了极致，我们在框架中通过模板数据依赖收集进行了深度的setData优化，做到了程序上的最优，让用户能够专注于业务开发；</span></p><p id=\"ua9004f65\" class=\"ne-p\"><span class=\"ne-text\">其次，Mpx的编译构建完全基于依赖收集，支持按需进行的npm构建，能够自动根据用户的分包配置抽离共用模块，确保用户最终产出项目的包体积最优；</span></p><p id=\"ud6f20def\" class=\"ne-p\"><span class=\"ne-text\">最后，Mpx的运行时框架部分仅占用51KB；</span></p><h2 id=\"AAOLz\"><span class=\"ne-text\">对比其他小程序框架</span></h2><p id=\"u0686d66b\" class=\"ne-p\"><span class=\"ne-text\">目前业内的小程序框架主要分为两类，一类是以uniapp，taro2为代表的静态编译型框架，这类框架以静态编译为主要手段，将React和Vue开发的业务源码转换到小程序环境中进行适配运行。这类框架的主要优点在于web项目迁移方便，跨端能力较强。但是由于React/Vue等web框架的DSL与小程序本身存在较大差距，无法完善支持原web框架的全部能力，开发的时候容易踩坑。</span></p><p id=\"u827bf2ec\" class=\"ne-p\"><span class=\"ne-text\">另一类是以kbone，taro3为代表的运行时框架，这类框架利用小程序本身提供的动态渲染能力，在小程序中模拟出web的运行时环境，让React/Vue等框架直接在上层运行。这类框架的优点在于web项目迁移方便，且在web框架语法能力的支持上比静态编译型的框架要强很多，开发时遇到的坑也会少很多。但是由于模拟的web运行时环境带来了巨大的性能开销，这类框架并不适合用于大型复杂的小程序开发。</span></p><p id=\"u757505d1\" class=\"ne-p\"><span class=\"ne-text\">不同于上面两类框架，Mpx以小程序本身的DSL为基础，通过编译和运行时手段结合对其进行了一系列拓展增强，没有复杂庞大的转译和环境抹平，在提升用户开发体验和效率的同时，既能保障开发的稳定和可预期性，又能保障接近原生的良好性能，非常适合开发大型复杂的小程序应用。</span></p><p id=\"u5ddd25d6\" class=\"ne-p\"><span class=\"ne-text\">在跨端方面，Mpx重点保障跨小程序平台的跨端能力，由于各家小程序标准具有很强的相似性，Mpx在进行跨端输出时，以静态编译为主要手段，辅以灵活便捷的条件编译，保障了跨端输出的性能和可用性。</span></p><h2 id=\"cnHm5\"><span class=\"ne-text\">运行时增强原理</span></h2><p id=\"ucc6611ee\" class=\"ne-p\"><span class=\"ne-text\">数据响应作为Vue最核心的特性，在我们的日常开发中被大量使用，能够极大地提高前端开发体验和效率，我们在框架设计初期最早考虑的就是如何将数据响应特性加入到小程序开发中。在数据响应的实现上，我们引入了MobX，一个实现了纯粹数据响应能力的知名开源项目。借助MobX和mixins，我们在小程序组件创建初期建立了一个响应式数据管理系统，该系统观察着小程序组件中的所有数据(data/props/computed)并基于数据的变更驱动视图的渲染(setData)及用户注册的watch回调，实现了Vue中的数据响应编程体验。与此同时，我们基于MobX封装实现了一个Vuex规范的数据管理store，能够方便地注入组件进行全局数据管理。为了提高跨团队开发的体验，我们对store添加了多实例可合并的特性，不同团队维护自己的store，在需要时能够合并他人或者公共的store生成新的store实例，我们认为这是一种比Vuex中modules更加灵活便捷的跨团队数据管理模式</span></p><p id=\"u5a7ec61e\" class=\"ne-p\"><span class=\"ne-text\">作为一个接管了小程序setData的数据响应开发框架，我们高度重视Mpx的渲染性能，通过小程序官方文档中提到的性能优化建议可以得知，setData对于小程序性能来说是重中之重，setData优化的方向主要有两个：</span></p><ol class=\"ne-ol\"><li id=\"u11bd16f2\"><span class=\"ne-text\">尽可能减少setData调用的频次</span></li><li id=\"u610fc2bd\"><span class=\"ne-text\">尽可能减少单次setData传输的数据</span></li></ol><p id=\"u0c376f4c\" class=\"ne-p\"><span class=\"ne-text\">为了实现以上两个优化方向，我们做了以下几项工作：</span></p><ul class=\"ne-ul\"><li id=\"u2cb72880\"><span class=\"ne-text\">将组件的静态模板编译为可执行的render函数，通过render函数收集模板数据依赖，只有当render函数中的依赖数据发生变化时才会触发小程序组件的setData，同时通过一个异步队列确保一个tick中最多只会进行一次setData，这个机制和Vue中的render机制非常类似，大大降低了setData的调用频次；</span></li><li id=\"ubfcde421\"><span class=\"ne-text\">将模板编译render函数的过程中，我们还记录输出了模板中使用的数据路径，在每次需要setData时会根据这些数据路径与上一次的数据进行diff，仅将发生变化的数据通过数据路径的方式进行setData，这样确保了每次setData传输的数据量最低，同时避免了不必要的setData操作，进一步降低了setData的频次。</span></li></ul><p id=\"u0f8fcc34\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1657000472275-1181d196-a4d6-4229-a7b1-b1ffc1ce08aa.png\" width=\"969\" id=\"u7cb9d382\" class=\"ne-image\"></p><p id=\"ufe6c61de\" class=\"ne-p\"><span class=\"ne-text\">Mpx数据响应机制流程示意图</span></p><h2 id=\"clfpG\"><span class=\"ne-text\">编译构建原理</span></h2><p id=\"u14e66beb\" class=\"ne-p\"><span class=\"ne-text\">我们希望使用目前设计最强大、生态最完善的编译构建工具Webpack来实现小程序的编译构建，让用户得到web开发中先进强大的工程化开发体验。使用过Webpack的同学都知道，通常来说Webpack都是将项目中使用到的一系列碎片化模块打包为一个或几个bundle，而小程序所需要的文件结构是非常离散化的，如Ï何调解这两者的矛盾成为了我们最大的难题。一种非常直观简单的思路在于遍历整个src目录，将其中的每一个.mpx文件都作为一个entry加入到Webpack中进行处理，这样做的问题主要有两个：</span></p><ol class=\"ne-ol\"><li id=\"uec17792b\"><span class=\"ne-text\">src目录中用不到的.mpx文件也会被编译输出，最终也会被小程序打包进项目包中，无意义地增加了包体积；</span></li><li id=\"u1d442fad\"><span class=\"ne-text\">对于node_modules下的.mpx文件，我们不认为遍历node_modules是一个好的选择。</span></li></ol><p id=\"ub3cafa26\" class=\"ne-p\"><span class=\"ne-text\">最终我们采用了一种基于依赖分析和动态添加entry的方式来进行实现，用户在Webpack配置中只需要配置一个入口文件app.mpx，loader在解析到json时会解析json中pages域和usingComponents域中声明的路径，通过动态添加entry的方式将这些文件添加到Webpack的构建系统当中（注意这里是添加entry而不是添加依赖，因为只有entry能生成独立的文件，满足小程序的离散化文件结构），并递归执行这个过程，直到整个项目中所有用到的.mpx文件都加入进来，在输出前，我们借助了CommonsChunkPlugin/SplitChunksPlugin的能力将复用的模块抽取到一个外部的bundle中，确保最终生成的包中不包含重复模块。我们提供了一个Webpack插件和一个.mpx文件对应的loader来实现上述操作，用户只需要将其添加到Webpack配置中就可以以打包web项目的方式正常打包小程序，没有任何的前置和后置操作，支持Webpack本身的完整生态。</span></p><p id=\"u4c1a4d71\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1657000497150-644f2744-2ea7-4fa0-8755-16394cc5c9d7.png\" width=\"891\" id=\"ue3d60153\" class=\"ne-image\"></p><p id=\"u53aa4418\" class=\"ne-p\"><span class=\"ne-text\">Mpx编译构建机制流程示意图Ï</span></p></div>",
  "body": "<a name=\"lgIKN\"></a>\n## 状态管理\nMpx 参考 vuex 设计实现了外部状态管理系统（store），其中的概念与 api 与 vuex 保持一致，为了更好地支持状态模块管理和跨团队合作场景，我们提出多实例 store 作为 vuex 中 modules 的替代方案，该方案在模块拆分及合并上的灵活性远高于 modules。\n\n与 vuex 中的不同的地方在于，vuex 奉行单一状态树，一个应用当中只存在一个 store 示例，用户能够在组件中通过 this.$store 隐式地访问到当前应用的 store；而 Mpx 当中为了追求灵活便捷的状态模块化管理及跨团队合作的能力，支持了多实例 store，用户需要显式地引入 store 实例，并通过计算属性将其注入到组件当中。\n\n在实际的跨团队业务当中，我们既希望不同团队间的数据管理尽量解耦，也希望一些共同的部分能够复用，这就要求我们的 store 实例可以以某种方式组合起来使用，我们提供了 deps 能来实现多实例 store 的合并与继承。\n<a name=\"AuwFo\"></a>\n## Mixin\nMpx 提供了一套完善的 mixin 机制，有人可能要问，原生小程序中已经支持了 behaviors，为何我们还需要提供 mixin 呢？主要有以下两点原因：\n\n1. Behaviors 是平台限度的，只有在部分小程序平台中可以使用，而且内置 behaviors 承载了除了 mixin 外的其他功能，框架提供的 mixin 是一个与平台无关的基础能力；\n2. Behaviors 只有组件支持使用，页面不支持，而且只支持局部声明，框架提供的 mixin 与组件页面无关，且支持全局 mixin 声明。\n<a name=\"yk1PK\"></a>\n## 分包异步化\n在小程序中，不同的分包对应不同的下载单元；因此，除了非独立分包可以依赖主包外，分包之间不能互相使用自定义组件或进行 require。 「分包异步化」特性将允许通过一些配置和新的接口，使部分跨分包的内容可以等待下载后异步使用，从而一定程度上解决这个限制。\n<a name=\"AubFm\"></a>\n## 图像资源引入有三种方式\n\n1. Template 中通过 image src 指定图像资源\n   - 直接指定图像的远程资源地址\n   - 资源为本地路径，若配置 publicPath，则 publicPath 与 webpack loader 中配置的 name 进行拼接\n2. Style 中通过 src 指定图像资源\n3. Style 中通过 class 指定图像资源\n\nWxss文件中只能用 CDN 地址或 Base64, 针对第二、三种方式引入的资源，可以通过配置决定使用 CDN 还是 Base64，且 Mpx 中图像资源处理会优先检查 Base64，具体配置参数如下：\n\n- publicPath：资源存放 CDN 地址，可选\n- limit: 资源大小限制，可根据资源的大小判断走 Base64 还是 CDN， 可选\n- publicPathScope: 限制输出 CDN 图像资源的范围，可选 styleOnly、all，默认为 styleOnly。（图像引用方式分两大类 Template, Style）\n- outputPathCDN: 设置 CDN 图像对应的本地相对地址（相对于当前编译输出目录的地址，如 dist,或者 dist/wx），可写脚本将本地图像批量上传到 CDN\n<a name=\"kPYvL\"></a>\n## 类名样式绑定\nMpx利用wxs完整实现了Vue中的类名样式绑定，性能优良且没有任何使用限制（很多小程序框架基于字符串解析来实现该能力，只支持在模板上写简单的字面量，大大限制了使用场景）\n<a name=\"uxpEa\"></a>\n## 极致性能\nMpx在性能上做到了极致，我们在框架中通过模板数据依赖收集进行了深度的setData优化，做到了程序上的最优，让用户能够专注于业务开发；<br />其次，Mpx的编译构建完全基于依赖收集，支持按需进行的npm构建，能够自动根据用户的分包配置抽离共用模块，确保用户最终产出项目的包体积最优；<br />最后，Mpx的运行时框架部分仅占用51KB；\n<a name=\"AAOLz\"></a>\n## 对比其他小程序框架\n目前业内的小程序框架主要分为两类，一类是以uniapp，taro2为代表的静态编译型框架，这类框架以静态编译为主要手段，将React和Vue开发的业务源码转换到小程序环境中进行适配运行。这类框架的主要优点在于web项目迁移方便，跨端能力较强。但是由于React/Vue等web框架的DSL与小程序本身存在较大差距，无法完善支持原web框架的全部能力，开发的时候容易踩坑。<br />另一类是以kbone，taro3为代表的运行时框架，这类框架利用小程序本身提供的动态渲染能力，在小程序中模拟出web的运行时环境，让React/Vue等框架直接在上层运行。这类框架的优点在于web项目迁移方便，且在web框架语法能力的支持上比静态编译型的框架要强很多，开发时遇到的坑也会少很多。但是由于模拟的web运行时环境带来了巨大的性能开销，这类框架并不适合用于大型复杂的小程序开发。<br />不同于上面两类框架，Mpx以小程序本身的DSL为基础，通过编译和运行时手段结合对其进行了一系列拓展增强，没有复杂庞大的转译和环境抹平，在提升用户开发体验和效率的同时，既能保障开发的稳定和可预期性，又能保障接近原生的良好性能，非常适合开发大型复杂的小程序应用。<br />在跨端方面，Mpx重点保障跨小程序平台的跨端能力，由于各家小程序标准具有很强的相似性，Mpx在进行跨端输出时，以静态编译为主要手段，辅以灵活便捷的条件编译，保障了跨端输出的性能和可用性。\n<a name=\"cnHm5\"></a>\n## 运行时增强原理\n数据响应作为Vue最核心的特性，在我们的日常开发中被大量使用，能够极大地提高前端开发体验和效率，我们在框架设计初期最早考虑的就是如何将数据响应特性加入到小程序开发中。在数据响应的实现上，我们引入了MobX，一个实现了纯粹数据响应能力的知名开源项目。借助MobX和mixins，我们在小程序组件创建初期建立了一个响应式数据管理系统，该系统观察着小程序组件中的所有数据(data/props/computed)并基于数据的变更驱动视图的渲染(setData)及用户注册的watch回调，实现了Vue中的数据响应编程体验。与此同时，我们基于MobX封装实现了一个Vuex规范的数据管理store，能够方便地注入组件进行全局数据管理。为了提高跨团队开发的体验，我们对store添加了多实例可合并的特性，不同团队维护自己的store，在需要时能够合并他人或者公共的store生成新的store实例，我们认为这是一种比Vuex中modules更加灵活便捷的跨团队数据管理模式<br />作为一个接管了小程序setData的数据响应开发框架，我们高度重视Mpx的渲染性能，通过小程序官方文档中提到的性能优化建议可以得知，setData对于小程序性能来说是重中之重，setData优化的方向主要有两个：\n\n1. 尽可能减少setData调用的频次\n2. 尽可能减少单次setData传输的数据\n\n为了实现以上两个优化方向，我们做了以下几项工作：\n\n- 将组件的静态模板编译为可执行的render函数，通过render函数收集模板数据依赖，只有当render函数中的依赖数据发生变化时才会触发小程序组件的setData，同时通过一个异步队列确保一个tick中最多只会进行一次setData，这个机制和Vue中的render机制非常类似，大大降低了setData的调用频次；\n- 将模板编译render函数的过程中，我们还记录输出了模板中使用的数据路径，在每次需要setData时会根据这些数据路径与上一次的数据进行diff，仅将发生变化的数据通过数据路径的方式进行setData，这样确保了每次setData传输的数据量最低，同时避免了不必要的setData操作，进一步降低了setData的频次。\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1657000472275-1181d196-a4d6-4229-a7b1-b1ffc1ce08aa.png#clientId=ua736ca9c-d1c2-4&from=paste&id=u7cb9d382&originHeight=432&originWidth=969&originalType=url&ratio=1&rotation=0&showTitle=false&size=120449&status=done&style=none&taskId=u913de88f-8ddd-4105-8edb-7bfee5c7530&title=)<br />Mpx数据响应机制流程示意图\n<a name=\"clfpG\"></a>\n## 编译构建原理\n我们希望使用目前设计最强大、生态最完善的编译构建工具Webpack来实现小程序的编译构建，让用户得到web开发中先进强大的工程化开发体验。使用过Webpack的同学都知道，通常来说Webpack都是将项目中使用到的一系列碎片化模块打包为一个或几个bundle，而小程序所需要的文件结构是非常离散化的，如Ï何调解这两者的矛盾成为了我们最大的难题。一种非常直观简单的思路在于遍历整个src目录，将其中的每一个.mpx文件都作为一个entry加入到Webpack中进行处理，这样做的问题主要有两个：\n\n1. src目录中用不到的.mpx文件也会被编译输出，最终也会被小程序打包进项目包中，无意义地增加了包体积；\n2. 对于node_modules下的.mpx文件，我们不认为遍历node_modules是一个好的选择。\n\n最终我们采用了一种基于依赖分析和动态添加entry的方式来进行实现，用户在Webpack配置中只需要配置一个入口文件app.mpx，loader在解析到json时会解析json中pages域和usingComponents域中声明的路径，通过动态添加entry的方式将这些文件添加到Webpack的构建系统当中（注意这里是添加entry而不是添加依赖，因为只有entry能生成独立的文件，满足小程序的离散化文件结构），并递归执行这个过程，直到整个项目中所有用到的.mpx文件都加入进来，在输出前，我们借助了CommonsChunkPlugin/SplitChunksPlugin的能力将复用的模块抽取到一个外部的bundle中，确保最终生成的包中不包含重复模块。我们提供了一个Webpack插件和一个.mpx文件对应的loader来实现上述操作，用户只需要将其添加到Webpack配置中就可以以打包web项目的方式正常打包小程序，没有任何的前置和后置操作，支持Webpack本身的完整生态。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/732231/1657000497150-644f2744-2ea7-4fa0-8755-16394cc5c9d7.png#clientId=ua736ca9c-d1c2-4&from=paste&id=ue3d60153&originHeight=503&originWidth=891&originalType=url&ratio=1&rotation=0&showTitle=false&size=87446&status=done&style=none&taskId=u337df90c-9512-46ba-a0c5-cb182a2eec3&title=)<br />Mpx编译构建机制流程示意图Ï\n",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"lgIKN\"><span class=\"ne-text\">状态管理</span></h2><p id=\"u553ca6d4\" class=\"ne-p\"><span class=\"ne-text\">Mpx 参考 vuex 设计实现了外部状态管理系统（store），其中的概念与 api 与 vuex 保持一致，为了更好地支持状态模块管理和跨团队合作场景，我们提出多实例 store 作为 vuex 中 modules 的替代方案，该方案在模块拆分及合并上的灵活性远高于 modules。</span></p><p id=\"u94a534a0\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ud3f1de34\" class=\"ne-p\"><span class=\"ne-text\">与 vuex 中的不同的地方在于，vuex 奉行单一状态树，一个应用当中只存在一个 store 示例，用户能够在组件中通过 this.$store 隐式地访问到当前应用的 store；而 Mpx 当中为了追求灵活便捷的状态模块化管理及跨团队合作的能力，支持了多实例 store，用户需要显式地引入 store 实例，并通过计算属性将其注入到组件当中。</span></p><p id=\"u119b1ef5\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"uc1c87b6f\" class=\"ne-p\"><span class=\"ne-text\">在实际的跨团队业务当中，我们既希望不同团队间的数据管理尽量解耦，也希望一些共同的部分能够复用，这就要求我们的 store 实例可以以某种方式组合起来使用，我们提供了 deps 能来实现多实例 store 的合并与继承。</span></p><h2 id=\"AuwFo\"><span class=\"ne-text\">Mixin</span></h2><p id=\"u80ee5afd\" class=\"ne-p\"><span class=\"ne-text\">Mpx 提供了一套完善的 mixin 机制，有人可能要问，原生小程序中已经支持了 behaviors，为何我们还需要提供 mixin 呢？主要有以下两点原因：</span></p><ol class=\"ne-ol\"><li id=\"u9dba62e4\"><span class=\"ne-text\">Behaviors 是平台限度的，只有在部分小程序平台中可以使用，而且内置 behaviors 承载了除了 mixin 外的其他功能，框架提供的 mixin 是一个与平台无关的基础能力；</span></li><li id=\"u194bf62d\"><span class=\"ne-text\">Behaviors 只有组件支持使用，页面不支持，而且只支持局部声明，框架提供的 mixin 与组件页面无关，且支持全局 mixin 声明。</span></li></ol><h2 id=\"yk1PK\"><span class=\"ne-text\">分包异步化</span></h2><p id=\"u70314832\" class=\"ne-p\"><span class=\"ne-text\">在小程序中，不同的分包对应不同的下载单元；因此，除了非独立分包可以依赖主包外，分包之间不能互相使用自定义组件或进行 require。 「分包异步化」特性将允许通过一些配置和新的接口，使部分跨分包的内容可以等待下载后异步使用，从而一定程度上解决这个限制。</span></p><h2 id=\"AubFm\"><span class=\"ne-text\">图像资源引入有三种方式</span></h2><ol class=\"ne-ol\"><li id=\"u4a9dc64f\"><span class=\"ne-text\">Template 中通过 image src 指定图像资源</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u7b096d2a\"><span class=\"ne-text\">直接指定图像的远程资源地址</span></li><li id=\"ufd9bc6b5\"><span class=\"ne-text\">资源为本地路径，若配置 publicPath，则 publicPath 与 webpack loader 中配置的 name 进行拼接</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u99a3c606\"><span class=\"ne-text\">Style 中通过 src 指定图像资源</span></li><li id=\"uaaf1375c\"><span class=\"ne-text\">Style 中通过 class 指定图像资源</span></li></ol><p id=\"u9dadb38f\" class=\"ne-p\"><span class=\"ne-text\">Wxss文件中只能用 CDN 地址或 Base64, 针对第二、三种方式引入的资源，可以通过配置决定使用 CDN 还是 Base64，且 Mpx 中图像资源处理会优先检查 Base64，具体配置参数如下：</span></p><ul class=\"ne-ul\"><li id=\"u8e24972f\"><span class=\"ne-text\">publicPath：资源存放 CDN 地址，可选</span></li><li id=\"u055e8182\"><span class=\"ne-text\">limit: 资源大小限制，可根据资源的大小判断走 Base64 还是 CDN， 可选</span></li><li id=\"u8e10b3d0\"><span class=\"ne-text\">publicPathScope: 限制输出 CDN 图像资源的范围，可选 styleOnly、all，默认为 styleOnly。（图像引用方式分两大类 Template, Style）</span></li><li id=\"u0cf1a88c\"><span class=\"ne-text\">outputPathCDN: 设置 CDN 图像对应的本地相对地址（相对于当前编译输出目录的地址，如 dist,或者 dist/wx），可写脚本将本地图像批量上传到 CDN</span></li></ul><h2 id=\"kPYvL\"><span class=\"ne-text\">类名样式绑定</span></h2><p id=\"u892b35c6\" class=\"ne-p\"><span class=\"ne-text\">Mpx利用wxs完整实现了Vue中的类名样式绑定，性能优良且没有任何使用限制（很多小程序框架基于字符串解析来实现该能力，只支持在模板上写简单的字面量，大大限制了使用场景）</span></p><h2 id=\"uxpEa\"><span class=\"ne-text\">极致性能</span></h2><p id=\"uf1040cf7\" class=\"ne-p\"><span class=\"ne-text\">Mpx在性能上做到了极致，我们在框架中通过模板数据依赖收集进行了深度的setData优化，做到了程序上的最优，让用户能够专注于业务开发；</span></p><p id=\"ua9004f65\" class=\"ne-p\"><span class=\"ne-text\">其次，Mpx的编译构建完全基于依赖收集，支持按需进行的npm构建，能够自动根据用户的分包配置抽离共用模块，确保用户最终产出项目的包体积最优；</span></p><p id=\"ud6f20def\" class=\"ne-p\"><span class=\"ne-text\">最后，Mpx的运行时框架部分仅占用51KB；</span></p><h2 id=\"AAOLz\"><span class=\"ne-text\">对比其他小程序框架</span></h2><p id=\"u0686d66b\" class=\"ne-p\"><span class=\"ne-text\">目前业内的小程序框架主要分为两类，一类是以uniapp，taro2为代表的静态编译型框架，这类框架以静态编译为主要手段，将React和Vue开发的业务源码转换到小程序环境中进行适配运行。这类框架的主要优点在于web项目迁移方便，跨端能力较强。但是由于React/Vue等web框架的DSL与小程序本身存在较大差距，无法完善支持原web框架的全部能力，开发的时候容易踩坑。</span></p><p id=\"u827bf2ec\" class=\"ne-p\"><span class=\"ne-text\">另一类是以kbone，taro3为代表的运行时框架，这类框架利用小程序本身提供的动态渲染能力，在小程序中模拟出web的运行时环境，让React/Vue等框架直接在上层运行。这类框架的优点在于web项目迁移方便，且在web框架语法能力的支持上比静态编译型的框架要强很多，开发时遇到的坑也会少很多。但是由于模拟的web运行时环境带来了巨大的性能开销，这类框架并不适合用于大型复杂的小程序开发。</span></p><p id=\"u757505d1\" class=\"ne-p\"><span class=\"ne-text\">不同于上面两类框架，Mpx以小程序本身的DSL为基础，通过编译和运行时手段结合对其进行了一系列拓展增强，没有复杂庞大的转译和环境抹平，在提升用户开发体验和效率的同时，既能保障开发的稳定和可预期性，又能保障接近原生的良好性能，非常适合开发大型复杂的小程序应用。</span></p><p id=\"u5ddd25d6\" class=\"ne-p\"><span class=\"ne-text\">在跨端方面，Mpx重点保障跨小程序平台的跨端能力，由于各家小程序标准具有很强的相似性，Mpx在进行跨端输出时，以静态编译为主要手段，辅以灵活便捷的条件编译，保障了跨端输出的性能和可用性。</span></p><h2 id=\"cnHm5\"><span class=\"ne-text\">运行时增强原理</span></h2><p id=\"ucc6611ee\" class=\"ne-p\"><span class=\"ne-text\">数据响应作为Vue最核心的特性，在我们的日常开发中被大量使用，能够极大地提高前端开发体验和效率，我们在框架设计初期最早考虑的就是如何将数据响应特性加入到小程序开发中。在数据响应的实现上，我们引入了MobX，一个实现了纯粹数据响应能力的知名开源项目。借助MobX和mixins，我们在小程序组件创建初期建立了一个响应式数据管理系统，该系统观察着小程序组件中的所有数据(data/props/computed)并基于数据的变更驱动视图的渲染(setData)及用户注册的watch回调，实现了Vue中的数据响应编程体验。与此同时，我们基于MobX封装实现了一个Vuex规范的数据管理store，能够方便地注入组件进行全局数据管理。为了提高跨团队开发的体验，我们对store添加了多实例可合并的特性，不同团队维护自己的store，在需要时能够合并他人或者公共的store生成新的store实例，我们认为这是一种比Vuex中modules更加灵活便捷的跨团队数据管理模式</span></p><p id=\"u5a7ec61e\" class=\"ne-p\"><span class=\"ne-text\">作为一个接管了小程序setData的数据响应开发框架，我们高度重视Mpx的渲染性能，通过小程序官方文档中提到的性能优化建议可以得知，setData对于小程序性能来说是重中之重，setData优化的方向主要有两个：</span></p><ol class=\"ne-ol\"><li id=\"u11bd16f2\"><span class=\"ne-text\">尽可能减少setData调用的频次</span></li><li id=\"u610fc2bd\"><span class=\"ne-text\">尽可能减少单次setData传输的数据</span></li></ol><p id=\"u0c376f4c\" class=\"ne-p\"><span class=\"ne-text\">为了实现以上两个优化方向，我们做了以下几项工作：</span></p><ul class=\"ne-ul\"><li id=\"u2cb72880\"><span class=\"ne-text\">将组件的静态模板编译为可执行的render函数，通过render函数收集模板数据依赖，只有当render函数中的依赖数据发生变化时才会触发小程序组件的setData，同时通过一个异步队列确保一个tick中最多只会进行一次setData，这个机制和Vue中的render机制非常类似，大大降低了setData的调用频次；</span></li><li id=\"ubfcde421\"><span class=\"ne-text\">将模板编译render函数的过程中，我们还记录输出了模板中使用的数据路径，在每次需要setData时会根据这些数据路径与上一次的数据进行diff，仅将发生变化的数据通过数据路径的方式进行setData，这样确保了每次setData传输的数据量最低，同时避免了不必要的setData操作，进一步降低了setData的频次。</span></li></ul><p id=\"u0f8fcc34\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1657000472275-1181d196-a4d6-4229-a7b1-b1ffc1ce08aa.png\" width=\"969\" id=\"u7cb9d382\" class=\"ne-image\"></p><p id=\"ufe6c61de\" class=\"ne-p\"><span class=\"ne-text\">Mpx数据响应机制流程示意图</span></p><h2 id=\"clfpG\"><span class=\"ne-text\">编译构建原理</span></h2><p id=\"u14e66beb\" class=\"ne-p\"><span class=\"ne-text\">我们希望使用目前设计最强大、生态最完善的编译构建工具Webpack来实现小程序的编译构建，让用户得到web开发中先进强大的工程化开发体验。使用过Webpack的同学都知道，通常来说Webpack都是将项目中使用到的一系列碎片化模块打包为一个或几个bundle，而小程序所需要的文件结构是非常离散化的，如Ï何调解这两者的矛盾成为了我们最大的难题。一种非常直观简单的思路在于遍历整个src目录，将其中的每一个.mpx文件都作为一个entry加入到Webpack中进行处理，这样做的问题主要有两个：</span></p><ol class=\"ne-ol\"><li id=\"uec17792b\"><span class=\"ne-text\">src目录中用不到的.mpx文件也会被编译输出，最终也会被小程序打包进项目包中，无意义地增加了包体积；</span></li><li id=\"u1d442fad\"><span class=\"ne-text\">对于node_modules下的.mpx文件，我们不认为遍历node_modules是一个好的选择。</span></li></ol><p id=\"ub3cafa26\" class=\"ne-p\"><span class=\"ne-text\">最终我们采用了一种基于依赖分析和动态添加entry的方式来进行实现，用户在Webpack配置中只需要配置一个入口文件app.mpx，loader在解析到json时会解析json中pages域和usingComponents域中声明的路径，通过动态添加entry的方式将这些文件添加到Webpack的构建系统当中（注意这里是添加entry而不是添加依赖，因为只有entry能生成独立的文件，满足小程序的离散化文件结构），并递归执行这个过程，直到整个项目中所有用到的.mpx文件都加入进来，在输出前，我们借助了CommonsChunkPlugin/SplitChunksPlugin的能力将复用的模块抽取到一个外部的bundle中，确保最终生成的包中不包含重复模块。我们提供了一个Webpack插件和一个.mpx文件对应的loader来实现上述操作，用户只需要将其添加到Webpack配置中就可以以打包web项目的方式正常打包小程序，没有任何的前置和后置操作，支持Webpack本身的完整生态。</span></p><p id=\"u4c1a4d71\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/732231/1657000497150-644f2744-2ea7-4fa0-8755-16394cc5c9d7.png\" width=\"891\" id=\"ue3d60153\" class=\"ne-image\"></p><p id=\"u53aa4418\" class=\"ne-p\"><span class=\"ne-text\">Mpx编译构建机制流程示意图Ï</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><meta name=\"paragraphSpacing\" content=\"relax\" /><h2 data-lake-id=\"lgIKN\" id=\"lgIKN\"><span data-lake-id=\"u3b0ea8b5\" id=\"u3b0ea8b5\">状态管理</span></h2><p data-lake-id=\"u553ca6d4\" id=\"u553ca6d4\"><span data-lake-id=\"ub3fac872\" id=\"ub3fac872\">Mpx 参考 vuex 设计实现了外部状态管理系统（store），其中的概念与 api 与 vuex 保持一致，为了更好地支持状态模块管理和跨团队合作场景，我们提出多实例 store 作为 vuex 中 modules 的替代方案，该方案在模块拆分及合并上的灵活性远高于 modules。</span></p><p data-lake-id=\"u94a534a0\" id=\"u94a534a0\"><span data-lake-id=\"ubed87526\" id=\"ubed87526\">​</span><br></p><p data-lake-id=\"ud3f1de34\" id=\"ud3f1de34\"><span data-lake-id=\"u2dcc1318\" id=\"u2dcc1318\">与 vuex 中的不同的地方在于，vuex 奉行单一状态树，一个应用当中只存在一个 store 示例，用户能够在组件中通过 this.$store 隐式地访问到当前应用的 store；而 Mpx 当中为了追求灵活便捷的状态模块化管理及跨团队合作的能力，支持了多实例 store，用户需要显式地引入 store 实例，并通过计算属性将其注入到组件当中。</span></p><p data-lake-id=\"u119b1ef5\" id=\"u119b1ef5\"><span data-lake-id=\"u1903cc87\" id=\"u1903cc87\">​</span><br></p><p data-lake-id=\"uc1c87b6f\" id=\"uc1c87b6f\"><span data-lake-id=\"u9195d966\" id=\"u9195d966\">在实际的跨团队业务当中，我们既希望不同团队间的数据管理尽量解耦，也希望一些共同的部分能够复用，这就要求我们的 store 实例可以以某种方式组合起来使用，我们提供了 deps 能来实现多实例 store 的合并与继承。</span></p><h2 data-lake-id=\"AuwFo\" id=\"AuwFo\"><span data-lake-id=\"ud9975328\" id=\"ud9975328\">Mixin</span></h2><p data-lake-id=\"u80ee5afd\" id=\"u80ee5afd\"><span data-lake-id=\"u784ea6d8\" id=\"u784ea6d8\">Mpx 提供了一套完善的 mixin 机制，有人可能要问，原生小程序中已经支持了 behaviors，为何我们还需要提供 mixin 呢？主要有以下两点原因：</span></p><ol list=\"ud30789e4\"><li fid=\"udfa83bfe\" data-lake-id=\"u9dba62e4\" id=\"u9dba62e4\"><span data-lake-id=\"u27588b1d\" id=\"u27588b1d\">Behaviors 是平台限度的，只有在部分小程序平台中可以使用，而且内置 behaviors 承载了除了 mixin 外的其他功能，框架提供的 mixin 是一个与平台无关的基础能力；</span></li><li fid=\"udfa83bfe\" data-lake-id=\"u194bf62d\" id=\"u194bf62d\"><span data-lake-id=\"uc2ba65f7\" id=\"uc2ba65f7\">Behaviors 只有组件支持使用，页面不支持，而且只支持局部声明，框架提供的 mixin 与组件页面无关，且支持全局 mixin 声明。</span></li></ol><h2 data-lake-id=\"yk1PK\" id=\"yk1PK\"><span data-lake-id=\"u23eef4a0\" id=\"u23eef4a0\">分包异步化</span></h2><p data-lake-id=\"u70314832\" id=\"u70314832\"><span data-lake-id=\"u899e3672\" id=\"u899e3672\">在小程序中，不同的分包对应不同的下载单元；因此，除了非独立分包可以依赖主包外，分包之间不能互相使用自定义组件或进行 require。 「分包异步化」特性将允许通过一些配置和新的接口，使部分跨分包的内容可以等待下载后异步使用，从而一定程度上解决这个限制。</span></p><h2 data-lake-id=\"AubFm\" id=\"AubFm\"><span data-lake-id=\"ua20efe11\" id=\"ua20efe11\">图像资源引入有三种方式</span></h2><ol list=\"uce3a6e18\"><li fid=\"u25a5daa0\" data-lake-id=\"u4a9dc64f\" id=\"u4a9dc64f\"><span data-lake-id=\"ua99010e6\" id=\"ua99010e6\">Template 中通过 image src 指定图像资源</span></li></ol><ul list=\"ud4b9f67b\" data-lake-indent=\"1\"><li fid=\"u13e26caa\" data-lake-id=\"u7b096d2a\" id=\"u7b096d2a\"><span data-lake-id=\"u312a82c6\" id=\"u312a82c6\">直接指定图像的远程资源地址</span></li><li fid=\"u13e26caa\" data-lake-id=\"ufd9bc6b5\" id=\"ufd9bc6b5\"><span data-lake-id=\"u90810d2f\" id=\"u90810d2f\">资源为本地路径，若配置 publicPath，则 publicPath 与 webpack loader 中配置的 name 进行拼接</span></li></ul><ol list=\"uce3a6e18\" start=\"2\"><li fid=\"u25a5daa0\" data-lake-id=\"u99a3c606\" id=\"u99a3c606\"><span data-lake-id=\"uf33b3a3b\" id=\"uf33b3a3b\">Style 中通过 src 指定图像资源</span></li><li fid=\"u25a5daa0\" data-lake-id=\"uaaf1375c\" id=\"uaaf1375c\"><span data-lake-id=\"u52eb9ac1\" id=\"u52eb9ac1\">Style 中通过 class 指定图像资源</span></li></ol><p data-lake-id=\"u9dadb38f\" id=\"u9dadb38f\"><span data-lake-id=\"udf0a985f\" id=\"udf0a985f\">Wxss文件中只能用 CDN 地址或 Base64, 针对第二、三种方式引入的资源，可以通过配置决定使用 CDN 还是 Base64，且 Mpx 中图像资源处理会优先检查 Base64，具体配置参数如下：</span></p><ul list=\"u91342412\"><li fid=\"u0752b9cd\" data-lake-id=\"u8e24972f\" id=\"u8e24972f\"><span data-lake-id=\"u667bd9d1\" id=\"u667bd9d1\">publicPath：资源存放 CDN 地址，可选</span></li><li fid=\"u0752b9cd\" data-lake-id=\"u055e8182\" id=\"u055e8182\"><span data-lake-id=\"ud2a19b3d\" id=\"ud2a19b3d\">limit: 资源大小限制，可根据资源的大小判断走 Base64 还是 CDN， 可选</span></li><li fid=\"u0752b9cd\" data-lake-id=\"u8e10b3d0\" id=\"u8e10b3d0\"><span data-lake-id=\"ub2982e2f\" id=\"ub2982e2f\">publicPathScope: 限制输出 CDN 图像资源的范围，可选 styleOnly、all，默认为 styleOnly。（图像引用方式分两大类 Template, Style）</span></li><li fid=\"u0752b9cd\" data-lake-id=\"u0cf1a88c\" id=\"u0cf1a88c\"><span data-lake-id=\"u22032cc5\" id=\"u22032cc5\">outputPathCDN: 设置 CDN 图像对应的本地相对地址（相对于当前编译输出目录的地址，如 dist,或者 dist/wx），可写脚本将本地图像批量上传到 CDN</span></li></ul><h2 data-lake-id=\"kPYvL\" id=\"kPYvL\"><span data-lake-id=\"u152384c6\" id=\"u152384c6\">类名样式绑定</span></h2><p data-lake-id=\"u892b35c6\" id=\"u892b35c6\"><span data-lake-id=\"u3013300d\" id=\"u3013300d\">Mpx利用wxs完整实现了Vue中的类名样式绑定，性能优良且没有任何使用限制（很多小程序框架基于字符串解析来实现该能力，只支持在模板上写简单的字面量，大大限制了使用场景）</span></p><h2 data-lake-id=\"uxpEa\" id=\"uxpEa\"><span data-lake-id=\"u9a94f845\" id=\"u9a94f845\">极致性能</span></h2><p data-lake-id=\"uf1040cf7\" id=\"uf1040cf7\"><span data-lake-id=\"u82e8af7c\" id=\"u82e8af7c\">Mpx在性能上做到了极致，我们在框架中通过模板数据依赖收集进行了深度的setData优化，做到了程序上的最优，让用户能够专注于业务开发；</span></p><p data-lake-id=\"ua9004f65\" id=\"ua9004f65\"><span data-lake-id=\"u19bda6c3\" id=\"u19bda6c3\">其次，Mpx的编译构建完全基于依赖收集，支持按需进行的npm构建，能够自动根据用户的分包配置抽离共用模块，确保用户最终产出项目的包体积最优；</span></p><p data-lake-id=\"ud6f20def\" id=\"ud6f20def\"><span data-lake-id=\"u8306395b\" id=\"u8306395b\">最后，Mpx的运行时框架部分仅占用51KB；</span></p><h2 data-lake-id=\"AAOLz\" id=\"AAOLz\"><span data-lake-id=\"ue2eff257\" id=\"ue2eff257\">对比其他小程序框架</span></h2><p data-lake-id=\"u0686d66b\" id=\"u0686d66b\"><span data-lake-id=\"u02b9f838\" id=\"u02b9f838\">目前业内的小程序框架主要分为两类，一类是以uniapp，taro2为代表的静态编译型框架，这类框架以静态编译为主要手段，将React和Vue开发的业务源码转换到小程序环境中进行适配运行。这类框架的主要优点在于web项目迁移方便，跨端能力较强。但是由于React/Vue等web框架的DSL与小程序本身存在较大差距，无法完善支持原web框架的全部能力，开发的时候容易踩坑。</span></p><p data-lake-id=\"u827bf2ec\" id=\"u827bf2ec\"><span data-lake-id=\"u06054137\" id=\"u06054137\">另一类是以kbone，taro3为代表的运行时框架，这类框架利用小程序本身提供的动态渲染能力，在小程序中模拟出web的运行时环境，让React/Vue等框架直接在上层运行。这类框架的优点在于web项目迁移方便，且在web框架语法能力的支持上比静态编译型的框架要强很多，开发时遇到的坑也会少很多。但是由于模拟的web运行时环境带来了巨大的性能开销，这类框架并不适合用于大型复杂的小程序开发。</span></p><p data-lake-id=\"u757505d1\" id=\"u757505d1\"><span data-lake-id=\"u1a162eda\" id=\"u1a162eda\">不同于上面两类框架，Mpx以小程序本身的DSL为基础，通过编译和运行时手段结合对其进行了一系列拓展增强，没有复杂庞大的转译和环境抹平，在提升用户开发体验和效率的同时，既能保障开发的稳定和可预期性，又能保障接近原生的良好性能，非常适合开发大型复杂的小程序应用。</span></p><p data-lake-id=\"u5ddd25d6\" id=\"u5ddd25d6\"><span data-lake-id=\"ua558645a\" id=\"ua558645a\">在跨端方面，Mpx重点保障跨小程序平台的跨端能力，由于各家小程序标准具有很强的相似性，Mpx在进行跨端输出时，以静态编译为主要手段，辅以灵活便捷的条件编译，保障了跨端输出的性能和可用性。</span></p><h2 data-lake-id=\"cnHm5\" id=\"cnHm5\"><span data-lake-id=\"uf025b6de\" id=\"uf025b6de\">运行时增强原理</span></h2><p data-lake-id=\"ucc6611ee\" id=\"ucc6611ee\"><span data-lake-id=\"ua353f4ed\" id=\"ua353f4ed\">数据响应作为Vue最核心的特性，在我们的日常开发中被大量使用，能够极大地提高前端开发体验和效率，我们在框架设计初期最早考虑的就是如何将数据响应特性加入到小程序开发中。在数据响应的实现上，我们引入了MobX，一个实现了纯粹数据响应能力的知名开源项目。借助MobX和mixins，我们在小程序组件创建初期建立了一个响应式数据管理系统，该系统观察着小程序组件中的所有数据(data/props/computed)并基于数据的变更驱动视图的渲染(setData)及用户注册的watch回调，实现了Vue中的数据响应编程体验。与此同时，我们基于MobX封装实现了一个Vuex规范的数据管理store，能够方便地注入组件进行全局数据管理。为了提高跨团队开发的体验，我们对store添加了多实例可合并的特性，不同团队维护自己的store，在需要时能够合并他人或者公共的store生成新的store实例，我们认为这是一种比Vuex中modules更加灵活便捷的跨团队数据管理模式</span></p><p data-lake-id=\"u5a7ec61e\" id=\"u5a7ec61e\"><span data-lake-id=\"ufeb3dcc2\" id=\"ufeb3dcc2\">作为一个接管了小程序setData的数据响应开发框架，我们高度重视Mpx的渲染性能，通过小程序官方文档中提到的性能优化建议可以得知，setData对于小程序性能来说是重中之重，setData优化的方向主要有两个：</span></p><ol list=\"u9bd1c0fb\"><li fid=\"uca11f7e0\" data-lake-id=\"u11bd16f2\" id=\"u11bd16f2\"><span data-lake-id=\"uf80c0b18\" id=\"uf80c0b18\">尽可能减少setData调用的频次</span></li><li fid=\"uca11f7e0\" data-lake-id=\"u610fc2bd\" id=\"u610fc2bd\"><span data-lake-id=\"u0431ed2c\" id=\"u0431ed2c\">尽可能减少单次setData传输的数据</span></li></ol><p data-lake-id=\"u0c376f4c\" id=\"u0c376f4c\"><span data-lake-id=\"u0e845268\" id=\"u0e845268\">为了实现以上两个优化方向，我们做了以下几项工作：</span></p><ul list=\"ua6db174c\"><li fid=\"uc2af6b8a\" data-lake-id=\"u2cb72880\" id=\"u2cb72880\"><span data-lake-id=\"uf4b95a58\" id=\"uf4b95a58\">将组件的静态模板编译为可执行的render函数，通过render函数收集模板数据依赖，只有当render函数中的依赖数据发生变化时才会触发小程序组件的setData，同时通过一个异步队列确保一个tick中最多只会进行一次setData，这个机制和Vue中的render机制非常类似，大大降低了setData的调用频次；</span></li><li fid=\"uc2af6b8a\" data-lake-id=\"ubfcde421\" id=\"ubfcde421\"><span data-lake-id=\"u8a78536c\" id=\"u8a78536c\">将模板编译render函数的过程中，我们还记录输出了模板中使用的数据路径，在每次需要setData时会根据这些数据路径与上一次的数据进行diff，仅将发生变化的数据通过数据路径的方式进行setData，这样确保了每次setData传输的数据量最低，同时避免了不必要的setData操作，进一步降低了setData的频次。</span></li></ul><p data-lake-id=\"u0f8fcc34\" id=\"u0f8fcc34\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1657000472275-1181d196-a4d6-4229-a7b1-b1ffc1ce08aa.png%22%2C%22taskId%22%3A%22u913de88f-8ddd-4105-8edb-7bfee5c7530%22%2C%22clientId%22%3A%22ua736ca9c-d1c2-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A120449%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A969%2C%22originHeight%22%3A432%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22TEMPLATE%20COMPILER%20CHANGES%20DATA%20PATHS%20RENDER%20FUNCTION%20PROPS%20OBSERVER%20REACTIONS%20REPORT%20CHANGE%20DATA%20DIFF%20DATA%20CHANGE%20SETDATA%20RENDER%20REACTION%20USER%20WATCH%20COMPUTED%20CHANGE%20USER%20REACTIONS%20CALLBACK%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A355.74664%2C%22y%22%3A59.895668%2C%22width%22%3A124.21697999999998%2C%22height%22%3A14.454055999999994%2C%22text%22%3A%22TEMPLATE%20COMPILER%22%7D%2C%7B%22x%22%3A100.35417%2C%22y%22%3A102.90103%2C%22width%22%3A58.428820000000016%2C%22height%22%3A13.589119999999994%2C%22text%22%3A%22CHANGES%22%7D%2C%7B%22x%22%3A584.4975%2C%22y%22%3A113.824295%2C%22width%22%3A64.27080000000001%2C%22height%22%3A12.731634999999997%2C%22text%22%3A%22DATA%20PATHS%22%7D%2C%7B%22x%22%3A373.3602%2C%22y%22%3A120.29389%2C%22width%22%3A88.88094999999998%2C%22height%22%3A12.294319999999999%2C%22text%22%3A%22RENDER%20FUNCTION%22%7D%2C%7B%22x%22%3A77.91533%2C%22y%22%3A165.28316%2C%22width%22%3A103.3325%2C%22height%22%3A11.853729999999985%2C%22text%22%3A%22PROPS%20OBSERVER%22%7D%2C%7B%22x%22%3A345.32388%2C%22y%22%3A183.52342%2C%22width%22%3A64.69678000000005%2C%22height%22%3A12.518940000000015%2C%22text%22%3A%22REACTIONS%22%7D%2C%7B%22x%22%3A230.5225%2C%22y%22%3A236.90076%2C%22width%22%3A83.51876000000001%2C%22height%22%3A12.830960000000005%2C%22text%22%3A%22REPORT%20CHANGE%22%7D%2C%7B%22x%22%3A608.90045%2C%22y%22%3A243.0713%2C%22width%22%3A59.434079999999994%2C%22height%22%3A12.976830000000007%2C%22text%22%3A%22DATA%20DIFF%22%7D%2C%7B%22x%22%3A86.23584%2C%22y%22%3A244.07552%2C%22width%22%3A83.44579999999999%2C%22height%22%3A12.852149999999966%2C%22text%22%3A%22DATA%20CHANGE%22%7D%2C%7B%22x%22%3A830.58813%2C%22y%22%3A244.37857%2C%22width%22%3A54.51517000000001%2C%22height%22%3A12.570030000000003%2C%22text%22%3A%22SETDATA%22%7D%2C%7B%22x%22%3A365.14365%2C%22y%22%3A244.53226%2C%22width%22%3A105.05859000000004%2C%22height%22%3A12.972620000000006%2C%22text%22%3A%22RENDER%20REACTION%22%7D%2C%7B%22x%22%3A599.70636%2C%22y%22%3A313.4253%2C%22width%22%3A75.22654%2C%22height%22%3A12.34802000000002%2C%22text%22%3A%22USER%20WATCH%22%7D%2C%7B%22x%22%3A67.53676%2C%22y%22%3A323.2039%2C%22width%22%3A121.9183%2C%22height%22%3A13.483540000000005%2C%22text%22%3A%22COMPUTED%20CHANGE%22%7D%2C%7B%22x%22%3A369.11514%2C%22y%22%3A323.5459%2C%22width%22%3A96.64146%2C%22height%22%3A11.929869999999994%2C%22text%22%3A%22USER%20REACTIONS%22%7D%2C%7B%22x%22%3A608.56396%2C%22y%22%3A332.7002%2C%22width%22%3A58.06409000000008%2C%22height%22%3A13.722829999999988%2C%22text%22%3A%22CALLBACK%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22u7cb9d382%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"ufe6c61de\" id=\"ufe6c61de\"><span data-lake-id=\"u46ef4bce\" id=\"u46ef4bce\">Mpx数据响应机制流程示意图</span></p><h2 data-lake-id=\"clfpG\" id=\"clfpG\"><span data-lake-id=\"u1aed3237\" id=\"u1aed3237\">编译构建原理</span></h2><p data-lake-id=\"u14e66beb\" id=\"u14e66beb\"><span data-lake-id=\"u6902bb07\" id=\"u6902bb07\">我们希望使用目前设计最强大、生态最完善的编译构建工具Webpack来实现小程序的编译构建，让用户得到web开发中先进强大的工程化开发体验。使用过Webpack的同学都知道，通常来说Webpack都是将项目中使用到的一系列碎片化模块打包为一个或几个bundle，而小程序所需要的文件结构是非常离散化的，如Ï何调解这两者的矛盾成为了我们最大的难题。一种非常直观简单的思路在于遍历整个src目录，将其中的每一个.mpx文件都作为一个entry加入到Webpack中进行处理，这样做的问题主要有两个：</span></p><ol list=\"u3c1f0b87\"><li fid=\"u3e2875c4\" data-lake-id=\"uec17792b\" id=\"uec17792b\"><span data-lake-id=\"u5daa288d\" id=\"u5daa288d\">src目录中用不到的.mpx文件也会被编译输出，最终也会被小程序打包进项目包中，无意义地增加了包体积；</span></li><li fid=\"u3e2875c4\" data-lake-id=\"u1d442fad\" id=\"u1d442fad\"><span data-lake-id=\"u3ae97ad7\" id=\"u3ae97ad7\">对于node_modules下的.mpx文件，我们不认为遍历node_modules是一个好的选择。</span></li></ol><p data-lake-id=\"ub3cafa26\" id=\"ub3cafa26\"><span data-lake-id=\"u06ca3956\" id=\"u06ca3956\">最终我们采用了一种基于依赖分析和动态添加entry的方式来进行实现，用户在Webpack配置中只需要配置一个入口文件app.mpx，loader在解析到json时会解析json中pages域和usingComponents域中声明的路径，通过动态添加entry的方式将这些文件添加到Webpack的构建系统当中（注意这里是添加entry而不是添加依赖，因为只有entry能生成独立的文件，满足小程序的离散化文件结构），并递归执行这个过程，直到整个项目中所有用到的.mpx文件都加入进来，在输出前，我们借助了CommonsChunkPlugin/SplitChunksPlugin的能力将复用的模块抽取到一个外部的bundle中，确保最终生成的包中不包含重复模块。我们提供了一个Webpack插件和一个.mpx文件对应的loader来实现上述操作，用户只需要将其添加到Webpack配置中就可以以打包web项目的方式正常打包小程序，没有任何的前置和后置操作，支持Webpack本身的完整生态。</span></p><p data-lake-id=\"u4c1a4d71\" id=\"u4c1a4d71\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2022%2Fpng%2F732231%2F1657000497150-644f2744-2ea7-4fa0-8755-16394cc5c9d7.png%22%2C%22taskId%22%3A%22u337df90c-9512-46ba-a0c5-cb182a2eec3%22%2C%22clientId%22%3A%22ua736ca9c-d1c2-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22name%22%3A%22image.png%22%2C%22size%22%3A87446%2C%22from%22%3A%22paste%22%2C%22originWidth%22%3A891%2C%22originHeight%22%3A503%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22INIT%20ENTRY%20DYNAMIC%20ADDENTRY%20SELECTOR%20INJECT%20RENDER%20TEMPLATE%20COMPILER%20JSON%20COMPILER%20JS%20MODULE%20STYLE%20COMPILER%20MAKE%20SEAL%20EXTRACTOR%20ASSETS%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A280.96823%2C%22y%22%3A60.13165%2C%22width%22%3A63.01159999999999%2C%22height%22%3A14.421309999999998%2C%22text%22%3A%22INIT%20ENTRY%22%7D%2C%7B%22x%22%3A116.41034%2C%22y%22%3A131.21782%2C%22width%22%3A108.19376999999999%2C%22height%22%3A16.87598%2C%22text%22%3A%22DYNAMIC%20ADDENTRY%22%7D%2C%7B%22x%22%3A284.44852%2C%22y%22%3A162.32568%2C%22width%22%3A55.20831000000004%2C%22height%22%3A12.508700000000005%2C%22text%22%3A%22SELECTOR%22%7D%2C%7B%22x%22%3A593.5355%2C%22y%22%3A263.40878%2C%22width%22%3A78.34750000000008%2C%22height%22%3A11.118870000000015%2C%22text%22%3A%22INJECT%20RENDER%22%7D%2C%7B%22x%22%3A444.41623%2C%22y%22%3A276.19995%2C%22width%22%3A124.14932000000005%2C%22height%22%3A15.737790000000018%2C%22text%22%3A%22TEMPLATE%20COMPILER%22%7D%2C%7B%22x%22%3A72.23264%2C%22y%22%3A277.50015%2C%22width%22%3A91.68158%2C%22height%22%3A13.972379999999987%2C%22text%22%3A%22JSON%20COMPILER%22%7D%2C%7B%22x%22%3A729.32367%2C%22y%22%3A278.02133%2C%22width%22%3A65.65337999999997%2C%22height%22%3A13.391570000000002%2C%22text%22%3A%22JS%20MODULE%22%7D%2C%7B%22x%22%3A266.2308%2C%22y%22%3A277.66818%2C%22width%22%3A94.69245000000001%2C%22height%22%3A13.995319999999992%2C%22text%22%3A%22STYLE%20COMPILER%22%7D%2C%7B%22x%22%3A744.62067%2C%22y%22%3A338.99777%2C%22width%22%3A33.46789000000001%2C%22height%22%3A9.86930000000001%2C%22text%22%3A%22MAKE%22%7D%2C%7B%22x%22%3A748.2617%2C%22y%22%3A355.7853%2C%22width%22%3A25.83077000000003%2C%22height%22%3A9.524819999999977%2C%22text%22%3A%22SEAL%22%7D%2C%7B%22x%22%3A474.29636%2C%22y%22%3A423.67035%2C%22width%22%3A63.70124000000004%2C%22height%22%3A13.211610000000007%2C%22text%22%3A%22EXTRACTOR%22%7D%2C%7B%22x%22%3A738.532%2C%22y%22%3A424.20483%2C%22width%22%3A46.244699999999966%2C%22height%22%3A11.03307000000001%2C%22text%22%3A%22ASSETS%22%7D%5D%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22ue3d60153%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u53aa4418\" id=\"u53aa4418\"><span data-lake-id=\"uf96248e8\" id=\"uf96248e8\">Mpx编译构建机制流程示意图Ï</span></p>",
  "public": 0,
  "status": 1,
  "likes_count": 0,
  "read_count": 0,
  "hits": 0,
  "comments_count": 0,
  "word_count": 3019,
  "created_at": "2022-07-05T05:31:32.000Z",
  "updated_at": "2022-07-05T05:55:06.000Z",
  "content_updated_at": "2022-07-05T05:55:06.000Z",
  "published_at": "2022-07-05T05:55:06.000Z",
  "first_published_at": "2022-07-05T05:31:54.156Z",
  "book": {
    "id": 24987782,
    "type": "Book",
    "slug": "aggvdq",
    "name": "项目梳理",
    "user_id": 732231,
    "description": "用来梳理一些项目的内容",
    "toc_yml": "- type: META\n  count: 27\n  display_level: 1\n  tail_type: UPDATED_AT\n  base_version_id: 219001536\n  published: true\n  max_level: 2\n  last_updated_at: 2022-07-05T05:31:54.296Z\n  version_id: 219001620\n- type: DOC\n  title: 自我介绍\n  uuid: czSnLwlZX5r2CJfX\n  url: nowm78\n  prev_uuid: ''\n  sibling_uuid: 0Z_QJNT6lajGoxNa\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 71314643\n  level: 0\n  id: 71314643\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 面经\n  uuid: 0Z_QJNT6lajGoxNa\n  url: uhv9t2\n  prev_uuid: czSnLwlZX5r2CJfX\n  sibling_uuid: BAls4pP-NeY80xRi\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 73218284\n  level: 0\n  id: 73218284\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 项目\n  uuid: BAls4pP-NeY80xRi\n  url: ''\n  prev_uuid: 0Z_QJNT6lajGoxNa\n  sibling_uuid: OBIPwt2GqG4q-vpQ\n  child_uuid: iAehDOuKbi90rUiI\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: mpx\n  uuid: iAehDOuKbi90rUiI\n  url: flzwri\n  prev_uuid: BAls4pP-NeY80xRi\n  sibling_uuid: ZBy9d0lBfyBCBXpu\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 82395946\n  level: 1\n  id: 82395946\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 滴滴出行小程序\n  uuid: ZBy9d0lBfyBCBXpu\n  url: ''\n  prev_uuid: iAehDOuKbi90rUiI\n  sibling_uuid: GLK4TI6bZt4Xxu6b\n  child_uuid: '-dL8H8y1HcmyCKgY'\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 小程序包体积优化\n  uuid: '-dL8H8y1HcmyCKgY'\n  url: qf3q0x\n  prev_uuid: ZBy9d0lBfyBCBXpu\n  sibling_uuid: EJe2oPQpRB-N11Xb\n  child_uuid: ''\n  parent_uuid: ZBy9d0lBfyBCBXpu\n  doc_id: 75039167\n  level: 2\n  id: 75039167\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: mpx 性能优化\n  uuid: EJe2oPQpRB-N11Xb\n  url: hgoyws\n  prev_uuid: '-dL8H8y1HcmyCKgY'\n  sibling_uuid: guwD9YXgthBX_ez4\n  child_uuid: ''\n  parent_uuid: ZBy9d0lBfyBCBXpu\n  doc_id: 74717740\n  level: 2\n  id: 74717740\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 冒泡页\n  uuid: guwD9YXgthBX_ez4\n  url: mo05y7\n  prev_uuid: EJe2oPQpRB-N11Xb\n  sibling_uuid: jVVd9OODBN3wWQ5P\n  child_uuid: ''\n  parent_uuid: ZBy9d0lBfyBCBXpu\n  doc_id: 73628145\n  level: 2\n  id: 73628145\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 行程中\n  uuid: jVVd9OODBN3wWQ5P\n  url: oyxdqe\n  prev_uuid: guwD9YXgthBX_ez4\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ZBy9d0lBfyBCBXpu\n  doc_id: 73628172\n  level: 2\n  id: 73628172\n  open_window: 0\n  visible: 1\n- type: TITLE\n  title: 小程序上线管理平台\n  uuid: GLK4TI6bZt4Xxu6b\n  url: ''\n  prev_uuid: ZBy9d0lBfyBCBXpu\n  sibling_uuid: 1Y-EVaBFWkuKnN0_\n  child_uuid: xpKQHRV_K7bfp3gb\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: ''\n  level: 1\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 介绍\n  uuid: xpKQHRV_K7bfp3gb\n  url: klkzoy\n  prev_uuid: GLK4TI6bZt4Xxu6b\n  sibling_uuid: xCty9hwaaVernWqJ\n  child_uuid: ''\n  parent_uuid: GLK4TI6bZt4Xxu6b\n  doc_id: 66948082\n  level: 2\n  id: 66948082\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 发布方式\n  uuid: xCty9hwaaVernWqJ\n  url: ohsgmx\n  prev_uuid: xpKQHRV_K7bfp3gb\n  sibling_uuid: 1robqYdQQG0wFPvT\n  child_uuid: ''\n  parent_uuid: GLK4TI6bZt4Xxu6b\n  doc_id: 75212608\n  level: 2\n  id: 75212608\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 数据库表设计\n  uuid: 1robqYdQQG0wFPvT\n  url: csg8d4\n  prev_uuid: xCty9hwaaVernWqJ\n  sibling_uuid: Dvglyu8bpWNiJpBK\n  child_uuid: ''\n  parent_uuid: GLK4TI6bZt4Xxu6b\n  doc_id: 66912281\n  level: 2\n  id: 66912281\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 原型设计\n  uuid: Dvglyu8bpWNiJpBK\n  url: ktgzlc\n  prev_uuid: 1robqYdQQG0wFPvT\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: GLK4TI6bZt4Xxu6b\n  doc_id: 67155542\n  level: 2\n  id: 67155542\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: webx\n  uuid: 1Y-EVaBFWkuKnN0_\n  url: yghis3\n  prev_uuid: GLK4TI6bZt4Xxu6b\n  sibling_uuid: s3s0XuEuOPAMWB6v\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 73626184\n  level: 1\n  id: 73626184\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: TypeScript 在团队内部的实践总结\n  uuid: s3s0XuEuOPAMWB6v\n  url: bp0lie\n  prev_uuid: 1Y-EVaBFWkuKnN0_\n  sibling_uuid: cBBVzib8WHiSWbfw\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 70125424\n  level: 1\n  id: 70125424\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 利用 ts + proxy 增强 api 类型推导功能\n  uuid: cBBVzib8WHiSWbfw\n  url: wagl2t\n  prev_uuid: s3s0XuEuOPAMWB6v\n  sibling_uuid: OSV3qUcGRRunfF_K\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 75215879\n  level: 1\n  id: 75215879\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 人工审核系统\n  uuid: OSV3qUcGRRunfF_K\n  url: nw2hf8\n  prev_uuid: cBBVzib8WHiSWbfw\n  sibling_uuid: Z9NSZiuYLWhda8gH\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 75041091\n  level: 1\n  id: 75041091\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 长列表性能优化\n  uuid: Z9NSZiuYLWhda8gH\n  url: gkfqwb\n  prev_uuid: OSV3qUcGRRunfF_K\n  sibling_uuid: Xkshht2CcjCCitea\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 75286551\n  level: 1\n  id: 75286551\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 小程序体验分优化\n  uuid: Xkshht2CcjCCitea\n  url: kdytb8\n  prev_uuid: Z9NSZiuYLWhda8gH\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: BAls4pP-NeY80xRi\n  doc_id: 75216281\n  level: 1\n  id: 75216281\n  open_window: 0\n  visible: 0\n- type: TITLE\n  title: 小程序接入原子化 css 样式库并支持分包输出\n  uuid: OBIPwt2GqG4q-vpQ\n  url: ''\n  prev_uuid: BAls4pP-NeY80xRi\n  sibling_uuid: aPheiwf1071mw6tU\n  child_uuid: tpFBhK_D2hlsZj9w\n  parent_uuid: ''\n  doc_id: ''\n  level: 0\n  id: ''\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 备忘录\n  uuid: tpFBhK_D2hlsZj9w\n  url: pbxykl\n  prev_uuid: OBIPwt2GqG4q-vpQ\n  sibling_uuid: iJCb_ylpdQ6AVtDy\n  child_uuid: ''\n  parent_uuid: OBIPwt2GqG4q-vpQ\n  doc_id: 67295600\n  level: 1\n  id: 67295600\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 架构设计\n  uuid: iJCb_ylpdQ6AVtDy\n  url: elafeo\n  prev_uuid: tpFBhK_D2hlsZj9w\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: OBIPwt2GqG4q-vpQ\n  doc_id: 70799795\n  level: 1\n  id: 70799795\n  open_window: 0\n  visible: 0\n- type: DOC\n  title: 研发流程\n  uuid: aPheiwf1071mw6tU\n  url: rl51ig\n  prev_uuid: OBIPwt2GqG4q-vpQ\n  sibling_uuid: KiBu4V9imsSGolKk\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 70125489\n  level: 0\n  id: 70125489\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: 一些分享\n  uuid: KiBu4V9imsSGolKk\n  url: guat9s\n  prev_uuid: aPheiwf1071mw6tU\n  sibling_uuid: 5AwFIGCO-4sox4yt\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 71173266\n  level: 0\n  id: 71173266\n  open_window: 1\n  visible: 1\n- type: DOC\n  title: 字节面经\n  uuid: 5AwFIGCO-4sox4yt\n  url: gq8kd3\n  prev_uuid: KiBu4V9imsSGolKk\n  sibling_uuid: 8ot1aeLekjpB9XKV\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 81937341\n  level: 0\n  id: 81937341\n  open_window: 0\n  visible: 1\n- type: DOC\n  title: polyfill\n  uuid: 8ot1aeLekjpB9XKV\n  url: nzrear\n  prev_uuid: 5AwFIGCO-4sox4yt\n  sibling_uuid: ''\n  child_uuid: ''\n  parent_uuid: ''\n  doc_id: 81938260\n  level: 0\n  id: 81938260\n  open_window: 0\n  visible: 1\n",
    "creator_id": 732231,
    "public": 0,
    "items_count": 23,
    "likes_count": 0,
    "watches_count": 1,
    "content_updated_at": "2022-12-25T07:59:52.340Z",
    "created_at": "2022-03-03T15:06:25.000Z",
    "updated_at": "2023-11-07T15:52:14.000Z",
    "user": {
      "id": 732231,
      "type": "User",
      "login": "wcywxq",
      "name": "magic",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
      "books_count": 21,
      "public_books_count": 0,
      "followers_count": 0,
      "following_count": 0,
      "public": 1,
      "description": null,
      "created_at": "2020-01-08T14:21:31.000Z",
      "updated_at": "2023-11-23T19:11:28.000Z",
      "work_id": "",
      "_serializer": "v2.user"
    },
    "namespace": "wcywxq/aggvdq",
    "_serializer": "v2.book"
  },
  "user": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-23T19:11:28.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "tags": [],
  "latest_version_id": 1084922394,
  "creator": {
    "id": 732231,
    "type": "User",
    "login": "wcywxq",
    "name": "magic",
    "avatar_url": "https://cdn.nlark.com/yuque/0/2020/png/732231/1606968271774-avatar/886ad88b-d2cc-4c9e-a674-f70eb51a679c.png",
    "books_count": 21,
    "public_books_count": 0,
    "followers_count": 0,
    "following_count": 0,
    "public": 1,
    "description": null,
    "created_at": "2020-01-08T14:21:31.000Z",
    "updated_at": "2023-11-23T19:11:28.000Z",
    "work_id": "",
    "_serializer": "v2.user"
  },
  "_serializer": "v2.doc_detail"
}